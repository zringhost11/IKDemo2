/**
 * @internal
 * 使用全局类的时候，避免引用其他模块
 */
declare class ILaya {
    static Laya: typeof Laya;
    static Loader: typeof Loader;
    static InputManager: typeof InputManager;
    static Scene3D: typeof Scene3D;
    static Laya3D: typeof Laya3D;
    static loader: Laya.Loader;
    static timer: Laya.Timer;
    static systemTimer: Laya.Timer;
    static physicsTimer: Laya.Timer;
    static stage: Laya.Stage;
}
/**
 * @internal
 */
declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
type TypedArrayConstructor = Laya.Float32ArrayConstructor | Laya.Int32ArrayConstructor | Laya.Uint32ArrayConstructor | Laya.Int16ArrayConstructor | Laya.Uint16ArrayConstructor | Laya.Int8ArrayConstructor | Laya.Uint8ArrayConstructor;
type TypedArrayType = Laya.Float32Array | Laya.Int32Array | Laya.Uint32Array | Laya.Int16Array | Laya.Uint16Array | Laya.Int8Array | Laya.Uint8Array;
/**
 * @en Laya is the reference entry for global objects.
 *
 * The Laya class refers to some commonly used global objects, such as Laya.stage: stage, Laya.timer: time manager, Laya.loader: loading manager. Pay attention to case when using.
 * @zh Laya是全局对象的引用入口集。
 *
 * Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
 * @blueprintable
 */
declare class Laya {
    /**
     * @en Reference to the stage object.
     * @zh 舞台对象的引用。
     */
    static readonly stage: Laya.Stage;
    /**
     * @ignore
     * @en System clock manager, used by the engine internally.
     * @zh 系统时钟管理器，引擎内部使用。
     */
    static readonly systemTimer: Laya.Timer;
    /**
     * @ignore
     * @en physics clock manager for components.
     * @zh 组件的物理时钟管理器
     */
    static readonly physicsTimer: Laya.Timer;
    /**
     * @en Main game timer, also manages scene, animation, tween effects clock. By controlling this timer's scale, fast-forward and slow-motion effects can be achieved.
     * @zh 游戏主时针，同时也是管理场景，动画，缓动等效果时钟，通过控制本时针缩放，达到快进慢播效果。
     */
    static readonly timer: Laya.Timer;
    /**
     * @en Reference to the loading manager.
     * @zh 加载管理器的引用。
     */
    static readonly loader: Laya.Loader;
    /**
     * @ignore
     * @en Reference to the Render class.
     * @zh physics2D类的引用。
     */
    static physics2D: Laya.IPhysics2DFactory;
    private static _inited;
    private static _initCallbacks;
    private static _beforeInitCallbacks;
    private static _afterInitCallbacks;
    /**
     * @en Initialize the engine. To use the engine, you need to initialize it first.
     * @param stageConfig Stage settings used to initialize the engine
     * @zh 初始化引擎。使用引擎需要先初始化引擎。
     * @param stageConfig 初始化引擎的舞台设置。
     * @blueprintIgnore
     */
    static init(stageConfig?: Laya.IStageConfig): Promise<void>;
    /**
     * @en Initialize the engine. To use the engine, you need to initialize it first.
     * @param width The width of the initialized game window, also known as design width.
     * @param height The height of the initialized game window, also known as design height.
     * @zh 初始化引擎。使用引擎需要先初始化引擎。
     * @param width 初始化的游戏窗口宽度，又称设计宽度。
     * @param height 初始化的游戏窗口高度，又称设计高度。
     * @blueprintIgnore
     */
    static init(width: number, height: number): Promise<void>;
    private static initRender2D;
    /**
     * @en Pop up error information, suitable for mobile devices and other convenient debugging.
     * @param value Indicates whether to capture global errors and display a prompt. When set to true, detailed error stacks can be thrown in a pop-up window if unknown errors occur. The default is false.
     * @zh 弹出错误信息，适用于移动设备等不方便调试的时候，
     * @param value 表示是否捕获全局错误并弹出提示。设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈,默认为false。
     */
    static alertGlobalError(value: boolean): void;
    /**
     * @en Global error callback function. Will be called when an error occurs in the engine and alertGlobalError is set to true.
     * @param ev The error event object.
     * @zh 全局错误回调函数，当引擎发生错误并且alertGlobalError设置为true时会被调用。
     * @param ev 错误事件对象。
     */
    static _onGlobalError(ev: ErrorEvent | PromiseRejectionEvent): void;
    /**
     * @en Adds an initialization function. Various engine modules, such as physics, pathfinding, etc., can register their initialization logic here if needed.
     * Developers typically do not use this directly. All registered callbacks are executed in parallel.
     * @param callback The initialization function of the module.
     * @zh 新增初始化函数，引擎各个模块，例如物理，寻路等，如果有初始化逻辑可以在这里注册初始化函数。
     * 开发者一般不直接使用。所有注册的回调是并行执行。
     * @param callback 模块的初始化函数。
     * @blueprintIgnore
     */
    static addInitCallback(callback: () => void | Promise<void>): void;
    /**
     * @en Execute custom logic before engine initialization.
     *
     * At this time, the Stage has not been created yet, so you can modify stageConfig to implement dynamic stage configuration. All registered callbacks are executed in the order of registration.
     * @param callback The initialization function of the module.
     * @zh 在引擎初始化前执行自定义逻辑。
     *
     * 此时 Stage 尚未创建，可以修改 stageConfig 实现动态舞台配置。所有注册的回调按注册顺序依次执行。
     * @param callback 模块的初始化函数。
     * @blueprintIgnore
     */
    static addBeforeInitCallback(callback: (stageConfig: Laya.IStageConfig) => void | Promise<void>): void;
    /**
     * @en Execute custom logic after engine initialization. All registered callbacks are executed in the order of registration.
     * @param callback The initialization function of the module.
     * @zh 在引擎初始化后执行自定义逻辑。所有注册的回调按注册顺序依次执行。
     * @param callback 模块的初始化函数。
     * @blueprintIgnore
     */
    static addAfterInitCallback(callback: () => void | Promise<void>): void;
    /**
     * @en Import a native library(e.g. dll/so/dylib). If not in the Conch environment, this function will return null.
     * @param name The name of the library to import. e.g. `test.dll`
     * @returns The imported object.
     * @zh 导入一个原生库（如dll/so/dylib）。
     * @param name 要导入的库的名称。例如：`test.dll`
     * @returns 导入的对象。
     */
    static importNative(name: string): any;
}
/**@internal */
declare var init: typeof Laya.init;
/**@internal */
declare var stage: Laya.Stage;
/**@internal */
declare var systemTimer: Laya.Timer;
/**@internal */
declare var physicsTimer: Laya.Timer;
/**@internal */
declare var timer: Laya.Timer;
/**@internal */
declare var loader: Laya.Loader;
/**@internal */
declare var alertGlobalError: typeof Laya.alertGlobalError;
declare var addInitCallback: typeof Laya.addInitCallback;
declare var addBeforeInitCallback: typeof Laya.addBeforeInitCallback;
declare var addAfterInitCallback: typeof Laya.addAfterInitCallback;
declare var importNative: typeof Laya.importNative;
/**
 * @en Laya3D class is used to initialize 3D settings.
 * @zh Laya3D类用于初始化3D设置。
 */
declare class Laya3D {
    /**
     * @en Physics creation manager.
     * @zh 物理创建管理器。
     */
    static _PhysicsCreateUtil: Laya.IPhysicsCreateUtil;
    /**@internal */
    static _enablePhysics: boolean;
    /**
     * @en The physics creation manager.
     * @zh 物理创建管理器。
     */
    static get PhysicsCreateUtil(): Laya.IPhysicsCreateUtil;
    static set PhysicsCreateUtil(value: Laya.IPhysicsCreateUtil);
    /**
     * @en Whether physics is enabled.
     * @zh 是否启用物理。
     * @returns {boolean} True if physics is enabled, false otherwise.
     * @returns {boolean} 如果启用了物理则返回true，否则返回false。
     */
    static get enablePhysics(): boolean;
    /**
     *@internal
     */
    static _changeWebGLSize(width: number, height: number): void;
    /**
     *@internal
     */
    static __init__(): void;
    /**
     *@internal
    */
    static __initPhysics__(): Promise<void>;
}
declare namespace Laya {
    /**
     * @en Config is used to set some global parameters. If you need to change them, please set them before initializing the engine.
     * @zh Config类用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
     * @blueprintable
     */
    class Config {
        /**
         * @en Canvas setting for anti-aliasing, only effective for 2D(WebGL). 3D anti-aliasing is controlled on the camera or RT.
         * @zh 画布设置是否抗锯齿，只对2D(WebGL)有效,3D抗锯齿在camera或RT上面控制。
         */
        static isAntialias: boolean;
        /**
         * @en Whether to use WebGL2
         * @zh 是否使用WebGL2
         */
        static useWebGL2: boolean;
        /**W
         * @en 是否提供Spri-v的shader
         * @zh
         */
        static useSPRIV: boolean;
        /**@internal */
        static _uniformBlock: boolean;
        /**
        * @en Whether to enable UniformBuffer
        * @zh 材质是否启用UniformBuffer
        */
        static matUseUBO: boolean;
        /**
        * @en Whether to enable UniformBuffer
        * @zh 是否启用UniformBuffer
        */
        static enableUniformBufferObject: boolean;
        /**
         * @en FPS limit
         * @zh 限制FPS
         */
        static FPS: number;
        /**
         * @en Whether to use the retina mode. In retina mode, a larger canvas is created for finer display effects.
         * @zh 是否使用视网膜模式。在视网膜模式下，会创建更大的Canvas，来达到更精细的显示效果
         */
        static useRetinalCanvas: boolean;
        /**
         * @en Default playback interval for 2D animation, in milliseconds.
         * @zh 2D动画 Animation 的默认播放时间间隔，单位为毫秒。
         */
        static animationInterval: number;
        /**
         * @en When using WebGL to render 2D, whether to allocate enough cache for 64k vertices each time a VB is created. This can improve efficiency.
         * @zh 当使用WebGL渲染2D的时候，每次创建VB是否直接分配足够64k个顶点的缓存。这样可以提高效率。
         */
        static webGL2D_MeshAllocMaxMem: boolean;
        /**
         * @en Default text size, default is 12
         * @zh 默认文本大小，默认为12
         */
        static defaultFontSize: number;
        /**
         * @en Default font, default is Arial
         * @zh 默认文本字体，默认为Arial
         */
        static defaultFont: string;
        /**
         * @en Set whether the canvas is transparent, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布是否透明，只对2D(WebGL)、3D有效。
         */
        static isAlpha: boolean;
        /**
         * @en Set whether the canvas contains depth
         * @zh 设置画布是否包含深度
         */
        static isDepth: boolean;
        /**
         * @en Boolean value indicating whether to create this context in a system with low performance
         * @zh 表明在一个系统性能低的环境是否创建该上下文
         */
        static isfailIfMajorPerformanceCaveat: boolean;
        /**
         * @en Power preference for the WebGL/WebGPU context. Hints the browser about the desired GPU configuration.
         * - "default": Let the browser decide. In WebGPU mode, this is automatically set to "high-performance".
         * - "high-performance": Prefer high-performance GPU. Use for graphically intensive applications.
         * - "low-power": Prefer low-power GPU. Suitable for energy-efficient applications.
         * @zh 图形（WebGL/WebGPU）上下文的电源偏好设置。向浏览器提示所需的 GPU 配置。
         * - "default"：让浏览器决定。在 WebGPU 模式下，`default`会让引擎自动设置为`high-performance`。
         * - "high-performance"：倾向于高性能 GPU。用于图形密集型应用。
         * - "low-power"：倾向于低功耗 GPU。适用于节能的应用。
         */
        static powerPreference: WebGLPowerPreference;
        /**
         * @en Set whether the canvas is pre-multiplied, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布是否预乘，只对2D(WebGL)、3D有效。
         */
        static premultipliedAlpha: boolean;
        /**
         * @en Set whether to enable stencil buffer for the canvas, only effective for 2D(WebGL) and 3D.
         * @zh 设置画布的是否开启模板缓冲，只对2D(WebGL)、3D有效。
         */
        static isStencil: boolean;
        /**
         * @en Whether to preserve the drawing buffer.
         * @zh 是否保留渲染缓冲区。
         */
        static preserveDrawingBuffer: boolean;
        /**
         * @en Whether to print WebGL instructions and locate WebGL errors
         * @zh 是否打印WebGL指令，同时定位WebGL报错
         */
        static printWebglOrder: boolean;
        /**
         * @en On iOS, some fonts may not be found. The engine provides font mapping functionality. For example, by default, "黑体" is mapped to "黑体-简". More mappings can be added.
         * @zh 在iOS下，一些字体会找不到，引擎提供了字体映射功能，比如默认会把 "黑体" 映射为 "黑体-简"，更多映射，可以自己添加
         */
        static fontFamilyMap: any;
        /**
         * @en Whether to use a fixed frame rate for rendering and updates.
         * - When true: Rendering and logic updates are limited to the frame rate defined by Config.FPS. Ensures consistent application speed across different devices.
         * - When false: Updates occur on every requestAnimationFrame callback. Can lead to varying application speeds on different devices.
         * @zh 是否使用固定帧率进行渲染和更新。
         * - 当为 true 时：渲染和逻辑更新被限制在由 Config.FPS 定义的帧率内。确保在不同设备上应用程序运行速度一致。
         * - 当为 false 时：在每次 requestAnimationFrame 回调时进行更新。可能导致在不同设备上应用程序运行速度不同。
         */
        static fixedFrames: boolean;
        /**
         * @en Whether to immediately delete resources when the reference parameter is 0. If not immediate deletion, please call DestrotyUnUse
         * @zh 资源引用参数为0是否立即删除资源，如果不立即删除请调用DestrotyUnUse
         */
        static destroyResourceImmediatelyDefault: boolean;
        /**
         * @en The maximum size of the audio buffer cache in bytes. After exceeding this size, the oldest unused audio data in the cache will be cleared.
         * @zh 声音缓冲区缓存的最大大小（字节）。超出后将清除缓存中最久未使用的音频数据。
         */
        static audioBufferCacheMaxSize: number;
    }
    const PlayerConfig: {
        physics2D?: any;
        physics3D?: any;
        light2D?: any;
        spineVersion?: string;
        workerLoaderLib?: string;
        UI?: any;
        [key: string]: any;
    };
    /**
     * @en Config3D class is used to create 3D initialization configuration.
     * @zh Config3D 类用于创建3D初始化配置。
     * @blueprintable
     */
    class Config3D {
        /**
         * @en Whether to enable dynamic batch
         * @zh 是否启用动态合并
         */
        static enableDynamicBatch: boolean;
        /**
         * @en Whether to enable static batch
         * @zh 是否启用静态合并
         */
        static enableStaticBatch: boolean;
        /**
         * @en Set 3D RT resolution multiplier
         * @zh 设置3D RT分辨率倍数
         */
        static pixelRatio: number;
        /**
         * @en Set custom resolution
         * @zh 设置自定义分辨率
         */
        static customResolution: boolean;
        /**
         * @en Set the maximum value cached by RendertexturePool
         * @zh 设置最大RendertexturePool缓存的值
         */
        static defaultCacheRTMemory: number;
        /**
         * @en Default physics function initialization memory, in MB.
         * @zh 默认物理功能初始化内存，单位为M。
         */
        static defaultPhysicsMemory: number;
        /**
         * @en Whether to enable multiple lights. If the scene doesn't need multiple lights, turning it off can improve performance.
         * @zh 是否启用多光源。如果场景不需要多光源，关闭后可提升性能。
         */
        static enableMultiLight: boolean;
        /**
         * @en Maximum number of lights.
         * @zh 最大光源数量。
         */
        static maxLightCount: number;
        /**
         * @en Number of light clusters on X, Y, Z axes. The Z value affects the number of area lights (point lights, spotlights) that a Cluster can receive. Math.floor(2048 / lightClusterCount.z - 1) * 4 is the maximum average number of area lights each Cluster can receive. If the average number of light sources affecting each Cluster is greater than this value, the more distant Clusters will ignore the excess light effects.
         * @zh X、Y、Z轴的光照集群数量。Z值会影响Cluster接受区域光（点光、聚光）影响的数量。Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量。如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。
         */
        static lightClusterCount: Vector3;
        /**
         * @en Maximum number of morph targets
         * @zh 最大形变数量
         */
        static maxMorphTargetCount: number;
        /**
         * @en Set resolution size (not the actual rendering resolution)
         * @param width Set resolution width, unit: pixel
         * @param height Set resolution height, unit: pixel
         * @zh 设置分辨率大小（并不是实际渲染分辨率）
         * @param width 设置分辨率宽度，单位为像素
         * @param height 设置分辨率高度，单位为像素
         */
        static setResolution(width: number, height: number): void;
        /**
         * @en Whether to use BVH culling
         * @zh 是否使用BVH裁剪
         */
        static useBVHCull: boolean;
        /**
         * @en Maximum number of cells in a BVH node, nodes exceeding this number will be separated
         * @zh 一个BVH节点最大的cell数，超过这个数会分离
         */
        static BVH_max_SpatialCount: number;
        /**
         * @en Maximum size of BVH node
         * @zh 最大BVH节点的大小
         */
        static BVH_limit_size: number;
        /**
         * @en Minimum number of cellbuilds, if less than this number, BVH construction will not occur
         * @zh 最小cellbuild数，如果小于这个数，不会进行BVH构建
         */
        static BVH_Min_Build_nums: number;
        /**@internal 设置分辨率宽度*/
        static _resoluWidth: number;
        /**@internal 设置分辨率高度*/
        static _resoluHeight: number;
        /**@internal */
        static _maxAreaLightCountPerClusterAverage: number;
        /**@internal */
        static _multiLighting: boolean;
        /**@internal 是否开启视锥裁剪调试 */
        static debugFrustumCulling: boolean;
    }
    type FEnumDescriptor = {
        name: string;
        value: any;
        extend?: FEnumDescriptor;
        [index: string]: any;
    }[] | any[] | Object | string;
    type FPropertyType = string | Function | Object | [
        FPropertyType
    ] | [
        "Record",
        FPropertyType
    ];
    interface FPropertyDescriptor {
        /**
        * @en Property name. Generally does not need to be set.
        * @zh 属性名称。一般不需要设定。
        */
        name: string;
        /**
         * @en Property type.
         * Basic types are: "number", "string", "boolean", "any", note that these are used as strings, not types.
         * Composite types are: arrays, expressed as ["number"]; dictionaries, expressed as ["Record", "number"], where the first element is fixed as "Record" and the second element is the actual type.
         * Other object types can directly use the class name, but note that the class must use the regClass decorator. Enum types are also supported. Enum types do not need regClass.
         * If type is not provided, it indicates that it is only used for UI style, has no actual corresponding data, and will not be serialized.
         * @zh 属性类型。
         * 基础类型有：number,string,boolean,any，注意是使用字符串，不是类型。
         * 复合类型有：数组，使用类似["number"]这样的方式表达；字典，使用类似["Record", "number"]这样的方式表达，第一个元素固定为Record，第二个元素为实际类型。
         * 其他对象类型可以直接使用类名，但要注意该类必须有使用regClass装饰器。也支持枚举类型。枚举类型不需要regClass。
         * 如果不提供type，表示只用于ui样式，没有实际对应数据，和不会序列化
         */
        type: FPropertyType;
        /**
         * @en The initial value of the property in the prototype. This value is also used for comparison during serialization, so if they are the same, this property will not be serialized. It must be ensured that the value set here is the initial value of the variable in the class.
         * @zh 该属性在原型中的初始值。这个值也用于序列化时比较，如果相同则不序列化这个属性，所以必须保证这里设置的值就是类中变量的初始值。
         */
        default?: any;
        /**
         * @en Title. If not provided, the name will be used.
         * @zh 标题。如果不提供，则使用name。
         */
        caption: string;
        /**
         * @en Tooltip text
         * @zh 提示文字
         */
        tips: string;
        /**
         * @en Property category. Setting the same value for multiple properties can display them in the same Inspector category.
         * @zh 属性栏目。为多个属性设置相同的值，可以将它们显示在同一个属性栏目内。
         */
        catalog: string;
        /**
         * @en Category title. If not provided, the category name will be used directly.
         * @zh 栏目标题。不提供则直接使用栏目名称。
         */
        catalogCaption: string;
        /**
         * @en The display order of the category, lower values are displayed in front. If not provided, it follows the order in which properties appear.
         * @zh 栏目的显示顺序，数值越小显示在前面。不提供则按属性出现的顺序。
         */
        catalogOrder: number;
        /**
         * @en The control for editing this property. Built-in ones include: number, string, boolean, color, vec2, vec3, vec4, asset
         * - number : Number input.
         * - string : String input. Default is single-line input, for multi-line, need to activate the multiline option.
         * - boolean : Boolean input, used for checkboxes or radio buttons.
         * - color : A color box + palette + color picker
         * - vec2 : Combination of X and Y inputs
         * - vec3 : Combination of X, Y, and Z inputs
         * - vec4 : Combination of X, Y, Z, and W inputs
         * - asset : Select resource
         * - Generally, you don't need to set this option, the editor will automatically select the appropriate control based on the property type, but in some cases you may need to specify it forcefully.
         * - For example, if the data type is Vector4, but it actually expresses a color, the default control for editing Vector4 is not suitable, and you need to set it to "color" here.
         * - Explicitly setting inspector to null will not construct an inspector for the property. This is different from setting hidden to true. When hidden is true, it is created but not visible,
         * while when inspector is null, it is not created at all.
         * @zh 编辑这个属性的控件。内置有：number,string,boolean,color,vec2,vec3,vec4,asset
         * - number : 数字输入。
         * - string : 字符串输入。默认为单行输入，如果是多行，需要激活multiline选项。
         * - boolean : 布尔值输入，用于单选框或多选框。
         * - color : 一个颜色框+调色盘+拾色器
         * - vec2 : XY输入的组合
         * - vec3 : XYZ输入的组合
         * - vec4 : XYZW输入的组合
         * - asset : 选择资源
         * - 一般来说，不需要设置这个选项，编辑器会自动根据属性类型选择适合的控件，但在某些情况下可以需要强制指定。
         * - 例如，如果数据类型是Vector4，但其实它表达的是颜色，用默认编辑Vector4的控件不适合，需要在这里设置为"color"。
         * - 显式设置inspector为null，则不会为属性构造inspector。这与hidden设置为true不同。hidden为true是创建但不可见，
         * inspector为null的话则是完全不创建。
         */
        inspector: string;
        /**
         * @en Hide control: true to hide, false to show. Often used in cases of associated properties.
         * - 1. Can use expressions by putting condition expressions in strings to get boolean type calculation results, for example "!data.a && !data.b" means when properties a and b are both empty, the condition is true, and this property is hidden.
         * - 2. Here, data is the object data of the current component, data.a and data.b property fields a and b refer to the a and b property values in the current component, by this method to get the property values in the component object data, used for conditional judgment, acting on whether the current property is hidden.
         * @zh 隐藏控制:true隐藏，false显示。常用于关联属性的情况。
         * - 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），隐藏这个属性。
         * - 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        hidden: boolean | string;
        /**
         * @en Read-only control.
         * - 1. Can use expressions by putting condition expressions in strings to get boolean type calculation results, for example "!data.a && !data.b" means when properties a and b are both empty, the condition is true, and this property is read-only.
         * - 2. Here, data is the object data of the current component, data.a and data.b property fields a and b refer to the a and b property values in the current component, by this method to get the property values in the component object data, used for conditional judgment, acting on whether the current property is hidden.
         * @zh 只读控制。
         * - 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），该属性只读。
         * - 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        readonly: boolean | string;
        /**
         * @en Data checking mechanism.
         * - 1. Pass in a string including expressions to judge whether it meets the conditions of the expression. If it meets the conditions, it needs to return an error message.
         * - 2. Usage example: "if(value == data.a) return 'Cannot be the same as the value of a'"
         * Where value is the value entered by the user for this property, data is the object data of the current component, data.a is the a property value in the current component
         * @zh 数据检查机制。
         * - 1. 将包括表达式的字符串传入，用于判断检查是否符合表达式的条件。符合条件，需要返回报错信息。
         * - 2. 使用示例为："if(value == data.a) return '不能与a的值相同'"
         * 其中的value为当前用户在该属性输入的值，data为当前组件的对象数据，data.a是当前组件中的a属性值
         */
        validator: string;
        /**
         * @en Whether to allow the data to be empty.
         * Can use expressions to return true or false results.
         * @zh 是否允许数据为空值。
         * 可以用表达式，返回true或者false的结果。
         */
        required: boolean | string;
        /**
         * @en Whether to serialize
         * @zh 是否序列化
         */
        serializable: boolean;
        /**
         * @en When the property does not participate in serialization, if its data may be affected by other serializable properties, fill in the names of other properties here. This is usually used to determine whether prefab properties are overridden.
         * @zh 属性在不参与序列化时，如果它的数据可能受其他可序列化的属性影响，在这里填写其他属性名称。这通常用于判断预制体属性是否覆盖。
         */
        affectBy: string;
        /**
         * @en Whether it's multi-line text input
         * @zh 是否多行文本输入
         */
        multiline: boolean;
        /**
         * @en Whether it's password input
         * @zh 是否密码输入
         */
        password: boolean;
        /**
         * @en If true or default, text input is submitted every time; otherwise, it's only submitted when losing focus
         * @zh 如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交
         */
        submitOnTyping: boolean;
        /**
         * @en If it's a text type, it's the prompt information for input text; if it's a boolean type, it's the title of the checkbox.
         * @zh 如果是文本类型，是输入文本的提示信息；如果是布尔类型，是多选框的标题。
         */
        prompt: string;
        /**
         * @en Define enumeration
         * @zh 定义枚举
         */
        enumSource: FEnumDescriptor;
        /**
         * @en Hide this property when the data source is empty
         * @zh 当数据源为空时，隐藏这个属性
         */
        hideIfEnumSourceEmpty: boolean;
        /**
         * @en Whether to invert the boolean value. For example, when the property value is true, the checkbox is displayed as unchecked.
         * @zh 是否反转布尔值。例如当属性值为true时，多选框显示为不勾选。
         */
        reverseBool: boolean;
        /**
         * @en Whether null values are allowed. Default is true. Sometimes it is necessary to explicitly set it to true, e.g. to display a checkbox for a color/vec2/vec3/vec4 inspector to determine whether the property value is null.
         * @zh 是否允许null值。默认为true。有时需要显式设置为true，例如为了显示一个color/vec2/vec3/vec4检查器的checkbox，决定属性值是否为null。
         */
        nullable: boolean;
        /**
         * @en For a property that can switch between null and non-null, when switching from a null value to a non-null value, the value here will be used.
         * @zh 对于可以在null和非null之间切换的属性，从null值切换到非null值时，会使用这里的值。
         */
        nonNullDefault?: any;
        /**
         * @en Minimum value for numbers
         * @zh 数字的最小值
         */
        min: number;
        /**
         * @en Maximum value for numbers
         * @zh 数字的最大值
         */
        max: number;
        /**
         * @en Value range, equivalent to setting min and max at once.
         * @zh 数值范围，等同于一次性设置min和max。
         */
        range: [
            number,
            number
        ];
        /**
         * @en The magnitude of value change each time when changing the value by dragging.
         * @zh 拖动方式改变数值时，每次数值改变的幅度。
         */
        step: number;
        /**
         * @en Number of decimal places
         * @zh 小数点后的位数
         */
        fractionDigits: number;
        /**
         * @en Display as percentage
         * @zh 显示为百分比
         */
        percentage: boolean;
        /**
         * @en Applicable to array type properties. Indicates that the array is of fixed length and not allowed to be modified.
         * @zh 对数组类型属性适用。表示数组是固定长度，不允许修改。
         */
        fixedLength: boolean;
        /**
         * @en Applicable to array type properties. Minimum length of the array. Default is null.
         * @zh 对数组类型属性适用。数组的最小长度。默认为null。
         */
        minArrayLength?: number;
        /**
         * @en Applicable to array type properties. Maximum length of the array. Default is null.
         * @zh 对数组类型属性适用。数组的最大长度。默认为null。
         */
        maxArrayLength?: number;
        /**
         * @en Applicable to array type properties. If not provided, it means the array allows all operations, if provided, only the listed operations are allowed.
         * @zh 对数组类型属性适用。如果不提供，则表示数组允许所有操作，如果提供，则只允许列出的操作。
         */
        arrayActions: Array<"append" | "insert" | "delete" | "move">;
        /**
         * @en Applicable to array type properties. Here you can define the properties of array elements
         * @zh 对数组类型属性适用。这里可以定义数组元素的属性
         */
        elementProps: Partial<FPropertyDescriptor>;
        /**
         * @en Applicable to color type properties. Indicates whether to provide modification of the transparency a value.
         * @zh 对颜色类型属性适用。表示是否提供透明度a值的修改。
         */
        showAlpha: boolean;
        /**
         * @deprecated Use 'nonNullDefault' instead.
         */
        defaultColor: any;
        /**
         * @deprecated Explicitly set 'nullable' to true to display a checkbox.
         */
        colorNullable: boolean;
        /**
         * @en Applicable to color type properties. When storing hexadecimal color values, this property determines the position of each channel. If the color value does not include an alpha channel, the default value is 'rgb'; if it does, the default value is 'argb'.
         * @zh 对颜色类型属性适用。存储十六进制颜色值时，这个属性决定每个通道的位置。如果颜色值不包含alpha通道，则默认值是'rgb'；如果包含，则默认值是'argb'。
         */
        colorFormat?: 'rgb' | 'argb' | 'abgr';
        /**
         * @en Applicable to object type properties. If true, hide the object's title, and the display indentation of the properties under the object will be reduced by one level.
         * @zh 对对象类型属性适用。如果为true，隐藏对象的标题，同时对象下的属性的显示缩进会减少一级。
         */
        hideHeader: boolean;
        /**
         * @en Applicable to object type properties. When creating an object, you can select a type from a dropdown menu. If explicitly set to null, the menu is disabled. By default, a menu for creating the base class is displayed.
         * @zh 对对象类型属性适用。对象创建时可以下拉选择一个类型。如果显示设置为null，则禁止菜单。默认是显示一个创建基类的菜单。
         */
        createObjectMenu: Array<string>;
        /**
         * @en Applicable to object type properties. Indicates that this property type has struct-like behavior characteristics, that is, it is always used as a whole.
         * For example, if the value of property b of object obj is a1, a1 is an instance of type T, and the structLike of type T is true, then when the properties of a1 change, the editor will simultaneously call obj.b = a1.
         * Default is false.
         * @zh 对对象类型属性适用。表示这个属性类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /**
         * @en Indicates that this property is a reference to a resource
         * @zh 说明此属性是引用一个资源
         */
        isAsset: boolean;
        /**
         * @en Applicable to resource type properties. Multiple resource types are separated by commas, for example "Image,Audio".
         * @zh 对资源类型的属性适用。多个资源类型用逗号分隔，例如"Image,Audio"。
         */
        assetTypeFilter: string;
        /**
         * @en If the property type is string, and when selecting a resource, this option determines whether the property value is the original path of the resource or in the format of res://uuid. If true, it's the original path of the resource. Default is false.
         * @zh 如果属性类型是string，并且进行资源选择时，这个选项决定属性值是资源原始路径还是res://uuid这样的格式。如果是true，则是资源原始路径。默认false。
         */
        useAssetPath: boolean;
        /**
         * @en Applicable to resource type properties. Whether to allow selection of internal resources when choosing a resource
         * @zh 对资源类型的属性适用。选择资源时是否允许选择内部资源
         */
        allowInternalAssets: boolean;
        /**
         * @en Applicable to resource type properties. You can set a custom filter. The filter needs to be registered first through EditorEnv.assetMgr.customAssetFilters.
         * @zh 对资源类型的属性适用。可以设置一个自定义的过滤器。过滤器需要先通过EditorEnv.assetMgr.customAssetFilters注册。
         */
        customAssetFilter: string;
        /**
         * @en Applicable to properties of type Node or Component. It sets a filter for the node/component types that can be selected. If not provided, all node types can be selected.
         * @zh 对类型是Node或者Component的属性适用。设置可以选择的节点/组件类型过滤器。如果不提供，则可以选择所有节点类型。
         */
        nodeTypeFilter: Array<string>;
        /**
         * @en Applicable to properties of type Node or Component. If not null, when deserialization is performed in the actual runtime environment, the referenced object is no longer instantiated, but its serialized data is saved as-is to the specified property.
         * @zh 对类型是Node或者Component的属性适用。如果不为null，当在实际运行环境里执行反序列化时，引用对象不再实例化，而是将它的序列化数据原样保存到指定的属性中。
         */
        toTemplate: string;
        /**
         * @en Display position. Syntax: before xxx/after xxx/first/last.
         * @zh 显示位置。语法：before xxx/after xxx/first/last。
         */
        position: string;
        /**
         * @en Increase indentation, unit is level, not pixels.
         * @zh 增加缩进，单位是层级，不是像素。
         */
        addIndent?: number;
        /**
         * @en Default collapsed state of sub-properties
         * @zh 子属性默认折叠状态
         */
        collapsed?: boolean;
        /**
         * @en Indicates that the property is a private property. Private properties will not be displayed in the Inspector, but will be serialized and saved.
         * @zh 表示属性是私有属性。私有属性不会显示在Inspector里，但会序列化保存。
         */
        "private": boolean;
        /**
         * @en If true, the property is always written during serialization. Otherwise, it is compared with the default value, and if they are the same, it is not written. Default is false.
         * @zh 如果为true，则属性在序列化时总是写入。否则，会和默认值比较，如果相同则不写入。默认为false。
         */
        forceWriteDefault?: boolean;
        /**
         * @en If true, the root node of the prefab instance will always write this property during serialization, regardless of whether it is overridden. This also means that this property will not appear in the override list. Default is false.
         * @zh 如果为true，则prefab实例的根节点在序列化时总是写入这个属性，不管是否被重写。这也意味着这个属性不会出现在重写列表中。默认为false。
         */
        forceWriteInPrefabRoot?: boolean;
        /**
         * @en Indicates whether the property is allowed to be edited in multiple selection situations. Default is true.
         * @zh 表示属性是否允许多选情况下编辑。默认true。
         */
        allowMultipleObjects: boolean;
        /**
         * @en Indicates that the property is not displayed in the property table of derived classes
         * @zh 表示属性不显示在派生类的属性表中
         */
        hideInDeriveType: boolean;
        /**
         * @en Indicates that the property is not allowed to reset to default by the "Reset Default" menu. Default is false.
         * @zh 表示属性不允许通过“重置为默认”菜单重置为默认值。默认为false。
         */
        disableReset?: boolean;
        /**
         * @en When the property changes, additionally call a function of the object, this is the function name.
         * The function prototype is func(key?:string). Where key is passed when changing internal properties of members.
         * For example, when changing the internal properties of an element of the data, key is the index of this element.
         * @zh 属性改变时额外调用对象的一个函数，这里是函数名称。
         * 函数原型是func(key?:string)。其中key在改变成员内部属性时会传递。
         * 例如改变数据某个元素的内部属性，则key是这个元素的索引。
         */
        onChange: string;
        /**
         * @en Additional options
         * @zh 额外的选项
         */
        options: Record<string, any>;
    }
    interface FTypeDescriptor {
        /**
         * @en Title. If not provided, the name will be used.
         * @zh 标题。如果不提供，则使用name。
         */
        caption: string;
        /**
         * @en URL of the help documentation.
         * @zh 帮助文档url地址。
         */
        help: string;
        /**
         * @en Add to the component menu.
         * @zh 添加到组件菜单。
         */
        menu: string;
        /**
         * @en When this type is clicked in the menu to create a new node, the name of the new node.
         * @zh 当在菜单中点击这个类型创建新节点时，新节点的名字。
         */
        newNodeName?: string;
        /**
         * @en Icon.
         * @zh 图标。
         */
        icon: string;
        /**
         * @en Whether it's a resource type.
         * @zh 是否资源类型。
         */
        isAsset: boolean;
        /**
         * @en Applicable to properties of resource types. Multiple resource types are separated by commas, e.g., "Image,Audio".
         * Available values can be found in editor/public/IAssetInfo.ts.
         * @zh 对资源类型的属性适用。多个资源类型用逗号分隔，例如"Image,Audio"。
         * 可用值参考editor/public/IAssetInfo.ts。
         */
        assetTypeFilter: string;
        /**
         * @en Effective when isAsset is true. When an instance of the asset is referenced by a field in the inspector, setting it to true allows the properties of the resource to be displayed inline. Similar to the display effect of materials. Default is false.
         * @zh 当isAsset为true时有效。当资源的实例被在inspector中的字段引用时，设置为true可以让资源的属性内联显示。类似于材质的显示效果。默认为false。
         */
        allowInpectInline?: boolean;
        /**
         * @en Indicates that this type has struct-like behavior, i.e., it's always used as a whole.
         * For example, if the value of property b of object obj is a1, a1 is an instance of type T,
         * and T's structLike is true, then when a1's properties change, the editor will also call obj.b = a1.
         * Default is false.
         * @zh 表示这个类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，
         * 那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /**
         * @en Initial value. This value is only used in the panel, it specifies the initial value
         * given to the property when creating an object from the interface.
         * @zh 初始值。这个值只在面板中使用，它指从界面上创建对象时赋予属性的初始值。
         */
        init: any;
        /**
         * @en List of properties.
         * @zh 属性列表。
         */
        properties: Array<Partial<FPropertyDescriptor>>;
        /**
         * @en Control for editing instances of this class.
         * @zh 编辑这个类实例的控件。
         */
        inspector: string;
        /**
         * @en Applicable to Components, indicates the type of node this component can be mounted on. Default is null.
         * @zh 对Component使用，表示这个组件允许挂载的节点类型。默认null。
         */
        worldType: "2d" | "3d" | null;
        /**
         * @en Applicable to Components, when AddComponent, add dependent Components at the same time.
         * @zh 对Component适用，当AddComponent时同时添加依赖的Component。
         */
        requireComponents?: Array<string>;
        /**
         * @en When creating a new node or adding a component, the dependent engine library is automatically added for Node and Component. For example: ["laya. physicals3D"]
         * @zh 对Node和Component使用，当新建Node或者添加Component时，自动添加依赖的引擎库。例如：["laya.physics3D"]
         */
        requireEngineLibs?: Array<string>;
        /**
         * @en Used for Component, if true and menu property is defined, this component will also
         * be displayed in the new object menu of the hierarchy panel.
         * @zh 对Component使用，如果为true，并且定义了menu属性，则这个组件还会显示在层级面板的新建对象菜单上。
         */
        inHierarchyMenu: boolean;
        /**
         * @en Additional options.
         * @zh 额外的选项。
         */
        options: Record<string, any>;
    }
    /**
     * @en Register a class so it can be automatically saved and loaded by the serialization system.
     * @param assetId The asset ID for the class.
     * @zh 注册一个类型，注册后才能被序列化系统自动保存和载入。
     * @param assetId 类型的资源ID。
     */
    function regClass(assetId?: string): any;
    /**
     * @en Set additional information for a class type.
     * @param info Additional information for the class type.
     * @zh 设置类型的额外信息。
     * @param info 类型的额外信息。
     */
    function classInfo(info?: Partial<FTypeDescriptor>): any;
    /**
     * @en Set the component to execute a complete lifecycle in the editor environment.
     * @param constructor The constructor of the component.
     * @zh 设置组件可以在编辑器环境中执行完整生命周期。
     * @param constructor 组件的构造函数。
     */
    function runInEditor(constructor: Function): void;
    /**
     * @en Allow multiple instances of the component to be added to the same node.
     * @param constructor The constructor of the component.
     * @zh 设置组件可以添加多个实例到同一个节点上。
     * @param constructor 组件的构造函数。
     */
    function allowMultiple(constructor: Function): void;
    /**
     * @en Use this decorator to make a property visible in the editor's property panel and serializable.
     * @param info The type of the property, such as Number, "number", [Number], ["Record", Number], etc.
     * Or pass an object describing detailed information, e.g., { type: "string", multiline: true }.
     * @zh 使用这个装饰器，可以使属性显示在编辑器属性设置面板上，并且能序列化保存。
     * @param info 属性的类型，如: Number,"number",[Number],["Record", Number]等。
     * 或传递对象描述详细信息，例如{ type: "string", multiline: true }。
     */
    function property(info: FPropertyType | Partial<FPropertyDescriptor>): any;
    /**
     * @en Register a resource loader.
     * @param fileExtensions File extensions that this loader can handle.
     * @param type Type identifier. If this resource needs to support identification without extension,
     * or if one extension corresponds to multiple resource types, specifying the type parameter is a best practice.
     * @param hotReloadable Whether it supports hot reloading.
     * @zh 注册一种资源装载器。
     * @param fileExtensions 扩展名。
     * @param type 类型标识。如果这种资源需要支持识别没有扩展名的情况，
     * 或者一个扩展名对应了多种资源类型的情况，那么指定type参数是个最优实践。
     * @param hotReloadable 是否支持热重载。
     */
    function regLoader(fileExtensions: string[], type?: string, hotReloadable?: boolean): (constructor: Function) => void;
    /**
     * @internal
     */
    class IAniLib {
        static Skeleton: typeof Skeleton;
        static AnimationTemplet: typeof AnimationTemplet;
        static Templet: typeof Templet;
    }
    /**
     * @internal
     * @author ...
     */
    class AnimationContent {
        nodes: AnimationNodeContent[];
        name: string;
        playTime: number;
        bone3DMap: any;
        totalKeyframeDatasLength: number;
    }
    /**
     * @internal
     */
    class AnimationNodeContent {
        name: string;
        parentIndex: number;
        parent: AnimationNodeContent;
        keyframeWidth: number;
        lerpType: number;
        interpolationMethod: any[];
        childs: any[];
        keyFrame: KeyFramesContent[];
        playTime: number;
        extenData: ArrayBuffer;
        dataOffset: number;
    }
    /**
     * @internal
     * @en The `AnimationParser01` class is responsible for parsing animation data.
     * @zh `AnimationParser01` 类用于解析动画数据。
     */
    class AnimationParser01 {
        /**
         * @private
         * @en Parses the animation data and populates the AnimationTemplet object.
         * This method reads various animation properties including bone structures, keyframes, and interpolation data.
         * @param templet The AnimationTemplet instance to populate with parsed data.
         * @param reader The Byte reader containing the animation data.
         * @zh 解析动画数据并填充 AnimationTemplet 对象。
         * 此方法读取各种动画属性，包括骨骼结构、关键帧和插值数据。
         * @param templet 要填充的 AnimationTemplet 对象。
         * @param reader 包含动画数据的 Byte 读取器。
         */
        static parse(templet: AnimationTemplet, reader: Byte): void;
    }
    /**
     * @internal
     * @en The `AnimationParser02` class is responsible for parsing animation data from a binary format into an `AnimationTemplet` object, which is then used for animation playback.
     * @zh `AnimationParser02` 类负责将二进制格式的动画数据解析到 `AnimationTemplet` 对象中，然后用于动画播放。
     */
    class AnimationParser02 {
        /**@internal */
        private static _templet;
        /**@internal */
        private static _reader;
        /**@internal */
        private static _strings;
        /**@internal */
        private static _BLOCK;
        /**@internal */
        private static _DATA;
        /**
         * @private
         * @en Reads the data offset and size from the binary reader.
         * @zh 从二进制读取器中读取数据偏移量和大小。
         */
        private static READ_DATA;
        /**
         * @private
         * @en Reads block information including count, starts, and lengths.
         * @zh 读取数据块信息，包括数量、起始位置和长度。
         */
        private static READ_BLOCK;
        /**
         * @private
         * @en Reads and stores string data from the binary reader.
         * @zh 从二进制读取器中读取并存储字符串数据。
         */
        private static READ_STRINGS;
        /**
         * @private
         * @en Parses the animation data from the binary reader into the AnimationTemplet.
         * This method orchestrates the overall parsing process, including reading data blocks and strings.
         * @param templet The `AnimationTemplet` instance to populate with parsed data.
         * @param reader The `Byte` reader containing the animation data.
         * @zh 将二进制读取器中的动画数据解析到 AnimationTemplet 中。
         * 此方法协调整个解析过程，包括读取数据块和字符串。
         * @param templet 要填充解析数据的 `AnimationTemplet` 实例。
         * @param reader 包含动画数据的 `Byte` 读取器。
         */
        static parse(templet: AnimationTemplet, reader: Byte): void;
        /**
         * @en Reads the animation data from the reader and initializes the animation content within the templet.
         * This method parses details such as keyframe width, interpolation methods, bone hierarchies, and keyframe data.
         * @zh 从读取器中读取动画数据，并在模板中初始化动画内容。
         * 此方法解析诸如关键帧宽度、插值方法、骨骼层次结构和关键帧数据等细节。
         */
        static READ_ANIMATIONS(): void;
    }
    /**
     * @en The AnimationPlayer class is used for animation players.
     * - Event.PLAYED: Schedule at start of playback.
     * - Event.PAUSED: Schedule when paused.
     * - Event.COMPLETE: Schedule upon completion of one cycle.
     * - Event.STOPPED: Schedule when stopped.
     * @zh AnimationPlayer类用于动画播放器。
     * - Event.PLAYED: 开始播放时调度。
     * - Event.PAUSED: 暂停时调度。
     * - Event.COMPLETE: 完成一次循环时调度。
     * - Event.STOPPED: 停止时调度。
     */
    class AnimationPlayer extends EventDispatcher {
        private _destroyed;
        /**@zh 数据模板*/
        private _templet;
        /**@zh 当前精确时间，不包括重播时间*/
        private _currentTime;
        /**@zh 当前帧时间，不包括重播时间*/
        private _currentFrameTime;
        /**@zh 动画播放的起始时间位置*/
        private _playStart;
        /**@zh 动画播放的结束时间位置*/
        private _playEnd;
        /**@zh 动画播放一次的总时间*/
        private _playDuration;
        /**@zh 动画播放总时间*/
        private _overallDuration;
        /**@zh 是否在一次动画结束时停止。 设置这个标志后就不会再发送complete事件了*/
        private _stopWhenCircleFinish;
        /**@zh 播放时帧数*/
        private _startUpdateLoopCount;
        /**@zh 当前动画索引*/
        private _currentAnimationClipIndex;
        /**@zh 当前帧数*/
        private _currentKeyframeIndex;
        /**@zh 是否暂停*/
        private _paused;
        /**@zh 默认帧率,必须大于0*/
        private _cacheFrameRate;
        /**@zh 帧率间隔时间*/
        private _cacheFrameRateInterval;
        /**@zh 缓存播放速率*/
        private _cachePlayRate;
        /**
         * @internal
         * @en The elapsed playback time, including replay time.
         * @zh 已播放时间，包括重播时间。
         */
        _elapsedPlaybackTime: number;
        /**
         * @en Whether to cache.
         * @zh 是否缓存。
         */
        isCache: boolean;
        /**
         * @en The playback rate of the animation.
         * @zh 播放速率。
         */
        playbackRate: number;
        /**
         * @en Whether to return to zero when stopped.
         * @zh 停止时是否归零。
         */
        returnToZeroStopped: boolean;
        /**
         * @en The animation data template.  Note: Modifying this value incurs computational overhead.
         * @zh 动画数据模板。注意：修改此值会有计算开销。
         */
        get templet(): AnimationTemplet;
        set templet(value: AnimationTemplet);
        /**
         * @en The start time position of the animation playback.
         * @zh 动画播放的起始时间位置。
         */
        get playStart(): number;
        /**
         * @en The end time position of the animation playback.
         * @zh 动画播放的结束时间位置。
         */
        get playEnd(): number;
        /**
         * @en The total duration of one playback of the animation.
         * @zh 动画播放一次的总时间。
         */
        get playDuration(): number;
        /**
         * @en The total duration of the animation playback.
         * @zh 动画播放的总时间
         */
        get overallDuration(): number;
        /**
         * @en The current animation clip index.
         * @zh 当前动画索引。
         */
        get currentAnimationClipIndex(): number;
        /**
         * @en The current keyframe index.
         * @zh 当前帧数。
         */
        get currentKeyframeIndex(): number;
        /**
         * @en The current precise time, excluding replay time.
         * @zh 当前精确时间，不包括重播时间。
         */
        get currentPlayTime(): number;
        /**
         * @en The current frame time, excluding replay time.
         * @zh 当前帧时间，不包括重播时间。
         */
        get currentFrameTime(): number;
        /**
         * @en The cached playback rate. The default value is 1.0, note: Modifying this value incurs computational overhead.
         * @zh 缓存播放速率。默认值为1.0,注意：修改此值会有计算开销。
         */
        get cachePlayRate(): number;
        set cachePlayRate(value: number);
        /**
         * @en The default frame rate. The default is 60 frames per second, note: Modifying this value incurs computational overhead.
         * @zh 默认帧率。默认为每秒60帧，注意：修改此值会有计算开销。
         */
        get cacheFrameRate(): number;
        set cacheFrameRate(value: number);
        /**
         * @en The current playback position.
         * @zh 当前播放位置。
         */
        set currentTime(value: number);
        /**
         * @en Whether the animation is currently paused.
         * @zh 当前是否暂停。
         */
        get paused(): boolean;
        set paused(value: boolean);
        /**
         * @en The cached frame rate interval time.
         * @zh 缓存帧率间隔时间。
         */
        get cacheFrameRateInterval(): number;
        /**
         * @en The current playback state of the animation.
         * @zh 当前动画的播放状态。
         */
        get state(): number;
        /**
         * @en If the animation instance has been destroyed.
         * @zh 动画实例是否已被销毁。
         */
        get destroyed(): boolean;
        /**
         * @en Constructor method of AnimationPlayer.
         * @zh 动画播放器的构造方法。
         */
        constructor();
        /**
         * @internal
         */
        _onTempletLoadedComputeFullKeyframeIndices(cachePlayRate: number, cacheFrameRate: number, templet: AnimationTemplet): void;
        /**
         * @internal
         */
        private _computeFullKeyframeIndices;
        /**
         * @internal
         */
        private _onAnimationTempletLoaded;
        /**
         * @internal
         */
        private _calculatePlayDuration;
        /**
         * @private
         */
        private _setPlayParams;
        /**
         * @private
         * 动画停止了对应的参数。目前都是设置时间为最后
         */
        private _setPlayParamsWhenStop;
        /**
         * @internal
         */
        _update(elapsedTime: number): void;
        /**
         * @internal
         */
        _destroy(): void;
        /**
         * @en Play animation based on time.
         * @param index The index of the animation to play.
         * @param playbackRate The rate at which to play the animation.
         * @param overallDuration The duration to play the animation (0 for once, Number.MAX_VALUE for loop play).
         * @param playStart The start time position of the playback.
         * @param playEnd The end time position of the playback (0 for the longest end time position of one loop of the animation).
         * @zh 基于时间来播放动画。
         * @param index 动画索引。
         * @param playbackRate 播放速率。
         * @param overallDuration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param playStart 播放的起始时间位置。
         * @param playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
         */
        play(index?: number, playbackRate?: number, overallDuration?: number, playStart?: number, playEnd?: number): void;
        /**
         * @en Play animation based on frame parameters.
         * @param index The index of the animation to play.
         * @param playbackRate The rate at which to play the animation.
         * @param overallDuration The duration to play the animation (0 for once, Number.MAX_VALUE for loop play).
         * @param playStartFrame The original start frame rate position for playback.
         * @param playEndFrame The original end frame rate position for playback (0 for the longest end time position of one loop of the animation).
         * @param fpsIn3DBuilder The frames per second in the 3D builder.
         * @zh 基于帧的参数来播放动画。
         * @param index 动画索引。
         * @param playbackRate 播放速率。
         * @param overallDuration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param playStartFrame 播放的原始起始帧率位置。
         * @param playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
         * @param fpsIn3DBuilder 3D构建器中的帧率。
         */
        playByFrame(index?: number, playbackRate?: number, overallDuration?: number, playStartFrame?: number, playEndFrame?: number, fpsIn3DBuilder?: number): void;
        /**
         * @en Stop playing the current animation.
         * If you don't stop immediately, wait for the animation to finish playing before stopping
         * @param immediate Whether to stop immediately. The default value is true.
         * @zh 停止播放当前动画。
         * 如果不是立即停止，则会等待动画播放完成后再停止。
         * @param immediate 是否立即停止，默认为true。
         */
        stop(immediate?: boolean): void;
        /**
         * @ignore
         */
        destroy(): void;
    }
    /**
     * @internal
     */
    class AnimationState {
        static stopped: number;
        static paused: number;
        static playing: number;
        constructor();
    }
    /**
     * @en The AnimationTemplate class is used for animation template resources.
     * @zh AnimationTemplet类用于动画模板资源。
     * @blueprintIgnore
     */
    class AnimationTemplet extends Resource {
        /**
         * @en Interpolation function
         * @zh 插值函数
         */
        static interpolation: any[];
        private static _LinearInterpolation_0;
        private static _QuaternionInterpolation_1;
        private static _AngleInterpolation_2;
        private static _RadiansInterpolation_3;
        private static _Matrix4x4Interpolation_4;
        private static _NoInterpolation_5;
        private static _BezierInterpolation_6;
        private static _BezierInterpolation_7;
        /**
         * 加载动画模板。
         * @param url 动画模板地址。
         */
        /**@internal */
        _aniVersion: string;
        /**@internal */
        _anis: AnimationContent[];
        /**@internal */
        _aniMap: any;
        /**
         * @internal
         * @en Public Extended Data
         * @zh 公共扩展数据
         */
        _publicExtData: ArrayBuffer;
        /**
         * @internal
         * @en Whether to use object tree data format
         * @zh 是否采用对象树数据格式
         */
        _useParent: boolean;
        /**@private */
        protected unfixedCurrentFrameIndexes: Uint32Array;
        /**@private */
        protected unfixedCurrentTimes: Float32Array;
        /**@private */
        protected unfixedKeyframes: KeyFramesContent[];
        /**@private */
        protected unfixedLastAniIndex: number;
        /**@internal */
        _aniClassName: string;
        /**@internal */
        _animationDatasCache: any;
        /**@internal */
        _fullFrames: any[];
        /**
         * 记录每个骨骼当前在动画的第几帧。这个是为了去掉缓存的帧索引数据。
        */
        private _boneCurKeyFrm;
        /**@ignore */
        constructor();
        /**
         * @internal
         */
        _calculateKeyFrame(node: AnimationNodeContent, keyframeCount: number, keyframeDataCount: number): void;
        /**
         * @internal
         */
        _onAsynLoaded(data: any, propertyParams?: any): void;
        /**
         * @en Get the number of animations.
         * @zh 获取动画的数量。
         */
        getAnimationCount(): number;
        /**
         * @en Retrieve an animation by its index.
         * @param aniIndex The index of the animation to retrieve.
         * @zh 通过索引获取动画。
         * @param aniIndex 要获取的动画的索引。
         */
        getAnimation(aniIndex: number): any;
        /**
         * @en Get the duration of an animation.
         * @param aniIndex The index of the animation to check.
         * @zh 获取动画时长。
         * @param aniIndex 要检查的动画的索引。
         */
        getAniDuration(aniIndex: number): number;
        /**
         * @en Get information about the nodes involved in an animation.
         * @param aniIndex The index of the animation.
         * @zh 获取动画的nodes信息。
         * @param aniIndex 指定动画的索引。
         */
        getNodes(aniIndex: number): any;
        /**
         * @en Retrieve the index of a bone by its name within an animation.
         * @param aniIndex The index of the animation.
         * @param name The name of the bone to retrieve.
         * @returns The index of the bone.
         * @zh 通过名称获取动画中的骨骼索引。
         * @param aniIndex 动画的索引。
         * @param name 要检索的骨骼名称。
         * @returns 骨骼的索引。
         */
        getNodeIndexWithName(aniIndex: number, name: string): number;
        /**
         * @en Get the count of nodes in an animation.
         * @param aniIndex The index of the animation.
         * @returns The number of nodes in the animation.
         * @zh 获取动画中的nodes数量。
         * @param aniIndex 动画的索引。
         * @returns 动画中的nodes数量。
         */
        getNodeCount(aniIndex: number): number;
        /**
         * @en Get the total length of keyframes in an animation.
         * @param aniIndex The index of the animation.
         * @returns The total number of keyframes.
         * @zh 获取动画关键帧长度。
         * @param aniIndex 动画的索引。
         * @returns 动画关键帧总数。
         */
        getTotalkeyframesLength(aniIndex: number): number;
        /**
         * @en Get the public extension data associated with the animation.
         * @returns The ArrayBuffer containing the public extension data.
         * @zh 获取动画的附加数据。
         * @returns 包含附加数据的ArrayBuffer。
         */
        getPublicExtData(): ArrayBuffer;
        /**
         * @en Retrieve animation data with caching mechanism.
         * @param key The key associated with the data to retrieve.
         * @param cacheDatas The cache data storage.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame to retrieve data from.
         * @returns The Float32Array containing the animation data, or null if not found.
         * @zh 使用缓存机制获取动画数据。
         * @param key 与要检索的数据关联的键。
         * @param cacheDatas 缓存数据存储。
         * @param aniIndex 动画的索引。
         * @param frameIndex 要检索数据的帧索引。
         * @returns 包含动画数据的Float32Array，如果未找到则返回null。
         */
        getAnimationDataWithCache(key: any, cacheDatas: any, aniIndex: number, frameIndex: number): Float32Array;
        /**
         * @en Set animation data with caching mechanism.
         * @param key The key associated with the data to set.
         * @param cacheDatas The array of cache data storages.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame to set data to.
         * @param data The data to set.
         * @zh 设置动画数据并使用缓存机制。
         * @param key 与要设置的数据关联的键。
         * @param cacheDatas 缓存数据存储数组。
         * @param aniIndex 动画的索引。
         * @param frameIndex 要设置数据的帧索引。
         * @param data 要设置的数据。
         */
        setAnimationDataWithCache(key: any, cacheDatas: any[], aniIndex: number, frameIndex: number, data: any): void;
        /**
         * @en Calculate which keyframe corresponds to the current time.
         * - There is an issue with the last frame. For example, if the time of the second to last frame is 0.033ms,
         * the next two frames are very close together. When the actual last frame is given, the time calculated
         * based on the frame number actually falls on the second to last frame.
         * Using accumulated time consistent with AnimationPlayer will resolve this issue.
         * @param nodeframes The keyframe data for the current bone.
         * @param nodeid The bone ID, used for updating the _boneCurKeyFrm.
         * @param tm The current time in the animation.
         * @returns The index of the keyframe that corresponds to the current time.
         * @zh 计算当前时间应该对应关键帧的哪一帧。
         * - 最后一帧有问题，例如倒数第二帧时间是0.033ms,则后两帧非常靠近，当实际给最后一帧的时候，根据帧数计算出的时间实际上落在倒数第二帧使用与AnimationPlayer一致的累积时间就行
         * @param nodeframes 当前骨骼的关键帧数据。
         * @param nodeid 骨骼ID，用于更新 _boneCurKeyFrm。
         * @param tm 当前动画的时间。
         * @returns 对应当前时间的关键帧的索引。
         */
        getNodeKeyFrame(nodeframes: KeyFramesContent[], nodeid: number, tm: number): number;
        /**
         * @en Retrieve and fill the original animation data for a specific frame and time.
         * @param aniIndex The index of the animation.
         * @param originalData A Float32Array to be filled with the retrieved animation data. This array is modified in-place.
         * @param nodesFrameIndices An array containing frame indices for each node (Note: This parameter is not used in the current implementation).
         * @param frameIndex The index of the frame to retrieve data for (Note: This parameter is not used in the current implementation).
         * @param playCurTime The current play time in the animation (in milliseconds).
         * @zh 获取并填充特定帧和时间的原始动画数据。
         * @param aniIndex 动画的索引。
         * @param originalData 用于存储检索到的动画数据的Float32Array。此数组会被直接修改。
         * @param nodesFrameIndices 包含每个节点的帧索引的数组（注意：当前实现中已删除此参数，为保持旧版本兼容而保留）。
         * @param frameIndex 要获取数据的帧索引（注意：当前实现中已删除此参数，为保持旧版本兼容而保留）。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         */
        getOriginalData(aniIndex: number, originalData: Float32Array, nodesFrameIndices: any[], frameIndex: number, playCurTime: number): void;
        /**
         * @en Get the current frame index for each node in the specified animation.
         * @param aniIndex The index of the animation to retrieve node information from.
         * @param playCurTime The current play time of the animation in milliseconds.
         * @returns A Uint32Array containing the current frame index for each node.
         * @zh 获取指定动画中每个节点的当前帧索引。
         * @param aniIndex 要检索节点信息的动画索引。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         * @returns 包含每个节点当前帧索引的Uint32Array。
         */
        getNodesCurrentFrameIndex(aniIndex: number, playCurTime: number): Uint32Array;
        /**
         * @en Retrieve and fill the original animation data at a specific time for the given animation.
         * @param aniIndex The index of the animation to retrieve data from.
         * @param originalData A Float32Array to be filled with the retrieved animation data. This array is modified in-place.
         * @param playCurTime The current play time of the animation in milliseconds.
         * @zh 获取并填充指定动画在特定时间的原始动画数据。
         * @param aniIndex 要检索数据的动画索引。
         * @param originalData 用于存储检索到的动画数据的Float32Array。此数组会被直接修改。
         * @param playCurTime 动画的当前播放时间（毫秒）。
         */
        getOriginalDataUnfixedRate(aniIndex: number, originalData: Float32Array, playCurTime: number): void;
    }
    /**
     * @private
     * @en The `Bone` class , used for skeletal animations.
     * @zh 骨骼类,用于骨骼动画
     */
    class Bone {
        /**
         * @en The visibility state of bones.
         * @zh 骨骼的可见性状态。
         */
        static ShowBones: any;
        /**
         * @en The name of the bone.
         * @zh 骨骼的名称。
         */
        name: string;
        /**
         * @en The root bone of the skeleton.
         * @zh 骨骼的根骨骼。
         */
        root: Bone;
        /**
         * @en The parent bone of this bone.
         * @zh 此骨骼的父骨骼。
         */
        parentBone: Bone;
        /**
         * @en The length of the bone, default is 10.
         * @zh 骨骼的长度，默认为 10。
         */
        length: number;
        /**
         * @en The transform properties of the bone.
         * @zh 骨骼的变换属性。
         */
        transform: Transform;
        /**
         * @en The result transform of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果变换。
         */
        resultTransform: Transform;
        /**
         * @en The result matrix of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果矩阵。
         */
        resultMatrix: Matrix;
        /**
         * @en Whether the bone inherits scale from its parent.
         * @zh 是否从父骨骼继承缩放。
         */
        inheritScale: boolean;
        /**
         * @en Whether the bone inherits rotation from its parent.
         * @zh 是否从父骨骼继承旋转。
         */
        inheritRotation: boolean;
        /**
         * @en The rotation of the bone in degrees.
         * @zh 骨骼的旋转角度，以度为单位。
         */
        rotation: number;
        /**
         * @en The result rotation of the bone after applying all transformations.
         * @zh 应用所有变换后骨骼的结果旋转。
         */
        resultRotation: number;
        d: number;
        /**@internal */
        private _tempMatrix;
        /**@internal */
        private _children;
        /**@internal */
        private _sprite;
        constructor();
        /**
         * @en Sets the temporary matrix for this bone and recursively for all child bones.
         * @param matrix The matrix to set as the temporary matrix.
         * @zh 为这个骨骼及其所有子骨骼设置临时矩阵。
         * @param matrix 要设置为临时矩阵的矩阵。
         */
        setTempMatrix(matrix: Matrix): void;
        /**
         * @en Updates the transformation of this bone and recursively updates all child bones.
         * @param pMatrix An optional matrix to apply to the transformation.
         * @zh 更新此骨骼的变换并递归更新所有子骨骼。
         * @param pMatrix 一个可选的矩阵，用于应用到变换中。
         */
        update(pMatrix?: Matrix | null): void;
        /**
         * @en Updates all child bones of this bone.
         * @zh 更新此骨骼的所有子骨骼。
         */
        updateChild(): void;
        /**
         * @en Convert the rotation of bone sprites from radians to degrees.
         * @param rd The rotation in radians.
         * @zh 将骨骼精灵的旋转从弧度转换为度。
         * @param rd 弧度值。
         */
        setRotation(rd: number): void;
        /**
         * @en Updates the drawing of the bone and its sprite at the specified position.
         * @param x The x-coordinate position to draw the bone.
         * @param y The y-coordinate position to draw the bone.
         * @zh 在指定的位置更新骨骼及其精灵的绘制。
         * @param x 绘制骨骼的 x 坐标位置。
         * @param y 绘制骨骼的 y 坐标位置。
         */
        updateDraw(x: number, y: number): void;
        /**
         * @en Adds a bone as a child to this bone.
         * @param bone The bone to be added as a child.
         * @zh 将一个骨骼添加为此骨骼的子骨骼。
         * @param bone 要添加为子骨骼的骨骼。
         */
        addChild(bone: Bone): void;
        /**
         * @en Finds a bone by its name in the hierarchy of this bone.
         * @param boneName The name of the bone to find.
         * @returns The bone if found, otherwise null.
         * @zh 在此骨骼的层级结构中按名称查找骨骼。
         * @param boneName 要查找的骨骼名称。
         * @returns 如果找到返回骨骼，否则返回 null。
         */
        findBone(boneName: string): Bone | null;
        /**
         * @en Converts local coordinates to world coordinates using this bone's transformation matrix.
         * @param local The local coordinates array to be converted.
         * @zh 使用此骨骼的变换矩阵将本地坐标转换为世界坐标。
         * @param local 要转换的本地坐标数组。
         */
        localToWorld(local: number[]): void;
    }
    /**
     * @en The `BoneSlot` class represents a slot in a skeletal animation that can display different skins or attachments.
     * @zh `BoneSlot` 类代表骨骼动画中的一个插槽，可以显示不同的皮肤或附件。
     */
    class BoneSlot {
        /**
         * @en The name of the slot.
         * @zh 插槽的名称。
         */
        name: string;
        /**
         * @en The name of the bone to which the slot is attached.
         * @zh 插槽绑定的骨骼名称。
         */
        parent: string;
        /**
         * @en The name of the current display data or attachment.
         * @zh 插槽显示数据数据的名称。
         */
        attachmentName: string;
        /**
         * @en The original index of the data.
         * @zh 原始数据的索引。
         */
        srcDisplayIndex: number;
        /**
         * @en Used to determine if it is the original object.
         * @zh 判断对象是否是原对象。
         */
        type: string;
        /**
         * @en The pointer to the template.
         * @zh 模板的指针。
         */
        templet: Templet;
        /**
         * @en The current slot data that the slot corresponds to.
         * @zh 当前插槽对应的数据。
         */
        currSlotData: SlotData;
        /**
         * @en The current texture that the slot is displaying.
         * @zh 当前插槽显示的纹理。
         */
        currTexture: Texture | null;
        /**
         * @en The data corresponding to the display object.
         * @zh 显示对象对应的数据。
         */
        currDisplayData: SkinSlotDisplayData | null;
        /**
         * @en The index of the displayed skin.
         * @zh 显示皮肤的索引。
         */
        displayIndex: number;
        /** @private */
        originalIndex: number;
        /**
         * @internal 用户自定义的皮肤。
         */
        private _diyTexture;
        /**@internal */
        private _parentMatrix;
        /**@internal */
        private _resultMatrix;
        /** @internal 索引替换表 */
        private _replaceDic;
        /** @internal 当前diyTexture的动画纹理 */
        private _curDiyUV;
        /** @internal 实时模式下，复用使用 */
        private _skinSprite;
        /** @private 变形动画数据 */
        deformData: any[];
        /**
         * @en Sets the slot data to be displayed.
         * @param slotData The slot data to display.
         * @param freshIndex Whether to reset the texture, default is true.
         * @zh 设置要显示的插槽数据。
         * @param slotData 要显示的插槽数据。
         * @param freshIndex 是否重置纹理，默认为 true。
         */
        showSlotData(slotData: SlotData, freshIndex?: boolean): void;
        /**
         * @en Displays the specified object by name.
         * @param name The name of the object to display.
         * @zh 通过名字显示指定对象。
         * @param name 要显示的对象的名称。
         */
        showDisplayByName(name: string): void;
        /**
         * @en Replaces the texture by name.
         * @param tarName The name of the texture to be replaced.
         * @param newName The name of the new texture to replace with.
         * @zh 替换贴图名。
         * @param tarName 要替换的贴图名
         * @param newName 替换后的贴图名
         */
        replaceDisplayByName(tarName: string, newName: string): void;
        /**
         * @en Replaces the display by index.
         * @param tarIndex The index of the display to be replaced.
         * @param newIndex The new index to replace with.
         * @zh 替换贴图索引。
         * @param tarIndex 要替换的索引
         * @param newIndex 替换后的索引
         */
        replaceDisplayByIndex(tarIndex: number, newIndex: number): void;
        /**
         * @en Displays the object by index.
         * @param index The index of the display object.
         * @zh 指定显示对象。
         * @param index 要显示的对象索引。
         */
        showDisplayByIndex(index: number): void;
        /**
         * @en Replaces the skin with a custom texture.
         * @param _texture The custom texture to replace the skin.
         * @zh 替换皮肤。
         * @param _texture 要替换的自定义皮肤。
         */
        replaceSkin(_texture: Texture): void;
        /**
         * @en Saves the index of the parent matrix.
         * @param parentMatrix The parent matrix to save.
         * @zh 保存父矩阵的索引。
         * @param parentMatrix 要保存的父矩阵。
         */
        setParentMatrix(parentMatrix: Matrix): void;
        private _mVerticleArr;
        /**
         * @en Create SkinGraphic Mesh data.
         * @zh 创建SkinGraphic网格数据
         */
        static createSkinMesh(): any;
        private static isSameArr;
        /**@internal */
        private static _tempResultMatrix;
        /**@internal */
        private _preGraphicVerticle;
        private getSaveVerticle;
        /**
         * @en Compares two matrices to check if they are identical.
         * @param mtA The first matrix.
         * @param mtB The second matrix.
         * @returns Whether the matrices are identical.
         * @zh 比较两个矩阵是否相同
         * @param mtA 第一个矩阵。
         * @param mtB 第二个矩阵。
         * @returns 是否相同
         */
        static isSameMatrix(mtA: Matrix, mtB: Matrix): boolean;
        private _preGraphicMatrix;
        private static useSameMatrixAndVerticle;
        private getSaveMatrix;
        /**
         * @en Draws the texture onto the Graphics object.
         * @param graphics The Graphics object to draw the texture onto.
         * @param boneMatrixArray An array of matrices corresponding to bone transformations.
         * @param noUseSave If true, do not use the shared matrix object _tempResultMatrix; only set to true when calculating in real-time.
         * @param alpha The alpha value for the texture being drawn, default is 1 (fully opaque).
         * @zh 将纹理绘制到 Graphics 对象上。
         * @param graphics 要在其上绘制纹理的Graphics对象。
         * @param boneMatrixArray 对应骨骼变换的矩阵数组。
         * @param noUseSave 如果为 true，则不使用共享的矩阵对象 _tempResultMatrix；仅在实时计算时设置为 true。
         * @param alpha 绘制纹理的透明度值，默认为 1（完全不透明）。
         */
        draw(graphics: GraphicsAni, boneMatrixArray: any[], noUseSave?: boolean, alpha?: number): void;
        /**
         * 显示蒙皮动画
         * @param boneMatrixArray 当前帧的骨骼矩阵
         */
        private skinMesh;
        /**
         * @en Draws the bone's origin point for debugging purposes.
         * @param graphics The Graphics object to draw the bone origin point.
         * @zh 绘制骨骼的起始点，方便调试。
         * @param graphics 要绘制骨骼起始点的 Graphics 对象。
         */
        drawBonePoint(graphics: Graphics): void;
        /**
         * 得到显示对象的矩阵
         * @return
         */
        private getDisplayMatrix;
        /**
         * @en Gets the matrix of the slot.
         * @zh 获取插槽的矩阵。
         */
        getMatrix(): Matrix;
        /**
         * @en Copies the original data to create a new instance.
         * @returns A new BoneSlot instance copied from the original data.
         * @zh 使用原始数据拷贝出一个新实例。
         * @returns 返回从原始数据拷贝出的新 BoneSlot 实例。
         */
        copy(): BoneSlot;
    }
    /**
     * @en Mesh data
     * @zh 网格数据
     */
    class MeshData {
        /**
         * @en Texture
         * @zh 纹理
         */
        texture: Texture;
        /**
         * @en UV data
         * @zh UV数据
         */
        uvs: Float32Array;
        /**
         * @en Vertex data
         * @zh 顶点数据
         */
        vertices: Float32Array;
        /**
         * @en Vertex indices
         * @zh 顶点索引
         */
        indexes: Uint16Array;
        /**
         * @en UV transform matrix
         * @zh UV变换矩阵
         */
        uvTransform: Matrix;
        /**
         * @en Whether to use UV transform matrix
         * @zh 是否使用UV变换矩阵
         */
        useUvTransform: boolean;
        /**
         * @en Extended pixels used to remove black edges
         * @zh 扩展像素，用于去除黑边
         */
        canvasPadding: number;
        /**
         * @en Calculate the bounds of the mesh
         * @returns Rectangle representing the bounds of the mesh
         * @zh 计算网格的边界
         * @returns 表示网格边界的矩形
         */
        getBounds(): Rectangle;
    }
    /**
     * @en Create SkinGraphic Mesh data.
     * @zh 创建SkinGraphic网格数据
     */
    class SkinMeshForGraphic extends MeshData {
        /**
         * @en Constructor method. Create SkinGraphic Mesh data.
         * @zh 构造方法，创建SkinGraphic网格数据
         */
        constructor();
        /**
         * @en Transform matrix
         * @zh 变换矩阵
         */
        transform: Matrix | null;
        /**
         * @en Create Texture MeshData
         * @param texture Texture
         * @param ps Index data
         * @param verticles Vertex data
         * @param uvs UV data
         * @zh 创建纹理网格数据
         * @param texture 纹理
         * @param ps 索引数据
         * @param verticles 顶点数据
         * @param uvs UV数据
         */
        init2(texture: Texture, ps: any[], verticles: any[], uvs: any[]): void;
    }
    /**
     * @internal
     */
    class DeformAniData {
        skinName: string;
        deformSlotDataList: DeformSlotData[];
        constructor();
    }
    /**
     * @internal
     * @en Deformation slot data class
     * Used to store and manage deformation data for a single slot.
     * @zh 变形插槽数据类
     * 用于存储和管理单个插槽的变形数据
     */
    class DeformSlotData {
        /**
         * @en Deformation slot display data list
         * Contains deformation data for the slot in different display states.
         * @zh 变形插槽显示数据列表
         * 包含了插槽在不同显示状态下的变形数据
         */
        deformSlotDisplayList: DeformSlotDisplayData[];
        constructor();
    }
    /**
     * @internal
     * @en The `DeformSlotDisplayData` class is used internally to store and manage the display data for deformable slots in animations.
     * @zh `DeformSlotDisplayData` 类用于在动画中存储和管理可变形插槽的显示数据。
     */
    class DeformSlotDisplayData {
        /**
         * @en The bone slot to which the deform data is applied.
         * @zh 应用变形数据的骨骼插槽。
         */
        boneSlot: BoneSlot;
        /**
         * @en The index of the slot in the skin.
         * @zh 插槽在皮肤中的索引。
         */
        slotIndex: number;
        /**
         * @en The name of the attachment associated with the deform data.
         * @zh 与变形数据相关的附件名称。
         */
        attachment: string;
        /**
         * @en A list of time values corresponding to the keyframes of the deform animation.
         * @zh 对应于变形动画关键帧的时间值列表。
         */
        timeList: number[];
        /**
         * @en A list of vertex data arrays for each keyframe, representing the deformed state.
         * @zh 每个关键帧的顶点数据数组列表，代表变形状态。
         */
        vectices: any[][];
        /**
         * @en A list indicating whether there is a tween between keyframes.
         * @zh 指示关键帧之间是否存在缓动的列表。
         */
        tweenKeyList: boolean[];
        /**
         * @en The deformed vertex data applied to the slot.
         * @zh 应用于插槽的变形顶点数据。
         */
        deformData: any[];
        /**
         * @en The current frame index for the deform animation.
         * @zh 变形动画的当前帧索引。
         */
        frameIndex: number;
        constructor();
        private binarySearch1;
        /**
         * @en Applies the deform data to the bone slot based on the given time and alpha value.
         * @param time The current time of the animation.
         * @param boneSlot The bone slot to which the deform data will be applied.
         * @param alpha The alpha value for tweening between keyframes, default is 1.
         * @zh 根据给定的时间和 alpha 值将变形数据应用到骨骼插槽。
         * @param time 当前动画的时间。
         * @param boneSlot 应用变形数据的骨骼插槽。
         * @param alpha 用于在关键帧之间补间的 alpha 值，默认为 1。
         */
        apply(time: number, boneSlot: BoneSlot, alpha?: number): void;
    }
    /**
     * @internal
     * @en The `DrawOrderData` class is used internally to manage the draw order data which determines the rendering order of the elements in an animation frame.
     * @zh `DrawOrderData` 类用于内部管理绘制顺序数据，该数据确定动画帧中元素的渲染顺序。
     */
    class DrawOrderData {
        /**
         * @en The time at which the draw order is defined.
         * @zh 定义绘制顺序的时间点。
         */
        time: number;
        /**
         * @en A list of indices representing the draw order of the slots at the given time.
         * @zh 代表给定时间点插槽绘制顺序的索引列表。
         */
        drawOrder: number[];
        constructor();
    }
    /**
     * @en Event data of Skeleton animation.
     * @zh 骨骼动画事件数据
     */
    class EventData {
        /**
         * @en The name of the event.
         * @zh 事件的名称。
         */
        name: string;
        /**
         * @en An integer data.
         * @zh 整数数据。
         */
        intValue: number;
        /**
         * @en A single-precision floating point data.
         * @zh 单精度浮点数数据。
         */
        floatValue: number;
        /**
         * @en String data.
         * @zh 字符串数据。
         */
        stringValue: string;
        /**
         * @en Multimedia data.
         * @zh 多媒体数据。
         */
        audioValue: string;
        /**
         * @en Time data.
         * @zh 时间数据。
         */
        time: number;
        constructor();
    }
    /**
     * @internal
     * @en Represents an inverse kinematics (IK) constraint in a skeletal animation system.
     * @zh 表示骨骼动画系统中的逆动力学（IK）约束。
     */
    class IkConstraint {
        /**@internal */
        private _targetBone;
        /**@internal */
        private _bones;
        /**@internal */
        /**
         * @en The name of the inverse kinematics constraint.
         * @zh IK约束的名称。
         */
        name: string;
        /**
         * @en The mix value determines the influence of the constraint on the bones, ranging from 0 (no effect) to 1 (full effect).
         * @zh 混合值确定约束对骨骼的影响程度，范围从 0（无效果）到 1（完全有效）。
         */
        mix: number;
        /**
         * @en The bend direction of the bones in the constraint, which can be positive or negative.
         * @zh 约束中骨骼的弯曲方向，可以是正向或负向。
         */
        bendDirection: number;
        /**
         * @en Indicating whether the constraint is applied using the Spine algorithm.
         * @zh 指示是否使用 Spine 算法应用约束。
         */
        isSpine: boolean;
        /**
         * @en A static property that converts radians to degrees.
         * @zh 一个静态属性，用于将弧度转换为度数。
         */
        static radDeg: number;
        /**
         * @en A static property that converts degrees to radians.
         * @zh 一个静态属性，用于将度数转换为弧度。
         */
        static degRad: number;
        constructor(data: IkConstraintData, bones: Bone[]);
        /**
         * @en Apply the IK constraint
         * @zh 应用IK约束
         */
        apply(): void;
        /**@internal */
        private _applyIk1;
        /**@internal */
        private _sp;
        private isDebug;
        /**
         * @en Update the position of the debug sprite
         * @param x The x-coordinate of the new position
         * @param y The y-coordinate of the new position
         * @zh 更新调试精灵的位置
         * @param x 新位置的x坐标
         * @param y 新位置的y坐标
         */
        updatePos(x: number, y: number): void;
        /**@internal */
        private _applyIk2;
        /**@internal */
        private _applyIk3;
    }
    /**
     * @internal
     * @en Represents the data structure for an inverse kinematics (IK) constraint in a skeletal animation system.
     * @zh 表示骨骼动画系统中逆动力学（IK）约束的数据结构。
     */
    class IkConstraintData {
        /**
         * @en The name of the IK constraint.
         * @zh IK 约束的名称。
         */
        name: string;
        /**
         * @en The name of the target bone that the IK constraint targets.
         * @zh IK 约束所指向的目标骨骼的名称。
         */
        targetBoneName: string;
        /**
         * @en An array of bone names that are affected by the IK constraint.
         * @zh 受 IK 约束影响的骨骼名称数组。
         */
        boneNames: string[];
        /**
         * @en The bend direction of the IK constraint.
         * @zh IK 约束的弯曲方向。
         */
        bendDirection: number;
        /**
         * @en The mix value of the IK constraint, influencing the weight of the constraint.
         * @zh IK 约束的混合值，影响约束的权重。
         */
        mix: number;
        /**
         * @en A boolean indicating whether the IK constraint is used in a Spine project.
         * @zh 一个布尔值，指示 IK 约束是否用于 Spine 项目。
         */
        isSpine: boolean;
        /**
         * @en The index of the target bone in the skeleton.
         * @zh 在骨架中目标骨骼的索引。
         */
        targetBoneIndex: number;
        /**
         * @en An array of bone indices affected by the IK constraint.
         * @zh 受 IK 约束影响的骨骼索引数组。
         */
        boneIndexs: number[];
        constructor();
    }
    /**
     * @internal
     * @en The `PathConstraint` class is used to control the movement of bones based on a path.
     * It performs the following operations:
     * 1. Generates control points based on bone calculations
     * 2. Generates the path and calculates the nodes on the path.
     * 3. Adjusts the position of the bones based on the nodes.
     * @zh `PathConstraint` 类是路径作用器，用于根据路径控制骨骼的移动。
     * 它执行以下操作：
     * 1. 生成根据骨骼计算控制点
     * 2. 根据控制点生成路径，并计算路径上的节点。
     * 3. 根据节点，重新调整骨骼的位置。
     */
    class PathConstraint {
        private static BEFORE;
        private static AFTER;
        /**
         * @en The target bone slot that the path constraint is applied to.
         * @zh 应用路径约束的目标骨骼插槽。
         */
        target: BoneSlot;
        /**
         * @en The path constraint data used to define the constraint.
         * @zh 用于定义约束的路径约束数据。
         */
        data: PathConstraintData;
        /**
         * @en An array of bones that will be influenced by the path constraint.
         * @zh 将受路径约束影响的骨骼数组。
         */
        bones: Bone[];
        /**
         * @en The position of the path constraint.
         * @zh 路径约束的位置。
         */
        position: number;
        /**
         * @en The spacing between bones when the path constraint is applied.
         * @zh 应用路径约束时骨骼之间的间隔。
         */
        spacing: number;
        /**
         * @en The amount of rotation mixing to apply to the bones.
         * @zh 应用于骨骼的旋转混合量。
         */
        rotateMix: number;
        /**
         * @en The amount of translation mixing to apply to the bones.
         * @zh 应用于骨骼的平移混合量。
         */
        translateMix: number;
        /**@internal */
        private _debugKey;
        /**@internal */
        private _segments;
        /**@internal */
        private _curves;
        /**@internal */
        private _spaces;
        constructor(data: PathConstraintData, bones: Bone[]);
        /**
         * @en Calculates the nodes of the skeleton on the path.
         * @param boneList An array of bones that the path constraint affects.
         * @param graphics The graphics context to use for path calculations.
         * @zh 计算骨骼在路径上的节点。
         * @param boneList 受路径约束影响的骨骼数组。
         * @param graphics 用于路径计算的 Graphics 实例。
         */
        apply(boneList: Bone[], graphics: Graphics): void;
        /**
         * @en Calculate the world coordinates of vertices.
         * @param boneSlot The bone slot to which the vertices belong.
         * @param boneList The list of bones that affect the vertices.
         * @param start The starting index of the vertices to calculate.
         * @param count The number of vertices to calculate.
         * @param worldVertices The array to store the calculated world coordinates.
         * @param offset The offset in the worldVertices array to start storing the results.
         * @zh 计算顶点的世界坐标。
         * @param boneSlot 顶点所属的骨骼插槽。
         * @param boneList 影响顶点的骨骼列表。
         * @param start 开始计算顶点的索引。
         * @param count 要计算的顶点数量。
         * @param worldVertices 用于存储计算结果的数组。
         * @param offset 数组中开始存储结果的偏移量。
         */
        computeWorldVertices2(boneSlot: BoneSlot, boneList: Bone[], start: number, count: number, worldVertices: number[], offset: number): void;
        /**
         * 计算路径上的节点
         * @param boneSlot
         * @param boneList
         * @param graphics
         * @param spacesCount
         * @param tangents
         * @param percentPosition
         * @param percentSpacing
         * @return
         */
        private computeWorldPositions;
        private addBeforePosition;
        private addAfterPosition;
        private addCurvePosition;
    }
    /**
     * @internal
     * @en The `PathConstraintData` class contains the setup data for a path constraint.
     * @zh `PathConstraintData` 类包含了路径约束的设置数据。
     */
    class PathConstraintData {
        /**
         * @en The name of the path constraint.
         * @zh 路径约束的名称。
         */
        name: string;
        /**
         * @en An array of bone indices that will be used as bones for the path constraint.
         * @zh 用作路径约束骨骼的骨骼索引数组。
         */
        bones: number[];
        /**
         * @en The target bone slot that will be constrained by the path.
         * @zh 将被路径约束的目标骨骼插槽。
         */
        target: string;
        /**
         * @en The mode for how the bones are positioned along the path.
         * @zh 骨骼沿路径定位的模式。
         */
        positionMode: string;
        /**
         * @en The mode for how the spacing between bones is controlled.
         * @zh 控制骨骼间距的模式。
         */
        spacingMode: string;
        /**
         * @en The mode for how bones are rotated to match the path.
         * @zh 骨骼如何旋转以匹配路径的模式。
         */
        rotateMode: string;
        /**
         * @en The rotation offset added to the constrained bones.
         * @zh 添加到受约束骨骼的旋转偏移量。
         */
        offsetRotation: number;
        /**
         * @en The position of the path constraint.
         * @zh 路径约束的位置。
         */
        position: number;
        /**
         * @en The spacing between bones when the path constraint is applied.
         * @zh 应用路径约束时骨骼之间的间隔。
         */
        spacing: number;
        /**
         * @en Used to apply path rotation to the mix ratio of the constrained bones.
         * @zh 用于将路径旋转应用到受约束骨骼的混合比例。
         */
        rotateMix: number;
        /**
         * @en Used to apply path translation to the mix ratio of the constrained bones.
         * @zh 用于将路径平移应用到受约束骨骼的混合比例。
         */
        translateMix: number;
        constructor();
    }
    /**
     * @en Skeleton animation consists of three parts: Template, AnimationPlayer, and Skeleton.
     * - Event.PLAYED: Animation start playback scheduling
     * - Event.STOPPED: Animation stop playback scheduling
     * - Event.PAUSED: Animation resume playback scheduling
     * - Event.LABEL: Custom events
     * @zh 骨骼动画由Templet，AnimationPlayer，Skeleton三部分组成。
     * - Event.PLAYED: 动画开始播放调度
     * - Event.STOPPED: 动画停止播放调度
     * - Event.PAUSED: 动画暂停播放调度
     * - Event.LABEL: 自定义事件
     */
    class Skeleton extends Sprite {
        protected _source: string;
        protected _templet: Templet;
        protected _player: AnimationPlayer;
        protected _curOriginalData: Float32Array;
        private _boneMatrixArray;
        private _lastTime;
        private _currAniIndex;
        private _pause;
        protected _aniClipIndex: number;
        protected _clipIndex: number;
        private _skinIndex;
        private _skinName;
        private _aniMode;
        /** 当前动画自己的缓冲区*/
        private _graphicsCache;
        private _boneSlotDic;
        private _bindBoneBoneSlotDic;
        private _boneSlotArray;
        private _index;
        private _total;
        private _indexControl;
        private _complete;
        private _yReverseMatrix;
        private _ikArr;
        private _tfArr;
        private _pathDic;
        private _rootBone;
        protected _boneList: Bone[];
        protected _aniSectionDic: any;
        private _eventIndex;
        private _drawOrderIndex;
        private _drawOrder;
        private _lastAniClipIndex;
        private _lastUpdateAniClipIndex;
        private _playAudio;
        private _soundChannelArr;
        private _animationName;
        private _loop;
        /**
         * @en Constructs method of Skeleton animation.
         * @param aniMode - Animation mode, 0 for no costume changes support, 1 or 2 for costume changes support.
         * @zh 骨骼动画的构造方法
         * @param aniMode	动画模式，0不支持换装，1、2支持换装
         */
        constructor(aniMode?: number);
        /**
         * @en The frame index.
         * @zh 帧索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The total number of frames.
         * @zh 总帧数。
         */
        get total(): number;
        /**
         * @en The reference to the animation player.
         * @zh 动画播放器的引用。
         */
        get player(): AnimationPlayer;
        /**
         * @en The skin name.
         * @zh 皮肤名称。
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * @en The animation name.
         * @zh 动画名称。
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * @en Whether the animation is looped.
         * @zh 动画是否循环播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The reference to the animation template.
         * @zh 动画模板的引用。
         */
        get templet(): Templet;
        set templet(value: Templet);
        /**
         * @en Animation address
         * @zh 动画地址
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Animation types with their descriptions.
         * - Mode 0: Uses template buffer data which cannot be modified. (Low memory overhead, low computation overhead, does not support costume changes)
         * - Mode 1: Uses the animation's own buffer. Each animation has its own buffer, which is quite memory-intensive. (High memory overhead, low computation overhead, supports costume changes)
         * - Mode 2: Uses a dynamic approach for real-time drawing. (Low memory overhead, high computation overhead, supports costume changes, not recommended)
         * @zh 动画类型及其描述。
         * - 模式 0: 使用模板缓冲数据，不允许修改。（内存开销小，计算开销小，不支持换装）
         * - 模式 1: 使用动画自己的缓冲区，每个动画都有自己的缓冲区，相当耗费内存。（内存开销大，计算开销小，支持换装）
         * - 模式 2: 使用动态方式进行实时绘制。（内存开销小，计算开销大，支持换装，不建议使用）
         */
        get aniMode(): number;
        set aniMode(value: number);
        /**
         * 初始化动画
         * @param templet		模板
         */
        protected init(templet: Templet): void;
        /**
         * @en Load and create an animation directly from a path.
         * @param path The path of the animation file to load.
         * @param complete The callback function when the loading is complete.
         * @zh 通过路径直接加载并创建动画。
         * @param path 要加载的动画文件路径。
         * @param complete 加载完成后的回调函数。
         */
        load(path: string, complete?: Handler): void;
        /**
         * @en Load and create an animation directly from a path.
         * @param path The path of the animation file to load.
         * @param complete The callback function when the loading is complete.
         * @zh 通过路径直接加载并创建动画。
         * @param path 要加载的动画文件路径。
         * @param complete 加载完成后的回调函数。
         */
        load(path: string, complete?: () => void): void;
        /**
         * 传递PLAY事件
         */
        private _onPlay;
        /**
         * 传递STOP事件
         */
        private _onStop;
        /**
         * 传递PAUSE事件
         */
        private _onPause;
        /**
         * 创建骨骼的矩阵，保存每次计算的最终结果
         */
        private _parseSrcBoneMatrix;
        /**
         * @param startTime
         * @param endTime
         * @param startIndex
         */
        private _emitMissedEvents;
        /**
         * 更新动画
         * @param autoKey true为正常更新，false为index手动更新
         */
        private _update;
        /**
         * 清掉播放完成的音频
         * @param force 是否强制删掉所有的声音channel
         */
        private _onAniSoundStoped;
        /**
         * 创建grahics图像. 并且保存到cache中
         * @param _clipIndex 第几帧
         */
        protected _createGraphics(_clipIndex?: number): GraphicsAni;
        private _checkIsAllParsed;
        /**
         * 设置deform数据
         * @param tDeformAniData
         * @param tDeformDic
         * @param _boneSlotArray
         * @param curTime
         */
        private _setDeform;
        /*******************************************定义接口*************************************************/
        /**
         * @en Get the number of current animations.
         * @return The number of current animations.
         * @zh 获取当前动画的数量。
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * @en Get the name of the animation by its index.
         * @param index The index of the animation.
         * @zh 通过索引获取动画的名称。
         * @param index 动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * @en Get the reference to a bone slot by its name.
         * @param name The name of the bone slot.
         * @return The reference to the bone slot.
         * @zh 通过名称获取插槽的引用。
         * @param name 动画的名字
         * @return 插槽的引用
         */
        getSlotByName(name: string): BoneSlot;
        /**
         * @en Display a set of skins by name.
         * @param name The name of the skin.
         * @param freshSlotIndex Whether to reset the slot textures to the initial state, default is true.
         * @zh 通过名称显示一套皮肤。
         * @param name 皮肤的名字
         * @param freshSlotIndex 是否将插槽纹理重置到初始状态，默认为true。
         */
        showSkinByName(name: string, freshSlotIndex?: boolean): void;
        /**
         * @en Display a set of skins by index.
         * @param skinIndex The index of the skin.
         * @param freshSlotIndex Whether to reset the slot textures to the initial state, default is true.
         * @zh 通过索引显示一套皮肤。
         * @param skinIndex 皮肤索引
         * @param freshSlotIndex 是否将插槽纹理重置到初始状态，默认为true。
         */
        showSkinByIndex(skinIndex: number, freshSlotIndex?: boolean): void;
        /**
         * @en Set the skin for a specific slot by index.
         * @param slotName The name of the slot.
         * @param index The index of the slot's skin.
         * @zh 通过索引设置某插槽的皮肤。
         * @param slotName 插槽名称
         * @param index 插槽的皮肤索引
         */
        showSlotSkinByIndex(slotName: string, index: number): void;
        /**
         * @en Set the skin for a specific slot by name.
         * @param slotName The name of the slot.
         * @param name The name of the skin.
         * @zh 通过名称设置某插槽的皮肤。
         * @param slotName 插槽名称
         * @param name 皮肤名称
         */
        showSlotSkinByName(slotName: string, name: string): void;
        /**
         * @en Replace the texture name of a slot.
         * @param slotName The name of the slot.
         * @param oldName The old texture name that will be replaced.
         * @param newName The new texture name to replace with.
         * @zh 替换插槽的贴图名称。
         * @param slotName 插槽名称
         * @param oldName 要替换的贴图名
         * @param newName 替换后的贴图名
         */
        replaceSlotSkinName(slotName: string, oldName: string, newName: string): void;
        /**
         * @en Replace the texture index of a slot.
         * @param slotName The name of the slot.
         * @param oldIndex The old texture index that will be replaced.
         * @param newIndex The new texture index to replace with.
         * @zh 替换插槽的贴图索引。
         * @param slotName 插槽名称
         * @param oldIndex 要替换的索引
         * @param newIndex 替换后的索引
         */
        replaceSlotSkinByIndex(slotName: string, oldIndex: number, newIndex: number): void;
        /**
         * @en Set custom skin for a slot.
         * @param slotName The name of the slot.
         * @param texture The custom texture to be applied.
         * @zh 为指定的插槽设置自定义皮肤。
         * @param slotName 插糟的名字
         * @param texture 自定义的纹理
         */
        setSlotSkin(slotName: string, texture: Texture): void;
        /**
         * 换装的时候，需要清一下缓冲区
         */
        private _clearCache;
        /**
         * @en Play an animation.
         * @param nameOrIndex The name or index of the animation to play.
         * @param loop Whether to loop the animation.
         * @param force If false, the animation will not take effect if the same one is already playing. If true, it will force the animation to play.
         * @param start The start time of the animation.
         * @param end The end time of the animation.
         * @param freshSkin Whether to refresh the skin data.
         * @param playAudio Whether to play the animation's audio.
         * @zh 播放动画。
         * @param nameOrIndex 动画名字或者索引
         * @param loop 是否循环播放
         * @param force false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param start 起始时间
         * @param end 结束时间
         * @param freshSkin 是否刷新皮肤数据
         * @param playAudio 是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        /**
         * @en Stop the animation.
         * @zh 停止动画。
         */
        stop(): void;
        /**
         * @en Set the playback rate of the animation.
         * @param value The playback rate, where 1 is the standard rate.
         * @zh 设置动画的播放速率。
         * @param value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * @en Pause the animation.
         * @zh 暂停动画。
         */
        paused(): void;
        /**
         * @en Resume playing the animation.
         * @zh 恢复动画的播放。
         */
        resume(): void;
        /**
         * 得到缓冲数据
         * @param aniIndex
         * @param frameIndex
         * @return
         */
        private _getGrahicsDataWithCache;
        /**
         * 保存缓冲grahpics
         * @param aniIndex
         * @param frameIndex
         * @param graphics
         */
        private _setGrahicsDataWithCache;
        private reset;
        /**
         * @en Destroy the current animation node.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁当前动画节点。
         * @param destroyChild 是否销毁子节点
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @internal
     */
    class SkinData {
        name: string;
        slotArr: any[];
    }
    /**
     * @en Slot display data
     * @zh 插槽显示数据
     */
    class SkinSlotDisplayData {
        /**
         * @en The name of the slot.
         * @zh 插槽的名称。
         */
        name: string;
        /**
         * @en The name of the attachment.
         * @zh 附件的名称。
         */
        attachmentName: string;
        /**
         * @en The type of the slot display.
         * @zh 插槽显示的类型。
         */
        type: number;
        /**
         * @en The transformation data of the slot.
         * @zh 插槽的变换数据。
         */
        transform: Transform;
        /**
         * @en The width of the slot.
         * @zh 插槽的宽度。
         */
        width: number;
        /**
         * @en The height of the slot.
         * @zh 插槽的高度。
         */
        height: number;
        /**
         * @en The texture of the slot.
         * @zh 插槽的纹理。
         */
        texture: Texture;
        /**
         * @en The bone data array.
         * @zh 骨骼数据数组。
         */
        bones: any[];
        /**
         * @en The UV data array.
         * @zh UV数据数组。
         */
        uvs: any[];
        /**
         * @en The weight data array.
         * @zh 权重数据数组。
         */
        weights: any[];
        /**
         * @en The triangle data array.
         * @zh 三角面数据数组。
         */
        triangles: any[];
        /**
         * @en The vertex data array.
         * @zh 顶点数据数组。
         */
        vertices: any[];
        /**
         * @en The length data array.
         * @zh 长度数据数组。
         */
        lengths: any[];
        /**
         * @en The version.
         * @zh 版本号。
         */
        verLen: number;
        /**
         * @en Create and update the texture for the slot based on the current texture.
         * @param currTexture The current texture to be used for creating the slot's texture.
         * @return The created and updated texture.
         * @zh 根据当前纹理创建并更新插槽纹理。
         * @param currTexture 用于创建槽纹理的当前纹理。
         * @return 新的插槽纹理。
         */
        createTexture(currTexture: Texture): Texture;
        /**
         * @en Destroy and clean up the resources used by the slot's texture.
         * @zh 销毁并清理插槽纹理所使用的资源。
         */
        destory(): void;
    }
    /**
     * Represents the data of a slot, which includes the slot's name and an array of display data.
     * @zh 表示插槽的数据，包括插槽名称和显示数据数组。
     */
    class SlotData {
        /**
        * @en The name of the slot.
        * @zh 插槽的名称。
        */
        name: string;
        /**
         * @en An array of display data that this slot contains.
         * @zh 此插槽包含的显示数据数组。
         */
        displayArr: any[];
        /**
         * @en Get the index of the display data by attachment name.
         * @param name The name of the attachment to search for.
         * @zh 通过附件名称获取显示数据的位置。
         * @param name 附件名称。
         */
        getDisplayByName(name: string): number;
    }
    /**
     * @en Animation template class
     * @zh 动画模板类
     */
    class Templet extends AnimationTemplet {
        /**
         * @en The frame rate of the animation
         * @zh 动画的帧率
         */
        rate: number;
        /**@internal */
        private _mainTexture;
        /**@internal */
        private _graphicsCache;
        /**
         * @en Stores the original bone information.
         * @zh 存放原始骨骼信息。
         */
        srcBoneMatrixArr: any[];
        /**
         * @en IK (Inverse Kinematics) data array.
         * @zh IK数据数组。
         */
        ikArr: any[];
        /**
         * @en Transform data array.
         * @zh transform数据数组。
         */
        tfArr: any[];
        /**
         * @en Path data array.
         * @zh path数据数组。
         */
        pathArr: any[];
        /**
         * @en Dictionary for storing slot data.
         * @zh 存放插槽数据的字典。
         */
        boneSlotDic: any;
        /**
         * @en Dictionary for binding slot data.
         * @zh 绑定插槽数据的字典。
         */
        bindBoneBoneSlotDic: any;
        /**
         * @en Array for storing slot data.
         * @zh 存放插槽数据的数组。
         */
        boneSlotArray: any[];
        /**
         * @en Skin data array.
         * @zh 皮肤数据数组。
         */
        skinDataArray: any[];
        /**
         * @en Dictionary for skin data.
         * @zh 皮肤的字典数据。
         */
        skinDic: any;
        /**
         * @en Dictionary for storing texture data.
         * @zh 存放纹理数据的字典。
         */
        subTextureDic: Record<string, Texture>;
        /**
         * @en Indicates whether parsing has failed.
         * @zh 是否解析失败。
         */
        isParseFail: boolean;
        /**
         * @en The reverse matrix, some bone animations need to be reversed to be displayed correctly.
         * @zh 反转矩阵，有些骨骼动画需要反转才能正确显示。
         */
        yReverseMatrix: Matrix;
        /**
         * @en Render order animation data array.
         * @zh 渲染顺序动画数据数组。
         */
        drawOrderAniArr: any[];
        /**
         * @en Event animation data array.
         * @zh 事件动画数据数组。
         */
        eventAniArr: any[];
        /** @private 索引对应的名称 */
        attachmentNames: any[];
        /**
         * @en Vertex animation data array.
         * @zh 顶点动画数据数组。
         */
        deformAniArr: any[];
        /**
         * @en Actual display object list for destruction purposes.
         * @zh 实际显示对象列表，用于销毁用。
         */
        skinSlotDisplayDataArr: SkinSlotDisplayData[];
        /** @internal 是否需要解析audio数据 */
        private _isParseAudio;
        aniSectionDic: any;
        /**@internal */
        private _path;
        /**@private */
        tMatrixDataLen: number;
        /**
         * @en Root bone of the skeleton
         * @zh 骨骼的根骨骼
         */
        mRootBone: Bone;
        /**
         * @en Array of all bones in the skeleton
         * @zh 骨骼中所有骨骼的数组
         */
        mBoneArr: Bone[];
        /**
         * @en Create skeletal animation.
         * - 0: Use the template's buffer data, which cannot be modified. (Low memory overhead, low computation overhead, does not support costume changes)
         * - 1: Use the animation's own buffer. Each animation will have its own buffer, which is quite memory-intensive. (High memory overhead, low computation overhead, supports costume changes)
         * - 2: Use a dynamic approach for real-time drawing. (Low memory overhead, high computation overhead, supports costume changes, not recommended)
         * @param aniMode The animation mode: 0 for no costume change support, 1 or 2 for costume change support.
         * @return The created instance.
         * @zh 创建骨骼动画。
         * - 0: 使用模板缓冲的数据，不允许修改。（内存开销小，计算开销小，不支持换装）
         * - 1: 使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存。（内存开销大，计算开销小，支持换装）
         * - 2: 使用动态方式进行实时绘制。（内存开销小，计算开销大，支持换装，不建议使用）
         * @param aniMode 动画模式，0:不支持换装；1、2支持换装
         * @return 创建的实例。
         */
        buildArmature(aniMode?: number): Skeleton;
        _parse(texture: Texture, createURL: string, skeletonData: ArrayBuffer): void;
        /**
         * @en Get the specified texture by its name.
         * @param name The name of the texture.
         * @returns The requested texture object.
         * @zh 通过名称获取指定的纹理。
         * @param name	纹理的名字
         * @returns 所请求的纹理对象。
         */
        getTexture(name: string): Texture;
        /**
         * @private
         * @en Display the specified skin using the bone slot dictionary and skin index.
         * @param boneSlotDic The dictionary of bone slots.
         * @param skinIndex The index of the skin to display.
         * @param freshDisplayIndex Whether to reset the slot textures, default is true.
         * @return Whether the skin was successfully displayed.
         * @zh 使用插槽字典和皮肤索引显示指定的皮肤。
         * @param boneSlotDic	插槽字典的引用
         * @param skinIndex	要显示的皮肤的索引
         * @param freshDisplayIndex	是否重置插槽纹理，默认为true
         * @return	是否显示皮肤成功
         */
        showSkinByIndex(boneSlotDic: any, skinIndex: number, freshDisplayIndex?: boolean): boolean;
        /**
         * @en Retrieves the index of a skin based on its name.
         * @param skinName The name of the skin.
         * @return The index of the skin, or -1 if not found.
         * @zh 通过皮肤名称获取皮肤索引。
         * @param skinName	皮肤名称
         * @return	皮肤索引，找不到返回-1
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * @en Retrieves the name of an animation based on its index.
         * @param index The index of the animation.
         * @return The name of the animation, or null if not found.
         * @zh 通过索引获取动画名称。
         * @param index 动画索引
         * @return 动画名称，找不到返回null
         */
        getAniNameByIndex(index: number): string;
        /**
         * @private
         * @en Retrieves the buffered graphics data for a specific animation frame.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame within the animation.
         * @return The graphics object for the specified animation frame, or null if not available.
         * @zh 获取特定动画帧的缓冲图形数据。
         * @param aniIndex	动画索引
         * @param frameIndex	帧索引
         * @return	指定动画帧的对象，如果不存在则返回null
         */
        getGrahicsDataWithCache(aniIndex: number, frameIndex: number): Graphics;
        /**
         * @private
         * @en Saves graphics data to the cache for a specific animation frame.
         * @param aniIndex The index of the animation.
         * @param frameIndex The index of the frame within the animation.
         * @param graphics The graphics object to cache.
         * @zh 保存特定动画帧的图形数据到缓冲区。
         * @param aniIndex	动画索引
         * @param frameIndex	帧索引
         * @param graphics	要缓存的数据
         */
        setGrahicsDataWithCache(aniIndex: number, frameIndex: number, graphics: Graphics): void;
        /**
         * @en Deletes animation data at the specified index.
         * @param aniIndex The index of the animation data to delete.
         * @zh 删除指定索引的动画数据。
         * @param aniIndex	要删除的动画索引
         */
        deleteAniData(aniIndex: number): void;
        protected _disposeResource(): void;
    }
    /**
     * @internal
     * @en Class representing a transform constraint which is used to control the transformations (translation, rotation, scale, shear) of bones based on a target bone.
     * @zh 变换约束类，用于根据目标骨骼控制其他骨骼的变换（平移、旋转、缩放、剪切）。
     */
    class TfConstraint {
        /**@internal */
        private _data;
        /**@internal */
        private _bones;
        /**
         * @en The target bone that the constraint will follow.
         * @zh 约束跟随的目标骨骼。
         */
        target: Bone;
        /**
         * @en The mix ratio for rotation transformation.
         * @zh 旋转变换的混合比率。
         */
        rotateMix: number;
        /**
         * @en The mix ratio for translation transformation.
         * @zh 平移变换的混合比率。
         */
        translateMix: number;
        /**
         * @en The mix ratio for scale transformation.
         * @zh 缩放变换的混合比率。
         */
        scaleMix: number;
        /**
         * @en The mix ratio for shear transformation.
         * @zh 剪切变换的混合比率。
         */
        shearMix: number;
        /**@internal */
        private _temp;
        /**
         * @en Creates a new transform constraint.
         * @param data The transform constraint data.
         * @param bones The bones to be constrained.
         * @zh 构造方法，创建一个新的变换约束。
         * @param data 变换约束数据。
         * @param bones 要被约束的骨骼。
         */
        constructor(data: TfConstraintData, bones: Bone[]);
        /**
         * @internal
         * @en Applies the constraint to the bones, adjusting their transformations to match the target bone.
         * @zh 应用约束，将骨骼的变换调整为与目标骨骼一致。
         */
        apply(): void;
    }
    /**
     * @internal
     */
    class TfConstraintData {
        name: string;
        boneIndexs: number[];
        targetIndex: number;
        rotateMix: number;
        translateMix: number;
        scaleMix: number;
        shearMix: number;
        offsetRotation: number;
        offsetX: number;
        offsetY: number;
        offsetScaleX: number;
        offsetScaleY: number;
        offsetShearY: number;
    }
    /**
     * @en The `Transform` class represents a 2D transformation matrix, used to apply rotations, scaling, skewing, and translation to objects.
     * @zh `Transform` 类表示一个2D变换矩阵，用于对对象应用旋转、缩放、倾斜和位移。
     */
    class Transform {
        /**
        * @en The rotation angle around the X-axis (in degrees).
        * @zh 绕X轴旋转的角度（以度为单位）。
        */
        skX: number;
        /**
         * @en The rotation angle around the Y-axis (in degrees).
         * @zh 绕Y轴旋转的角度（以度为单位）。
         */
        skY: number;
        /**
         * @en The scaling factor along the X-axis.
         * @zh 沿X轴的缩放系数。
         */
        scX: number;
        /**
         * @en The scaling factor along the Y-axis.
         * @zh 沿Y轴的缩放系数。
         */
        scY: number;
        /**
         * @en The translation along the X-axis.
         * @zh 沿X轴的平移。
         */
        x: number;
        /**
         * @en The translation along the Y-axis.
         * @zh 沿Y轴的平移。
         */
        y: number;
        /**
         * @en The skew angle along the X-axis (in degrees).
         * @zh 沿X轴的倾斜角度（以度为单位）。
         */
        skewX: number;
        /**
         * @en The skew angle along the Y-axis (in degrees).
         * @zh 沿Y轴的倾斜角度（以度为单位）。
         */
        skewY: number;
        /**
         * @en The internal matrix used for transformations.
         * @zh 用于变换的内部矩阵。
         */
        private mMatrix;
        /**
         * @en Initializes the transform data with the provided values.
         * @param data The data object containing transformation properties.
         * @zh 使用提供的数据初始化变换。
         * @param data 数据对象，包含变换属性。
         */
        initData(data: any): void;
        /**
         * @en Gets the current matrix.
         * @returns The transformation matrix.
         * @zh 获取当前矩阵。
         * @returns 变换矩阵。
         */
        getMatrix(): Matrix;
        /**
         * @en Applies skew to the matrix based on the given angles.
         * @param m The matrix to apply the skew transformation to.
         * @param x The horizontal skew angle, in radians.
         * @param y The vertical skew angle, in radians.
         * @returns The modified matrix with skew applied.
         * @zh 根据给定的角度对矩阵应用倾斜。
         * @param m 要应用倾斜变换的矩阵。
         * @param x 水平倾斜角度，以弧度为单位。
         * @param y 垂直倾斜角度，以弧度为单位。
         * @returns 应用倾斜后的矩阵。
         */
        skew(m: Matrix, x: number, y: number): Matrix;
    }
    /**
     * @internal
     * @en Utility class for UV transformation.
     * @zh 用于UV转换的工具类。
     */
    class UVTools {
        constructor();
        /**
         * @en Converts small UV coordinates, which are relative to an atlas, to UV coordinates relative to a specific large image.
         * @param bigUV UV of the specific large image.
         * @param smallUV UV within the atlas.
         * @param rst Optional array to store the result.
         * @returns UV coordinates relative to the specific large image.
         * @zh 将相对于图集的小UV转换成相对某个大图的UV。
         * @param bigUV 特定大图的UV。
         * @param smallUV 图集中的UV。
         * @param rst 可选数组用于存储结果。
         * @returns 相对于特定大图的UV。
         */
        static getRelativeUV(bigUV: ArrayLike<number>, smallUV: any[], rst?: any[]): any[];
        /**
         * @en Converts UV coordinates relative to a specific large image to UV coordinates relative to the atlas that contains the large image.
         * @param bigUV UV of the specific large image.
         * @param smallUV UV coordinates relative to the specific large image.
         * @param rst Optional array to store the result.
         * @returns UV coordinates relative to the atlas that contains the large image.
         * @zh 将相对于某个大图的UV转换成相对于大图图集的UV。
         * @param bigUV 特定大图的UV。
         * @param smallUV 相对于特定大图的UV。
         * @param rst 可选数组用于存储结果。
         * @return 相对于大图图集的UV
         */
        static getAbsoluteUV(bigUV: ArrayLike<number>, smallUV: any[], rst?: any[]): any[];
    }
    /**
     * @internal
     * @en Graphic animation class.
     * @zh 图形动画类。
     */
    class GraphicsAni extends Graphics {
        /**
         * @private
         * @en Draws a custom skinned mesh for graphic animation.
         * @param skinA The skin mesh object for graphic.
         * @param alpha The opacity value to apply to the graphic.
         * @zh 绘制自定义蒙皮动画。
         * @param skinA 图形的蒙皮网格对象。
         * @param alpha 要应用于图形的不透明度值。
         */
        drawSkin(skinA: SkinMeshForGraphic, alpha: number): void;
        private static _caches;
        /**
         * @en Retrieves an instance of GraphicsAni from the cache or creates a new one if none are available.
         * @returns An instance of GraphicsAni.
         * @zh 从缓存中获取一个 GraphicsAni 实例，如果没有可用的实例则创建一个新的。
         * @returns GraphicsAni 的一个实例。
         */
        static create(): GraphicsAni;
        /**
         * @en Recycles a GraphicsAni instance by clearing its content and adding it to the cache for future use.
         * @param graphics The GraphicsAni instance to recycle.
         * @zh 通过清除其内容并将其实例添加到缓存中来回收 GraphicsAni。
         * @param graphics 要回收的 GraphicsAni 实例。
         */
        static recycle(graphics: GraphicsAni): void;
    }
    /**
     * @en Keyframes
     * @zh 关键帧
     */
    class KeyFramesContent {
        /**
         * @en The start time of the keyframe in milliseconds.
         * @zh 关键帧的开始时间（毫秒）。
         */
        startTime: number;
        /**
         * @en The duration of the keyframe in milliseconds.
         * @zh 关键帧的持续时间（毫秒）。
         */
        duration: number;
        /**
         * @en Private interpolation data.
         * An array containing the interpolation types and their associated data in the format [type0, Data0, type1, Data1, ...].
         * Type represents the interpolation method, and Data is the associated interpolation data which can be null.
         * Note: The value 254 indicates linear interpolation throughout, and 255 indicates no interpolation.
         * @zh 私有插值数据。
         * 数组内包含插值类型和相关数据，格式为 [type0, Data0, type1, Data1, ...]。
         * Type 表示插值方法，Data 是相关的插值数据，可以为空。
         * 注意：值 254 表示全线性插值，255 表示不进行插值。
         */
        interpolationData: any[];
        /**
         * @en The keyframe data.
         * @zh 关键帧的数据。
         */
        data: Float32Array;
        /**
         * @en The change in keyframe data.
         * @zh 关键帧数据的变化量。
         */
        dData: Float32Array;
        /**
         * @en The data for the next keyframe.
         * @zh 下一个关键帧的数据。
         */
        nextData: Float32Array;
    }
    /**
     * @en MovieClip is used to play SWF animations that have been processed by tools.
     * - Event.COMPLETE: After the animation is played.
     * - Event.LABEL: After playing to a tag.
     * - Event.LOADED: After loading.
     * - Event.FRAME: After entering the frame.
     * @zh MovieClip 用于播放经过工具处理后的 swf 动画。
     * - Event.COMPLETE: 动画播放完毕后调度。
     * - Event.LABEL: 播放到某标签后调度。
     * - Event.LOADED: 加载完成后调度。
     * - Event.FRAME: 进入帧后调度。
     */
    class MovieClip extends Sprite {
        protected static _ValueList: any[];
        /** 数据起始位置。*/
        protected _start: number;
        /** 当前位置。*/
        protected _Pos: number;
        /** 数据。*/
        protected _data: Byte;
        protected _curIndex: number;
        protected _preIndex: number;
        protected _playIndex: number;
        protected _playing: boolean;
        protected _ended: boolean;
        /** 总帧数。*/
        protected _count: number;
        /**@internal id_data起始位置表*/
        _ids: any;
        protected _loadedImage: any;
        /**@internal id_实例表*/
        _idOfSprite: any[];
        /**@internal 父mc*/
        _parentMovieClip: MovieClip;
        /**@internal 需要更新的movieClip表*/
        _movieClipList: MovieClip[];
        protected _labels: any;
        /**
         * @en Resource root directory
         * @zh 资源根目录
         */
        basePath: string;
        private _isRoot;
        private _completeHandler;
        private _endFrame;
        private _source;
        /**
         * @en Playback interval (in milliseconds)
         * @zh 播放间隔(单位：毫秒)。
         */
        interval: number;
        /**
         * @en Whether to play in a loop
         * @zh 是否循环播放
         */
        loop: boolean;
        /**
         * @en Constructor method of MovieClip.
         * @param parentMovieClip The parent MovieClip, this parameter is not required when creating your own MovieClip.
         * @zh MovieClip构造方法
         * @param parentMovieClip 父 MovieClip，自己创建时不需要传该参数。
         */
        constructor(parentMovieClip?: MovieClip);
        /**
         * @en Destroys this object and its referenced Texture.
         * @param destroyChild Whether to destroy child nodes simultaneously. If true, child nodes are destroyed; otherwise, they are not.
         * @zh 销毁此对象及其引用的Texture。
         * @param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
        private _onDisplay;
        /**
         * @en Update the timeline of the MovieClip.
         * @zh 更新 MovieClip 的时间轴。
         */
        updates(): void;
        /**
         * @en The current playback index of the MovieClip.
         * @zh MovieClip 当前播放的索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en Adds a label to a specified frame index. When played to this index, a label event will be dispatched.
         * @param label The name of the label.
         * @param index The frame index to add the label to.
         * @zh 在指定的帧索引上增加一个标签，播放到此索引后会派发label事件。
         * @param label	标签名称
         * @param index	索引位置
         */
        addLabel(label: string, index: number): void;
        /**
         * @en Remove the corresponding label from the specified label name.
         * @param label The name of the label to remove. If not provided, all labels are removed.
         * @zh 从指定的标签名字删除对应标签。
         * @param label 标签名字，如果label为空，则删除所有Label
         */
        removeLabel(label: string): void;
        /**
         * @en The total number of frames in the MovieClip.
         * @zh MovieClip 中的帧总数。
         */
        get count(): number;
        /**
         * @en Whether the MovieClip is currently playing.
         * @zh MovieClip 是否正在播放中。
         */
        get playing(): boolean;
        /**
         * 动画的帧更新处理函数。
         */
        private _update;
        /**
         * @en Stops the playback of the animation.
         * @zh 停止播放动画。
         */
        stop(): void;
        /**
         * @en Jumps to a specified frame and stops playing the animation.
         * @param index The frame index to jump to.
         * @zh 跳到指定帧并停止播放动画。
         * @param index 要跳到的帧
         */
        gotoAndStop(index: number): void;
        /**
         * 清理。
         */
        private _clear;
        /**
         * @en Play Animation
         * @param index frame index
         * @zh 播放动画。
         * @param index 帧索引
         */
        play(index?: number, loop?: boolean): void;
        private _displayFrame;
        private _reset;
        private _parseFrame;
        _setData(data: Byte, start: number): void;
        /**
         * @en The source of the MovieClip.
         * @zh MovieClip 的资源地址。
         */
        get source(): string;
        set source(value: string);
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.BUFFER)
         * @en Loads resources for the MovieClip.
         * @param url The URL of the SWF resource.
         * @param atlas Whether to use atlas resources.
         * @param atlasPath The path of the atlas, by default it uses the atlas with the same name as the SWF.
         * @zh 加载 MovieClip 资源。
         * @param url SWF 资源的 URL。
         * @param atlas 是否使用图集资源。
         * @param   atlasPath  图集路径，默认使用与swf同名的图集
         */
        load(url: string, atlas?: boolean, atlasPath?: string): void;
        private _initState;
        private _initData;
        /**
         * @en Plays the animation from the start index to the end index, and triggers the complete callback when finished.
         * @param start The starting frame index.
         * @param end The ending frame index.
         * @param complete End callback.
         * @zh 从开始索引播放到结束索引，结束后触发 complete 回调。
         * @param start 开始索引
         * @param end 结束索引
         * @param complete 结束回调
         */
        playTo(start: number, end: number, complete?: Handler): void;
    }
    /**
     * @en Animation condition types
     * @zh 动画条件类型
     */
    enum AniConditionType {
        /**
         * @en Greater than
         * @zh 大于
         */
        Greater = 0,
        /**
         * @en Less than
         * @zh 小于
         */
        Less = 1,
        /**
         * @en Equal to
         * @zh 等于
         */
        Equals = 2,
        /**
         * @en Not equal to
         * @zh 不等于
         */
        NotEqual = 3
    }
    /**
     * @en 2D animation types
     * @zh 2D动画类型
     */
    class Animation2DCondition {
        /**
         * @en ID number
         * @zh id编号
         */
        id: number;
        /**
         * @en Animation conditions
         * @zh 动画条件
         */
        type: AniConditionType;
        /**
         * @en Detection value
         * @zh 检测值
         */
        checkValue: any;
    }
    /**
     * @en Animation2DEvent class is used to implement animation events.
     * @zh Animation2DEvent 类用于实现动画事件。
     */
    class Animation2DEvent {
        /**
         * @en The time at which the event is triggered.
         * @zh 事件触发的时间。
         */
        time: number;
        /**
         * @en The name of the event that is triggered.
         * @zh 被触发的事件名称。
         */
        eventName: string;
        /**
         * @en Event triggering parameters
         * @zh 事件触发参数。
         */
        params: any[];
        /**
         * @en Constructor method, instance of Animation2DEvent.
         * @zh 2D动画事件类实例
         */
        constructor();
    }
    /**
     * @en Represents a parameter for 2D animation that includes a name, type, and value.
     * @zh 表示2D动画的参数，包括名称、类型和值。
     */
    class Animation2DParm {
        name: string;
        type: AniParmType;
        value: boolean | number;
    }
    /**
     * @en Class for parsing and storing 2D animation data.
     * @zh 用于处理2D动画片段的类。
     */
    class AnimationClip2D extends Resource {
        /**
         * @internal
         * @en Parses animation data into a 2D animation clip.
         * @param data The animation data to be parsed.
         * @returns The parsed 2D animation clip.
         * @zh 将动画数据解析为2D动画片段。
         * @param data 要解析的动画数据。
         * @returns 解析后的2D动画片段。
         */
        static _parse(data: ArrayBuffer): AnimationClip2D;
        /**
         * @internal
         */
        _frameRate: number;
        /**
         * @internal
         */
        _duration: number;
        /**
         * @internal
         */
        _animationEvents: Animation2DEvent[];
        /**
         * @internal
         */
        _nodesDic: Record<string, KeyframeNode2D>;
        /**
         * @internal
         */
        _nodesMap: Record<string, KeyframeNode2D[]>;
        /**
         * @internal
         */
        _nodes: KeyframeNodeList2D | null;
        /**
         * @en Is it a loop?
         * @zh 是否循环
         */
        islooping: boolean;
        /**
         * @en Constructor method. ctructs a AnimationClip2D object.
         * @zh 构造方法，创建AnimationClip2D对象。
         */
        constructor();
        /**
         * @en Animation duration
         * @zh 动画时长
         */
        duration(): number;
        /**
         * @internal
         * @param playCurTime
         * @param realTimeCurrentFrameIndexes
         * @param addtive
         * @param frontPlay
         * @param outDatas
         */
        _evaluateClipDatasRealTime(playCurTime: number, realTimeCurrentFrameIndexes: Int16Array, addtive: boolean, frontPlay: boolean, outDatas: Array<number | string | boolean | {
            pos: Vector3;
            rotation: Vector3;
        }>): void;
        /**
         * @internal
         * @param frame
         * @param nextFrame
         * @param t
         * @param dur
         * @returns
         */
        private _getTweenVal;
        /**
         * @internal
         * @param time
         * @returns
         */
        private _binarySearchEventIndex;
        /**
         * @en hermite interpolation algorithm
         * @param frameValue The value of the previous keyframe.
         * @param frametime The time point of the previous keyframe.
         * @param frameOutWeight The weight of the outgoing tangent for the previous keyframe.
         * @param frameOutTangent The outgoing tangent value for the previous keyframe.
         * @param nextframeValue The value of the next keyframe.
         * @param nextframetime The time point of the next keyframe.
         * @param nextframeInweight The weight of the incoming tangent for the next keyframe.
         * @param nextframeIntangent The incoming tangent value for the next keyframe.
         * @param time The current time.
         * @returns The interpolated value at the specified time.
         * @zh hermite插值算法
         * @param frameValue 上一帧值
         * @param frametime 上一帧时间
         * @param frameOutWeight 上一帧权重
         * @param frameOutTangent 上一帧切线
         * @param nextframeValue 下一帧值
         * @param nextframetime 下一帧时间
         * @param nextframeInweight 下一帧权重
         * @param nextframeIntangent 下一帧切线
         * @param time 时间
         * @returns 指定时间的插值。
         */
        hermiteCurveSplineWeight(frameValue: number, frametime: number, frameOutWeight: number, frameOutTangent: number, nextframeValue: number, nextframetime: number, nextframeInweight: number, nextframeIntangent: number, time: number): number;
        /**
         * @en Adds an animation event to the animation timeline.
         * @param event The animation event to be added.
         * @zh 添加动画事件
         * @param event 动画事件
         */
        addEvent(event: Animation2DEvent): void;
    }
    /**
     * @en Class for AnimationClip resource parsing
     * @zh 用于AnimationClip资源解析
     */
    class AnimationClip2DParse01 {
        /**@internal */
        private static _clip;
        /**@internal */
        private static _reader;
        /**@internal */
        private static _version;
        /**@internal */
        private static _strings;
        /**@internal */
        private static _DATA;
        /**@internal */
        private static _BLOCK;
        /**
         * @internal
         */
        private static READ_DATA;
        /**
         * @internal
         */
        private static READ_BLOCK;
        /**
         * @internal
         */
        private static READ_STRINGS;
        /**
         * @internal
         * @en Parses the animation data from the specified reader and clip, based on the given version.
         * @param clip The animation clip to be parsed into.
         * @param reader The reader containing the binary data of the animation.
         * @param version The version of the animation file format.
         * @zh 根据指定的版本，从指定的读取器和剪辑解析动画数据.
         * @param clip 要解析的动画剪辑.
         * @param reader 包含动画二进制数据的读取器.
         * @param version 动画文件格式的版本.
         */
        static parse(clip: AnimationClip2D, reader: Byte, version: string): void;
        /**
         * @internal
         * @param second
         * @param fps
         * @returns
         */
        private static timeToFrame;
        private static createPathPoints;
        /**
         * @internal
         */
        static READ_ANIMATIONS2D(): void;
    }
    /**
     * @en 2D animation components
     * @zh 2D动画组件
     */
    class Animator2D extends Component {
        /**@internal */
        private _speed;
        /**@internal 更新模式*/
        private _updateMode;
        /**@internal 降低更新频率调整值*/
        private _lowUpdateDelty;
        /**@internal */
        private _isPlaying;
        /**@internal */
        private _ownerMap;
        /**@internal */
        _parameters: Record<string, Animation2DParm>;
        /**@internal */
        _controllerLayers: AnimatorControllerLayer2D[];
        /**@internal */
        _controller: AnimatorController2D;
        /**@internal */
        _checkEnterIndex: number[];
        /**@internal */
        _isPlayBack: boolean;
        /**
         * @en Constructor method of Animator2D Component.
         * @zh 2D动画组件构造方法。
         */
        constructor();
        /**
         * @en The 2D animation controller.
         * @zh 2D动画控制器。
         */
        get controller(): AnimatorController2D;
        set controller(val: AnimatorController2D);
        /**
         * @en The current 2D animation controller.
         * @zh 动画参数
         */
        get parameters(): Record<string, Animation2DParm>;
        set parameters(val: Record<string, Animation2DParm>);
        /**
         * @en The playback speed of the animation.
         * @zh 播放速度
         */
        get speed(): number;
        set speed(num: number);
        /**
         * @en If the animation is currently playing.
         * @zh 动画是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * @internal
         * @param animatorState
         * @param playState
         */
        private _updateStateFinish;
        /**
         * @internal
         * @param parentState
         * @param currentState
         */
        private _switchState;
        /**
         * @en Assigns data to a Node.
         * @param stateInfo The animation state information.
         * @param additive Indicates if it is additive.
         * @param weight The weight of the state.
         * @param isFirstLayer Indicates if it is the first layer.
         * @zh 赋值Node数据。
         * @param stateInfo 动画状态信息。
         * @param additive 是否为加法。
         * @param weight 状态的权重。
         * @param isFirstLayer 是否是第一层。
         */
        private _setClipDatasToNode;
        /**
         * @internal
         * @param o
         * @param additive
         * @param weight
         * @param isFirstLayer
         * @param data
         */
        private _applyAniData;
        /**
         * @internal
         * @param node
         * @returns
         */
        private getOwner;
        /**
         * 更新clip数据
         * @internal
         */
        private _updateClipDatas;
        /**
         * @internal
         * @param animatorState
         * @param playState
         * @param elapsedTime
         * @param loop
         * @param layerIndex
         * @returns
         */
        private _updatePlayer;
        /**
         * @internal
         * @param stateInfo
         * @param playStateInfo
         */
        private _updateEventScript;
        /**
        * @internal
        */
        private _eventScript;
        /**
         * @internal
         */
        /**
         * 启用过渡
         * @param layerindex
         * @param transition
         * @returns
         */
        private _applyTransition;
        /**
         * @internal
         * @param delta
         * @returns
         */
        private _applyUpdateMode;
        /**
         * @en Jump to the specified frame and stop playing the animation.
         * @param name The name of the animation.
         * @param layerIndex The index of the animation layer.
         * @param frame The specified frame to jump to.
         * @zh 跳转到指定帧并停止播放动画。
         * @param name 动画名称
         * @param layerIndex 动画层
         * @param frame 指定帧
         */
        gotoAndStopByFrame(name: string, layerIndex: number, frame: number): void;
        /**
         * @en Gets the controller layer.
         * @param layerIndex The layer index. Defaults to 0.
         * @returns The AnimatorControllerLayer at the specified index.
         * @zh 获取控制器层。
         * @param layerIndex 层索引。
         * @return 指定索引处的AnimatorControllerLayer。
         */
        getControllerLayer(layerIndex?: number): AnimatorControllerLayer2D;
        /**
         * @en Jump to the specified time and stop playing the animation.
         * @param name The name of the animation.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized playback time of the animation.
         * @zh 跳转到指定时间并停止播放动画。
         * @param name 动画名称
         * @param layerIndex 层索引
         * @param normalizedTime 归一化播放动画时间
         */
        gotoAndStop(name: string, layerIndex: number, normalizedTime: number): void;
        /**
         * @en Play animation
         * @param name The name of the animation.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized time.
         * @zh 播放动画
         * @param name 动画名称
         * @param layerIndex 层索引
         * @param normalizedTime 归一化时间
         */
        play(name?: string, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Stop playing animation.
         * @zh 停止播放动画
         */
        stop(): void;
        /**
         * @en Frame Loop
         * @zh 帧循环
         */
        onUpdate(): void;
        /**
         * @en Adds an animator controller layer.
         * @param controllerLayer The animator controller layer to be added.
         * @zh 增加一个动画控制器层。
         * @param controllerLayer 动画控制器层.
         */
        addControllerLayer(controllerLayer: AnimatorControllerLayer2D): void;
        /**
         * @en Cross-fades between the current and target animation states.
         * @param name The name of the target animation state.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized start time for playback.
         * @param transitionDuration The duration of the transition in normalized time (between 0.0 and 1.0).
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param name 目标动画状态。
         * @param layerIndex 层索引。
         * @param normalizedTime 归一化的播放起始时间。
         * @param transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         */
        crossFade(name: string, layerIndex: number, normalizedTime: number, transitionDuration: number): boolean;
        /**
         * @en Cross-fades between the current and target animation states with an optional transition duration.
         * @param name The name of the target animation state.
         * @param layerIndex The index of the layer.
         * @param normalizedTime The normalized start time for playback.
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param name 目标动画状态的名称。
         * @param layerIndex 层的索引。
         * @param normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, layerIndex: number, normalizedTime: number): boolean;
        /**
         * @internal
         * @returns
         */
        onAfterDeserialize(): void;
        /**
         * @internal
         */
        onEnable(): void;
        /**
         * @en Get the default State Machine
         * @param layerIndex The index of the layer.
         * @zh 获取默认状态机
         * @param layerIndex 层索引
         */
        getDefaultState(layerIndex?: number): AnimatorState2D;
        /**
         * @en Set a parameter's trigger value.
         * @param name The name of the parameter.
         * @zh 设置参数Trigger值
         * @param name 名字
         */
        setParamsTrigger(name: string): void;
        /**
         * @en Set a parameter's float value.
         * @param name The name of the parameter.
         * @param value The value of the parameter.
         * @zh 设置参数Number值
         * @param name 名字
         * @param value 值
         */
        setParamsNumber(name: string, value: number): void;
        /**
         * @en Set a parameter's bool value.
         * @param name The name of the parameter.
         * @param value The value of the parameter.
         * @zh 设置参数Bool值
         * @param name 名字
         * @param value 值
         */
        setParamsBool(name: string, value: boolean): void;
        /**
         * @en Get a parameter's trigger value.
         * @param name The name of the parameter.
         * @zh 得到参数值
         * @param name 名字
         */
        getParamsvalue(name: string): number | boolean;
        /**
         * @internal
         */
        onDestroy(): void;
    }
    /**
     * @en 2D animation controller
     * @zh 2D动画控制器
     */
    class AnimatorController2D extends Resource {
        /**
         * @internal
         * @en Data of the animator controller
         * @zh 动画控制器的数据
         */
        data: TypeAnimatorControllerData;
        /**
         * @internal
         * @en Array of clip IDs
         * @zh 剪辑ID数组
         */
        clipsID: string[];
        /**
         * @en Constructor method of 2D animation controller
         * @zh 2D动画控制器的构造方法
         */
        constructor(data: any);
        /**
         * @internal
         * @returns
         */
        private getLayers;
        /**
         * @internal
         * @param states
         * @param idCatch
         * @param acl
         * @returns
         */
        private createState;
        /**
         * @internal
         * @param states
         * @param acl
         * @param data
         */
        private getState;
        /**
         * @internal
         * @param exitRet
         * @param transitions
         * @param idCatch
         * @param data
         * @param pExitRet
         */
        private setExitTransition;
        private _getAnimatorTransition2D;
        /**
         * @internal
         * @param states
         * @param idCatch
         * @param acl
         * @param data
         * @param pState
         * @returns
         */
        private setTransitions;
        /**
         * @internal
         * @param arr
         * @param ato
         * @param data
         * @returns
         */
        private addConditions;
        /**
         * @internal
         * @param a
         */
        updateTo(a: Animator2D): void;
    }
    /**
     * @en Layer of 2D animation controllers
     * @zh 2D动画控制器层
     */
    class AnimatorControllerLayer2D implements IClone {
        /**
         * @en Mixed Mode: Overwrite
         * @zh 混合模式_覆盖。
         */
        static readonly BLENDINGMODE_OVERRIDE: number;
        /**
         * @en Mixed Mode: Stacking
         * @zh 混合模式_叠加。
         */
        static readonly BLENDINGMODE_ADDTIVE: number;
        /**@internal */
        private _defaultState;
        /**@internal */
        private _referenceCount;
        /**@internal */
        private _defaultStateNameCatch;
        /**@internal*/
        _playStateInfo: AnimatorPlayState2D | null;
        /**@internal*/
        _crossPlayStateInfo: AnimatorPlayState2D | null;
        /**@internal*/
        _crossMark: number;
        /**@internal */
        _crossNodesOwnersCount: number;
        /**@internal */
        _crossNodesOwnersIndicesMap: any;
        /**@internal */
        _srcCrossClipNodeIndices: number[];
        /**@internal */
        _destCrossClipNodeIndices: number[];
        /**@internal */
        _enterTransition: AnimatorTransition2D;
        /**
         * @en layer name
         * @zh 层的名字
         */
        name: string;
        /**
         * @en Whether to play when the layer is started.
         * @zh 是否开始时播放
         */
        playOnWake: boolean;
        /**
         * @en Default weight
         * @zh 默认权重
         */
        defaultWeight: number;
        /**
         * @en Mixed Mode
         * @zh 混合模式
         */
        blendingMode: number;
        /**
         * @en Is it enabled
         * @zh 是否开启
         */
        enable: boolean;
        /**
         * @internal
         * @en State machine
         * @zh 状态机
         */
        _states: AnimatorState2D[];
        /**
         * @internal
         * @en 0:normal play, 1:dynamic fusing play, 2:fixed fusing play
         * @zh 0:常规播放、1:动态融合播放、2:固定融合播放
         */
        _playType: number;
        /**
         * @en Constructor method of 2D animator controller Layer.
         * @zh 2D动画控制器层的构造方法
         */
        constructor(name: string);
        /**
         * @en State machine
         * @zh 状态机
         */
        get states(): ReadonlyArray<AnimatorState2D>;
        set states(states: ReadonlyArray<AnimatorState2D>);
        /**
         * @en The default state name.
         * @zh 默认状态名称。
         */
        get defaultStateName(): string;
        set defaultStateName(str: string);
        /**
         * @en Default animation state machine
         * @zh 默认动画状态机。
         */
        get defaultState(): AnimatorState2D;
        set defaultState(value: AnimatorState2D);
        /**
         * 移除Clip
         * @param clipStateInfos
         * @param index
         * @param state
         */
        private _removeClip;
        /**
         * @internal
         * @returns
         */
        _getReferenceCount(): number;
        /**
         * @internal
         * @param count
         */
        _addReference(count: number): void;
        /**
         * @internal
         * @param count
         */
        _removeReference(count?: number): void;
        /**
         * @internal
         */
        _clearReference(): void;
        /**
         * @en Gets the current play state of the animator.
         * @returns The play state of the animation.
         * @zh 获取当前的动画播放状态。
         * @returns 动画的播放状态。
         */
        getCurrentPlayState(): AnimatorPlayState2D;
        /**
         * @en Gets an animator state by its name.
         * @param str The name of the state to retrieve.
         * @returns The AnimatorState2D object if found, otherwise null.
         * @zh 通过状态机名称获取动画状态对象。
         * @param str 要检索的状态名称。
         * @returns 如果找到，返回 AnimatorState2D 对象，否则返回 null。
         */
        getStateByName(str: string): AnimatorState2D;
        /**
         * @en Adds an animation state to the animator.
         * @param state The AnimatorState2D to add.
         * @zh 向动画机添加动画状态。
         * @param state 要添加的 AnimatorState2D。
         */
        addState(state: AnimatorState2D): void;
        /**
         * @en Removes an animation state.
         * @param state The AnimatorState2D to remove.
         * @zh 移除动画状态。
         * @param state 要移除的 AnimatorState2D。
         */
        removeState(state: AnimatorState2D): void;
        /**
         * @en Clones the current animator controller layer.
         * @returns A clone of the current animator controller layer.
         * @zh 克隆当前的动画控制器层。
         * @returns 当前动画控制器层的克隆副本。
         */
        clone(): AnimatorControllerLayer2D;
        /**
         * @en Clones the current animator controller layer to a destination object.
         * @param destObject The destination object to clone to.
         * @zh 克隆当前的动画控制器层到目标对象。
         * @param destObject 克隆到的目标对象。
         */
        cloneTo(destObject: AnimatorControllerLayer2D): void;
        /**
         * @en Destroys the animator controller layer and all its states.
         * @zh 销毁动画控制器层及其所有状态。
         */
        destroy(): void;
    }
    interface TypeAnimatorControllerData {
        layerW: number;
        controllerLayers: TypeAnimatorLayer[];
        cullingMode?: number;
        enable?: boolean;
        animatorParams?: TypeAnimatorParams[];
    }
    interface TypeAnimatorParams {
        id: number;
        name: string;
        type: AniParmType;
        val: number | boolean;
    }
    interface TypeAnimatorLayer {
        defaultStateName?: string;
        name: string;
        blendingMode: number;
        states: TypeAnimatorState[];
        playOnWake: boolean;
        defaultWeight: number;
        avatarMask?: any;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    enum AniParmType {
        Float = 0,
        Bool = 1,
        Trigger = 2
    }
    /**
     * @en Animation state condition types
     * @zh 动画状态条件类型
     */
    enum AniStateConditionType {
        Number = 0,
        Bool = 1,
        Trigger = 2
    }
    interface TypeAnimatorState {
        x: number;
        y: number;
        /**-1代表enter，-2代表exit，-3代表anyState */
        id: string;
        name: string;
        speed?: number;
        clipStart?: number;
        clipEnd?: number;
        loop?: number;
        yoyo?: boolean;
        soloTransitions?: TypeAnimatorTransition[];
        clip?: {
            _$uuid: string;
        };
        scripts?: string[];
        states?: TypeAnimatorState[];
        defaultStateName?: string;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    interface TypeAnimatorTransition {
        id: string;
        name?: string;
        mute?: boolean;
        solo?: boolean;
        exitTime?: number;
        transduration?: number;
        transstartoffset?: number;
        exitByTime?: boolean;
        conditions?: TypeAnimatorConditions[];
    }
    interface TypeAnimatorConditions {
        id?: number;
        type?: AniStateConditionNumberCompressType;
        checkValue?: number | boolean;
        name?: string;
    }
    enum AniStateConditionNumberCompressType {
        Less = 0,
        Greater = 1
    }
    /**
     * @en Animation controller parsing and processing utility class.
     * @zh 解析和处理动画控制器数据的工具类。
     */
    class AnimatorControllerParse {
        /**
         * @en Parses the provided data to create a structured TypeAnimatorControllerData object..
         * @zh 解析提供的数据以创建结构化的 TypeAnimatorControllerData 对象。
         */
        static parse(data: TypeAnimatorControllerData): {
            ret: TypeAnimatorControllerData;
            clipsID: string[];
        };
        private static checkStates;
        private static checkNext;
        private static checkConditions;
        private static checkDefault;
        private static getStateByID;
    }
    /**
     * @en 2D Animator Play State.
     * @zh 2D 动画播放状态。
     */
    class AnimatorPlayState2D {
        _finish: boolean;
        /**@internal */
        _startPlayTime: number;
        /**@internal */
        _lastElapsedTime: number;
        /**
         * @internal
         * @en Animation playback time
         * @zh 动画播放时间
         */
        _elapsedTime: number;
        /**
         * @internal
         * @en Playback count
         * @zh 播放的次数
         */
        _playNum: number;
        /**
         * @en Total play time, not affected by negative speed values.
         * @zh 总播放时间，不受速度为负数的影响。
         */
        _playAllTime: number;
        /**
         * @internal
         * @en Normalized time for a single playback.
         * @zh 单次播放的归一化时间。
         */
        _normalizedPlayTime: number;
        /**@internal */
        _duration: number;
        /**
         * @internal
         * @en The time of the last playback, used by event events.
         * @zh 上次播放的时间，用于event事件。
         */
        _parentPlayTime: number;
        /**@internal */
        _lastIsFront: boolean;
        /**@internal */
        _currentState: AnimatorState2D | null;
        /**
         * @en Indicates if the playback is in forward direction.
         * @zh 表示播放是否为正向。
         */
        _frontPlay: boolean;
        /**
         * @en The duration of the current animation, in seconds.
         * @zh 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * @en Animation state machine
         * @zh 动画状态机。
         */
        get animatorState(): AnimatorState2D;
        /**
         * @en Constructor method of AnimatorPlayState2D class.
         * @zh AnimatorPlayState2D类的构造方法
         */
        constructor();
        /**
         * @internal
         */
        _resetPlayState(startTime: number, clipDuration: number): void;
        /**
         * @internal
         */
        _cloneTo(dest: AnimatorPlayState2D): void;
    }
    /**
     * @en The Animator class is used to create animation components.
     * @zh Animator 类用于创建动画组件。
     */
    class AnimatorState2D extends EventDispatcher implements IClone {
        /**
         * @en Event triggered when entering the state
         * @zh 进入状态时触发的事件
         * @blueprintIgnore
         */
        static EVENT_OnStateEnter: string;
        /**
         * @en Event triggered during state update
         * @zh 状态更新时触发的事件
         * @blueprintIgnore
         */
        static EVENT_OnStateUpdate: string;
        /**
         * @en Event triggered when exiting the state
         * @zh 退出状态时触发的事件
         * @blueprintIgnore
         */
        static EVENT_OnStateExit: string;
        /**
         * @en Event triggered when switching to a new state
         * @zh 切换到新状态时触发的事件
         * @blueprintIgnore
         */
        static EVENT_OnStateSwitch: string;
        /**
         * @en Event triggered when the state loops
         * @zh 状态循环时触发的事件
         * @blueprintIgnore
         */
        static EVENT_OnStateLoop: string;
        /** @internal */
        private _referenceCount;
        /** @internal */
        _clip: AnimationClip2D | null;
        /**@internal */
        _currentFrameIndices: Int16Array | null;
        /**
         * @en Play on awake start offset
         * @zh 启动时播放偏移
         */
        cycleOffset: number;
        /**
         * @en name
         * @zh 名称
         */
        name: string;
        /**
         * @en Animation playback speed
         * @zh 动画播放速度
         */
        speed: number;
        /**
         * @en Action playback start time.
         * @zh 动作播放起始时间
         */
        clipStart: number;
        /**
         * @en The end time of the action playback.
         * @zh 动作播放结束时间。
         */
        clipEnd: number;
        /**
         * @en The number of animation loops. -1 or less than -1 to use the loop state of the clip, 1 for playing once, 2 for playing twice, 0 for infinite looping.
         * @zh 动画循环次数，-1或小于-1使用clip的循环状态，1表示播放一次，2表示播放两次，0表示无限循环。
         */
        loop: number;
        /**
         * @en Is it a one-time forward playback and one-time reverse playback mode
         * @zh 是否为一次正播放，一次倒播放模式
         */
        yoyo: boolean;
        /**
         * @internal
         * @en The list of transitions for the animator.
         * @zh 动画器的过渡列表。
         */
        transitions: AnimatorTransition2D[];
        /**
         * @internal
         * @en Priority Transition List.
         * @zh 优先过渡列表。
         */
        soloTransitions: AnimatorTransition2D[];
        /**@internal */
        _scripts: AnimatorState2DScript[] | null;
        /**@internal */
        _realtimeDatas: Array<number | string | boolean | {
            pos: Vector3;
            rotation: Vector3;
        }>;
        /**
         * @en Animation Clip
         * @zh 动画剪辑
         */
        get clip(): AnimationClip2D | null;
        set clip(value: AnimationClip2D | null);
        /**
         * @internal
         */
        _eventStateUpdate(value: number): void;
        /**
         * @internal
         */
        _eventStart(animator: Animator2D, layerIndex: number): void;
        /**
         * @internal
         */
        _eventExit(): void;
        _eventSwitch(currentState: AnimatorState2D): void;
        /**
         * @internal
         */
        _eventLoop(): void;
        /**
         * @en Dispatches the transition event and checks for transitions based on normalized time and parameters.
         * @param normalizeTime The normalized time for transition checking.
         * @param paramsMap The map of parameters for transition checking.
         * @param isReplay Whether to repeat playback.
         * @zh 派发过渡事件并根据归一化时间和参数检查过渡。
         * @param normalizeTime 用于检查过渡的归一化时间。
         * @param paramsMap 用于检查过渡的参数映射。
         * @param isReplay 是否重复播放
         */
        _eventtransition(normalizeTime: number, paramsMap: Record<string, Animation2DParm>, isReplay: boolean): AnimatorTransition2D;
        /**
         * @internal
         */
        _resetFrameIndices(): void;
        /**
         * @internal
         * @returns
         */
        _getReferenceCount(): number;
        /**
         * @internal
         * @param count
         */
        _addReference(count: number): void;
        /**
         * @internal
         * @param count
         */
        _removeReference(count: number): void;
        /**
         * @internal
         */
        _clearReference(): void;
        /**
         * @en Adds a script of the specified type to the animator state.
         * @param type The type of the script to be added.
         * @returns The added script instance.
         * @zh 向动画状态添加指定类型的脚本。
         * @param type 要添加的脚本类型。
         * @returns 添加的脚本实例。
         */
        addScript(type: typeof AnimatorState2DScript): AnimatorState2DScript;
        /**
         * @en Get the script of the specified type.
         * @param type The type of the script to retrieve.
         * @returns The script instance if found, or null if not found.
         * @zh 获取指定类型的脚本。
         * @param type 要检索的脚本类型。
         * @returns 如果找到则返回脚本实例，如果没有找到则返回 null。
         */
        getScript(type: typeof AnimatorState2DScript): AnimatorState2DScript | null;
        /**
         * @en Get the collection of scripts of the specified type.
         * @param type The type of scripts to retrieve.
         * @returns An array of scripts if found, or null if no scripts match the type.
         * @zh 获取指定类型的脚本集合。
         * @param type 要检索的脚本类型。
         * @returns 如果找到则返回脚本数组，如果没有找到匹配类型的脚本则返回 null。
         */
        getScripts(type: typeof AnimatorState2DScript): AnimatorState2DScript[] | null;
        /**
         * @en Clone of the current instance.
         * @returns A new instance of AnimatorState2D that is a clone of the current instance.
         * @zh 当前实例的克隆
         * @returns 一个新的 AnimatorState2D 实例，是当前实例的克隆。
         */
        clone(): AnimatorState2D;
        /**
         * @en Copies the properties of the current animator state to a target object.
         * @param destObject The target object to which the properties are copied.
         * @zh 将当前动画状态的属性拷贝到目标对象。
         * @param destObject 要拷贝属性的目标对象。
         */
        cloneTo(destObject: AnimatorState2D): void;
        /**
         * @en Destroys .
         * @zh 销毁。
         */
        destroy(): void;
    }
    interface AnimatorPlay2DScriptInfo {
        animator: Animator2D;
        layerindex: number;
        playState: AnimatorState2D;
    }
    /**
     * @en The AnimatorStateScript class is used as the parent class for animation state scripts. This class is abstract and does not allow instances.
     * @zh AnimatorStateScript 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorState2DScript {
        /**@internal */
        playStateInfo: AnimatorPlay2DScriptInfo;
        /**
         * @internal
         * @en Set the play script information
         * @zh 设置播放脚本信息
         */
        setPlayScriptInfo(animator: Animator2D, layerindex: number, playstate: AnimatorState2D): void;
        /**
         * @en Constructor method of AnimatorStateScript.
         * @zh AnimatorStateScript的构造方法
         */
        constructor();
        /**
         * @en Executed when the animation state starts.
         * @zh 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * @en Called during the execution of the animation state, providing the normalized play time.
         * @param normalizeTime The normalized play time of the animation, ranging from 0 to 1.
         * @zh 在动画状态运行中调用，提供归一化的播放时间。
         * @param normalizeTime 动画的归一化播放时间，范围从0到1。
         */
        onStateUpdate(normalizeTime: number): void;
        /**
         * @en Executed when the animation state is about to exit.
         * @zh 动画状态退出时执行。
         */
        onStateExit(): void;
        /**
         * @en Executed when switching to a new state
         * @zh 切换到新状态时执行
         */
        onStateSwitch(currentState: AnimatorState2D): void;
        /**
         * @en Executed at the end of each loop cycle if the animation is set to loop.
         * @zh 如果动画设置为循环，在每次循环结束时执行。
         */
        onStateLoop(): void;
    }
    /**
     * @en Animation state machine transition condition
     * @zh 动画状态机过渡条件
     */
    class AnimatorStateCondition {
        /**
         * @internal
         */
        static _conditionNameMap: any;
        /**
         * @internal
         */
        static _propertyNameCounter: number;
        /**
         * @en Gets the unique ID associated with a name.
         * @param name The unique name.
         * @return The unique ID.
         * @zh 根据名称获取唯一的ID。
         * @param name 唯一的名称。
         * @return 唯一ID。
         */
        static conditionNameToID(name: string): number;
        /**
         * @en Gets the unique name associated with an ID.
         * @param id The condition ID.
         * @returns The unique name.
         * @zh 根据ID获取唯一的名称。
         * @param id 条件ID。
         * @returns 唯一名称。
         */
        static conditionIDToName(id: number): string;
        /**
         * @en The type of the condition.
         * @zh 状态条件类型
         */
        protected _type: AniStateConditionType;
        private _id;
        private _name;
        /**
         * @en Constructor method of AnimatorStateCondition.
         * @zh 动画状态机过渡条件的构造方法
         */
        constructor(name?: string);
        /**
         * @en The unique identifier of the condition.
         * @zh 条件的唯一标识符。
         */
        get id(): number;
        /**
         * @en The name of the condition.
         * @zh 条件的名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en The type of the condition.
         * @zh 条件的类型。
         */
        get type(): AniStateConditionType;
        /**
         * @internal
         * @en Checks if the state condition is triggered based on the provided value.
         * @param value The value to check against the condition, can be a number or a boolean.
         * @zh 根据提供的值检查状态条件是否被触发。
         * @param value 用于检查条件的值，可以是数字或布尔值。
         */
        checkState(value: number | boolean): boolean;
    }
    /**
     * @en Numerical condition class. Used to handle conditions based on numerical comparisons.
     * @zh 数值条件类。用于处理基于数值比较的条件。
     */
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        private _numberValue;
        private _numberCompareFlag;
        /**
         * @en Constructor method of AnimatorStateNumberCondition.
         * @zh 创建number比较条件类的构造方法
         */
        constructor(name: string);
        /**
         * @en The number value.
         * @zh 数字值。
         */
        get numberValue(): number;
        set numberValue(value: number);
        /**
         * @en Determine type
         * @zh 判断类型
         */
        get compareFlag(): AniStateConditionNumberCompressType;
        set compareFlag(value: AniStateConditionNumberCompressType);
        /**
         * @en Checks if the state is triggered based on the comparison of the provided value with the number value.
         * @param value The value to compare.
         * @zh 根据提供的值与数值的比较结果检查状态是否触发。
         * @param value 要比较的值。
         */
        checkState(value: number): boolean;
    }
    /**
     * @en Boolean conditional class. Used to handle Boolean based conditions.
     * @zh 布尔条件类。用于处理基于布尔值的条件。
     */
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        private _compareFlag;
        /**
         * @en Constructor method.
         * @zh 构造方法
         */
        constructor(name: string);
        /**
         * @en Determine type
         * @zh 判断类型
         */
        get compareFlag(): boolean;
        set compareFlag(value: boolean);
        /**
         * @en Checks if the state is triggered based on the comparison of the provided boolean value with the comparison flag.
         * @param value The boolean value to compare.
         * @zh 根据提供的布尔值与比较标志的比较结果检查状态是否触发。
         * @param value 要比较的布尔值。
         */
        checkState(value: boolean): boolean;
    }
    /**
     * @en Trigger condition class. Used to handle trigger type conditions.
     * @zh 触发器条件类。用于处理触发器类型的条件。
     */
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        /**
         * @en Constructor method.
         * @zh 触发器条件类的构造方法
         */
        constructor(name: string);
        /**
         * @en Check if the state is triggered. If the trigger is true, the condition is met.
         * @param value Boolean value.
         * @zh 检查状态是否触发,tigger 如果是true,就算条件达成
         * @param value 布尔值。
         */
        checkState(value: boolean): boolean;
    }
    /**
     * @en 2D animation transition
     * @zh 2D动画过渡
     */
    class AnimatorTransition2D {
        /**
         * @en Whether the state is muted.
         * @zh 状态是否被禁用。
         */
        mute: boolean;
        /**
         * @en The exit time of the state.
         * @zh 状态的退出时间。
         */
        exitTime: number;
        /**
         * @en Is the effective time set.
         * @zh 是否设置生效时间。
         */
        exitByTime: boolean;
        /**
         * @en The normalized playback position of the next state in the transition.
         * @zh 过渡中下一个状态的归一化播放位置。
         */
        transstartoffset: number;
        /**
         * @en The normalized transition duration.
         * @zh 归一化的过渡持续时间。
         */
        transduration: number;
        /**
         * @en Transition conditions
         * @zh 过渡条件。
         */
        conditions: AnimatorStateCondition[];
        /**
         * @en The destination state for the transition.
         * @zh 过渡的目标状态。
         */
        destState: AnimatorState2D;
        /**
         * @en Whether to use and operate when there are multiple conditions
         * @zh 当有多个条件的时候是否使用与操作
         */
        isAndOperEnabled: boolean;
        /**
         * @en Constructor method of Animatortransition2D.
         * @zh Animatortransition2D的构造方法
         */
        constructor();
        /**
         * @en Adds a state transition condition to the list of conditions.
         * @param condition The AnimatorStateCondition to be added.
         * @zh 向条件列表中添加一个状态转换条件。
         * @param condition 要添加的状态转换条件。
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Removes a state transition condition from the list of conditions.
         * @param condition The AnimatorStateCondition to be removed.
         * @zh 从条件列表中删除一个状态转换条件。
         * @param condition 要删除的状态转换条件。
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Checks whether the transition is enabled based on the normalized time, condition parameters, and replay status.
         * @param normalizeTime The current normalized time (between 0 and 1) in the animation.
         * @param paramsMap Condition group
         * @param isReplay Whether to repeat playback.
         * @zh 根据归一化时间、条件参数和重播状态检查过渡是否启用。
         * @param normalizeTime 动画中当前的归一化时间（0到1之间）。
         * @param paramsMap 条件组
         * @param isReplay 是否重复播放
         */
        check(normalizeTime: number, paramsMap: Record<string, Animation2DParm>, isReplay: boolean): boolean;
    }
    /**
     * @en Animation update modes
     * @zh 动画更新模式
     */
    enum AnimatorUpdateMode {
        /**
         * @en Normal update mode
         * @zh 正常更新。
         */
        Normal = 0,
        /**
         * @en Low frame rate update mode
         * @zh 低频率更新。
         */
        LowFrame = 1,
        /**
         * @en Do not update thes animations based on time
         * @zh 不更新。
         */
        UnScaleTime = 2
    }
    /**
     * @en The Component class is used to create the base class for components.
     * @zh Component 类用于创建组件的基类。
     * @blueprintable @blueprintableSubclasses
     */
    class Component {
        /**
         * @en Unique identifier for the component.
         * @zh 组件的唯一标识。
         */
        _id: number;
        /**@private */
        private _hideFlags;
        /**@private */
        private _enableState;
        /** @internal */
        _status: number;
        /**
         * @en Gets the owner Node to which the component belongs.
         * @zh 获取组件所属的 Node 节点。
         */
        readonly owner: Node;
        /** @internal */
        _enabled: boolean;
        /**
         * @en Whether the component is a singleton, meaning only one instance of this type of script can be added to the same node.
         * @zh 是否为单例，即同一个节点只能添加此类型的脚本一次。
         */
        _singleton: boolean;
        /**
         * @en Whether the script can run in the IDE environment.
         * @zh 是否可以在 IDE 环境中运行。
         * @blueprintIgnore
         */
        runInEditor: boolean;
        /**
         * @en The path of the script file.
         * @zh 脚本文件的路径。
         * @blueprintIgnore
         */
        scriptPath: string;
        /**
         * @en Extra data of the node.
         * @zh 组件的额外数据。IDE内部使用。
         * @blueprintIgnore
         */
        _extra: IComponentExtra;
        /**
         * @internal
         */
        _driver: ComponentDriver;
        /**
         * @en The hide flags that determine the hiding behavior of the component.
         * @zh 确定组件隐藏行为的标志。
         */
        get hideFlags(): number;
        set hideFlags(value: number);
        /**
         * @en Constructor method of Component.
         * @zh 组件的构造方法
         */
        constructor();
        /**
         * @internal
         * @en used in IDE
         * @zh 在IDE中使用。
         * */
        _initialize(): void;
        /**
         * @en Checks if the component has a specific hide flag set.
         * @param flag The hide flag to check for.
         * @zh 检查组件是否设置了特定的隐藏标志。
         * @param flag 要检查的隐藏标志。
         */
        hasHideFlag(flag: number): boolean;
        /**
         * @en The unique identifier for the component.
         * @zh 组件的唯一标识。
         */
        get id(): number;
        /**
         * @en whether the component is enabled.
         * @zh 是否启用组件。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en whether the component has been awakened.
         * @zh 组件是否已经被唤醒。
         */
        get awaked(): boolean;
        /**
         * @en whether the component has been destroyed.
         * @zh 组件是否已经被销毁。
         */
        get destroyed(): boolean;
        /**
         * @ignore
         * @blueprintIgnore
         */
        _isScript(): boolean;
        /**
         * @internal
         */
        protected _resetComp(): void;
        /**
         * @internal
         * @en Sets the owner Node of the component.
         * @param node The Node that now owns the component.
         * @zh 设置组件所属的 Node 节点。
         * @param node 现在拥有该组件的 Node。
         */
        _setOwner(node: Node): void;
        /**
         * @ignore
         * 被添加到节点后调用，可根据需要重写此方法
         */
        protected _onAdded(): void;
        /**
         * @ignore
         * 被激活后调用，可根据需要重写此方法
         */
        protected _onAwake(): void;
        /**
         * @ignore
         * 被激活后调用，可根据需要重写此方法
         */
        protected _onEnable(): void;
        /**
         * @ignore
         * 被禁用时调用，可根据需要重写此方法
         * 销毁组件
         */
        protected _onDisable(): void;
        /**
         * @ignore
         * 被销毁时调用，可根据需要重写此方法
         */
        protected _onDestroy(): void;
        /**
         * @internal
         */
        _parse(data: any, interactMap?: any): void;
        /**
         * @internal
         */
        _parseInteractive(data?: any, spriteMap?: any): void;
        /**
         * @internal
         */
        _cloneTo(dest: Component): void;
        /**
         * @ignore
         */
        _setActive(value: boolean): void;
        /**
         * @internal
         */
        protected setupScript(): void;
        /**
         * @en Destroy components
         * @zh 销毁组件
         */
        destroy(): void;
        /**
         * @internal
         */
        _destroy(second?: boolean): void;
        /**
         * @en Called after the component is added to a node. Unlike Awake, onAdded is called even if the node is not active.
         * @zh 组件被添加到节点后调用，与 onAwake 不同的是，即使节点未激活也会调用 onAdded。
         * @blueprintEvent
         */
        onAdded(): void;
        /**
         * @en Resets the component's parameters to their default values. If this function is implemented, the component will be reset and automatically recycled for future use.
         * If not reset, it will not be recycled for reuse.
         * @zh 将组件的参数重置为默认值。如果实现了这个函数，组件将被重置并自动回收到对象池，方便下次复用。
         * 如果没有重置，则不会进行回收复用。
         */
        onReset?(): void;
        /**
         * @en Executed after the component is activated. At this point, all nodes and components have been created. This method is executed only once.
         * @zh 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次。
         * @blueprintEvent
         */
        onAwake(): void;
        /**
         * @en Executed after the component is enabled, such as when the node is added to the stage.
         * @zh 组件被启用后执行，比如节点被添加到舞台后。
         * @blueprintEvent
         */
        onEnable(): void;
        /**
         * @en Executed once, before the first update.
         * @zh 在第一次执行 update 之前执行，只会执行一次。
         * @blueprintDefaultEvent
         */
        onStart?(): void;
        /**
         * @en Executed every frame during the update phase. Avoid writing complex loop logic or using the getComponent method here.
         * @zh 每帧更新时执行，在 update 阶段。尽量不要在这里写大循环逻辑或使用 getComponent 方法。
         * @blueprintEvent
         */
        onUpdate?(): void;
        /**
         * @en Executed every frame during the late update phase, after the update phase.
         * @zh 每帧更新时执行，在 late update 阶段，update 阶段之后。
         * @blueprintEvent
         */
        onLateUpdate?(): void;
        /**
         * @en Executed before rendering.
         * @zh 渲染之前执行。
         * @blueprintEvent
         */
        onPreRender?(): void;
        /**
         * @en Executed after rendering.
         * @zh 渲染之后执行。
         * @blueprintEvent
         */
        onPostRender?(): void;
        /**
         * @en Executed when the component is disabled, such as when the node is removed from the stage.
         * @zh 组件被禁用时执行，比如从节点从舞台移除后。
         * @blueprintEvent
         */
        onDisable(): void;
        /**
         * @en Executed when the node is destroyed manually.
         * @zh 手动调用节点销毁时执行。
         * @blueprintEvent
         */
        onDestroy(): void;
    }
    interface IComponentExtra {
    }
    /**
     * @en Core classes for managing and driving the lifecycle of components
     * @zh 用于管理和驱动组件生命周期的核心类
     */
    class ComponentDriver {
        private _onUpdates;
        private _onLateUpdates;
        private _onPreRenders;
        private _onPostRenders;
        private _toStarts;
        readonly _toDestroys: Set<Component>;
        /**
         * @internal
         * @en Calling component Onstart
         * @zh 调用组件Onstart
         */
        callStart(): void;
        /**
         * @internal
         * @en Calling component OnUpdate
         * @zh 调用组件OnUpdate
         */
        callUpdate(): void;
        /**
         * @internal
         * @en Calling component LayeUpdate
         * @zh 调用组件LayeUpdate
         */
        callLateUpdate(): void;
        /**
         * @internal
         * @en Calling component onPreRender
         * @zh 调用组件onPreRender
         */
        callPreRender(): void;
        /**
         * @internal
         * @en Calling component onPostRender
         * @zh 调用组件onPostRender
         */
        callPostRender(): void;
        /**
         * @internal
         * @en Calling destroy
         * @zh 调用销毁
         */
        callDestroy(): void;
        /**
         * @internal
         * @en Adds a component.
         * @param comp The component to be added.
         * @zh 添加一个组件。
         * @param comp 要添加的组件。
         */
        add(comp: Component): void;
        /**
         * @internal
         * @en Removes a component.
         * @param comp The component to be removed.
         * @zh 移除一个组件。
         * @param comp 要移除的组件。
         */
        remove(comp: Component): void;
        /**
         * @internal
         * 删除组件Driver
         */
        destroy(): void;
        /**
         * @en Error handling.
         * @zh 错误处理。
         */
        onError(err: any): void;
    }
    enum AnimationWrapMode {
        /**
         * @en Animation playback order type: Forward playback.
         * @zh 动画播放顺序类型：正序播放。
         */
        Positive = 0,
        /**
         * @en Animation playback order type: Reverse playback.
         * @zh 动画播放顺序类型：倒序播放。
         */
        Reverse = 1,
        /**
         * @en Animation playback order type: Ping-pong playback (changes playback direction after reaching the end when continuing to play).
         * @zh 动画播放顺序类型：pingpong播放(当按指定顺序播放完结尾后，如果继续播放，则会改变播放顺序)。
         */
        PingPong = 2
    }
    enum AnimationStretchMode {
        /**
         * @en No stretch.
         * @zh 不拉伸。
         */
        None = 0,
        /**
         * @en Fill the entire sprite size.
         * @zh 填满整个精灵尺寸。
         */
        Fill = 1,
        /**
         * @en Resize the sprite to fit the size of the first frame.
         * @zh 调整精灵尺寸适应第一帧的大小。
         */
        ResizeToFit = 2
    }
    /**
     * @en The FrameAnimation component is used to play frame animation.
     * @zh FrameAnimation 组件，用于播放帧动画。
     */
    class FrameAnimation extends Component {
        /**
         * @en The interval between frame changes, in milliseconds.
         * @zh 帧改变之间的间隔时间，单位为毫秒。
         */
        interval: number;
        /**
         * @en The delay between each repeat, in milliseconds.
         * @zh 每次重复之间的延迟，单位为毫秒。
         */
        repeatDelay: number;
        /**
         * @en Playback speed.
         * @zh 播放速率。
         */
        timeScale: number;
        private _wrapMode;
        private _loop;
        private _frame;
        private _frames;
        private _delays;
        private _autoPlay;
        private _stretchMode;
        private _offset;
        private _source;
        private _images;
        private _color;
        private _atlas;
        private _playing;
        private _count;
        private _index;
        private _elapsed;
        private _reversed;
        private _drawCmd;
        private _drawCmds;
        private _loadId;
        private _changingSize;
        /** @internal */
        _labels: string[];
        readonly owner: Sprite;
        /**
         * @en Constructor method of Animation.
         * @zh 动画类的构造方法
         */
        constructor();
        /**
         * @en The index of the current frame in the animation.
         * @zh 动画当前帧的索引。
         */
        get frame(): number;
        set frame(value: number);
        /**
         * @en The current animation frame image array.
         * @zh 当前动画的帧图像数组。
         */
        get frames(): ReadonlyArray<Texture>;
        set frames(value: ReadonlyArray<Texture>);
        /**
         * @en The delay time of each frame, in milliseconds.
         * @zh 每帧的延迟时间，单位为毫秒。
         */
        get frameDelays(): Array<number>;
        /**
         * @en Whether the animation is playing.
         * @zh 动画是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * @en Whether to automatically play the animation after the component is activated.
         * @zh 是否在组件激活后自动播放动画。
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Playback order type.
         * @zh 播放顺序类型。
         */
        get wrapMode(): AnimationWrapMode;
        set wrapMode(value: AnimationWrapMode);
        /**
         * @en Whether to loop playback. The default is true.
         * @zh 是否循环播放。默认为 true。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The stretch mode of the animation. The default is AnimationStretchMode.None.
         * @zh 动画的拉伸模式。默认为 AnimationStretchMode.None。
         */
        get stretchMode(): AnimationStretchMode;
        set stretchMode(value: AnimationStretchMode);
        /**
         * @en The offset of the animation. Only applies when the stretch mode is AnimationStretchMode.None.
         * @zh 动画的偏移量。仅在 stretchMode 为 AnimationStretchMode.None 时生效。
         */
        get offset(): Point;
        set offset(value: Readonly<Point>);
        /**
         * @en The color of the object.
         * @zh 对象的颜色。
         */
        get color(): Color;
        set color(value: Color);
        get width(): number;
        get height(): number;
        private applyStretchMode;
        /**
         * @en Play the animation.
         * @zh 播放动画。
         */
        play(): void;
        /**
         * @en Stop playing the animation.
         * @zh 停止播放动画。
         */
        stop(): void;
        protected _onEnable(): void;
        protected _onDestroy(): void;
        /**
         * @ignore
         */
        onUpdate(): void;
        protected drawFrame(): void;
        /**
         * @en Atlas path.
         * @zh 图集路径。
         */
        get source(): string;
        set source(value: string);
        /**
         * @en The image path array of the animation.
         * @zh 动画的图片路径数组。
         */
        get images(): string[];
        set images(value: string[]);
        private load;
        protected loadImages(urls: string[]): this;
        protected loadAtlas(url: string): this;
        /**
         * @en Set the atlas for the frame animation.
         * @param res The atlas.
         * @zh 设置帧动画的图集。
         * @param res 图集。
         */
        setAtlas(res: AtlasResource): void;
        private onLoaded;
        private onAtlasReload;
    }
    /**
     * @en Interface for the overall management of a type of component within a 3D scene.
     * @zh 3D 场景中某种类型组件的全面管理接口
     * @blueprintIgnore
     */
    interface IElementComponentManager {
        /**
         * @en An internal identifier used to find the manager by Scene3D.
         * @zh 用于通过 Scene3D 查找管理器的内部标识符
         */
        name: string;
        /**
         * @en Initialization method called during Scene3D initialization.
         * @zh 在 Scene3D 初始化过程中调用的初始化方法
         */
        Init(data: any): void;
        /**
         * @en Update method called every frame in the render loop.
         * @zh 渲染循环中每一帧调用的更新方法
         */
        update(dt: number): void;
        /**
         * @en This method is called to clean up resources and perform any necessary destruction tasks for the manager.
         * @zh 该方法用于清理资源并执行管理器所需的销毁任务。
         */
        destroy(): void;
    }
    interface TypeAniKey {
        /**
         * @en The frame index.
         * @zh 第几帧
         */
        f: number;
        val: number | string | boolean | CurvePath;
        /**
         * @en Currently used for 2D animation, it is used to record the types of animation gaps, for example (Linear|Quad_EaseIn)...
         * @zh 目前用于2D动画，用于记录动画补间的类型，比如(Linear|Quad_EaseIn)...
         */
        tweenType?: string;
        /**
         * @en Extension
         * @zh 扩展，如果有一些其它数据需要加入到关键帧中可以写在这里
         */
        extend?: any;
        /**
         * @en The tween information.
         * @zh tween的信息
         */
        tweenInfo?: TypeTweenInfo;
    }
    interface TypeTweenInfo {
        outTangent?: number;
        outWeight?: number;
        inTangent?: number;
        inWeight?: number;
        inWeightLock?: boolean;
        outWeightLock?: boolean;
        broken?: boolean;
    }
    /**
     * @en Class used to represent 2D animation keyframes
     * @zh 用于表示2D动画关键帧的类
     */
    class Keyframe2D implements IClone {
        static defaultWeight: number;
        /**
         * @en time
         * @zh 时间。
         */
        time: number;
        /**
         * @en Specific data within the frame
         * @zh 帧里面的具体数据
         */
        data: TypeAniKey;
        /**
         * @en Creates a clone of the current keyframe.
         * @returns A new instance of Keyframe2D that is a clone of the current keyframe.
         * @zh 创建当前关键帧的克隆。
         * @returns 一个新实例的 Keyframe2D，是当前关键帧的克隆。
         */
        clone(): Keyframe2D;
        /**
         * @en Copies the properties of the current keyframe to another Keyframe2D instance.
         * @param destObject The Keyframe2D instance to which the properties are copied.
         * @zh 将当前关键帧的属性复制到另一个 Keyframe2D 实例。
         * @param destObject 要复制属性的 Keyframe2D 实例。
         */
        cloneTo(destObject: Keyframe2D): void;
    }
    /**
     * @en 2D animation keyframe nodes.
     * @zh 2D 动画关键帧节点的类。
     */
    class KeyframeNode2D {
        _ownerPath: string[];
        _propertys: string[];
        fullPath: string;
        nodePath: string;
        _indexInList: number;
        _keyFrames: Keyframe2D[];
        /**
         * @en Number of frames
         * @zh 帧个数。
         */
        get keyFramesCount(): number;
        _setOwnerPathCount(value: number): void;
        _setOwnerPathByIndex(index: number, value: string): void;
        _setPropertyCount(value: number): void;
        _setPropertyByIndex(index: number, value: string): void;
        _setKeyframeCount(value: number): void;
        _joinOwnerPath(sep: string): string;
        _joinProperty(sep: string): string;
        /**
         * @en Gets a keyframe by its index in the animation timeline.
         * @param index The index of the keyframe to retrieve.
         * @zh 通过索引获取动画时间线上的关键帧。
         * @param index 要检索的关键帧的索引。
         */
        getKeyframeByIndex(index: number): Keyframe2D;
        /**
         * @en The number of owner paths in the animation.
         * @zh 动画中的精灵路径个数。
         */
        get ownerPathCount(): number;
        /**
         * @en The number of property paths in the animation.
         * @zh 动画中的属性路径个数。
         */
        get propertyCount(): number;
        /**
         * @en Gets an owner path by its index in the list of owner paths.
         * @param index The index of the owner path to retrieve.
         * @zh 通过索引获取精灵路径列表中的精灵路径。
         * @param index 要检索的精灵路径的索引。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * @en Gets a property path by its index in the list of property paths.
         * @param index The index of the property path to retrieve.
         * @zh 通过索引获取属性路径列表中的属性路径。
         * @param index 要检索的属性路径的索引。
         */
        getPropertyByIndex(index: number): string;
    }
    /**
     * @en A class used to manage 2D keyframe nodes list.
     * @zh 用于管理2D关键帧节点的列表类。
     */
    class KeyframeNodeList2D {
        private _nodes;
        /**
         * @en The number of nodes in the list.
         * @zh 列表中的节点个数。
         */
        get count(): number;
        set count(value: number);
        /**
         * @en Retrieves node by its index in the list.
         * @param index The index of the node to retrieve.
         * @returns The node at the specified index.
         * @zh 通过索引获取列表中的节点。
         * @param index 要检索的节点的索引。
         * @returns 指定索引处的节点。
         */
        getNodeByIndex(index: number): KeyframeNode2D;
        /**
         * @en Sets a node by its index in the list.
         * @param index The index at which to set the node.
         * @param node The node to set at the specified index.
         * @zh 通过索引设置列表中的节点。
         * @param index 要设置节点的索引。
         * @param node 要设置的节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode2D): void;
    }
    /**
     * @en The Script class is used to create the parent class of a script, which is an abstract class and does not allow instances.
     * @zh Script 类用于创建脚本的父类，该类为抽象类，不允许实例。
     * @blueprintInheritable
     */
    class Script extends Component {
        /**
         * @en Script belonging to sprite
         * @zh 脚本所属精灵
         */
        readonly owner: Sprite | Sprite3D;
        /**
         * @ignore
         * @blueprintIgnore
         */
        _isScript(): boolean;
        /**
         * 设置脚本
         */
        protected setupScript(): void;
        /**
         * @en Called when a 3D physics trigger event or a 2D physics collision event begins.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself.
         * @param contact The contact point information.
         * @zh 开始碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件。
         * @param self 自身的碰撞器组件。
         * @param contact 接触点信息。
         * @blueprintEvent
         */
        onTriggerEnter?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called during the frame a 3D physics trigger event or a 2D physics collision event stays collided.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself, if not provided it's assumed to be the owner of the script.
         * @param contact The contact point information, can be any type depending on the physics engine used.
         * @zh 持续碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件。
         * @param self 自身的碰撞器组件。
         * @param contact 接触点信息。
         * @blueprintEvent
         */
        onTriggerStay?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called when a 3D physics trigger event or a 2D physics collision event ends.
         * @param other The collider component or base of the other object in the collision.
         * @param self The collider component or base of the object itself.
         * @param contact The contact point information.
         * @zh 结束碰撞时执行的3D物理触发器事件或2D物理碰撞事件。
         * @param other 其他对象的碰撞器组件或基类。
         * @param self 自身的碰撞器组件或基类。
         * @param contact 接触点信息。
         * @blueprintEvent
         */
        onTriggerExit?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * @en Called when a 3D physics collider event begins (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件开始时调用（不适用于2D）。
         * @param collision 碰撞器。
         * @blueprintEvent
         */
        onCollisionEnter?(collision: Collision): void;
        /**
         * @en Called during the frame a 3D physics collider event stays collided (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件持续碰撞时调用（不适用于2D）。
         * @param collision 碰撞器。
         * @blueprintEvent
         */
        onCollisionStay?(collision: Collision): void;
        /**
         * @en Called when a 3D physics collider event ends (not applicable to 2D).
         * @param collision The collision.
         * @zh 3D物理碰撞器事件结束碰撞时调用（不适用于2D）。
         * @param collision 碰撞器。
         * @blueprintEvent
         */
        onCollisionExit?(collision: Collision): void;
        /**
         * @en Called when a joint is broken in the physics simulation.
         * @zh 物理模拟中关节断裂时调用。
         * @blueprintEvent
         */
        onJointBreak?(): void;
        /**
         * @en Called when the mouse button is pressed down on the node.
         * @param evt The mouse event.
         * @zh 鼠标按下时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseDown?(evt: Event): void;
        /**
         * @en Called when the mouse button is released from the node.
         * @param evt The mouse event.
         * @zh 鼠标抬起时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseUp?(evt: Event): void;
        /**
         * @en Called when the right or middle mouse button is pressed down.
         * @param evt The mouse event.
         * @zh 鼠标右键或中键按下时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onRightMouseDown?(evt: Event): void;
        /**
         * @en Called when the right or middle mouse button is released.
         * @param evt The mouse event.
         * @zh 鼠标右键或中键抬起时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onRightMouseUp?(evt: Event): void;
        /**
         * @en Called when the mouse moves over the node.
         * @param evt The mouse event.
         * @zh 鼠标在节点上移动时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseMove?(evt: Event): void;
        /**
         * @en Called when the mouse enters the node boundaries.
         * @param evt The mouse event.
         * @zh 鼠标进入节点时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseOver?(evt: Event): void;
        /**
         * @en Called when the mouse leaves the node boundaries.
         * @param evt The mouse event.
         * @zh 鼠标离开节点时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseOut?(evt: Event): void;
        /**
         * @en Called when the mouse is held down and an object is dragged.
         * @param evt The mouse event.
         * @zh 鼠标按住一个物体后，拖拽时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseDrag?(evt: Event): void;
        /**
         * @en Called when the mouse button is released after dragging an object.
         * @param evt The mouse event.
         * @zh 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseDragEnd?(evt: Event): void;
        /**
         * @en Called when the mouse button is clicked (pressed and released) on the node.
         * @param evt The mouse event.
         * @zh 鼠标点击时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseClick?(evt: Event): void;
        /**
         * @en Called when the mouse button is double-clicked on the node.
         * @param evt The mouse event.
         * @zh 鼠标双击时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseDoubleClick?(evt: Event): void;
        /**
         * @en Called when the right mouse button is clicked on the node.
         * @param evt The mouse event.
         * @zh 鼠标右键点击时执行。
         * @param evt 鼠标事件。
         * @blueprintEvent
         */
        onMouseRightClick?(evt: Event): void;
        /**
         * @en Called when a key is pressed down.
         * @param evt The keyboard event.
         * @zh 键盘按下时执行。
         * @param evt 键盘事件。
         * @blueprintEvent
         */
        onKeyDown?(evt: Event): void;
        /**
         * @en Called when a key is pressed and holds long enough to generate a character.
         * @param evt The keyboard event.
         * @zh 键盘产生一个字符时执行。
         * @param evt 键盘事件。
         * @blueprintEvent
         */
        onKeyPress?(evt: Event): void;
        /**
         * @en Called when a key is released.
         * @param evt The keyboard event.
         * @zh 键盘抬起时执行。
         * @param evt 键盘事件。
         * @blueprintEvent
         */
        onKeyUp?(evt: Event): void;
    }
    /**
     * @en Relative layout Component.
     * @zh 相对布局组件
     * @blueprintIgnore
     */
    class Widget extends Component {
        /**
         * @en An static instance of a Widget that has been initialized.
         * @zh 一个已初始化的 Widget 静态实例。
         */
        static EMPTY: Widget;
        private _top;
        private _bottom;
        private _left;
        private _right;
        private _centerX;
        private _centerY;
        readonly owner: Sprite;
        constructor();
        /**
         * @en Resets the boundaries and center coordinates of the object to null.
         * @zh 将对象的边界和中心坐标重置为 null。
         */
        onReset(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onAdded(): void;
        /**
         * 父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
         */
        protected _onParentResize(): void;
        /**
         * @en Resets the object's layout along the X-axis (horizontal direction).
         * @zh 重置对象的水平布局（X轴方向）。
         */
        resetLayoutX(): boolean;
        /**
         * @en Resets the object's layout along the Y-axis (vertical direction).
         * @zh 重置对象的垂直布局（Y轴方向）。
         */
        resetLayoutY(): boolean;
        /**
         * @en Recalculate layout
         * @zh 重新计算布局
         */
        resetLayout(): void;
        /**
         * @en The distance from the top edge, in pixels.
         * @zh 距顶边的距离（以像素为单位）。
         */
        get top(): number;
        set top(value: number);
        /**
         * @en The distance from the bottom edge, in pixels.
         * @zh 距底边的距离（以像素为单位）。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The distance from the left edge, in pixels.
         * @zh 距左边的距离（以像素为单位）。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The distance from the right edge, in pixels.
         * @zh 距右边的距离（以像素为单位）。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance from the horizontal center axis, in pixels.
         * @zh 距水平方向中心轴的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance from the vertical center axis, in pixels.
         * @zh 距垂直方向中心轴的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
    }
    /**
     * @ignore
     * 静态常量集合
     */
    class Const {
        static MAX_CLIP_SIZE: number;
    }
    /**
     * @ignore
     * 节点标志
     */
    class NodeFlags {
        static ACTIVE: number;
        static ACTIVE_INHIERARCHY: number;
        static AWAKED: number;
        static DISPLAY: number;
        static HAS_ZORDER: number;
        static DISPLAYED_INSTAGE: number;
        static CHECK_INPUT: number;
        static DEMAND_TRANS_EVENT: number;
        static HAS_SCRIPT: number;
        static ESCAPE_DRAWING_TO_TEXTURE: number;
        static DISABLE_INNER_CLIPPING: number;
        static DISABLE_OUTER_CLIPPING: number;
        static FORCE_VISIBLE: number;
        static EDITING_NODE: number;
        static HIDE_BY_EDITOR: number;
        static LOCK_BY_EDITOR: number;
        static EDITING_ROOT_NODE: number;
        static FORCE_HIDDEN: number;
        static NOT_IN_PAGE: number;
        static ESCAPE_LAYOUT: number;
    }
    /**
     * @en HideFlags is a class that defines the flags used to control the visibility and saving behavior of objects in the editor.
     * @zh HideFlags 是一个类，用于定义在编辑器中控制对象的可见性和保存行为的标志。
     */
    class HideFlags {
        /**
         * @en The object is hidden in the hierarchy.
         * @zh 对象在层级中隐藏。
         */
        static HideInHierarchy: number;
        /**
         * @en The object is hidden in the inspector.
         * @zh 对象在检查器中隐藏。
         */
        static HideInInspector: number;
        /**
         * @en The object is not saved to the scene or prefab.
         * @zh 对象不会保存到场景或预制件中。
         */
        static DontSave: number;
        /**
         * @en The object is hidden and not saved to the scene or prefab.
         * @zh 对象隐藏且不会保存到场景或预制件中。
         */
        static HideAndDontSave: number;
    }
    /**
     * @en The AnimationClip class is used for animation clip resources.
     * @zh AnimationClip 类用于动画片段资源。
     */
    class AnimationClip extends Resource {
        /**@internal	*/
        static _tempQuaternion0: Quaternion;
        /**
         * @en Parse animation data into animation clip
         * @returns Animation clip
         * @zh 动画数据解析为动画片段
         * @returns 动画片段
         */
        static _parse(data: any): AnimationClip;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.ANIMATIONCLIP)
         * @en Load animation clip.
         * @param url The URL of the animation clip.
         * @param complete Callback function when loading is complete.
         * @zh 加载动画片段。
         * @param url 动画片段地址。
         * @param complete 加载完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**@internal */
        _duration: number;
        /**@internal */
        _frameRate: number;
        /**@internal */
        _nodes: KeyframeNodeList | null;
        /**@internal */
        _nodesDic: any;
        /**@internal */
        _nodesMap: any;
        /** @internal */
        _animationEvents: AnimationEvent[];
        /**
         * @en Whether the animation is looping.
         * @zh 是否循环。
         */
        islooping: boolean;
        /**
         * @en Get the duration of the animation.
         * @returns The duration of the animation.
         * @zh 动画持续时间。
         * @returns 返回动画持续时间。
         */
        duration(): number;
        /**
         * @ignore
         * @en Creates an instance of AnimationClip.
         * @zh 创建一个AnimationClip实例。
         */
        constructor();
        /**
         * @en Whether is Weight mode.
         * @param weightMode The current weight mode.
         * @param nextweightMode The next weight mode.
         * @returns True if this animation segment uses Hermite interpolation.
         * @zh 是否是Weight模式。
         * @param weightMode 当前的权重模式。
         * @param nextweightMode 下一个权重模式。
         * @returns 返回true，表示此段动画插值使用埃尔米特插值。
         */
        private _weightModeHermite;
        /**
         * @internal
         */
        private _hermiteInterpolate;
        /**
         * @internal
         */
        private _hermiteInterpolateVector3;
        /**
         * @internal
         */
        private _hermiteInterpolateQuaternion;
        private _hermiteInterpolateVector4;
        private _hermiteInterpolateVector2;
        private _hermiteCurveSplineWeight;
        private _curveInterpolate;
        /**
         * @internal
         * @en Calculate animation data for the current frame.
         * @param nodes Animation keyframes.
         * @param playCurTime Current playback time.
         * @param realTimeCurrentFrameIndexes Current frame indices of the animation.
         * @param addtive Whether it's in additive mode.
         * @param frontPlay Whether it's playing forward.
         * @param outDatas Calculated animation data.
         * @zh 计算当前帧的动画数据。
         * @param nodes 动画帧。
         * @param playCurTime 现在的播放时间。
         * @param realTimeCurrentFrameIndexes 目前到达了动画的第几帧。
         * @param addtive 是否是addtive模式。
         * @param frontPlay 是否是前向播放。
         * @param outDatas 计算好的动画数据。
         */
        _evaluateClipDatasRealTime(nodes: KeyframeNodeList, playCurTime: number, realTimeCurrentFrameIndexes: Int16Array, addtive: boolean, frontPlay: boolean, outDatas: Array<boolean | number | Vector3 | Quaternion | Vector4 | Vector2 | {
            pos: Vector3;
            rotation: Vector3;
        }>, avatarMask: AvatarMask): void;
        private _evaluateFrameNodeVector3DatasRealTime;
        private _evaluateFrameNodeVector2DatasRealTime;
        private _evaluateFrameNodeVector4DatasRealTime;
        private _evaluateFrameNodeQuaternionDatasRealTime;
        private _binarySearchEventIndex;
        /**
         * @en Add an animation event.
         * @param event The animation event to be added.
         * @zh 添加动画事件。
         * @param event 动画事件。
         */
        addEvent(event: AnimationEvent): void;
        /**
         * @en Dispose the resources.
         * @zh 销毁资源。
         */
        protected _disposeResource(): void;
    }
    /**
     * @internal
     * @en A tool class for parsing AnimationClip data.
     * @zh 解析AnimationClip数据的工具类。
     */
    class AnimationClipParser03 {
        private static _animationClip;
        private static _reader;
        private static _strings;
        private static _BLOCK;
        private static _DATA;
        private static READ_DATA;
        private static READ_BLOCK;
        private static READ_STRINGS;
        /**
         * @internal
         * @en Parse the AnimationClip data from the byte reader.
         * This method reads the AnimationClip data, including blocks and strings, and processes each block according to its type.
         * @param clip The AnimationClip object to be populated with parsed data.
         * @param reader The Byte reader containing the AnimationClip data.
         * @zh 从字节读取器中解析AnimationClip数据。
         * 此方法读取AnimationClip数据，包括块和字符串，并根据每个块的类型进行处理。
         * @param clip 要填充解析数据的 AnimationClip 对象。
         * @param reader 包含AnimationClip数据的字节读取器。
         */
        static parse(clip: AnimationClip, reader: Byte): void;
        /**
         * @internal
         * @en Read and parse animation data from the byte reader.
         * This method reads AnimationClip information, keyframe nodes, and animation events.
         * It populates the AnimationClip object with the parsed data.
         * @zh 从字节读取器中读取并解析动画数据。
         * 此方法读取AnimationClip信息、关键帧节点和动画事件。
         * 它用解析的数据填充 AnimationClip 对象。
         */
        static READ_ANIMATIONS(): void;
    }
    /**
     * @internal
     * @en A tool class for parsing AnimationClip data.
     * @zh 解析AnimationClip数据的工具类。
     */
    class AnimationClipParser04 {
        private static _animationClip;
        private static _reader;
        private static _strings;
        private static _BLOCK;
        private static _DATA;
        private static _version;
        private static READ_DATA;
        private static READ_BLOCK;
        private static READ_STRINGS;
        /**
         * @internal
         * @en Parse AnimationClip data from a byte stream.
         * @param clip The AnimationClip object to be populated with parsed data.
         * @param reader The Byte object containing the animation data to be parsed.
         * @param version The version string of the animation data format.
         * @zh 从字节流中解析AnimationClip数据。
         * @param clip 要填充解析数据的 AnimationClip 对象。
         * @param reader 包含要解析的动画数据的 Byte 对象。
         * @param version 动画数据格式的版本字符串。
         */
        static parse(clip: AnimationClip, reader: Byte, version: string): void;
        static createPathPoints(arr: any[]): PathPoint[];
        /**
         * @internal
         * @en Parse the various components of the AnimationClip from binary data and assemble them into a complete AnimationClip object for subsequent animation playback and processing.
         * @zh 从二进制数据中解析出 AnimationClip 的各个组成部分，并将其组装成一个完整的 AnimationClip 对象，以便后续的动画播放和处理。
         */
        static READ_ANIMATIONS(): void;
    }
    /**
     * @en The AnimationEvent class is used to implement animation events.
     * @zh AnimationEvent 类用于实现动画事件。
     */
    class AnimationEvent {
        /**
         * @en The time at which the event is triggered.
         * @zh 事件触发的时间。
         */
        time: number;
        /**
         * @en The name of the triggered event.
         * @zh 触发的事件名称。
         */
        eventName: string;
        /**
         * @en The parameters of the triggered event.
         * @zh 触发事件的参数。
         */
        params: any[];
        /**
         * @ignore
         */
        constructor();
    }
    interface AnimatorPlayScriptInfo {
        animator: Animator;
        layerindex: number;
        playState: AnimatorState;
    }
    /**
     * @en The AnimatorStateScript class is the base class for animation state scripts. This is an abstract class and cannot be instantiated.
     * @zh AnimatorStateScript 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorStateScript {
        /**
         * @internal
         * 动画播放脚本的相关信息。
         */
        playStateInfo: AnimatorPlayScriptInfo;
        /**
         * @internal
         * @en Set the play script information.
         * @param animator The animator instance.
         * @param layerindex The index of the layer.
         * @param playstate The animator state.
         * @zh 设置播放脚本信息。
         * @param animator 动画器实例。
         * @param layerindex 层索引。
         * @param playstate 动画状态。
         */
        setPlayScriptInfo(animator: Animator, layerindex: number, playstate: AnimatorState): void;
        /**
         * @ignore
         * @en Creates an instance of AnimatorStateScript.
         * @zh 创建 AnimatorStateScript 实例。
         */
        constructor();
        /**
         * @en Executed when the animation state begins.
         * @zh 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * @en Executed when the animation state is running.
         * @param normalizeTime The animation playback state (0-1).
         * @zh 动画状态运行中。
         * @param normalizeTime 0-1动画播放状态。
         */
        onStateUpdate(normalizeTime: number): void;
        /**
          * @en Executed when the animation state exits.
          * @zh 动画状态退出时执行。
          */
        onStateExit(): void;
        /**
         * @en Executed when switching to a new state
         * @zh 切换到新状态时执行
         */
        onStateSwitch(currentState: AnimatorState): void;
        /**
         * @en Executed at the end of each loop if the animation is set to loop.
         * @zh 如果动画设置了循环，则在每次循环结束时执行。
         */
        onStateLoop(): void;
    }
    /**
     * @en The KeyframeNode class is used for animation keyframes.
     * @zh KeyframeNode 类用于动画关键帧。
     */
    class KeyframeNode {
        private _ownerPath;
        private _propertys;
        /**@internal */
        _keyFrames: Keyframe[];
        /**@internal */
        _indexInList: number;
        /**@internal */
        type: KeyFrameValueType;
        /**@internal */
        fullPath: string;
        /**@internal */
        nodePath: string;
        /**@internal */
        propertyOwner: string;
        /**@internal call bake fun*/
        callbackFunData: string;
        /**@internal apply params*/
        callParams: any[];
        /**
         * @internal
         * ide
         */
        propertyChangePath: string;
        /**
         * @en The number of sprite paths.
         * @zh 精灵路径个数。
         */
        get ownerPathCount(): number;
        /**
         * @en The number of property paths.
         * @zh 属性路径个数。
         */
        get propertyCount(): number;
        /**
         * @en The number of keyframes.
         * @zh 帧个数。
         */
        get keyFramesCount(): number;
        /**
         * @internal
         */
        _setOwnerPathCount(value: number): void;
        /**
         * @internal
         */
        _setOwnerPathByIndex(index: number, value: string): void;
        /**
         * @internal
         */
        _joinOwnerPath(sep: string): string;
        /**
         * @internal
         */
        _setPropertyCount(value: number): void;
        /**
         * @internal
         */
        _setPropertyByIndex(index: number, value: string): void;
        /**
         * @internal
         */
        _joinProperty(sep: string): string;
        /**
         * @internal
         */
        _setKeyframeCount(value: number): void;
        /**
         * @internal
         */
        _setKeyframeByIndex(index: number, value: Keyframe): void;
        /**
         * @en Get the sprite path by index.
         * @param index The index of the sprite path.
         * @returns The sprite path at the specified index.
         * @zh 通过索引获取精灵路径。
         * @param index 索引。
         * @returns 指定索引处的精灵路径。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * @en Get the property path by index.
         * @param index The index of the property path.
         * @returns The property path at the specified index.
         * @zh 通过索引获取属性路径。
         * @param index 索引。
         * @returns 指定索引处的属性路径。
         */
        getPropertyByIndex(index: number): string;
        /**
         * @en Get the keyframe by index.
         * @param index The index of the keyframe.
         * @returns The keyframe at the specified index.
         * @zh 通过索引获取帧。
         * @param index 索引。
         * @returns 指定索引处的关键帧。
         */
        getKeyframeByIndex(index: number): Keyframe;
    }
    /**
     * @en The KeyframeNodeList class is used to create a queue of KeyframeNode nodes.
     * @zh KeyframeNodeList 类用于创建 KeyframeNode 节点队列。
     */
    class KeyframeNodeList {
        /** @internal */
        private _nodes;
        /**
         * @en The number of nodes.
         * @zh 节点个数。
         */
        get count(): number;
        set count(value: number);
        /**
         * @ignore
         * @en Creates an instance of KeyframeNodeList.
         * @zh 创建一个KeyframeNodeList实例。
         */
        constructor();
        /**
         * @en Get a node by its index.
         * @param index The index of the node.
         * @returns The KeyframeNode at the specified index.
         * @zh 通过索引获取节点。
         * @param index 索引。
         * @returns 指定索引处的 KeyframeNode 节点。
         */
        getNodeByIndex(index: number): KeyframeNode;
        /**
         * @en Set a node at the specified index.
         * @param index The index at which to set the node.
         * @param node The KeyframeNode to set.
         * @zh 通过索引设置节点。
         * @param index 索引。
         * @param node 要设置的 KeyframeNode 节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode): void;
    }
    type AnimatorParams = {
        [key: number]: number | boolean;
    };
    /**
     * @en The `Animator` class is used to create 3D animation components.
     * @zh `Animator` 类用于创建3D动画组件。
     */
    class Animator extends Component {
        /**
         * @en Culling mode: Always animate.
         * @zh 裁剪模式：始终播放动画。
         */
        static readonly CULLINGMODE_ALWAYSANIMATE: number;
        /**
         * @en Culling mode: Don't animate when not visible.
         * @zh 裁剪模式：不可见时完全不播放动画。
         */
        static readonly CULLINGMODE_CULLCOMPLETELY: number;
        private _speed;
        private _keyframeNodeOwnerMap;
        private _keyframeNodeOwners;
        private _updateMark;
        private _controllerLayers;
        /** 更新模式*/
        private _updateMode;
        /** 降低更新频率调整值*/
        private _lowUpdateDelty;
        private _animatorParams;
        /**@internal	*/
        _avatarNodeMap: any;
        /**@internal */
        _linkAvatarSpritesData: any;
        /**@internal */
        _linkAvatarSprites: Sprite3D[];
        /**
         * @en Culling mode，By default, when set to invisible, the animation will not play at all.
         * @zh 裁剪模式,默认为不可见时完全不播放动画。
         */
        cullingMode: number;
        /**@internal	[NATIVE]*/
        _animationNodeLocalPositions: Float32Array;
        /**@internal	[NATIVE]*/
        _animationNodeLocalRotations: Float32Array;
        /**@internal	[NATIVE]*/
        _animationNodeLocalScales: Float32Array;
        /**@internal	[NATIVE]*/
        _animationNodeWorldMatrixs: Float32Array;
        /**@internal	[NATIVE]*/
        _animationNodeParentIndices: Int16Array;
        private _finishSleep;
        private _LateUpdateEvents;
        /**
         * @internal
         */
        _controller: AnimatorController;
        /**
         * @en The animation controller.
         * @zh 动画控制器。
         */
        get controller(): AnimatorController;
        set controller(val: AnimatorController);
        /**
         * @en The playback speed of the animation. 1.0 is the normal playback speed.
         * @zh 动画的播放速度。1.0 为正常播放速度。
         */
        get speed(): number;
        set speed(value: number);
        /**
         * @en The update mode for the animator.
         * @zh 动画更新模式。
         */
        set updateMode(value: AnimatorUpdateMode);
        /**
         * @en Low update mode
         * @zh 低更新模式
         */
        set lowUpdateDelty(value: number);
        /**
         * @en The number of layers in the state machine animation.
         * @zh 状态机动画层的数量。
         */
        get controllerLayerCount(): number;
        /**
         * @en The map of animator parameters.
         * @zh 状态机参数map。
         */
        get animatorParams(): AnimatorParams;
        set animatorParams(values: AnimatorParams);
        /**
         * @en Whether to stop updating after the animation is completed.
         * @zh 动画完成后是否停止更新。
         */
        get sleep(): boolean;
        set sleep(value: boolean);
        /**
         * @ignore
         * @en The constructor of Animator.
         * @zh 构造方法，创建动画组件。
         */
        constructor();
        private _addKeyframeNodeOwner;
        /**
         * @internal
         */
        _removeKeyframeNodeOwner(nodeOwners: (KeyframeNodeOwner | null)[], node: KeyframeNode): void;
        /**
         * @internal
         */
        _getOwnersByClip(clipStateInfo: AnimatorState): void;
        private _updatePlayer;
        /**
         * 启用过渡
         * @param layerindex
         * @param transition
         * @returns
         */
        private _applyTransition;
        /**
         * @param animatorState
         * @param playState
         */
        private _updateStateFinish;
        /**
         * @internal
         * @param parentState
         * @param currentState
         */
        private _switchState;
        private _updateEventScript;
        private _eventScript;
        /**
         * 更新clip数据
         */
        private _updateClipDatas;
        private _applyFloat;
        private _applyVec2;
        private _applyVec3;
        private _applyVec4;
        private _applyColor;
        private _applyPositionAndRotationEuler;
        private _applyRotation;
        private _applyScale;
        private _applyCrossData;
        /**
         * 赋值Node数据
         * @param stateInfo 动画状态
         * @param additive 是否为addtive
         * @param weight state权重
         * @param isFirstLayer 是否是第一层
         */
        private _setClipDatasToNode;
        private _setCrossClipDatasToNode;
        private _setFixedCrossClipDatasToNode;
        private _revertDefaultKeyframeNodes;
        /** @internal */
        onAfterDeserialize(): void;
        protected _onEnable(): void;
        protected _onDestroy(): void;
        private _applyUpdateMode;
        /**
         * @internal
         */
        _handleSpriteOwnersBySprite(isLink: boolean, path: string[], sprite: Sprite3D): void;
        /**
         * @internal
         * @perfTag PerformanceDefine.T_AnimatorUpdate
         */
        onUpdate(): void;
        /**
         * @internal
         */
        _cloneTo(dest: Animator): void;
        /**
         * @en Gets the default animation state.
         * @param layerIndex The layer index.
         * @returns The default animation state.
         * @zh 获取默认动画状态。
         * @param layerIndex 层索引。
         * @return 默认动画状态。
         */
        getDefaultState(layerIndex?: number): AnimatorState;
        /**
         * @en Adds an animation state.
         * @param state The animation state to add.
         * @param layerIndex The layer index.
         * @zh 添加动画状态。
         * @param state 动画状态。
         * @param   layerIndex 层索引。
         */
        addState(state: AnimatorState, layerIndex?: number): void;
        /**
         * @en Removes an animation state.
         * @param state The animation state to remove.
         * @param layerIndex The layer index.
         * @zh 移除动画状态。
         * @param state 动画状态。
         * @param   layerIndex 层索引。
         */
        removeState(state: AnimatorState, layerIndex?: number): void;
        /**
         * @en Adds a controller layer.
         * @param controllerLayer The animation controller layer to add.
         * @zh 添加控制器层。
         * @param controllerLayer 动画控制层。
         */
        addControllerLayer(controllerLayer: AnimatorControllerLayer): void;
        /**
         * @en Gets the controller layer.
         * @param layerIndex The layer index. Defaults to 0.
         * @returns The AnimatorControllerLayer at the specified index.
         * @zh 获取控制器层。
         * @param layerIndex 层索引。
         * @return 指定索引处的AnimatorControllerLayer。
         */
        getControllerLayer(layerIndex?: number): AnimatorControllerLayer;
        /**
         * @en Plays an animation.
         * @param name If null, plays the default animation; otherwise, plays the animation clip with the specified name.
         * @param layerIndex The layer index. Defaults to 0.
         * @param normalizedTime The normalized start time of the animation. Defaults to Number.NEGATIVE_INFINITY.
         * @zh 播放动画。
         * @param name 如果为null则播放默认动画，否则按名字播放动画片段。
         * @param layerIndex 层索引。
         * @param normalizedTime 归一化的播放起始时间。
         */
        play(name?: string | null, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Performs a crossfade transition between the current animation state and the target animation state.
         * @param name The name of the target animation state.
         * @param transitionDuration The transition duration, normalized to the current animation state's duration. Value should be between 0.0 and 1.0.
         * @param layerIndex The layer index. Defaults to 0.
         * @param normalizedTime The normalized start time of the animation. Defaults to Number.NEGATIVE_INFINITY.
         * @zh 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param name 目标动画状态。
         * @param transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         * @param layerIndex 层索引。
         * @param normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, transitionDuration: number, layerIndex?: number, normalizedTime?: number): void;
        /**
         * @en Enables a trigger parameter.
         * @param name The name or index of the trigger parameter.
         * @zh 启用触发条件参数。
         * @param name 触发条件的名字或者索引
         */
        setParamsTrigger(name: number): void;
        setParamsTrigger(name: string): void;
        /**
         * @en Sets the value of a number parameter.
         * @param name The name or index of the parameter.
         * @param value The value to set.
         * @zh 设置数值类型参数的值。
         * @param name 属性的名字或者索引
         * @param value 属性值
         */
        setParamsNumber(name: number, value: number): void;
        setParamsNumber(name: string, value: number): void;
        /**
         * @en Sets the value of a boolean parameter.
         * @param name The name or index of the parameter.
         * @param value The value to set.
         * @zh 设置布尔类型参数的值。
         * @param name 属性的名字或者索引
         * @param value 属性值
         */
        setParamsBool(name: number, value: boolean): void;
        setParamsBool(name: string, value: boolean): void;
        /**
         * @en Gets the value of a parameter.
         * @param name The name or index of the parameter.
         * @returns The value of the parameter.
         * @zh 获取参数的值。
         * @param name 属性的名字或者索引
         * @return 属性值
         */
        getParamsvalue(name: number): number | boolean;
        getParamsvalue(name: string): number | boolean;
        /**
         * @deprecated 请使用animator.getControllerLayer(layerIndex).getCurrentPlayState()替换。use animator.getControllerLayer(layerIndex).getCurrentPlayState() instead
         * 获取当前的播放状态。
         * @param   layerIndex 层索引。
         * @return  动画播放状态。
         */
        getCurrentAnimatorPlayState(layerIndex?: number): AnimatorPlayState;
    }
    /**
     * @en Represents an animator controller resource that manages animation states and transitions.
     * @zh 管理动画状态和转换的动画控制器资源。
     */
    class AnimatorController extends Resource {
        /**
         * @en The parsed data of the animator controller.
         * @zh 解析后的动画控制器数据。
         */
        data: TypeAnimatorControllerData;
        /**
         * @en An array of clip IDs associated with this animator controller.
         * @zh 与此动画控制器关联的剪辑ID数组。
         */
        clipsID: string[];
        /**
         * @en The constructor of AnimatorController, initialize a new AnimatorController object.
         * @param data The animator controller data.
         * @zh 构造函数，初始化一个新的 AnimatorController 对象。
         * @param data 动画控制器数据。
         */
        constructor(data: any);
        private getLayers;
        /**
         * @en Updates the given Animator with the current AnimatorController's data.
         * This method updates the controller layers and animator parameters.
         * @param a The Animator to update.
         * @zh 使用当前AnimatorController的数据更新给定的Animator。
         * 此方法更新控制器层和动画参数。
         * @param a 要更新的Animator。
         */
        updateTo(a: Animator): void;
        private createState;
        private setExitTransition;
        private setTransitions;
        private getState;
        private addConditions;
    }
    /**
     * @en The `AnimatorControllerLayer` class is used to create animation controller layers.
     * @zh `AnimatorControllerLayer` 类用于创建动画控制器层。
     */
    class AnimatorControllerLayer implements IClone {
        /**
         * @en Blending mode: Override.
         * @zh 混合模式：覆盖。
         */
        static readonly BLENDINGMODE_OVERRIDE: number;
        /**
         * @en Blending mode: Additive.
         * @zh 混合模式：叠加。
         */
        static readonly BLENDINGMODE_ADDTIVE: number;
        /**@internal */
        private _defaultState;
        /**@internal */
        private _referenceCount;
        /**
         * @internal
         * @en Play type of the layer. 0: Normal play, 1: Dynamic blend play, 2: Fixed blend play
         * @zh 层的播放类型。0：常规播放、1：动态融合播放、2：固定融合播放
         */
        _playType: number;
        /**@internal */
        _crossDuration: number;
        /**@internal */
        _crossPlayState: AnimatorState;
        /**@internal */
        _crossMark: number;
        /**@internal */
        _crossNodesOwnersCount: number;
        /**@internal */
        _crossNodesOwners: KeyframeNodeOwner[];
        /**@internal */
        _crossNodesOwnersIndicesMap: any;
        /**@internal */
        _srcCrossClipNodeIndices: number[];
        /**@internal */
        _destCrossClipNodeIndices: number[];
        /**@internal */
        _animator: Animator;
        /**@internal */
        _states: AnimatorState[];
        /**@internal */
        _playStateInfo: AnimatorPlayState | null;
        /**@internal */
        _crossPlayStateInfo: AnimatorPlayState | null;
        /**@internal */
        _avatarMask: AvatarMask;
        /**
         * @en The name of the layer.
         * @zh 层的名称。
         */
        name: string;
        /**
         * @en The blending mode of the layer.
         * @zh 层的混合模式。
         */
        blendingMode: number;
        /**
         * @en The default weight of the layer.
         * @zh 层的默认权重。
         */
        defaultWeight: number;
        /**
         * @en Whether to automatically play when activated.
         * @zh 激活时是否自动播放。
         */
        playOnWake: boolean;
        /**
         * @en Whether the layer is enabled.
         * @zh 层是否启用。
         */
        enable: boolean;
        /**
         * @en Default animation state machine.
         * @zh 默认动画状态机。
         */
        get defaultState(): AnimatorState;
        set defaultState(value: AnimatorState);
        /**
         * @en The avatar mask of the layer.
         * @zh 层的骨骼遮罩。
         */
        get avatarMask(): AvatarMask;
        set avatarMask(value: AvatarMask);
        /**
         * @internal
         * @en The name of the default animation state machine for this layer.
         * @zh 此层的默认动画状态机的名称。
         */
        get defaultStateName(): string;
        private _defaultStateNameCatch;
        set defaultStateName(value: string);
        /**
         * @en The AnimatorStates in this layer.
         * @zh 此层中动画状态
         */
        get states(): ReadonlyArray<AnimatorState>;
        set states(states: ReadonlyArray<AnimatorState>);
        /**
         * @en Constructor method.
         * @param name 动画层名称
         * @zh 构造方法
         * @param name 动画层名称
         */
        constructor(name: string);
        /**
         * @internal
         */
        private _removeClip;
        /**
         * @internal
         */
        _getReferenceCount(): number;
        /**
         * @internal
         */
        _addReference(count?: number): void;
        /**
         * @internal
         */
        _removeReference(count?: number): void;
        /**
         * @internal
         */
        _clearReference(): void;
        /**
         * @en Gets the current play state of the animation.
         * @returns The current AnimatorPlayState.
         * @zh 获取当前的动画播放状态。
         * @return 动画播放状态。
         */
        getCurrentPlayState(): AnimatorPlayState;
        /**
         * @en Gets an animator state by its name.
         * @param name The name of the animator state to find.
         * @returns The AnimatorState if found, or null if not found.
         * @zh 通过名称获取动画状态。
         * @param name 要查找的动画状态的名称。
         * @returns 如果找到则返回AnimatorState，否则返回null。
         */
        getAnimatorState(name: string): AnimatorState | null;
        /**
         * @en Adds an animation state to the layer.
         * @param state The AnimatorState to add.
         * @zh 向层中添加动画状态。
         * @param state 要添加的AnimatorState。
         */
        addState(state: AnimatorState): void;
        /**
         * @en Removes an animation state from the layer.
         * @param state The AnimatorState to remove.
         * @zh 从层中移除动画状态。
         * @param state 要移除的动画状态。
         */
        removeState(state: AnimatorState): void;
        /**
         * @en Destroys the AnimatorControllerLayer and clears all references.
         * @zh 销毁AnimatorControllerLayer并清除所有引用。
         */
        destroy(): void;
        /**
         * @en Clones the properties of this AnimatorControllerLayer to another object.
         * @param destObject The target object to clone to.
         * @zh 将此AnimatorControllerLayer的属性克隆到另一个对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: AnimatorControllerLayer): void;
        /**
         * @en Creates and returns a clone of this AnimatorControllerLayer.
         * @returns A new AnimatorControllerLayer instance with properties copied from this one.
         * @zh 创建并返回此AnimatorControllerLayer的克隆副本。
         * @returns 一个新的AnimatorControllerLayer实例，其属性从当前实例复制。
         */
        clone(): AnimatorControllerLayer;
    }
    /**
     * @en The AnimatorPlayState class is used to create animation play state information.
     * @zh AnimatorPlayState 类用于创建动画播放状态信息。
     */
    class AnimatorPlayState {
        /**@internal */
        _finish: boolean;
        /**@internal */
        _startPlayTime: number;
        /**@internal */
        _lastElapsedTime: number;
        /**@internal 动画播放时间*/
        _elapsedTime: number;
        /**@internal 播放状态的归一化时间,整数为循环次数，小数为单次播放时间。*/
        _normalizedTime: number;
        /**@internal 单词播放归一化时间 */
        _normalizedPlayTime: number;
        /**@internal */
        _duration: number;
        /**@internal 上次播放的时间，event事件使用*/
        _parentPlayTime: number;
        /**@internal */
        _playEventIndex: number;
        /**@internal */
        _lastIsFront: boolean;
        /**@internal */
        private _currentState;
        /**
         * @en The current AnimatorState.
         * @zh 当前的动画状态。
         */
        get currentState(): AnimatorState | null;
        set currentState(value: AnimatorState | null);
        /**
         * @en The normalized time of the play state. The integer part represents the number of loops, and the fractional part represents the time of a single play.
         * @returns The normalized time of the animation.
         * @zh 播放状态的归一化时间。整数部分表示循环次数，小数部分表示单次播放时间。
         * @returns 动画的归一化时间。
         */
        get normalizedTime(): number;
        /**
         * @en The duration of the current animation in seconds.
         * @zh 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * @en The current animator state.
         * @zh 当前的动画状态机。
         */
        get animatorState(): AnimatorState;
        /**
         * @en constructor
         * @zh 构造函数
         */
        constructor();
        /**
         * @internal
         */
        _resetPlayState(startTime: number, clipDuration: number): void;
        /**
         * @internal
         */
        _cloneTo(dest: AnimatorPlayState): void;
    }
    /**
     * @en Animator resource class for handling animation-related resources.
     * @zh 动画资源类，用于处理与动画相关的资源。
     */
    class AnimatorResource {
        /**
         * @en Get the animator resource component from a Sprite3D object.
         * @param sprite The Sprite3D object to get the component from.
         * @param propertyKey The key of the property to get the component for.
         * @zh 从Sprite3D对象获取动画资源组件。
         * @param sprite 要获取组件的Sprite3D对象。
         * @param propertyKey 要获取组件的属性键。
         */
        static getAnimatorResource(sprite: Sprite3D, propertyKey: string): Component;
    }
    /**
     * @en The AnimatorState class is used to create animation states.
     * @zh AnimatorState 类用于创建动画状态。
     */
    class AnimatorState extends EventDispatcher implements IClone {
        /**
         * @en Animation event called when the state is entered.
         * @zh 动画事件，在进入状态时调用。
         * @blueprintIgnore
         */
        static readonly EVENT_OnStateEnter = "OnStartEnter";
        /**
         * @en Animation event called when the state is updated.
         * @zh 动画事件，在更新状态时调用。
         * @blueprintIgnore
         */
        static readonly EVENT_OnStateUpdate = "OnStateUpdate";
        /**
         * @en Animation event called when a loop is completed.
         * @zh 动画事件，在循环完成时调用。
         * @blueprintIgnore
         */
        static readonly EVENT_OnStateLoop = "OnStateLoop";
        /**
         * @en Animation event called when the state is exited.
         * @zh 动画事件，在离开状态时调用。
         * @blueprintIgnore
         */
        static readonly EVENT_OnStateExit = "OnStateExit";
        /**
         * @en Event triggered when switching to a new state
         * @zh 切换到新状态时触发的事件
         * @blueprintIgnore
         */
        static readonly EVENT_OnStateSwitch = "OnStateSwitch";
        /** @internal */
        private _referenceCount;
        /** @internal */
        _clip: AnimationClip | null;
        /** @internal */
        _nodeOwners: KeyframeNodeOwner[];
        /** @internal */
        _currentFrameIndices: Int16Array | null;
        /**
         * @internal
         * @en Whether to loop playback. 0 uses _clip.islooping, 1 for loop, 2 for no loop.
         * @zh 是否循环播放。0表示使用_clip.islooping，1表示循环，2表示不循环。
         */
        _isLooping: 0 | 1 | 2;
        /**
         * @internal
         * @en Realtime data array to avoid data confusion. Must store realtime data in animatorState, not in animationClip.
         * This is necessary for operations like crossFade() with different animatorStates but the same clip source.
         * @zh 实时数据数组，用于避免数据混淆。必须将实时数据存储在animatorState中，而不是animationClip中。
         * 这对于像crossFade()这样的操作是必要的，因为可能使用不同的animatorState但相同的片段源。
         */
        _realtimeDatas: Array<number | Vector3 | Quaternion>;
        /** @internal */
        _scripts: AnimatorStateScript[] | null;
        /**
         * @internal
         * @en List of transitions.
         * @zh 过渡列表。
         */
        _transitions: AnimatorTransition[];
        /**
         * @internal
         * @en List of solo transitions that only play this transition.
         * @zh 优先过渡列表，只播放此过渡。
         */
        _soloTransitions: AnimatorTransition[];
        /**
         * @en Current transition content.
         * @zh 当前过渡内容。
         */
        curTransition: AnimatorTransition;
        /**
         * @en Name of the animator state.
         * @zh 动画状态的名称。
         */
        name: string;
        /**
         * @en Animation playback speed. 1.0 is normal playback speed.
         * @zh 动画播放速度。1.0为正常播放速度。
         */
        speed: number;
        /**
         * @en Start time of animation playback.
         * @zh 动画播放的起始时间。
         */
        clipStart: number;
        /**
         * @en End time of animation playback.
         * @zh 动画播放的结束时间。
         */
        clipEnd: number;
        /**
         * @en Play on awake start offset.
         * @zh 唤醒时播放的起始偏移量。
         */
        cycleOffset: number;
        /**
         * @en The animation clip.
         * @zh 动画片段。
         */
        get clip(): AnimationClip | null;
        set clip(value: AnimationClip | null);
        /**
         * @en Whether the animation is looping.
         * @zh 动画是否循环播放。
         */
        get islooping(): boolean;
        /**
         * @en The animation transition content (used by IDE).
         * @zh 动画过渡内容（IDE使用）。
         */
        get transitions(): AnimatorTransition[];
        set transitions(value: AnimatorTransition[]);
        /**
         * @en The priority animation transition content (used by IDE).
         * @zh 优先动画过渡内容（IDE使用）。
         */
        get soloTransitions(): AnimatorTransition[];
        set soloTransitions(value: AnimatorTransition[]);
        /**
         * @en consrtuctor of AnimatorState
         * @zh 动画状态的构造方法
         */
        constructor();
        /**
         * @internal
         */
        _eventStart(animator: Animator, layerIndex: number): void;
        /**
         * @internal
         */
        _eventExit(): void;
        /**
         * @internal
         * @param currentState
         */
        _eventSwitch(currentState: AnimatorState): void;
        /**
         * @internal
         */
        _eventStateUpdate(value: number): void;
        /**
         * @internal
         */
        _eventLoop(): void;
        /**
         * @internal
         * @en Dispatch transition events.
         * @param normalizeTime Normalized time of the animation.
         * @param paramsMap Map of animator parameters.
         * @returns The triggered transition, or null if no transition is triggered.
         * @zh 派发过渡事件。
         * @param normalizeTime 动画的归一化时间。
         * @param paramsMap 动画参数映射。
         * @returns 触发的过渡，如果没有触发过渡则返回null。
         */
        _eventtransition(normalizeTime: number, paramsMap: AnimatorParams): AnimatorTransition;
        /**
         * @internal
         */
        _getReferenceCount(): number;
        /**
         * @internal
         * @param count
         */
        _addReference(count?: number): void;
        /**
         * @internal
         * @param count
         */
        _removeReference(count?: number): void;
        /**
         * @internal
         */
        _clearReference(): void;
        /**
         * @internal
         */
        _resetFrameIndices(): void;
        /**
         * @en Add a script to the animator state.
         * @param type The type of the script to add.
         * @returns The added script instance.
         * @zh 向动画状态添加脚本。
         * @param type 要添加的脚本类型。
         * @returns 添加的脚本实例。
         */
        addScript(type: typeof AnimatorStateScript): AnimatorStateScript;
        /**
         * @en Get a script of the specified type from the animator state.
         * @param type The type of the script to get.
         * @returns The script of the specified type, or null if not found.
         * @zh 从动画状态获取指定类型的脚本。
         * @param type 要获取的脚本类型。
         * @returns 指定类型的脚本，如果未找到则返回null。
         */
        getScript(type: typeof AnimatorStateScript): AnimatorStateScript | null;
        /**
         * @en Get all scripts of the specified type from the animator state.
         * @param type The type of the scripts to get.
         * @returns An array of scripts of the specified type, or null if none found.
         * @zh 从动画状态获取所有指定类型的脚本。
         * @param type 要获取的脚本类型。
         * @returns 指定类型的脚本数组，如果未找到则返回null。
         */
        getScripts(type: typeof AnimatorStateScript): AnimatorStateScript[] | null;
        /**
         * @en Clone the current AnimatorState to another object.
         * @param destObject The target object to clone to.
         * @zh 将当前AnimatorState克隆到另一个对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: AnimatorState): void;
        /**
         * @en Create a clone of the current AnimatorState.
         * @returns A new AnimatorState object with the same properties as the current one.
         * @zh 创建当前AnimatorState的克隆。
         * @returns 一个新的AnimatorState对象，具有与当前对象相同的属性。
         */
        clone(): AnimatorState;
        /** @internal @blueprintEvent */
        Animator_bpEvent: {
            [AnimatorState.EVENT_OnStateEnter]: () => void;
            [AnimatorState.EVENT_OnStateUpdate]: () => void;
            [AnimatorState.EVENT_OnStateLoop]: (state: AnimatorState) => void;
            [AnimatorState.EVENT_OnStateExit]: () => void;
        };
    }
    /**
     * @en The AnimatorTransition class represents a transition between two AnimatorStates.
     * @zh AnimatorTransition 类表示两个 AnimatorState 之间的过渡。
     */
    class AnimatorTransition {
        /**
         * @internal
         */
        private _name;
        /**
         * @internal
         */
        private _mute;
        /**
         * @internal
         */
        private _exitTime;
        /**
         * @internal
         */
        private _exitByTime;
        /**
         * @internal
         */
        private _transstartoffset;
        /**
         * @internal
         */
        private _transduration;
        /**
         * @internal
         */
        private _conditions;
        /**
         * @internal
         */
        private _destState;
        /**
         *  @internal
         */
        private _isAndOperEnabled;
        /**
         * 创建一个新的Animatortransition
         */
        constructor();
        /**
         * @en The name of the transition.
         * @zh 过渡的名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en Whether the transition is disabled.
         * @zh 过渡是否被禁用。
         */
        get mute(): boolean;
        set mute(value: boolean);
        /**
         * @en The destination state of the transition.
         * @zh 过渡的目标状态。
         */
        get destState(): AnimatorState;
        set destState(value: AnimatorState);
        /**
         * @en The conditions array for the transition. Used by IDE.
         * @zh 过渡的条件数组。由IDE使用。
         */
        get conditions(): AnimatorStateCondition[];
        set conditions(value: AnimatorStateCondition[]);
        /**
         * @en Whether the transition is triggered by time.
         * @zh 过渡是否由时间触发。
         */
        get exitByTime(): boolean;
        set exitByTime(value: boolean);
        /**
         * @en The normalized transition duration (relative to the target state).
         * @zh 过渡的归一化持续时间（相对于目标状态）。
         */
        set transduration(value: number);
        get transduration(): number;
        /**
         * @en The playback time offset of the target state (normalized time).
         * @zh 目标状态的播放时间偏移（归一化时间）。
         */
        set transstartoffset(value: number);
        get transstartoffset(): number;
        /**
         * @en The trigger time (normalized time).
         * @zh 触发时间（归一化时间）。
         */
        get exitTime(): number;
        set exitTime(value: number);
        /**
         * @en Adds a condition to the transition.
         * @zh 增加一个条件到过渡中。
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Removes a condition from the transition.
         * @param condition The condition to remove.
         * @zh 从过渡中删除一个条件。
         * @param condition 要删除的条件。
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
         * @en Whether to use AND operation when there are multiple conditions.
         * @zh 当有多个条件时是否使用与（AND）操作。
         */
        get isAndOperEnabled(): boolean;
        set isAndOperEnabled(vlaue: boolean);
        /**
         * @en Checks if the transition should be enabled based on the current conditions and time.
         * @param normalizeTime The normalized time of the current animation state.
         * @param paramsMap A map of condition parameters, where the key is the condition ID and the value is the condition state.
         * @returns True if the transition should be enabled, false otherwise.
         * @zh 检查是否应该根据当前条件和时间启用过渡。
         * @param normalizeTime 当前动画状态的归一化时间。
         * @param paramsMap 条件参数的映射，其中键是条件ID，值是条件状态。
         * @returns 如果应该启用过渡则返回true，否则返回false。
         */
        check(normalizeTime: number, paramsMap: {
            [key: number]: number | boolean;
        }): boolean;
    }
    /**
     * @en Describes the animation layer mask.
     * @zh 用来描述动画层遮罩。
     */
    class AvatarMask {
        /**@internal */
        private _avatarPathMap;
        /**
         * @en Constructor, initialize mask information.
         * @param data Mask information.
         * @zh 构造函数,初使化遮罩信息。
         * @param data 遮罩信息
         */
        constructor(data?: any);
        /**
         * @en Checks if the transform at the given path is active in the mask.
         * @param path The node path.
         * @returns Whether the transform is active.
         * @zh 查找节点路径遮罩。
         * @param path 节点路径
         * @returns 节点路径是否启用
         */
        getTransformActive(path: string): boolean;
        /**
         * @en Sets the mask for a specific transform path.
         * @param path The node path.
         * @param value Whether to enable the mask.
         * @zh 设置遮罩。
         * @param path 节点路径
         * @param value 是否启用遮罩
         */
        setTransformActive(path: string, value: boolean): void;
        /**
         * @en Gets all mask information.
         * @returns The mask information.
         * @zh 获得遮罩信息。
         * @returns 遮罩信息
         */
        getAllTranfromPath(): Record<string, boolean>;
        /**
         * @en Clones the AvatarMask.
         * @returns A clone of the AvatarMask.
         * @zh 克隆。
         * @returns 克隆的AvatarMask。
         */
        clone(): AvatarMask;
        /**
         * @en Clones the AvatarMask to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 目标对象
         */
        cloneTo(destObject: AvatarMask): void;
    }
    enum KeyFrameValueType {
        None = -1,
        Float = 0,
        Position = 1,
        Rotation = 2,
        Scale = 3,
        RotationEuler = 4,
        Vector2 = 5,
        Vector3 = 6,
        Vector4 = 7,
        Color = 8,
        Boolean = 9,
        PathPoint = 10
    }
    /**
     * @internal
     * @en The KeyframeNodeOwner class is used to store the owner information of frame nodes.
     * @zh KeyframeNodeOwner 类用于保存帧节点的拥有者信息。
     */
    class KeyframeNodeOwner {
        /**
         * @internal
         * @en Index in the list
         * @zh 列表中的索引
         */
        indexInList: number;
        /**
         * @internal
         * @en Reference count
         * @zh 引用计数
         */
        referenceCount: number;
        /**
         * @internal
         * @en Update mark
         * @zh 更新标记
         */
        updateMark: number;
        /**
         * @internal
         * @en 0 float, 1 position, 2 rotation, 3 Scale, 4 rotationEuler
         * @zh 0 浮点数, 1 位置, 2 旋转, 3 缩放, 4 欧拉角旋转
         */
        type: KeyFrameValueType;
        /**
         * @internal
         * @en Full path of the node
         * @zh 节点的完整路径
         */
        fullPath: string | null;
        nodePath: string | null;
        /**
         * @internal
         * @en Owner of the property
         * @zh 属性的所有者
         */
        propertyOwner: any;
        /**
         * @internal
         * @en Property array
         * @zh 属性数组
         */
        property: string[] | null;
        /**
         * @internal
         * @en Default value of the property
         * @zh 属性的默认值
         */
        defaultValue: any;
        /**
         * @internal
         * @en Current value of the property
         * @zh 属性的当前值
         */
        value: any;
        /**
         * @internal
         * @en Fixed value for cross-fading
         * @zh 用于交叉淡入淡出的固定值
         */
        crossFixedValue: any;
        /**
         * @internal
         * @en Whether the property belongs to a material
         * @zh 属性是否属于材质
         */
        isMaterial: boolean;
        /**
         * @internal
         * @en Callback path
         * @zh 回调路径
         */
        callbackFunData: string;
        /**
         * @internal
         * @en Callback owner
         * @zh 回调归属
         */
        callBackOwner: any;
        /**@internal */
        callbackFun: string;
        /**@internal */
        callParams: any[];
        /**
         * @en constructor of KeyframeNodeOwner
         * @zh 构造函数
         */
        constructor();
        /**
         * @internal
         */
        saveCrossFixedValue(): void;
        /**
         * @internal
         */
        animatorDataSetCallBack(): void;
        /**
         * @internal
         */
        getCallbackNode(): void;
    }
    /**
     * @en HLOD (Hierarchical Level of Detail) component for optimizing rendering performance.
     * @zh HLOD（分层细节层次）组件，用于优化渲染性能。
     * @blueprintIgnore
     */
    class HLOD extends Component {
        /**@internal */
        _resourceList: HLODResourceGroup[];
        /**@internal */
        _curLODSource: HLODResourceGroup;
        /**@internal 包围盒*/
        _bounds: Bounds;
        /**@internal */
        _curRender: HLODRender[];
        /**@internal TODO*/
        /**@internal TODO*/
        /**@internal TODO*/
        /**@internal */
        _HLODConfig: HLODConfig;
        /**@internal */
        private _lodRateArray;
        /**@internal */
        private _size;
        readonly owner: Sprite3D;
        constructor();
        /**
         * @en The bounds of the HLOD.
         * @zh HLOD 的边界。
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * @en The LOD resources for the HLOD.
         * @zh HLOD 的 LOD 资源。
         */
        get lodResource(): HLODResourceGroup[];
        set lodResource(value: HLODResourceGroup[]);
        /**
         * @en The LOD culling rate array. The array will be sorted in descending order.
         * @zh LOD 裁剪率数组。数组将按降序排列。
         */
        get lodCullRateArray(): number[];
        set lodCullRateArray(value: number[]);
        private _applyLODResource;
        private _releaseGroupRender;
        /**
         * @internal
         * @en Recalculates the bounding box.
         * @zh 重新计算包围盒。
         */
        recalculateBounds(): void;
        /**
         * @internal
         * @en Updates before rendering.
         * @zh 渲染之前的更新。
         */
        onPreRender(): void;
        /**
         * @ignore
         * @en Executed every frame during the update phase.
         * @zh 每帧更新时执行。
         */
        onUpdate(): void;
        /**
         * @en Applies the specified HLOD resource.
         * @param resource The HLOD resource group to apply.
         * @zh 应用指定的 HLOD 资源。
         * @param resource 要应用的 HLOD 资源组。
         */
        applyResource(resource: HLODResourceGroup): void;
    }
    /**
     * @en a batched mesh for hierarchical level of detail (HLOD) in 3D rendering. This class optimizes rendering performance by combining multiple sub-meshes into a single rendering unit, reducing draw calls.
     * @zh 用于层次化细节级别（HLOD）的批处理网格。该类通过合并多个子网格为单一的渲染单元来优化渲染性能，减少绘制调用。
     */
    class HLODBatchMesh extends GeometryElement {
        /**@internal batchMesh */
        private _mesh;
        /**@internal */
        private _batchSubMeshInfos;
        /**@internal */
        private _drawSubMeshs;
        /**
         * @en construct method of HLODBatchMesh.
         * @zh HLODBatchMesh的构造方法。
         */
        constructor();
        /**
         * @en The batched mesh.
         * @zh 合批后的网格。
         */
        get batchMesh(): Mesh;
        set batchMesh(mesh: Mesh);
        /**
         * @en The batch sub-mesh information.
         * @zh 合批子网格信息。
         */
        get batchSubMeshInfo(): HLODBatchSubMesh[];
        set batchSubMeshInfo(value: HLODBatchSubMesh[]);
        /**
         * @internal
         * @en The draw sub-meshes.
         * @zh 绘制的子网格。
         */
        get drawSubMeshs(): HLODBatchSubMesh[];
        set drawSubMeshs(value: HLODBatchSubMesh[]);
        /**
         * @internal
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @internal
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Destroy the HLODBatchMesh.
         * @zh 销毁 HLODBatchMesh。
         */
        destroy(): void;
    }
    /**
     * @en Handles the rendering of a hierarchical level of detail (HLOD) element. This class is responsible for managing LODs for objects to achieve better performance by rendering simpler meshes when objects are further from the camera.
     * @zh HLOD渲染处理类，负责管理场景中对象的层级细节层次（HLOD），以提高渲染性能。通过在相机较远时渲染更简单的网格来实现。
     */
    class HLODRender extends BaseRender {
        /**@internal */
        _singleton: boolean;
        /**@internal */
        _curHLODRS: HLODElement;
        /**@internal */
        _curSubBatchMeshBounds: Bounds[];
        /** @ignore */
        constructor();
        /**
         * @en The current HLOD rendering state.
         * @zh 当前的 HLOD 渲染状态。
         */
        get curHLODRS(): HLODElement;
        set curHLODRS(value: HLODElement);
        /**
         * @en Set the geometry and material of the RenderElement based on the given HLODElement resource.
         * @param source The HLODElement containing mesh and material information.
         * @param out The RenderElement to be set.
         * @zh 根据给定的 HLOD 资源设置渲染节点的几何体和材质。
         * @param source 包含网格和材料信息的 HLODElement。
         * @param out 要设置的 RenderElement。
         */
        private _createRenderelementByHLODElement;
        /**
         * @en Change the current rendering mesh to a new LOD mesh.
         * @param lodMesh The new LOD mesh for rendering.
         * @zh 将当前渲染网格更改为新的 LOD 网格。
         * @param lodMesh 新的 LOD 网格，用于渲染。
         */
        private _changeMesh;
        /**
         * @internal
         * @en Apply the lightmap parameters of the current HLOD element to the shader.
         * @zh 将当前 HLOD 元素的光照图参数应用到着色器上。
         */
        _applyLightMapParams(): void;
        /**
         * @en re caculate BoundBox
         * @zh 重新计算包围盒
         */
        _calculateBoundingBox(): void;
        /**
         * @en Update rendering data.
         * @zh 更新渲染数据。
         */
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @en Determine if the object needs to be rendered based on its visibility within the bounding frustum.
         * @param boundFrustum The bounding frustum used for culling.
         * @param context The rendering context.
         * @returns True if the object needs to be rendered, false otherwise.
         * @zh 根据对象在边界视锥体内的可见性确定是否需要渲染该对象。
         * @param boundFrustum 用于裁剪的边界视锥体。
         * @param context 渲染上下文。
         * @returns 如果对象需要被渲染则返回 true，否则返回 false。
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         * @ignore
         * @en Called when the component is being destroyed.
         * @zh 当组件被销毁时调用。
         */
        onDestroy(): void;
    }
    /**
     * @en Configuration for Hierarchical Level of Detail (HLOD) settings.
     * @zh 分层细节层次(HLOD)的配置设置。
     */
    class HLODConfig {
        releaseCallTime: number;
        releaseTime: number;
    }
    /**
     * @en Represents a sub-mesh within an HLOD batch resource, describing geometric bounds and render parameters.
     * @zh 在 HLOD 批处理资源中表示一个子网格，包括几何边界和渲染参数。
     */
    class HLODBatchSubMesh {
        bounds: Bounds;
        drawPramas: Vector2;
    }
    /**
     * @en An element representing a set of HLOD renderable resources.
     * @zh 表示一组 HLOD 可渲染资源的元素。
     */
    class HLODElement {
        /**
         * @en The batch mesh for this HLOD element.
         * @zh 此 HLOD 元素的批处理网格。
         */
        HLODMesh: HLODBatchMesh;
        /**material */
        private _material;
        /**
         * @en The material for this HLOD element.
         * @zh 此 HLOD 元素的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**lightmap */
        private _lightmap;
        /**
         * @en The lightmap for this HLOD element.
         * @zh 此 HLOD 元素的光照贴图。
         */
        get lightmap(): Lightmap;
        set lightmap(value: Lightmap);
        /**
         * @en Release resources associated with this HLOD element.
         * Lightmap is directly destroyed.
         * @zh 释放与此 HLOD 元素关联的资源。
         * 光照贴图会被直接销毁。
         */
        release(): void;
    }
    /**
     * @en A resource group for managing the lifecycle of HLOD resources, handling their load and release state.
     * @zh 用于管理 HLOD 资源生命周期的资源组，处理其加载和释放状态。
     */
    class HLODResourceGroup {
        /**
         * @en The URL of the HLOD resource.
         * @zh HLOD 资源的 URL。
         */
        url: string;
        /**
         * @en Update marker for the resource group.
         * @zh 资源组的更新标记。
         */
        updateMark: number;
        /**
         * @en Array of HLOD elements in this resource group.
         * @zh 此资源组中的 HLOD 元素数组。
         */
        resources: HLODElement[];
        /**
         * @en Indicates whether the resource group is loaded.
         * @zh 资源组是否已加载。
         */
        loaded: boolean;
        /**
         * @en Load the HLOD resource group.
         * @param callFun The callback function to be called after loading.
         * @param hlod The HLOD instance.
         * @zh 加载 HLOD 资源组。
         * @param callFun 加载完成后要调用的回调函数。
         * @param hlod HLOD 实例。
         */
        load(callFun: Function, hlod: any): void;
        /**
         * @en Releases all the resources of the HLOD group, marking the group as unloaded.
         * @zh 释放 HLOD 组的所有资源，并标记组为未加载。
         */
        release(): void;
    }
    /**
     * @en The `LODInfo` class describes Level of Detail (LOD) data.
     * @zh `LODInfo` 类描述了细节层次（LOD）数据。
     */
    class LODInfo {
        /**@internal */
        _mincullRate: number;
        /**@internal */
        _renders: BaseRender[];
        /**@internal */
        _cachSprite3D: Sprite3D[];
        /**@internal */
        _lodIndex: number;
        /**@internal */
        private _group;
        /**
         * @en Constructor method of LODInfo.
         * @zh 细节层次数据的构造方法
         */
        constructor(mincullRate: number);
        /**
         * @en Minimum culling ratio for LOD.
         * @zh LOD的最小剔除率。
         */
        get mincullRate(): number;
        set mincullRate(value: number);
        /**
         * @internal
         * @en Sets the LOD group
         * @zh 设置LOD组。
         */
        set group(value: LODGroup);
        /**
         * @en The node information for the LODInfo.
         * @zh LODInfo的节点信息。
         */
        get renders(): Sprite3D[];
        set renders(value: Sprite3D[]);
        /**
         * @en Adds a rendering node to the LODInfo.
         * @param node The Sprite3D node to be added as a rendering node.
         * @zh 在LODInfo中增加渲染节点。
         * @param node 要作为渲染节点添加的Sprite3D节点。
         */
        addNode(node: Sprite3D): void;
        /**
         * @en Removes a LOD node from the LODInfo.
         * @param node The Sprite3D node to be removed from the LOD.
         * @zh 从LODInfo中删除某个LOD节点。
         * @param node 要从LOD中删除的Sprite3D节点。
         */
        removeNode(node: Sprite3D): void;
        /**
         * @en Releases all render node cull flags in the LODInfo.
         * @zh 释放LODInfo中的所有渲染节点的剔除标记。
         */
        removeAllRender(): void;
    }
    /**
     * @en The `LODGroup` class is used to build LOD components.
     * @zh SpotLight 类用于构建LOD组件
     */
    class LODGroup extends Component {
        /**
       * @en Indicates whether the LOD bounds radius and bounds need to be recalculated. Recalculation is needed when there is a relative change in the LOD values.
       * @zh 是否需要重新计算 _lodBoundsRadius 和 _bounds。当 LOD 值的位置有相对改动时，需要重新计算。
       */
        private _needcaculateBounds;
        /**
         * @en The bounds calculation for all rendering nodes in the LOD group.
         * @zh lodGroup 所有的渲染节点的包围盒计算
         */
        private _bounds;
        /**
         * @en The size of the LOD group.
         * @zh LOD组大小
         */
        private _size;
        /**
         * @en The center position of the bounding box.
         * @zh 包围盒中心位置
         */
        private _lodPosition;
        /**
         * @en The number of LOD levels.
         * @zh LOD 等级数量
         */
        private _lodCount;
        /**
         * @en The information of LOD levels.
         * @zh LOD 等级信息
         */
        private _lods;
        /**
         * @en The index of the visible node.
         * @zh 显示节点
         */
        private _visialIndex;
        /**
         * @en The ratio of the LOD node.
         * @zh LOD节点比例
         */
        private _nowRate;
        readonly owner: Sprite3D;
        /**
         * @en Constructor method of LODGroup.
         * @zh LOD组的构造方法
         */
        constructor();
        /**
         * @en Shadow culling pass
         * @zh 阴影裁剪pass
         */
        shadowCullPass(): boolean;
        /**
         * @en Currently displayed LOD node index
         * @zh 当前显示的LOD节点下标
         */
        get visialIndex(): number;
        /**
         * @en The array of LODInfo objects
         * @zh LODInfo数组
         */
        get lods(): LODInfo[];
        set lods(data: LODInfo[]);
        /**
         * @en Proportion of lod nodes
         * @zh lod节点比例
         */
        get nowRate(): number;
        /**
         * @en LOD bounds
         * @zh LOD包围盒
         */
        get bounds(): Bounds;
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDisable(): void;
        /**
         * 设置显示隐藏组
         * @param rate
         * @returns
         */
        private _applyVisibleRate;
        /**
         * 设置某一级LOD显示
         * @param index
         */
        private _setLODvisible;
        /**
         * 设置某一级LOD不显示
         * @param index
         */
        private _setLODinvisible;
        /**
         * @internal
         * @en Called when the object is being destroyed to perform cleanup operations.
         * @zh 在对象被销毁时调用，以执行清理操作。
         */
        onDestroy(): void;
        /**
         * @internal
         */
        _updateRecaculateFlag(): void;
        /**
         * @internal
         * @param lodGroup
         */
        _cloneTo(lodGroup: LODGroup): void;
        /**
         * @internal
         * @en Recalculate the bounding box
         * @zh 重新计算包围盒
         */
        recalculateBounds(): void;
        /**
         * @internal
         * @en Update before rendering
         * @zh 渲染之前的更新
         */
        onPreRender(): void;
    }
    /**
     * @en Maintain compatibility with 2.0. The new script supports the use of scripts.
     * @zh 保持对2.0的兼容。新脚本支持使用Script即可。
     */
    var Script3D: typeof Script;
    type Script3D = Script;
    /**
     * @en Represents a static batch mesh for efficient rendering of multiple static meshes.
     * @zh 用于高效渲染多个静态网格的静态批处理网格。
     */
    class StaticBatchMesh {
        /**
         * @en Creates a new StaticBatchMesh instance based on the provided merge information.
         * @param info The static mesh merge information.
         * @returns A new StaticBatchMesh instance.
         * @zh 根据提供的合并信息创建一个新的静态合批实例。
         * @param info 静态网格合并信息。
         * @returns 一个新的静态合批实例。
         */
        static create(info: StaticMeshMergeInfo): StaticBatchMesh;
        /**@internal */
        _bufferState: BufferState;
        /**@internal */
        _vertexBuffer: VertexBuffer3D;
        /**@internal */
        _indexBuffer: IndexBuffer3D;
        /**@internal */
        _staticSubMeshes: Map<Material, StaticBatchSubMesh>;
        /**
         * @en The bounding volume of the static batch mesh.
         * @zh 静态批处理网格的边界体积。
         */
        bounds: Bounds;
        /**
         * @en Constructs, initializes a new static batch mesh.
         * @zh 构造方法，初始化静态网格合批。
         */
        constructor();
        /**
         * @en Sets the vertex and index buffers for this static batch mesh.
         * @param vertex The vertex buffer to set.
         * @param index The index buffer to set.
         * @zh 为此静态批处理网格设置顶点和索引缓冲区。
         * @param vertex 要设置的顶点缓冲区。
         * @param index 要设置的索引缓冲区。
         */
        setBuffer(vertex: VertexBuffer3D, index: IndexBuffer3D): void;
        /**
         * @en Destroys this static batch mesh and releases all associated resources.
         * @zh 销毁此静态批处理网格并释放所有相关资源。
         */
        destroy(): void;
    }
    /**
     * @en StaticBatchMeshRender class, extends BaseRender for static batch mesh rendering.
     * @zh StaticBatchMeshRender 类，继承自 BaseRender，用于静态批处理网格渲染。
     * @blueprintIgnore
     */
    class StaticBatchMeshRender extends BaseRender {
        /**
         * @en Creates a new StaticBatchMeshRender instance.
         * @param info The static mesh merge information.
         * @returns A new StaticBatchMeshRender instance.
         * @zh 创建一个新的 StaticBatchMeshRender 实例。
         * @param info 静态网格合并信息。
         * @returns 新的 StaticBatchMeshRender 实例。
         */
        static create(info: StaticMeshMergeInfo): StaticBatchMeshRender;
        private _staticMesh;
        /**
         * @en The static batch mesh.
         * @zh 静态批处理网格。
         */
        get staticMesh(): StaticBatchMesh;
        private _mergeInfo;
        /**
         * @en The static mesh merge information.
         * @zh 静态网格合并信息。
         */
        get mergeInfo(): StaticMeshMergeInfo;
        set mergeInfo(value: StaticMeshMergeInfo);
        _singleton: boolean;
        private constructor();
        _calculateBoundingBox(): void;
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @en Gets mesh defines based on vertex elements.
         * @param mesh The static batch mesh.
         * @param out Array to store the resulting shader defines.
         * @zh 根据顶点元素获取网格定义。
         * @param mesh 静态批处理网格。
         * @param out 用于存储结果着色器定义的数组。
         */
        _getMeshDefine(mesh: StaticBatchMesh, out: Array<ShaderDefine>): void;
        /**
         * @en Determines if the mesh needs to be rendered based on frustum culling.
         * @param boundFrustum The bounding frustum for culling.
         * @param context The 3D render context.(Not used)
         * @returns True if the mesh needs to be rendered, false otherwise.
         * @zh 根据视锥体剔除确定是否需要渲染网格。
         * @param boundFrustum 用于剔除的边界视锥体。
         * @param context 3D渲染上下文。(未使用)
         * @returns 如果需要渲染网格则返回true，否则返回false。
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         * @ignore
         * @en Called when the component is enabled.
         * Sets the batch render flag for all renders in the merge info.
         * @zh 当组件启用时调用。
         * 为合并信息中的所有渲染器设置批处理渲染标志。
         */
        onEnable(): void;
        /**
         * @ignore
         * @en Called when the component is disabled.
         * Unsets the batch render flag for all renders in the merge info.
         * @zh 当组件禁用时调用。
         * 为合并信息中的所有渲染器取消设置批处理渲染标志。
         */
        onDisable(): void;
        /**
         * @ignore
         * @en Called when the component is being destroyed.
         * Cleans up resources including render elements and static mesh.
         * @zh 当组件被销毁时调用。
         * 清理资源，包括渲染元素和静态网格。
         */
        onDestroy(): void;
        /**
         * @en Clones the current StaticBatchMeshRender to another instance.
         * @param dest The destination StaticBatchMeshRender instance.
         * @zh 将当前 StaticBatchMeshRender 克隆到另一个实例。
         * @param dest 目标 StaticBatchMeshRender 实例。
         */
        _cloneTo(dest: StaticBatchMeshRender): void;
    }
    /**
     * @internal
     */
    class StaticBatchMeshRenderElement extends RenderElement {
        constructor();
        /** @internal */
        getInvertFront(): boolean;
    }
    /**
     * @en represents information for a sub-batch in static batch rendering.
     * @zh 静态批处理渲染中子批次的信息。
     */
    class StaticBatchSubInfo {
        /**
         * @en The starting index of the sub-batch in the index buffer.
         * @zh 子批次在索引缓冲区中的起始索引。
         */
        indexStart: number;
        /**
         * @en The number of indices in the sub-batch.
         * @zh 子批次中的索引数量。
         */
        indexCount: number;
        /**
         * @en The bounding volume of the sub-batch mesh.
         * @zh 子批次网格的边界体积。
         */
        meshBounds: Bounds;
        /**
         * @en Indicates whether this sub-batch needs to be rendered.
         * @zh 指示是否需要渲染此子批次。
         */
        needRender: boolean;
        /**
         * @en Constructor method, initializes data.
         * @zh 构造方法，初始化数据
         */
        constructor();
    }
    /**
     * @en static batch sub-mesh rendering.
     * @zh 用于静态批处理子网格渲染。
     */
    class StaticBatchSubMesh extends GeometryElement {
        /**@internal */
        private static _type;
        /**
         * @en Array of StaticBatchSubInfo objects representing sub-mesh information.
         * @zh StaticBatchSubInfo 对象数组，表示子网格信息。
         */
        subInfos: StaticBatchSubInfo[];
        /**
         * @en The byte count of indices in the sub-mesh.
         * @zh 子网格中索引的字节数。
         */
        indexByteCount: number;
        constructor();
        /**
         * @en Adds a sub-mesh to the StaticBatchSubMesh.
         * @param indexCount The number of indices in the sub-mesh.
         * @param indexStart The starting index of the sub-mesh.
         * @param bounds The bounding volume of the sub-mesh.
         * @zh 向 StaticBatchSubMesh 添加一个子网格。
         * @param indexCount 子网格中的索引数量。
         * @param indexStart 子网格的起始索引。
         * @param bounds 子网格的边界体积。
         */
        addSubMesh(indexCount: number, indexStart: number, bounds: Bounds): void;
        /**
         * @en Gets the type of the StaticBatchSubMesh.
         * @zh 获取 StaticBatchSubMesh 的类型。
         */
        _getType(): number;
        /**
         * @en Updates render parameters based on the current render context.
         * @param state The current render context.
         * @zh 根据当前渲染上下文更新渲染参数。
         * @param state 当前渲染上下文。
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Prepares the sub-mesh for rendering.
         * @param state The current render context.(Not used)
         * @returns True if any sub-info needs rendering, false otherwise.
         * @zh 准备子网格进行渲染。
         * @param state 当前渲染上下文。（未使用）
         * @returns 如果有任何子信息需要渲染则返回 true，否则返回 false。
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @en Destroys the StaticBatchSubMesh and its resources.
         * @zh 销毁 StaticBatchSubMesh 及其资源。
         */
        destroy(): void;
    }
    /**
     * @internal
     * @en Manages static mesh batching.
     * @zh 管理静态网格批处理。
     */
    class StaticMeshBatchManager {
        private meshVertexDecSet;
        constructor();
        /**
         * @en Combines multiple MeshRenderers into static batch renders.
         * @param renders Array of MeshRenderer objects to be combined.
         * @returns Array of StaticBatchMeshRender objects created from the combination.
         * @zh 将多个 MeshRenderer 合并为静态批处理渲染器。
         * @param renders 要合并的 MeshRenderer 对象数组。
         * @returns 由合并创建的 StaticBatchMeshRender 对象数组。
         */
        combine(renders: MeshRenderer[]): StaticBatchMeshRender[];
        /**
         * @en Merges a single StaticMeshMergeInfo into a StaticBatchMeshRender.
         * @param info The StaticMeshMergeInfo to be merged.
         * @returns A new StaticBatchMeshRender created from the merge info.
         * @zh 将单个 StaticMeshMergeInfo 合并为 StaticBatchMeshRender。
         * @param info 要合并的 StaticMeshMergeInfo。
         * @returns 从合并信息创建的新 StaticBatchMeshRender。
         */
        merge(info: StaticMeshMergeInfo): StaticBatchMeshRender;
    }
    /**
     * @en StaticMeshMergeInfo class represents information for merging static meshes.
     * @zh StaticMeshMergeInfo 类表示用于合并静态网格的信息。
     */
    class StaticMeshMergeInfo {
        /**
         * @en Creates a new StaticMeshMergeInfo instance from a MeshRenderer.
         * @param render The MeshRenderer to create the merge info from.
         * @returns A new StaticMeshMergeInfo instance.
         * @zh 从 MeshRenderer 创建新的 StaticMeshMergeInfo 实例。
         * @param render 用于创建合并信息的 MeshRenderer。
         * @returns 新的 StaticMeshMergeInfo 实例。
         */
        static create(render: MeshRenderer): StaticMeshMergeInfo;
        /**
         * @en Indicates whether the object receives shadows.
         * @zh 表示对象是否接收阴影。
         */
        receiveShadow: boolean;
        /**
         * @en The index of the lightmap used by this object.
         * @zh 此对象使用的光照贴图索引。
         */
        lightmapIndex: number;
        /**
         * @en The vertex declaration describing the structure of vertex data.
         * @zh 描述顶点数据结构的顶点声明。
         */
        vertexDec: VertexDeclaration;
        private _renders;
        /**
         * @en The array of MeshRenderer components attached to this object.
         * @zh 附加到此对象的 MeshRenderer 组件数组。
         */
        get renders(): MeshRenderer[];
        /**
         * @en The total number of vertices in this batch.
         * @zh 此批次中的顶点总数。
         */
        vertexCount: number;
        /**
         * @en The total number of indices in this batch.
         * @zh 此批次中的索引总数。
         */
        indexCount: number;
        private constructor();
        /**
         * @en Checks if a MeshRenderer matches the criteria for this batch.
         * @param render The MeshRenderer to check.
         * @returns True if the renderer matches, false otherwise.
         * @zh 检查 MeshRenderer 是否符合此批次的条件。
         * @param render 要检查的 MeshRenderer。
         * @returns 如果渲染器匹配则返回 true，否则返回 false。
         */
        match(render: MeshRenderer): boolean;
        /**
         * @en Adds a MeshRenderer to this batch.
         * @param render The MeshRenderer to add.
         * @zh 将 MeshRenderer 添加到此批次。
         * @param render 要添加的 MeshRenderer。
         */
        addElement(render: MeshRenderer): void;
        /**
         * @en Destroys this batch and releases its resources.
         * @zh 销毁此批次并释放其资源。
         */
        destroy(): void;
    }
    /**
     * @en Class used to describe batched rendering nodes.
     * @zh 类用来描述合批的渲染节点。
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    class BatchRender extends BaseRender {
        /**@internal */
        protected _checkLOD: boolean;
        /**@internal */
        protected _lodCount: number;
        /**@internal */
        protected _lodRateArray: number[];
        /**@internal*/
        protected _batchList: FastSinglelist<BaseRender>;
        /**@internal*/
        protected _batchbit: RenderBitFlag;
        /**@internal*/
        protected _RenderBitFlag: RenderBitFlag;
        /**@internal*/
        protected _lodInstanceRenderElement: {
            [key: number]: InstanceRenderElement[];
        };
        /**@internal*/
        protected _lodsize: number;
        /**@internal*/
        private _cacheLod;
        /**
         * @en constructor, initialize the batch rendering node.
         * @zh 构造方法, 初始化合批渲染节点。
         */
        constructor();
        /**
         * @en Whether to batch based on LOD (Level of Detail).
         * @zh 是否根据 LOD（细节层次）来进行合批。
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * @en Sets the LOD culling rate array for filtering.
         * @zh 设置 LOD 裁剪率数组用于过滤。
         */
        get lodCullRateArray(): number[];
        set lodCullRateArray(value: number[]);
        /**
         * @internal
         * Overrid it
         *  是否满足batch条件
         */
        protected _canBatch(render: BaseRender): boolean;
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDisable(): void;
        /**
         * @internal
         * 根据lod的改变
         */
        protected _changeLOD(lod: number): void;
        /**
         * @en Called before rendering. Handles LOD (Level of Detail) calculations and changes.
         * @zh 渲染前调用。处理 LOD（细节级别）计算和变更。
         */
        onPreRender(): void;
        /**
         * @internal
         * @param render
         */
        _batchOneRender(render: BaseRender): boolean;
        /**
         * @internal
         * @param render
         */
        _removeOneRender(render: BaseRender): void;
        /**
         * @internal
         * @param render
         */
        _updateOneRender(render: BaseRender): void;
        /**
         * @en Adds a list of render nodes to the batch queue.
         * @param renderNode An array of BaseRender objects to be added to the batch.
         * @zh 将渲染节点队列添加到合批队列中。
         * @param renderNode 要添加到合批的 BaseRender 对象数组。
         */
        addList(renderNode: BaseRender[]): void;
        /**
         * @en Performs batching based on the _batchList.
         * This method iterates through the _batchList and batches each render node.
         * @zh 根据 _batchList 执行合批操作。
         * 此方法遍历 _batchList 并对每个渲染节点进行合批。
         */
        reBatch(): void;
        /**
         * @internal
         * @en Restoring the Batch Render State
         * @zh 恢复批处理渲染状态
         */
        _restorRenderNode(): void;
        /**
         * @internal
         */
        _clear(): void;
    }
    /**
     * @en Class used to describe the volume of a mergeable render node.
     * @zh 用来描述一个可合并渲染节点的体积。
     */
    class StaticBatchVolume extends Volume {
        /** 缓存可以合并的*/
        private _cacheRender;
        /** 已经合并了的BaseRender */
        private _batchRender;
        /** 是否根据LOD属性优化 */
        private _checkLOD;
        /** StaticInstanceBatch */
        /** 是否开启静态物体Instance的合批 */
        private _enableStaticInstanceBatch;
        /** 内置静态物体Instance合批 */
        private _instanceBatchRender;
        /**StaticVertexMergeBatch */
        /** 是否开启顶点静态合批 TODO */
        private _enableStaticVertexMergeBatch;
        /** 顶点静态合批  TODO*/
        private _vertexMergeBatchRender;
        /** CustomBatch自定义的batch流程*/
        private _enableCustomBatch;
        private _customBatchs;
        private _getStaticInstanceBatchRender;
        private _getStatiVertexMergeBatchRender;
        /**
         * @en Whether LOD (Level of Detail) is considered in batching.
         * @zh 合批是否考虑 LOD（细节层次）。
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * @en Whether static instance batching is enabled.
         * @zh 是否启用静态实例合批渲染。
         */
        get enableStaticInstanceBatchRender(): boolean;
        set enableStaticInstanceBatchRender(value: boolean);
        /**
         * @en Whether static vertex merge batching is enabled.
         * @zh 是否启用静态顶点合并合批。
         */
        get enableMergeBatchRender(): boolean;
        set enableMergeBatchRender(value: boolean);
        /**
         * @en Whether custom batching is enabled.
         * @zh 是否启用自定义合批。
         */
        get enableCustomBatchRender(): boolean;
        set enableCustomBatchRender(value: boolean);
        /**
         * @en The custom batch renderers.
         * @zh 自定义的合批渲染器。
         */
        get customBatchRenders(): BatchRender[];
        set customBatchRenders(value: BatchRender[]);
        /**
         * @ignore
         * @en Constructor method，initialize rendering related settings.
         * @zh 构造方法，初始化渲染相关的设置。
         */
        constructor();
        /**
         * Restoring the Batch Render State
         */
        private _restorRenderNode;
        /**
         * add one RenderNode
         * @param renderNode
         * @returns
         */
        private __addRenderNodeToBatch;
        /**
         * remove one RenderNode
         * @param renderNode
         */
        private __removeRenderNodeFromBatch;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @internal
         * @en Adds a render node to the volume when it enters.
         * This method handles the addition of static batch render nodes.
         * @param renderNode The render node to be added.
         * @zh 当一个渲染节点进入体积时添加该节点。
         * 此方法处理静态批次渲染节点的添加。
         * @param renderNode 要添加的渲染节点。
         */
        _addRenderNode?(renderNode: BaseRender): void;
        /**
         * @internal
         * @en Removes a render node from the volume when it exits.
         * This method handles the removal of static batch render nodes.
         * @param renderNode The render node to be removed.
         * @zh 当一个渲染节点移出体积时移除该节点。
         * 此方法处理静态批次渲染节点的移除。
         * @param renderNode 要移除的渲染节点。
         */
        _removeRenderNode(renderNode: BaseRender): void;
        /**
         * @internal
         * @en Volume change
         * @zh 体积变化
         */
        _VolumeChange(): void;
        /**
         * @internal
         * @en Called when the component starts.
         * Initiates the rebatching process.
         * @zh 当组件启动时调用。
         * 启动重新合批过程。
         */
        onStart(): void;
        /**
         * @en Rebatches the render nodes, clearing previous states.
         * This method should be called manually when necessary. Performs batching based on the values in the Volume.
         * @zh 重新合批渲染节点，清理先前的状态。
         * 必要时需要手动调用此方法。根据 Volume 中的值执行合批。
         */
        reBatch(): void;
    }
    /**
     * @en used to create static instance batch rendering.
     * @zh 用于创建静态实例批处理渲染。
     */
    class StaticInstanceBatchRender extends BatchRender {
        /** instanceBatchManager*/
        private _batchManager;
        /** 记录每个BatchMask对应的Instance的数量*/
        private _insBatchMarksNums;
        private _insElementMarksArray;
        /** batch rule:Batch min count*/
        private _instanceBatchminNums;
        /** cache udpate element*/
        private _updateChangeElement;
        /**
         * @en constructor, initialize static instance batch rendering.
         * @zh 构造方法, 初始化静态实例批处理渲染。
         */
        constructor();
        /**
         * @en Determines whether this render supports instance batching.
         * @param render The render object to be checked.
         * @returns A boolean value indicating whether instance batching is supported.
         * @zh 判断这个 Render 是否支持 InstanceBatch。
         * @param render 要检查的渲染对象。
         * @returns 一个布尔值，指示是否支持实例批处理。
         */
        private _isRenderNodeAllCanInstanceBatch;
        /**
         * @en Calculates the number of instances to be batched.
         * @param render The render object containing the elements to be batched.
         * @zh 计算实例合并的数量。
         * @param render 包含要合并元素的渲染对象。
         */
        private _sumInstanceBatch;
        /**
         * batch one element
         * @param element
         * @param render
         * @returns
         */
        private _batchOneElement;
        /**
         * remove one element
         * @param element
         * @param render
         * @returns
         */
        private _removeOneElement;
        /**
         * update one element
         * @param element
         * @param render
         * @returns
         */
        private _updateOneElement;
        /**
         * create instanceElement
         * @param element
         * @param render
         * @param batchMark
         * @returns
         */
        private _createInstanceElement;
        /**
         * @en Determines whether the render instance meets the batch conditions.
         * @param render The base render object to check for batching conditions.
         * @returns boolean True if the render instance meets the batching conditions; otherwise, false.
         * @zh 判断渲染实例是否满足批处理条件。
         * @param render 要检查批处理条件的基础渲染对象。
         * @returns boolean 如果渲染实例满足批处理条件，则返回 true；否则返回 false。
         */
        protected _canBatch(render: BaseRender): boolean;
        /**
         *
         * @en Recalculate the bounding box
         * @zh 重新计算包围盒
         */
        _calculateBoundingBox(): Bounds;
        protected _onDestroy(): void;
        /**
         * 添加合批到render
         * @param render
         * @returns
         */
        _batchOneRender(render: BaseRender): boolean;
        /**
         * 删除合批
         * @param render
         * @returns
         */
        _removeOneRender(render: BaseRender): void;
        /**
         * 合批过的更新数据
         * @param render
         * @returns
         */
        _updateOneRender(render: BaseRender): void;
        /**
         * @en Clean up all renderings
         * @zh 清理所有渲染
         */
        _clear(): void;
        /**
         * @en Add a list of renders to the batch queue
         * @param renderNodes  The render queue to be added
         * @zh 将渲染队列添加到批处理队列
         * @param renderNodes  要添加的渲染队列
         */
        addList(renderNodes: BaseRender[]): void;
        /**
         * @en Rebatch based on the _batchList
         * @zh 根据_batchList重新进行批处理
         */
        reBatch(): void;
    }
    /**
     * @en The batch rendering of the static vertex merge.
     * @zh 静态顶点合并的批量渲染。
     */
    class StatiVertexMergeBatchRender extends BatchRender {
        _addList(renderNodes: BaseRender[]): void;
    }
    /**
     * @en The `VolumeManager` class is used to manage volume components.
     * @zh `VolumeManager` 类用于管理体积组件。
     */
    interface IVolumeManager {
        /**是否需要重新更新 */
        /** @internal */
        _needUpdateAllRender: boolean;
        add(volume: Volume): void;
        remove(volume: Volume): void;
        _updateRenderObject(baseRender: BaseRender): void;
        handleMotionlist(motionObjects: FastSinglelist<BaseRender>): void;
        reCaculateAllRenderObjects(baseRenders: FastSinglelist<BaseRender>): void;
        destroy(): void;
    }
    /**
     * @en Reflective probe mode
     * @zh 反射探针模式
     */
    enum ReflectionProbeMode {
        /**
         * @en Baking mode. Currently, only Back baking is supported.
         * @zh 烘培模式。现在仅仅支持Back烘培
         */
        off = 0,
        /**
         * @en Real time simple sampling mode, not supported yet.
         * @zh 实时简单采样模式 还未支持*/
        simple = 1
    }
    /**
     * @en used to implement reflection probe components
     * @zh 用于实现反射探针组件
     */
    class ReflectionProbe extends Volume {
        /** @internal */
        static CommandMap: CommandUniformMap;
        /** @internal */
        static BlockName: string;
        /** @internal */
        static SHADERDEFINE_GI_IBL: ShaderDefine;
        /** @internal */
        static IBLTEX: number;
        /** @internal */
        static IBLROUGHNESSLEVEL: number;
        /** @internal */
        static AMBIENTSH: number;
        /** @internal */
        static AMBIENTCOLOR: number;
        /** @internal */
        static AMBIENTINTENSITY: number;
        /** @internal */
        static REFLECTIONINTENSITY: number;
        /** 反射探针位置 最大、最小值*/
        /** @internal */
        static REFLECTIONCUBE_PROBEPOSITION: number;
        /** @internal */
        static REFLECTIONCUBE_PROBEBOXMAX: number;
        /** @internal */
        static REFLECTIONCUBE_PROBEBOXMIN: number;
        /**
         * @en Number of reflection probes
         * @zh 反射探针数量
         */
        static reflectionCount: number;
        /**
         * @en Get a globally unique ID
         * @zh 获取一个全局唯一ID
         * @internal
         */
        static getID(): number;
        /** @internal */
        static init(): void;
        /**
         * @en Default HDR decode values
         * @zh 默认的 HDR 解码数据
         * @internal
         */
        static defaultTextureHDRDecodeValues: Vector4;
        /**@internal 探针重要度 */
        protected _importance: number;
        /**漫反射顔色 */
        private _ambientColor;
        /**漫反射SH */
        private _ambientSH;
        /**
         * @internal
         * @en Whether the probe is a scene probe.
         * @zh 是否是场景探针
         */
        _isScene: boolean;
        /**@internal */
        _reflectionProbeID: number;
        /**@internal */
        _dataModule: IReflectionProbeData;
        constructor();
        /**
         * @en The shader data of the reflection probe
         * @zh 反射探针的着色器数据
         */
        get shaderData(): ShaderData;
        /**
         * @en Whether to enable orthogonal reflection
         * @zh 是否开启正交反射
         */
        get boxProjection(): boolean;
        set boxProjection(value: boolean);
        /**
         * @en The importance of the reflection probe
         * @zh 反射探针的重要度
         */
        get importance(): number;
        set importance(value: number);
        /**
         * @en The intensity of ambient diffuse reflection
         * @zh 环境漫反射的强度
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * @en The intensity of the reflection probe
         * @zh 反射探针的强度
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        _reCaculateBoundBox(): void;
        /**
         * @en The bounding box of the reflection probe
         * @zh 反射探针的包围盒
         */
        get bounds(): Bounds;
        /**
         * @en The maximum point of the bounding box
         * @zh 包围盒的最大点
         */
        get boundsMax(): Vector3;
        set boundsMax(value: Vector3);
        /**
         * @en The minimum point of the bounding box
         * @zh 包围盒的最小点
         */
        get boundsMin(): Vector3;
        set boundsMin(value: Vector3);
        /**
         * @en The position of the probe
         * @zh 探针的位置
         */
        get probePosition(): Vector3;
        /**
         * @en The ambient diffuse color
         * @zh 环境漫反射颜色
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * @en The spherical harmonics coefficients for ambient color
         * @zh 环境颜色的球谐系数
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
         * @en Get or set the ambient light mode
         * If the value is AmbientMode.SolidColor, ambientColor is generally used as the ambient light source
         * If the value is AmbientMode.SphericalHarmonics, ambientSphericalHarmonics is generally used as the ambient light source
         * @zh 获取或设置环境光模式
         * 如果值为AmbientMode.SolidColor，一般使用ambientColor作为环境光源
         * 如果值为AmbientMode.SphericalHarmonics，一般使用ambientSphericalHarmonics作为环境光源
         */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        private _iblTex;
        /**
         * @en The Image-Based Lighting (IBL) texture
         * @zh 基于图像的照明(IBL)纹理
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * @en Whether the Image-Based Lighting texture is compressed using RGBD format
         * @zh 基于图像的照明纹理是否使用RGBD格式压缩
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        /**
         * @inheritdoc
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @inheritdoc
         * @internal
         */
        protected _onDestroy(): void;
    }
    /**
     * @en The `ReflectionProbeManager` class is used for managing reflection probes.
     * @zh `ReflectionProbeManager` 类用于管理反射探针。
     */
    class ReflectionProbeManager implements IVolumeManager {
        /** @internal 反射探针队列 */
        private _reflectionProbes;
        /** @internal 环境探针 */
        private _sceneReflectionProbe;
        /** @internal */
        _needUpdateAllRender: boolean;
        /**
         * @en The constructor of the `ReflectionProbeManager` class.
         * @zh `ReflectionProbeManager` 类构造函数。
         */
        constructor();
        /**
         * @en The scene reflection probe
         * @zh 场景反射探针
         */
        get sceneReflectionProbe(): ReflectionProbe;
        set sceneReflectionProbe(value: ReflectionProbe);
        /**
         * @en Update the reflection probe for the base render.
         * @param baseRender The base render object to update.
         * @zh 更新基础渲染对象的反射探针。
         * @param baseRender 要更新的基础渲染对象。
         */
        _updateRenderObject(baseRender: BaseRender): void;
        /**
         * @internal
         * @en Add a reflection probe to the scene.
         * @param volume The reflection probe to add.
         * @zh 在场景中添加反射探针。
         * @param volume 要添加的反射探针。
         */
        add(volume: ReflectionProbe): void;
        /**
         * @internal
         * @en Remove a reflection probe from the scene.
         * @param volume The reflection probe to remove.
         * @zh 从场景中删除反射探针。
         * @param volume 要删除的反射探针。
         */
        remove(volume: ReflectionProbe): void;
        /**
         * @internal
         * @en Update reflection probe information for moving objects.
         * @param motionObjects List of moving render objects.
         * @zh 更新运动物体的反射探针信息。
         * @param motionObjects 运动渲染对象列表。
         */
        handleMotionlist(motionObjects: SingletonList<BaseRender>): void;
        /**
         * @internal
         * @en Recalculate reflection probes for all provided renderers.
         * @param baseRenders List of base renderers to update.
         * @zh 重新计算所有提供的渲染器的反射探针。
         * @param baseRenders 要更新的基础渲染器列表。
         */
        reCaculateAllRenderObjects(baseRenders: SingletonList<BaseRender>): void;
        /**
         * @internal
         * @en Destroy the ReflectionProbeManager and all associated resources.
         * @zh 销毁 ReflectionProbeManager 及其关联的所有资源。
         */
        destroy(): void;
    }
    /**
     * @en Enum representing the types of intersection between volumes.
     * @zh 表示体积之间相交类型的枚举。
     */
    enum volumeIntersectType {
        /**
         * @en One volume contains the other.
         * @zh 一个体积包含另一个体积。
         */
        contain = 0,
        /**
         * @en Volumes intersect but do not fully contain each other.
         * @zh 体积相交但不完全包含彼此。
         */
        intersect = 1,
        /**
         * @en Volumes are disjoint (do not intersect).
         * @zh 体积不相交（互不相交）。
         */
        Disjoint = 2
    }
    /**
     * @en Represents the intersection properties between volume.
     * @zh 表示物体的相交属性。
     */
    class volumeIntersectInfo {
        /**
         * @en Intersection Type
         * @zh 相交类型
         */
        type: volumeIntersectType;
        /**
         * @en Intersection ratio
         * @zh 相交比例
         */
        intersectRate: number;
    }
    /**
     * @en Represents a volume component in the scene.
     * @zh 表示场景中的体积组件。
     */
    class Volume extends Component {
        protected _primitiveBounds: Bounds;
        /**包围盒 */
        protected _bounds: Bounds;
        /**@internal cache number of around Volume */
        protected _aroundVolumeCacheNum: number;
        /**around Volume */
        protected _aroundVolume: Volume[];
        /**volume manager */
        protected _volumeManager: VolumeManager;
        /**volume intersect Comonent */
        protected _type: number;
        /**重要性 */
        protected _importance: number;
        readonly owner: Sprite3D;
        /**
         * @ignore
         * @en constractor of Volume
         * @zh 体积组件的构造函数。
         */
        constructor();
        /**
         * @en The volume type.
         * @zh 体积类型。
         */
        get type(): number;
        /**
         * @internal
         * @en The bounds of the volume.
         * @zh 体积的边界。
         */
        get bounds(): Bounds;
        /**
         * @en The maximum point of the volume component's own bounding box.
         * @zh 体积组件自身包围盒的最大点。
         */
        get boundsMax(): Vector3;
        set boundsMax(value: Vector3);
        /**
         * @en The minimum point of the volume component's own bounding box.
         * @zh 体积组件自身包围盒的最小点。
         */
        get boundsMin(): Vector3;
        set boundsMin(value: Vector3);
        /**
         * @en The probe position of the volume.
         * @zh 体积的探针位置。
         */
        get probePosition(): Vector3;
        /**
         * @en The importance value of the volume probe.
         * @zh 体积探针的重要度。
         */
        get importance(): number;
        set importance(value: number);
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @internal
         * @en Called when a render node enters the volume.
         * @param renderNode The BaseRender node entering the volume.
         * @zh 当一个渲染节点进入体积时调用。
         * @param renderNode 进入体积的BaseRender节点。
         */
        _addRenderNode?(renderNode: BaseRender): void;
        /**
         * @internal
         * @en Called when a render node is removed from the volume.
         * @param renderNode The BaseRender node being removed from the volume.
         * @zh 当一个渲染节点从体积中移除时调用。
         * @param renderNode 从体积中移除的BaseRender节点。
         */
        _removeRenderNode?(renderNode: BaseRender): void;
        /**
         * @internal
         * @en Called when a render node moves within the volume.
         * @param renderNode The BaseRender node moving within the volume.
         * @zh 当一个渲染节点在体积中移动时调用。
         * @param renderNode 在体积中移动的BaseRender节点。
         */
        _motionInVolume?(renderNode: BaseRender): void;
        /**
         * @internal
         * @en Handles volume changes.
         * @zh 处理体积变化。
         */
        _VolumeChange(): void;
        /**
         * @internal
         */
        _reCaculateBoundBox(): void;
    }
    /**
     * @en The `VolumeManager` class is used to manage volume components in a scene.
     * @zh `VolumeManager` 类用于管理场景中的体积组件。
     */
    class VolumeManager implements IVolumeManager {
        /**
         * @en Type identifier for Reflection Probe Volume.
         * @zh 反射探针体积的类型标识符。
         */
        static ReflectionProbeVolumeType: number;
        /**
         * @en Type identifier for Volumetric Global Illumination.
         * @zh 体积全局光照的类型标识符。
         */
        static VolumetricGIType: number;
        /** @internal 需要跟新反射探针的渲染队列 */
        private _motionObjects;
        /** @internal volume list */
        private _volumeList;
        /**
         * @internal
         * @en whether all renders need to be updated.
         * @zh 是否需要更新所有渲染。
         */
        _needUpdateAllRender: boolean;
        /**
         * @en Dictionary of specialized volume managers for different volume types.
         * @zh 不同体积类型的专门体积管理器字典。
         */
        _regVolumeManager: {
            [key: number]: IVolumeManager;
        };
        /**
         * @internal
         * @en Reflection probe manager.
         * @zh 反射探针管理器。
         */
        _reflectionProbeManager: ReflectionProbeManager;
        /**
         * @en Volumetric Global Illumination manager.
         * @zh 体积全局光照管理器。
         */
        _volumetricGIManager: VolumetricGIManager;
        constructor();
        /**
         * @en The reflection probe manager.
         * @zh 反射探针管理器。
         */
        get reflectionProbeManager(): ReflectionProbeManager;
        /**
         * @en The volumetric global illumination manager.
         * @zh 体积全局光照管理器。
         */
        get volumetricGIManager(): VolumetricGIManager;
        /**
         * @en Add a volume component to the manager.
         * @zh 向管理器添加一个体积组件。
         */
        add(volume: Volume): void;
        /**
         * @en Remove a volume component from the manager.
         * @zh 从管理器中移除一个体积组件。
         */
        remove(volume: Volume): void;
        /**
         * @en Add a motion object to the handle list.
         * @zh 将运动对象添加到处理列表中。
         */
        addMotionObject(renderObj: BaseRender): void;
        /**
         * @en Remove a motion object from the handle list.
         * @zh 从处理列表中移除运动对象。
         */
        removeMotionObject(renderObj: BaseRender): void;
        /**
         * @en Update one RenderNode Volume info
         * @param baseRender The BaseRender object to update
         * @zh 更新一个RenderNode的Volume信息
         * @param baseRender 要更新的BaseRender对象
         */
        _updateRenderObject(baseRender: BaseRender): void;
        /**
         * @internal
         * @en Handle motion list.
         * This method updates render objects, processes reflection probes, and handles volumetric GI for objects in motion.
         * @zh 处理运动列表。
         * 此方法更新渲染对象，处理反射探针，并处理运动物体的体积全局光照。
         */
        handleMotionlist(): void;
        /**
         * @en Recalculate and update all Volume information for render objects
         * @zh 重新计算并更新所有渲染对象的Volume信息
         */
        reCaculateAllRenderObjects(baseRenders: SingletonList<BaseRender>): void;
        /**
         * @en Check if all render objects need to be recalculated
         * @zh 检查是否需要重新计算所有渲染对象
         */
        needreCaculateAllRenderObjects(): boolean;
        /**
         * @internal
         * @en Clean up the change queue
         * @zh 清理变动队列
         */
        clearMotionObjects(): void;
        /**
         * @internal
         * @en Destroy the object
         * @zh 销毁对象
         */
        destroy(): void;
    }
    /**
     * @en The VolumetricGI class represents volumetric global illumination in the scene.
     * @zh VolumetricGI 类表示场景中的体积全局光照。
     */
    class VolumetricGI extends Volume {
        /** @internal */
        static BlockName: string;
        /** @internal */
        static SHADERDEFINE_VOLUMETRICGI: ShaderDefine;
        /** @internal */
        static VOLUMETRICGI_PROBECOUNTS: number;
        /** @internal */
        static VOLUMETRICGI_PROBESTEPS: number;
        /** @internal */
        static VOLUMETRICGI_PROBESTARTPOS: number;
        /** @internal */
        static VOLUMETRICGI_PROBEPARAMS: number;
        /** @internal */
        static VOLUMETRICGI_IRRADIANCE: number;
        /** @internal */
        static VOLUMETRICGI_DISTANCE: number;
        static init(): void;
        /**
         * @en The count of volumetric global illumination probes.
         * @zh 体积全局光照探针的数量。
         */
        static volumetricCount: number;
        /**
         * @en Get a globally unique ID.
         * @zh 获取一个全局唯一的ID。
         */
        static getID(): number;
        /** @internal IDE*/
        probeLocations: Float32Array;
        private _probeCounts;
        private _probeStep;
        /**
         * x: irradiance probe texel size
         * y: distance probe texel size
         * z: normalBias
         * w: viewBias
         */
        private _params;
        /**@internal */
        _volumetricProbeID: number;
        /**@internal */
        _dataModule: IVolumetricGIData;
        get shaderData(): ShaderData;
        /**
         * @en construct method, initialize VolumetricGI object.
         * @zh 构造方法，初始化VolumetricGI对象。
         */
        constructor();
        protected _onEnable(): void;
        private _irradiance;
        /**
         * @en Light probe irradiance texture.
         * @zh 光照探针辐照度纹理。
         */
        get irradiance(): Texture2D;
        set irradiance(value: Texture2D);
        private _distance;
        /**
         * @en Distance texture for light probe.
         * @zh 光照探针的距离纹理。
         */
        get distance(): Texture2D;
        set distance(value: Texture2D);
        /**
         * @en Normal bias for volumetric global illumination.
         * @zh 体积全局光照的法线偏移。
         */
        get normalBias(): number;
        set normalBias(value: number);
        /**
         * @en View bias for volumetric global illumination.
         * @zh 体积全局光照的视图偏移。
         */
        get viewBias(): number;
        set viewBias(value: number);
        /**
         * @en Number of texels per probe in the irradiance texture.
         * @zh 辐照度纹理中每个探针的纹素数量。
         */
        get irradianceTexel(): number;
        /**
         * @en Number of texels per probe in the distance texture.
         * @zh 距离纹理中每个探针的纹素数量。
         */
        get distanceTexel(): number;
        /**
         * @en The intensity of the reflection probe.
         * @zh 反射探针的强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The number of probes for volumetric global illumination.
         * @zh 体积全局光照的探针数量。
         */
        get probeCounts(): Vector3;
        set probeCounts(value: Vector3);
        /**
         * @en The step size between probes for volumetric global illumination.
         * @zh 体积全局光照探针之间的间隔。
         */
        get probeStep(): Vector3;
        set probeStep(value: Vector3);
        _reCaculateBoundBox(): void;
        /**
         * @internal
         */
        _onDestroy(): void;
        /**@internal */
        _cloneTo(dest: VolumetricGI): void;
    }
    /**
     * @internal
     * @en Manager class for Volumetric Global Illumination (GI).
     * @zh 体积全局光照(GI)管理器类。
     */
    class VolumetricGIManager implements IVolumeManager {
        /**
         * @en Whether all renders need to be updated.
         * @zh 是否需要更新所有渲染。
         */
        _needUpdateAllRender: boolean;
        private _GIVolumes;
        /**
         * @en Constructor, initialize the VolumetricGI manager.
         * @zh 构造函数，初始化体积全局光照(VolumetricGI)管理器。
         */
        constructor();
        /**
         * @en Remove Volumetric GI from the specified renderer.
         * @zh 从指定的渲染器中移除体积全局光照。
         */
        removeVolumetricGI(renderer: BaseRender): void;
        /**
         * @en Add a VolumetricGI volume to the collection.
         * @zh 添加一个体积全局光照(VolumetricGI)到集合中。
         */
        add(volume: VolumetricGI): void;
        /**
         * @en Remove a VolumetricGI volume from the collection.
         * @zh 从集合中移除一个体积全局光照(VolumetricGI)。
         */
        remove(volume: VolumetricGI): void;
        /**
         * @en Update the render object based on the current VolumetricGI volumes.
         * This method checks for overlap between the renderer's bounds and VolumetricGI volumes, and applies the most overlapping volume's settings to the renderer.
         * @param renderer The BaseRender object to update.
         * @zh 根据当前的体积全局光照(VolumetricGI)更新渲染对象。
         * 此方法检查渲染器边界与VolumetricGI之间的重叠，并将重叠最多的体积的设置应用于渲染器。
         * @param renderer 要更新的BaseRender对象。
         */
        _updateRenderObject(renderer: BaseRender): void;
        /**
         * @en Handle the list of motion objects by updating their VolumetricGI settings.
         * @param motionObjects A SingletonList of BaseRender objects representing motion objects.
         * @zh 处理运动对象列表，更新它们的体积全局光照(VolumetricGI)设置。
         * @param motionObjects 表示运动对象的BaseRender对象的SingletonList。
         */
        handleMotionlist(motionObjects: SingletonList<BaseRender>): void;
        /**
         * @en Recalculate VolumetricGI settings for all render objects.
         * @param renders A SingletonList of BaseRender objects to recalculate.
         * @zh 重新计算所有渲染对象的体积全局光照(VolumetricGI)设置。
         * @param renders 需要重新计算的BaseRender对象的SingletonList。
         */
        reCaculateAllRenderObjects(renders: SingletonList<BaseRender>): void;
        /**
         * @en Destroy the instance and release resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `BaseCamera` class is used to create the parent class of cameras.
     * @zh `BaseCamera` 类用于创建摄像机的父类。
     */
    class BaseCamera extends Sprite3D {
        /**
         * @internal
         * @en CameraUniformBlock Map
         * @zh 相机UniformBlock映射
         */
        static cameraUniformMap: CommandUniformMap;
        /** @internal */
        static cameraBlockName: string;
        /**Camera Uniform PropertyID */
        /**@internal */
        static CAMERAPOS: number;
        /**@internal */
        static VIEWMATRIX: number;
        /**@internal */
        static PROJECTMATRIX: number;
        /**@internal */
        static VIEWPROJECTMATRIX: number;
        /**@internal */
        static CAMERADIRECTION: number;
        /**@internal */
        static CAMERAUP: number;
        /**@internal */
        static VIEWPORT: number;
        /**@internal */
        static PROJECTION_PARAMS: number;
        /**@internal */
        static OPAQUETEXTURE: number;
        /**@internal */
        static OPAQUETEXTUREPARAMS: number;
        /**@internal */
        static DEPTHTEXTURE: number;
        /**@internal */
        static DEPTHNORMALSTEXTURE: number;
        /**@internal */
        static DEPTHZBUFFERPARAMS: number;
        /**@internal */
        static CAMERAUNIFORMBLOCK: number;
        /**Camera Define*/
        /**@internal */
        static SHADERDEFINE_FXAA: ShaderDefine;
        /** @internal */
        static RENDERINGTYPE_SHADERDEFINE_FXAA: string;
        /**渲染模式,延迟光照渲染，暂未开放。 @internal */
        static RENDERINGTYPE_DEFERREDLIGHTING: string;
        /**
         * @en Rendering mode: Forward rendering.
         * @zh 渲染模式：前向渲染。
         * @internal
         */
        static RENDERINGTYPE_FORWARDRENDERING: string;
        protected static _invertYScaleMatrix: Matrix4x4;
        protected static _invertYProjectionMatrix: Matrix4x4;
        protected static _invertYProjectionViewMatrix: Matrix4x4;
        /**
         * @internal
         * @en Initialize shader information
         * @zh 初始化着色器信息
         */
        static shaderValueInit(): void;
        /**
         * @en Initialize the Camera
         * @zh 初始化相机
         */
        static __init__(): void;
        /**
         * @internal
         * @en Rendering order.
         * @zh 渲染顺序。
         */
        _renderingOrder: number;
        /**
         * @en Near clipping plane.
         * @zh 近裁剪面。
         */
        protected _nearPlane: number;
        /**
         * @en Far clipping plane.
         * @zh 远裁剪面。
         */
        protected _farPlane: number;
        /**
         * @en Render engine.
         * @zh 渲染引擎。
         */
        protected _renderEngine: IRenderEngine;
        /**
         * @en The opening height at the farthest point of the camera.
         * @zh 相机最远处的开合高度。
         */
        private _yrange;
        /**
         * @en Field of view.
         * @zh 视野。
         */
        protected _fieldOfView: number;
        /**
         * @en Vertical size of orthographic projection.
         * @zh 正交投影的垂直尺寸。
         */
        private _orthographicVerticalSize;
        private _skyRenderElement;
        /**
         * @en Forward vector.
         * @zh 前向量。
         */
        _forward: Vector3;
        /**
         * @en Up vector.
         * @zh 上向量。
         */
        _up: Vector3;
        /**
         * @en Whether the camera uses orthographic projection.
         * @zh 是否使用正交投影。
         */
        protected _orthographic: boolean;
        /**
         * @en Whether to use a user-defined projection matrix. If a user projection matrix is used, changes to camera projection-related parameters will not affect the projection matrix value. The ResetProjectionMatrix method needs to be called to update it.
         * @zh 是否使用用户自定义投影矩阵。如果使用了用户投影矩阵，摄像机投影矩阵相关的参数改变则不改变投影矩阵的值，需调用ResetProjectionMatrix方法来更新。
         */
        protected _useUserProjectionMatrix: boolean;
        /**
         * @internal
         * @en Shader data.
         * @zh 着色器数据。
         */
        _shaderValues: ShaderData;
        /** @internal */
        _linearClearColor: Color;
        /**
         * @en The clear color of the camera. The default color is CornflowerBlue.
         * @zh 摄像机的清除颜色。默认颜色为CornflowerBlue。
         */
        private _clearColor;
        get clearColor(): Color;
        set clearColor(value: Color);
        /**
         * @en The culling mask value for visible layers, supporting mixed values. For example, cullingMask = Math.pow(2,0) | Math.pow(2,1) means layers 0 and 1 are visible.
         * @zh 可视层位标记遮罩值,支持混合 例:cullingMask=Math.pow(2,0)|Math.pow(2,1)为第0层和第1层可见。
         */
        private _cullingMask;
        /**
         * @internal
         * @en Static mask
         * @zh 静态遮罩
         */
        staticMask: number;
        /**
         * @en Whether to use occlusion culling during rendering.
         * @zh 渲染时是否使用遮挡剔除。
         */
        useOcclusionCulling: boolean;
        /**
         * @en Sky renderer element.
         * @zh 天空渲染器。
         */
        get skyRenderElement(): SkyRenderElement;
        /**
         * @en Field of view.
         * @zh 视野。
         */
        get fieldOfView(): number;
        set fieldOfView(value: number);
        /**
         * @en Maximum local distance.
         * @zh 最大本地距离。
         */
        get maxlocalYDistance(): number;
        /**
         * @en Near clipping plane.
         * @zh 近裁剪面。
         */
        get nearPlane(): number;
        set nearPlane(value: number);
        /**
         * @en Far clipping plane.
         * @zh 远裁剪面。
         */
        get farPlane(): number;
        set farPlane(vaule: number);
        /**
         * @en Whether to use orthographic projection matrix.
         * @zh 是否使用正交投影矩阵。
         */
        get orthographic(): boolean;
        set orthographic(vaule: boolean);
        /**
         * @en Vertical size of the orthographic projection.
         * @zh 正交投影的垂直尺寸。
         */
        get orthographicVerticalSize(): number;
        set orthographicVerticalSize(vaule: number);
        /**
         * @en Culling mask.
         * @zh 剔除遮罩。
         */
        get cullingMask(): number;
        set cullingMask(value: number);
        /**
         * @en Rendering order.
         * @zh 渲染顺序。
         */
        get renderingOrder(): number;
        set renderingOrder(value: number);
        /**
         * @en Constructor function.
         * @param nearPlane The near clipping plane. Default value is 0.3.
         * @param farPlane The far clipping plane. Default value is 1000.
         * @zh 构造函数。
         * @param nearPlane 近裁剪面。默认值为 0.3。
         * @param farPlane 远裁剪面。默认值为 1000。
         */
        constructor(nearPlane?: number, farPlane?: number);
        private _caculateMaxLocalYRange;
        protected _calculateProjectionMatrix(): void;
        protected _onScreenSizeChanged(): void;
        /**
         * @internal
         * @en Sort cameras by their RenderingOrder property.
         * @zh 通过 RenderingOrder 属性对摄像机进行排序。
         */
        _sortCamerasByRenderingOrder(): void;
        /**
         * @internal
         */
        _prepareCameraToRender(): void;
        /**
         * @en Camera rendering.
         * @param scene The scene to render.
         * @zh 相机渲染。
         * @param scene 要渲染的场景。
         */
        render(scene: Scene3D): void;
        /**
         * @en Add a visible layer, layer value ranges from 0 to 31.
         * @param layer The layer to add.
         * @zh 增加可视图层，layer值为0到31层。
         * @param layer 要添加的图层。
         */
        addLayer(layer: number): void;
        /**
         * @en Remove a visible layer, layer value ranges from 0 to 31.
         * @param layer The layer to remove.
         * @zh 移除可视图层，layer值为0到31层。
         * @param layer 要移除的图层。
         */
        removeLayer(layer: number): void;
        /**
         * @en Add all layers.
         * @zh 增加所有图层。
         */
        addAllLayers(): void;
        /**
         * @en Remove all layers.
         * @zh 移除所有图层。
         */
        removeAllLayers(): void;
        /**
         * @en Recalculate the projection matrix.
         * @zh 重新计算投影矩阵。
         */
        resetProjectionMatrix(): void;
        protected _onActive(): void;
        protected _onInActive(): void;
        /**
         * @en Destroy the camera.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁相机。
         * @param destroyChild 是否销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Camera clear flags.
     * @zh 相机清除标记。
     */
    enum CameraClearFlags {
        /**
         * @en Solid color.
         * @zh 固定颜色。
         */
        SolidColor = 0,
        /**
         * @en Sky.
         * @zh 天空。
         */
        Sky = 1,
        /**
         * @en Depth only.
         * @zh 仅深度。
         */
        DepthOnly = 2,
        /**
         * @en Do not clear.
         * @zh 不清除。
         */
        Nothing = 3,
        /**
         * @en Clear color only.
         * @zh 只清理颜色。
         */
        ColorOnly = 4
    }
    /**
     * @en Camera event flags.
     * @zh 相机事件标记。
     */
    enum CameraEventFlags {
        /**
         * @en Before rendering opaque objects.
         * @zh 在渲染非透明物体之前。
         */
        BeforeForwardOpaque = 0,
        /**
         * @en Before rendering the skybox.
         * @zh 在渲染天空盒之前。
         */
        BeforeSkyBox = 2,
        /**
         * @en Before rendering transparent objects.
         * @zh 在渲染透明物体之前。
         */
        BeforeTransparent = 4,
        /**
         * @en Before applying image effects.
         * @zh 在后期处理之前。
         */
        BeforeImageEffect = 6,
        /**
         * @en After all rendering is complete.
         * @zh 所有渲染之后。
         */
        AfterEveryThing = 8
    }
    /**
     * @en The Camera class is used to create cameras.
     * @zh Camera 类用于创建摄像机。
     */
    class Camera extends BaseCamera {
        /** @internal*/
        static _context3DViewPortCatch: Viewport;
        /**@internal */
        static _contextScissorPortCatch: Vector4;
        /**
         * @internal
         * @en Update flag
         * @zh 更新标志位
         */
        static get _updateMark(): number;
        static set _updateMark(value: number);
        /**
         * @internal
         * @en Depth map pipeline
         * @zh 深度贴图管线
         */
        static depthPass: DepthPass;
        /**
         * @en Get the rendering result of a certain position in the scene based on camera and scene information.
         * @param camera The camera
         * @param scene The scene to be rendered
         * @param renderTexture The render texture to draw to
         * @returns The rendered texture
         * @zh 根据相机、场景信息获得场景中某一位置的渲染结果。
         * @param camera 相机
         * @param scene 需要渲染的场景
         * @param renderTexture 要绘制到的渲染纹理
         * @returns 渲染后的纹理
         */
        static drawRenderTextureByScene(camera: Camera, scene: Scene3D, renderTexture: RenderTexture): RenderTexture;
        /**
         * @deprecated 请使用getTexturePixelAsync函数代替
         * get PixelTexture
         * 获得纹理的像素
         * @param texture 纹理
         * @returns
         */
        static getTexturePixel(texture: Texture2D): ArrayBufferView;
        /**
         * @en Get the pixels of a texture asynchronously
         * @param texture The texture
         * @returns A promise that resolves with the pixel data
         * @zh 获得纹理的像素
         * @param texture 纹理
         * @returns 解析为像素数据的 Promise
         */
        static getTexturePixelAsync(texture: Texture2D): Promise<ArrayBufferView>;
        /**
         * @en Draw scene content based on the camera's position in the scene and return it
         * @param camera The camera
         * @param scene The scene
         * @param renderCubeSize The pixel size of the cube texture
         * @param format The color format
         * @param cullingMask The culling mask
         * @returns Output texture pixels in order: back, front, left, right, up, down
         * @zh 根据场景中相机的位置绘制场景内容并返回
         * @param camera 相机
         * @param scene 场景
         * @param renderCubeSize 立方体纹理像素大小
         * @param format 颜色格式
         * @param cullingMask 剔除遮罩
         * @returns 输出纹理像素顺序：后、前、左、右、上、下
         */
        static drawTextureCubePixelByScene(camera: Camera, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask: number): ArrayBufferView[];
        /**
         * @en Draw the content of a specified scene to a cube map texture.
         * @param camera The camera used for rendering.
         * @param position The position of the camera.
         * @param scene The specified scene to render.
         * @param renderCubeSize The size of the cube map texture.
         * @param format The format of the cube map texture.
         * @param cullingMask The culling mask for the camera. Default is 0.
         * @returns The created cube map texture.
         * @zh 绘制指定场景的内容到立方体贴图。
         * @param camera 用于渲染的相机。
         * @param position 相机的位置。
         * @param scene 要渲染的指定场景。
         * @param renderCubeSize 立方体贴图的大小。
         * @param format 立方体贴图的格式。
         * @param cullingMask 相机的剔除遮罩。默认值为0。
         * @returns 创建的立方体贴图。
         */
        static drawTextureCubeByScene(camera: Camera, position: Vector3, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask?: number): TextureCube;
        /**
         * @internal
         */
        static __init__(): void;
        protected _aspectRatio: number;
        protected _viewport: Viewport;
        protected _rayViewport: Viewport;
        protected _normalizedViewport: Viewport;
        protected _viewMatrix: Matrix4x4;
        protected _projectionMatrix: Matrix4x4;
        protected _projectionViewMatrix: Matrix4x4;
        protected _boundFrustum: BoundFrustum;
        private _updateViewMatrix;
        private _updateViewProjectionMatrix;
        protected _postProcess: PostProcess;
        protected _enableHDR: boolean;
        private _viewportParams;
        private _projectionParams;
        protected _needBuiltInRenderTexture: boolean;
        protected _msaa: boolean;
        private _fxaa;
        private _depthTextureMode;
        _offScreenRenderTexture: RenderTexture;
        _internalRenderTexture: RenderTexture;
        /**
         * @internal
         * @en Whether to directly use the rendered depth map
         * @zh 是否直接使用渲染深度贴图
         */
        _canBlitDepth: boolean;
        /**@internal */
        _internalCommandBuffer: CommandBuffer;
        /**
         * @en Depth texture format
         * @zh 深度贴图格式
         */
        protected _depthTextureFormat: RenderTargetFormat;
        /**
         * @en Depth texture
         * @zh 深度贴图
         */
        private _depthTexture;
        /**
         * @en Depth normals texture
         * @zh 深度法线贴图
         */
        private _depthNormalsTexture;
        /**
         * @internal
         * @en Opaque objects texture
         * @zh 非透明物体贴图
         */
        _opaqueTexture: RenderTexture;
        /**
         * @en Whether to enable the opaque objects pass
         * @zh 是否开启非透明物体通道
         */
        private _opaquePass;
        /** @internal */
        _cameraEventCommandBuffer: {
            [key: string]: CommandBuffer[];
        };
        /**
         * @en Implement shadow rendering using CommandBuffer
         * @zh 实现CommandBuffer的阴影渲染
         */
        private _shadowCasterCommanBuffer;
        /** @internal */
        _clusterXPlanes: Vector3[];
        /** @internal */
        _clusterYPlanes: Vector3[];
        /** @internal */
        _clusterPlaneCacheFlag: Vector2;
        /** @internal */
        _screenOffsetScale: Vector4;
        /**
         * @en Whether rendering is allowed.
         * @zh 是否允许渲染。
         */
        enableRender: boolean;
        /**
         * @en Clear flag.
         * @zh 清除标记。
         */
        clearFlag: CameraClearFlags;
        /**
         * @internal
         * @en Whether to cache the depth texture from the previous frame.
         * @zh 是否缓存上一帧的深度纹理。
         */
        _cacheDepth: boolean;
        /**
         * @internal
         * @en Cached texture from the previous frame.
         * @zh 缓存的上一帧纹理。
         */
        _cacheDepthTexture: RenderTexture;
        _renderDataModule: ICameraNodeData;
        private _Render3DProcess;
        /**
         * @en The near clipping plane of the camera.
         * @param value The distance to the near clipping plane.
         * @zh 相机的近裁剪平面。
         * @param value 近裁剪平面的距离。
         */
        set nearPlane(value: number);
        get nearPlane(): number;
        /**
         * @en The far clipping plane of the camera.
         * @param value The distance to the far clipping plane.
         * @zh 相机的远裁剪平面。
         * @param value 远裁剪平面的距离。
         */
        set farPlane(value: number);
        get farPlane(): number;
        /**
         * @en Set the field of view of the camera.
         * @param value The field of view in degrees.
         * @zh 设置相机的视野。
         * @param value 单位为度。
         */
        set fieldOfView(value: number);
        get fieldOfView(): number;
        /**
         * @en The aspect ratio of the camera.
         * @zh 相机的横纵比。
         */
        get aspectRatio(): number;
        set aspectRatio(value: number);
        /**
         * @en The viewport in screen pixel coordinates.
         * @zh 屏幕像素坐标的视口。
         */
        get viewport(): Viewport;
        set viewport(value: Viewport);
        /**
         * @en The display width of the camera.
         * @zh 相机显示宽度。
         */
        get clientWidth(): number;
        /**
         * @en The display height of the camera.
         * @zh 相机显示高度。
         */
        get clientHeight(): number;
        /**
         * @en Multi-sample anti-aliasing.
         * @zh 多重采样抗锯齿。
         */
        set msaa(value: boolean);
        get msaa(): boolean;
        /**
         * @en Space anti-aliasing.
         * @zh 空间抗锯齿
         */
        set fxaa(value: boolean);
        get fxaa(): boolean;
        /**
         * @en The viewport in clip space.
         * @zh 裁剪空间的视口。
         */
        get normalizedViewport(): Viewport;
        set normalizedViewport(value: Viewport);
        /**
         * @en Get the view matrix.
         * @zh 视图矩阵。
         */
        get viewMatrix(): Matrix4x4;
        /**
         * @en The projection matrix.
         * @zh 投影矩阵。
         */
        get projectionMatrix(): Matrix4x4;
        set projectionMatrix(value: Matrix4x4);
        /**
         * @en The projection view matrix.
         * @zh 视图投影矩阵。
         */
        get projectionViewMatrix(): Matrix4x4;
        private updateViewProjectionMatrix;
        /**
         * @en The bound frustum of the camera.
         * @zh 摄像机视锥。
         */
        get boundFrustum(): BoundFrustum;
        /**
         * @en Customize the rendering target for the scene.
         * @zh 自定义渲染场景的渲染目标。
         */
        get renderTarget(): RenderTexture;
        set renderTarget(value: RenderTexture);
        /**
         * @en Post processing.
         * @zh 后期处理。
         */
        get postProcess(): PostProcess;
        set postProcess(value: PostProcess);
        /**
         * @en Whether to enable HDR. Enabling it has a certain impact on performance.
         * @zh 是否开启HDR。开启后对性能有一定影响。
         */
        get enableHDR(): boolean;
        set enableHDR(value: boolean);
        /**
         * @en Whether to use the RenderTexture being rendered for CommandBuffer service. Set to true when used with CommandBuffer.
         * @zh 是否使用正在渲染的 RenderTexture 为 CommandBuffer 服务。通常与 CommandBuffer 一起使用时设置为 true。
         */
        get enableBuiltInRenderTexture(): boolean;
        set enableBuiltInRenderTexture(value: boolean);
        /**
         * @en The depth texture mode for the camera.
         * @zh 相机的深度纹理模式。
         */
        get depthTextureMode(): DepthTextureMode;
        set depthTextureMode(value: DepthTextureMode);
        /**
         * @en Set the Opaque Pass mode for the camera.
         * @zh 相机的不透明通道模式。
         */
        set opaquePass(value: boolean);
        get opaquePass(): boolean;
        opaqueTextureSize: number;
        /**
         * @en The format of the depth texture.
         * @zh 深度纹理的格式。
         */
        get depthTextureFormat(): RenderTargetFormat;
        set depthTextureFormat(value: RenderTargetFormat);
        /**
         * @en Enable or disable the use of built-in depth texture (TODO: If enabled, the depth texture can only be used in post-processing, not in the rendering process).
         * @zh 设置是否使用内置的深度纹理（TODO:如果开启，深度纹理只能在后期处理中使用，不能在渲染流程中使用）。
         */
        set enableBlitDepth(value: boolean);
        get enableBlitDepth(): boolean;
        /**
         * @en Whether the camera can blit (draw) the depth texture.
         * @zh 相机是否可以绘制深度纹理。
         */
        get canblitDepth(): boolean;
        /**
         * @en Creates an instance of the Camera.
         * @param aspectRatio The aspect ratio of the camera view.
         * @param nearPlane The near clipping plane distance.
         * @param farPlane The far clipping plane distance.
         * @zh 创建一个Camera实例。
         * @param aspectRatio 横纵比。
         * @param nearPlane 近裁面。
         * @param farPlane 远裁面。
         */
        constructor(aspectRatio?: number, nearPlane?: number, farPlane?: number);
        private _calculationViewport;
        protected _calculateProjectionMatrix(): void;
        /**
         * @internal
         * @en Check if a layer is visible based on the culling mask.
         * @param layer The layer to check.
         * @returns Whether the layer is visible.
         * @zh 通过蒙版值获取蒙版是否显示。
         * @param layer 要检查的图层。
         * @returns 图层是否可见。
         */
        _isLayerVisible(layer: number): boolean;
        /**
         * @internal
         */
        _onTransformChanged(flag: number): void;
        /**
         * @en Clone the camera.
         * @zh 克隆相机。
         */
        clone(): Camera;
        /**
         * @internal
         */
        _getCanvasWidth(): number;
        /**
         * @internal
         */
        _getCanvasHeight(): number;
        /**
         * @internal
         */
        _getRenderTexture(): RenderTexture;
        /**
         * @internal
         * @en Determine if the render result needs gamma correction.
         * @param rt The render target format to check.
         * @returns Whether gamma correction is needed for the given render target format.
         * @zh 判断渲染结果是否需要 Gamma 校正。
         * @param rt 要检查的渲染目标格式。
         * @returns 给定的渲染目标格式是否需要 Gamma 校正。
         */
        _needRenderGamma(rt: RenderTargetFormat): boolean;
        /**
         * @internal
         */
        _needInternalRenderTexture(): boolean;
        /**
         * @internal
         */
        _getRenderTextureFormat(): RenderTargetFormat;
        /**
         * @internal
         * update Camera Render
         * @param context
         */
        _updateCameraRenderData(context: RenderContext3D): void;
        /**
         * @internal
         */
        _prepareCameraToRender(): void;
        /**
         * @internal
         * @param context
         */
        _contextApply(context: RenderContext3D): void;
        /**
         * @internal
         */
        _applyViewProject(viewMat: Matrix4x4, proMat: Matrix4x4, invertY: boolean): void;
        /**
         * @internal
         */
        _updateClusterPlaneXY(): void;
        /**
        * @internal
        */
        _addCasterShadowCommandBuffer(commandBuffer: CommandBuffer): void;
        /**
         * @internal
         * @param commandBuffer
         */
        _removeCasterShadowCommandBuffer(commandBuffer: CommandBuffer): void;
        /**
         * @internal
         * @en Pre-render process for the main rendering pass.
         * @param context The rendering context.
         * @param scene The scene to be rendered.
         * @param needInternalRT Whether an internal render target is needed.
         * @param viewport The viewport for rendering.
         * @zh 主渲染流程之前的预处理过程。
         * @param context 渲染上下文。
         * @param scene 要渲染的场景。
         * @param needInternalRT 是否需要内部渲染目标。
         * @param viewport 渲染的视口。
         */
        _preRenderMainPass(context: RenderContext3D, scene: Scene3D, needInternalRT: boolean, viewport: Viewport): void;
        /**
         * @internal
         * @en The depth texture of the camera.
         * @zh 相机的深度纹理。
         */
        get depthTexture(): BaseTexture;
        set depthTexture(value: BaseTexture);
        /**
         * @internal
         * @en The depth-normal texture of the camera.
         * @zh 相机的深度法线纹理。
         */
        get depthNormalTexture(): RenderTexture;
        set depthNormalTexture(value: RenderTexture);
        /**
         * @internal
         */
        _aftRenderMainPass(): void;
        /**
         * @internal
         * @en Create the opaque pass texture.
         * @zh 创建不透明通道纹理。
         */
        _createOpaqueTexture(): void;
        /**
         * @en Render the scene.
         * @param scene The scene to render.
         * @zh 渲染场景。
         * @param scene 要渲染的场景。
         */
        render(scene: Scene3D): void;
        /**
         * @en Calculate a ray from screen space.
         * @param point The position in screen space.
         * @param out The output ray.
         * @zh 计算从屏幕空间生成的射线。
         * @param point 屏幕空间的位置位置。
         * @param out  输出射线。
         */
        viewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * @en Calculate a ray from normalized viewport space.
         * @param point The position in normalized viewport space.
         * @param out The output ray.
         * @zh 计算从归一化视口空间生成的射线。
         * @param point 裁切空间的位置。
         * @param out  输出射线。
         */
        normalizedViewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * @en Transform a point from world space to viewport space.
         * @param position The coordinate in world space.
         * @param out x, y, z are viewport space coordinates, w is the z-axis coordinate relative to the camera.
         * @zh 将一个点从世界空间转换到视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * @en Transform a point from world space to normalized viewport space.
         * @param position The coordinate in world space.
         * @param out x, y, z are normalized viewport space coordinates, w is the z-axis coordinate relative to the camera.
         * @zh 将一个点从世界空间转换到归一化视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为归一化视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToNormalizedViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * @en Convert 2D screen coordinate system to 3D orthographic projection coordinate system. Note: Only valid under orthographic model.
         * @param source The source coordinate.
         * @param out The output coordinate.
         * @returns Whether the conversion was successful.
         * @zh 转换2D屏幕坐标系统到3D正交投影下的坐标系统，注：只有正交模型下有效。
         * @param   source 源坐标。
         * @param   out 输出坐标。
         * @return 是否转换成功。
         */
        convertScreenCoordToOrthographicCoord(source: Vector3, out: Vector3): boolean;
        /**
         * @en Destroy the Camera node.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 删除Camera节点。
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Add a command buffer to the camera's rendering pipeline.
         * @param event The camera event flag.
         * @param commandBuffer The rendering command buffer.
         * @zh 增加camera渲染节点渲染缓存。
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        addCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * @en Remove a command buffer from the camera's rendering pipeline.
         * @param event The camera event flag.
         * @param commandBuffer The rendering command buffer to remove.
         * @zh 移除camera渲染节点渲染缓存。
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        removeCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * @en Remove all command buffers for a specific camera event.
         * @param event The camera event flag.
         * @zh 移除camera相机节点的所有渲染缓存。
         * @param event 相机事件标志
         */
        removeCommandBuffers(event: CameraEventFlags): void;
        /** @internal [NATIVE]*/
        _boundFrustumBuffer: Float32Array;
    }
    /**
     * @en The `GeometryElement` class is used to implement geometric elements. This class is abstract.
     * @zh `GeometryElement` 类用于实现几何体元素，该类为抽象类。
     */
    class GeometryElement {
        /** @internal */
        private static _uniqueIDCounter;
        protected _owner: any;
        static _typeCounter: number;
        /**@internal */
        protected _destroyed: boolean;
        _geometryElementOBj: IRenderGeometryElement;
        /** @internal */
        _id: number;
        protected _bufferState: BufferState;
        /**
         * @en VAO (Vertex Array Object) instance
         * @zh VAO (顶点数组对象) 实例
         */
        set bufferState(value: BufferState);
        get bufferState(): BufferState;
        /**
         * @en Mesh topology type
         * @zh 网格拓扑类型
         */
        set mode(value: MeshTopology);
        get mode(): MeshTopology;
        /**
         * @en Draw type
         * @zh 绘制类型
         */
        set drawType(value: number);
        get drawType(): number;
        /**
         * @en Set parameters for drawing arrays
         * @param first The starting index in the array
         * @param count The number of indices to be rendered
         * @zh 设置绘制数组的参数。
         * @param first 数组起始索引。
         * @param count 要渲染的索引数量。
         */
        setDrawArrayParams(first: number, count: number): void;
        /**
         * @en Set parameters for drawing elements
         * @param count The number of elements to be rendered
         * @param offset The starting offset in the element array
         * @zh 设置绘制元素的参数。
         * @param count 要渲染的元素数量。
         * @param offset 元素数组的起始偏移。
         */
        setDrawElemenParams(count: number, offset: number): void;
        /**
         * @en Number of instances to draw
         * @zh 要绘制的实例数量
         */
        set instanceCount(value: number);
        get instanceCount(): number;
        /**
         * @en Index buffer format
         * @zh 索引缓冲区格式
         */
        set indexFormat(value: IndexFormat);
        get indexFormat(): IndexFormat;
        /**
         * @en Get whether the object is destroyed
         * @zh 获取是否已销毁
         */
        get destroyed(): boolean;
        /**
         * @ignore
         * @en Creates an instance of GeometryElement.
         * @param mode The topology used by the mesh.
           * @param drawType The draw type used for rendering.
         * @zh 创建一个 GeometryElement 的实例。
         * @param mode 网格使用的拓扑结构。
         * @param drawType 用于渲染的绘制类型。
         */
        constructor(mode: MeshTopology, drawType: DrawType);
        /**
         * @en Get the geometry type
         * @zh 获取几何体类型
         */
        _getType(): number;
        /**
         * @internal
         * @en Whether rendering is needed
         * @param state The render context
         * @returns Whether rendering is needed
         * @zh 是否需要渲染。
         * @param state 渲染上下文。
         * @return 是否需要渲染。
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @internal
         * @en Update geometry data
         * @param state The render context
         * @zh 更新几何体数据
         * @param state 渲染上下文。
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Destroy the object
         * @zh 销毁对象
         */
        destroy(): void;
        /**
         * @en Clear render parameters
         * @zh 清除渲染参数
         */
        clearRenderParams(): void;
    }
    enum AreaShape {
        rectangle = 0,
        ellipse = 1
    }
    /**
     * @en The AreaLightCom class is used to create area lights.
     * @zh AreaLightCom 类用于创建区域光。
     */
    class AreaLightCom extends Light {
        private _areaShape;
        private _power;
        private _size;
        private _spread;
        private _maxBounces;
        /**
         * @ignore
         * @en Creates an instance of AreaLightCom.
         * @zh 创建一个 AreaLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        /**
         * @en The lightmap baked type.
         * @zh 灯光烘焙类型。
         */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        /**
         * @en The area light shape.
         * @zh 区域光的形状。
         */
        get shape(): AreaShape;
        set shape(value: AreaShape);
        /**
         * @en The light intensity.
         * @zh 光照强度。
         */
        get power(): number;
        set power(value: number);
        /**
         * @en The size of the area light.
         * @zh 区域光大小。
         */
        get size(): Vector2;
        set size(value: Vector2);
        /**
         * @en The spread angle of the area light.
         * @zh 区域光的辐射角度。
         */
        get spread(): number;
        set spread(value: number);
        /**
         * @en The maximum number of light bounces.
         * @zh 区域光的最大反弹次数。
         */
        get maxBounces(): number;
        set maxBounces(value: number);
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
    }
    /**
     * @en DirectionLight used to create parallel light.
     * @zh DirectionLight 类用于创建方向光。
     */
    class DirectionLightCom extends Light {
        /**@internal */
        _dataModule: IDirectLightData;
        /** @internal */
        private _direction;
        /** @internal */
        _shadowTwoCascadeSplits: number;
        /** @internal */
        _shadowFourCascadeSplits: Vector3;
        /**
         * @en The direction of the directional light.
         * @zh 方向光的方向。
         */
        get direction(): Vector3;
        set direction(value: Vector3);
        /**
         * @en The number of shadow cascades.
         * @zh 阴影级联数量。
         */
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        /**
         * @en The split ratio for two cascade shadows.
         * @zh 二级级联阴影分割比例。
         */
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        /**
         * @en The split ratios for four cascade shadows. X, Y, Z represent the split ratios in order. Z must be greater than Y, and Y must be greater than X.
         * @zh 四级级联阴影分割比例。X、Y、Z依次为其分割比例，Z必须大于Y，Y必须大于X。
         */
        get shadowFourCascadeSplits(): Vector3;
        set shadowFourCascadeSplits(value: Vector3);
        /**
         * @ignore
         * @en Creates an instance of DirectionLight.
         * @zh 创建一个 DirectionLight 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
    }
    /**
     * @en Light type.
     * @zh 灯光类型。
     */
    enum LightType {
        Directional = 0,
        Spot = 1,
        Point = 2,
        Area = 3
    }
    /**
     * @en Light mode.
     * @zh 灯光模式。
     */
    enum LightMode {
        mix = 0,
        realTime = 1,
        bakeOnly = 2
    }
    /**
     * @en LightSprite is the base class for creating light sources.
     * @zh LightSprite 类用于创建灯光的父类。
     */
    class Light extends Component {
        /**@internal 下沉数据集合 */
        protected _dataModule: IDirectLightData | ISpotLightData | IPointLightData;
        /** @internal */
        protected _shadowMode: ShadowMode;
        /** @internal */
        private _isAlternate;
        /** @internal */
        _intensityColor: Vector3;
        /** @internal */
        _intensity: number;
        /** @internal */
        _lightmapBakedType: LightMode;
        /** @internal */
        _lightType: LightType;
        /**
         * @internal
         * @en The light world matrix,because the scale will affect the clipping of the shadow
         * @zh 因为scale会影响裁剪阴影
         */
        _lightWoldMatrix: Matrix4x4;
        /**
         * @en The light color.
         * @zh 灯光颜色。
         */
        color: Color;
        readonly owner: Sprite3D;
        /**
         * @en The light intensity.
         * @zh 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en Shadow mode.
         * @zh 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * @en The maximum shadow distance.
         * @zh 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * @en The shadow map resolution.
         * @zh 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * @en The shadow depth bias.
         * @zh 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * @en The shadow normal bias.
         * @zh 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * @en The shadow strength.
         * @zh 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * @en The near cut surface of the shadow cone.
         * @zh 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * @en Light baking type
         * @zh 灯光烘培类型。
         */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        /**
         * @en The light world matrix.
         * @zh 灯光世界矩阵
         */
        get lightWorldMatrix(): Matrix4x4;
        /**
         * @en The light type.
         * @zh 灯光类型
         */
        get lightType(): LightType;
        /**
         * @ignore
         * @en Creates an instance of Light.
         * @zh 创建一个 Light 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        /**@internal */
        _setOwner(node: Sprite3D): void;
        /**@internal */
        _getRenderDataModule(): IDirectLightData | ISpotLightData | IPointLightData;
        /**
         * @internal
         */
        _cloneTo(dest: Light): void;
        private _addToScene;
        private _removeFromScene;
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
    }
    /**
     * @internal
     * @en The `LightQueue` class manages a queue of lights.
     * @zh `LightQueue` 类管理一个灯光队列
     */
    class LightQueue<T extends Light> {
        _length: number;
        _elements: T[];
        /**
         * @en Adds a light to the queue.
         * @zh 向队列中添加一个灯光。
         */
        add(light: T): void;
        /**
         * @en Removes a light from the queue.
         * @zh 从队列中移除一个灯光。
         */
        remove(light: T): void;
        /**
         * @en Removes and returns the first light in the queue.
         * @zh 移除并返回队列中的第一个灯光。
         */
        shift(): T | undefined;
        /**
         * @en Gets the index of the brightest light in the queue.
         * @zh 获取队列中最亮的灯光的索引。
         */
        getBrightestLight(): number | undefined;
        /**
         * @en Rearranges the lights in the queue to ensure the brightest light is first.
         * @zh 重新排列队列中的灯光，确保最亮的灯光在最前面。
         */
        normalLightOrdering(brightestIndex: number): void;
    }
    /**
     * @internal
     * @en The `AlternateLightQueue` class extends the `LightQueue` class, and overrides the remove method.
     * @zh `AlternateLightQueue` 类继承自 `LightQueue` 类，重写了移除灯光的方法
     */
    class AlternateLightQueue extends LightQueue<Light> {
        /**
         * @en Removes a light from the queue.
         * @zh 从队列中移除灯光。
         */
        remove(light: Light): void;
    }
    /**
     * @ignore
     * @deprecated
     * <code>LightSprite</code> 类用于创建灯光的父类。
     */
    class LightSprite extends Sprite3D {
        /** @internal */
        _light: Light;
        /**
         * 灯光颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * 灯光烘焙模式
         */
        get mode(): LightMode;
        set mode(value: LightMode);
        /**
         * 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * 灯光烘培类型。
         */
        get lightmapBakedType(): number;
        set lightmapBakedType(value: number);
        /**
         * 获取灯光世界矩阵
         */
        get lightWorldMatrix(): Matrix4x4;
        /**
         * 创建一个 <code>LightSprite</code> 实例。
         */
        constructor();
        /**
         * @internal
         */
        _cloneTo(destObject: LightSprite, rootSprite: Node, dstSprite: Node): void;
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
    }
    /**
     * @en The `PointLightCom` class represents a point light source in the scene.
     * @zh `PointLightCom` 类表示场景中的点光源。
     */
    class PointLightCom extends Light {
        /**
         * @en Declares the data module for point light.
         * @zh 声明点光源的数据模块。
         */
        _dataModule: IPointLightData;
        private _range;
        /**
         * @en The range of the point light.
         * @zh 点光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * @ignore
         * @en Creates an instance of PointLightCom.
         * @zh 创建一个 PointLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
        /**
         * @internal
         */
        _cloneTo(dest: PointLightCom): void;
    }
    /**
     * @en Shadow cascade mode.
     * @zh 阴影的级联模式。
     */
    enum ShadowCascadesMode {
        /**
         * @en No cascades.
         * @zh 无级联。
         */
        NoCascades = 0,
        /**
         * @en Two-level cascades.
         * @zh 二级级联。
         */
        TwoCascades = 1,
        /**
         * @en Four-level cascades.
         * @zh 四级级联。
         */
        FourCascades = 2
    }
    /**
     * @en The shadow mode.
     * @zh 阴影模式。
     */
    enum ShadowMode {
        /**
         * @en No shadows are produced.
         * @zh 不产生阴影。
         */
        None = 0,
        /**
         * @en Hard shadows with lower performance requirements.
         * @zh 硬阴影，对性能要求较低。
         */
        Hard = 1,
        /**
         * @en Soft shadows with low intensity, moderate performance requirements.
         * @zh 低强度软阴影，对性能要求一般。
         */
        SoftLow = 2,
        /**
         * @en Soft shadows with high intensity, higher performance requirements.
         * @zh 高强度软阴影，对性能要求较高。
         */
        SoftHigh = 3
    }
    /**
     * @en Enum representing the format of the shadow map.
     * @zh 表示阴影贴图格式的枚举。
     */
    enum ShadowMapFormat {
        bit16 = 0,
        bit24_8 = 1,
        bit32 = 2
    }
    /**
     * @internal
     * @en Utility class for shadow-related calculations and operations.
     * @zh 用于阴影相关计算和操作的实用工具类。
     */
    class ShadowUtils {
        /** @internal */
        private static _adjustNearPlane;
        /** @internal */
        private static _adjustFarPlane;
        /** @internal */
        private static _backPlaneFaces;
        /** @internal */
        private static _edgePlanePoint2;
        /**
         * @internal
         * @en The size of the border for the shadow atlas, which is used to avoid shadow artifacts. Now the maximum shadow sample tent is 5x5, so the atlas border size should be at least 3 (ceiling of 2.5), plus 1 pixel for the global border in no cascade mode.
         * @zh 阴影图集的边框大小，用于避免阴影伪影。当前最大阴影采样罩是5x5，因此图集边框大小至少应为3（2.5的上取整），再加上1像素用于无级联模式下的全局边框。
         */
        static readonly atlasBorderSize: number;
        /**
         * @en Initializes the shadow utility with default planes for adjusting the near and far planes.
         * @zh 使用默认平面初始化阴影工具，以调整近平面和远平面。
         */
        static init(): void;
        /**
         * @internal
         * @en Checks if shadow rendering is supported by the current rendering engine.
         * @zh 检查当前渲染引擎是否支持阴影渲染。
         */
        static supportShadow(): boolean;
        /**
         * @internal
         * @en Creates a temporary shadow texture with the specified dimensions and format.
         * @param width The width of the shadow texture.
         * @param height The height of the shadow texture.
         * @param shadowFormat The format of the shadow map.
         * @zh 创建一个具有指定尺寸和格式的临时阴影纹理。
         * @param width 阴影纹理的宽度。
         * @param height 阴影纹理的高度。
         * @param shadowFormat 阴影贴图的格式。
         */
        static getTemporaryShadowTexture(witdh: number, height: number, shadowFormat: ShadowMapFormat): RenderTexture;
        /**
         * @internal
         * @en Calculates the shadow bias for a light based on the shadow projection matrix and shadow resolution.
         * @param light The light source.
         * @param shadowProjectionMatrix The shadow projection matrix.
         * @param shadowResolution The resolution of the shadow map.
         * @param out The output vector to store the calculated depth and normal bias values.
         * @zh 根据阴影投影矩阵和阴影分辨率为光源计算阴影偏差。
         * @param light 光源。
         * @param shadowProjectionMatrix 阴影投影矩阵。
         * @param shadowResolution 阴影贴图的分辨率。
         * @param out 输出向量，用于存储计算出的深度和法线偏差值。
         */
        static getShadowBias(light: Light, shadowProjectionMatrix: Matrix4x4, shadowResolution: number, out: Vector4): void;
        /**
         * @internal
         * @en Retrieves the frustum planes from the camera's view-projection matrix.
         * @param cameraViewProjectMatrix The combined camera view and projection matrix.
         * @param frustumPlanes An array to store the retrieved frustum planes.
         * @zh 从相机的视图投影矩阵中检索透视体的各个平面。
         * @param cameraViewProjectMatrix 相机的视图和投影矩阵。
         * @param frustumPlanes 一个数组，用于存储检索到的透视体平面。
         */
        static getCameraFrustumPlanes(cameraViewProjectMatrix: Matrix4x4, frustumPlanes: Plane[]): void;
        /**
         * @internal
         * @en Calculates the far distance based on the given radius and denominator.
         * @param radius The radius used for calculation.
         * @param denominator The denominator used in the calculation.
         * @zh 根据给定的半径和分母计算远距离。
         * @param radius 用于计算的半径。
         * @param denominator 计算中使用的分母。
         */
        static getFarWithRadius(radius: number, denominator: number): number;
        /**
         * @internal
         * @en Calculates the split distances for cascade shadow mapping.
         * @param twoSplitRatio The split ratio for two cascades.
         * @param fourSplitRatio The split ratios for four cascades.
         * @param cameraNear The near plane distance of the camera.
         * @param shadowFar The far plane distance for shadow rendering.
         * @param fov The field of view of the camera.
         * @param aspectRatio The aspect ratio of the camera.
         * @param cascadesMode The cascade mode (NoCascades, TwoCascades, or FourCascades).
         * @param out The output array to store the calculated split distances.
         * @zh 计算级联阴影映射的分割距离。
         * @param twoSplitRatio 两级级联的分割比例。
         * @param fourSplitRatio 四级级联的分割比例。
         * @param cameraNear 相机的近平面距离。
         * @param shadowFar 阴影渲染的远平面距离。
         * @param fov 相机的视野角度。
         * @param aspectRatio 相机的宽高比。
         * @param cascadesMode 级联模式（无级联、两级级联或四级级联）。
         * @param out 用于存储计算得出的分割距离的输出数组。
         */
        static getCascadesSplitDistance(twoSplitRatio: number, fourSplitRatio: Vector3, cameraNear: number, shadowFar: number, fov: number, aspectRatio: number, cascadesMode: ShadowCascadesMode, out: number[]): void;
        /**
         * @internal
         * @en Applies transformation to the shadow slice.
         * @param shadowSliceData The data containing the resolution and offset for the shadow slice.
         * @param atlasWidth The width of the shadow map atlas.
         * @param atlasHeight The height of the shadow map atlas.
         * @param cascadeIndex The index of the cascade to apply the transformation to.
         * @param outShadowMatrices The output array to store the transformed shadow matrices.
         * @zh 对阴影切片应用变换。
         * @param shadowSliceData 包含阴影切片的分辨率和偏移量的数据。
         * @param atlasWidth 阴影图集的宽度。
         * @param atlasHeight 阴影图集的高度。
         * @param cascadeIndex 要应用变换的级联索引。
         * @param outShadowMatrices 输出数组，用于存储变换后的阴影矩阵。
         */
        static applySliceTransform(shadowSliceData: ShadowSliceData, atlasWidth: number, atlasHeight: number, cascadeIndex: number, outShadowMatrices: Float32Array): void;
        /**
         * @internal
         * @en Calculates the culling planes for a directional light shadow from the camera frustum planes and the specified cascade index.
         * @param cameraFrustumPlanes Array containing the planes of the camera frustum.
         * @param cascadeIndex The index of the cascade for which to calculate the shadow culling planes.
         * @param splitDistance Array containing the split distances for the shadow cascades.
         * @param cameraNear The near plane distance of the camera.
         * @param direction The direction of the directional light.
         * @param shadowSliceData The data structure to store the calculated culling planes and related information.
         * @zh 根据相机透视体平面和指定的级联索引计算定向光阴影的剔除平面。
         * @param cameraFrustumPlanes 包含相机透视体平面的数组。
         * @param cascadeIndex 要计算阴影剔除平面的级联索引。
         * @param splitDistance 包含阴影级联分割距离的数组。
         * @param cameraNear 相机的近平面距离。
         * @param direction 定向光的方向。
         * @param shadowSliceData 用于存储计算得到的剔除平面和相关信息的数据结构。
         */
        static getDirectionLightShadowCullPlanes(cameraFrustumPlanes: Array<Plane>, cascadeIndex: number, splitDistance: number[], cameraNear: number, direction: Vector3, shadowSliceData: ShadowSliceData): void;
        /**
         * @internal
         * @en Calculates the minimal bounding sphere of a frustum defined by a camera.
         * @param near The distance to the near plane of the frustum.
         * @param far The distance to the far plane of the frustum.
         * @param fov The field of view angle of the camera.
         * @param aspectRatio The aspect ratio of the camera.
         * @param cameraPos The position of the camera.
         * @param forward The forward direction of the camera.
         * @param outBoundSphere The output bound sphere containing the calculated center and radius.
         * @returns The calculated center Z position of the bounding sphere.
         * @zh 计算由相机定义的透视体的最小边界球。
         * @param near 到透视体近平面的距离。
         * @param far 到透视体远平面的距离。
         * @param fov 相机的视野角度。
         * @param aspectRatio 相机的宽高比。
         * @param cameraPos 相机的位置。
         * @param forward 相机的前方向。
         * @param outBoundSphere 输出边界球，包含计算得到的中心和半径。
         * @returns 计算得到的边界球的中心 Z 位置。
         */
        static getBoundSphereByFrustum(near: number, far: number, fov: number, aspectRatio: number, cameraPos: Vector3, forward: Vector3, outBoundSphere: BoundSphere): number;
        /**
         * @internal
         * @en Calculates the maximum tile resolution that can fit in the given atlas dimensions.
         * @param atlasWidth The width of the atlas.
         * @param atlasHeight The height of the atlas.
         * @param tileCount The number of tiles to fit in the atlas.
         * @zh 计算在给定的图集尺寸内可以容纳的最大瓦片分辨率。
         * @param atlasWidth 图集的宽度。
         * @param atlasHeight 图集的高度。
         * @param tileCount 需要在图集中容纳的瓦片数量。
         */
        static getMaxTileResolutionInAtlas(atlasWidth: number, atlasHeight: number, tileCount: number): number;
        /**
         * @internal
         * @en Calculates the matrices for directional light shadows.
         * @param lightUp The up vector of the light.
         * @param lightSide The side vector of the light.
         * @param lightForward The forward vector of the light.
         * @param cascadeIndex The index of the current cascade.
         * @param nearPlane The near plane distance.
         * @param shadowResolution The resolution of the shadow map.
         * @param shadowSliceData The data for the shadow slice.
         * @param shadowMatrices The output array for the calculated shadow matrices.
         * @zh 计算定向光阴影的矩阵。
         * @param lightUp 光源的上向量。
         * @param lightSide 光源的侧向量。
         * @param lightForward 光源的前向量。
         * @param cascadeIndex 当前级联的索引。
         * @param nearPlane 近平面距离。
         * @param shadowResolution 阴影贴图的分辨率。
         * @param shadowSliceData 阴影切片的数据。
         * @param shadowMatrices 用于存储计算得出的阴影矩阵的输出数组。
         */
        static getDirectionalLightMatrices(lightUp: Vector3, lightSide: Vector3, lightForward: Vector3, cascadeIndex: number, nearPlane: number, shadowResolution: number, shadowSliceData: ShadowSliceData, shadowMatrices: Float32Array): void;
        /**
         * @internal
         * @en Prepares shader values for shadow receivers.
         * @param shadowMapWidth The width of the shadow map.
         * @param shadowMapHeight The height of the shadow map.
         * @param shadowSliceDatas An array of ShadowSliceData objects.
         * @param cascadeCount The number of shadow cascades.
         * @param shadowMapSize A Vector4 to store shadow map size information.
         * @param shadowMatrices A Float32Array to store shadow matrices.
         * @param splitBoundSpheres A Float32Array to store split bound spheres.
         * @zh 为阴影接收者准备着色器值。
         * @param shadowMapWidth 阴影贴图的宽度。
         * @param shadowMapHeight 阴影贴图的高度。
         * @param shadowSliceDatas 阴影切片数据对象的数组。
         * @param cascadeCount 阴影级联的数量。
         * @param shadowMapSize 用于存储阴影贴图大小信息的 Vector4。
         * @param shadowMatrices 用于存储阴影矩阵的 Float32Array。
         * @param splitBoundSpheres 用于存储分割边界球的 Float32Array。
         */
        static prepareShadowReceiverShaderValues(shadowMapWidth: number, shadowMapHeight: number, shadowSliceDatas: ShadowSliceData[], cascadeCount: number, shadowMapSize: Vector4, shadowMatrices: Float32Array, splitBoundSpheres: Float32Array): void;
    }
    /**
     * @en The `SpotLightCom` class is used to create a spotlight.
     * @zh `SpotLightCom` 类用于创建聚光。
     */
    class SpotLightCom extends Light {
        /**
         * @en Declares the data module for the spotlight.
         * @zh 声明聚光灯的数据模块。
         */
        _dataModule: ISpotLightData;
        /** @internal */
        private _direction;
        /**
         * @en The direction of the spotlight.
         * @zh 聚光的方向。
         */
        get direction(): Vector3;
        set direction(value: Vector3);
        /**
         * @en The cone angle of the spotlight.
         * @zh 聚光灯的锥形角度。
         */
        get spotAngle(): number;
        set spotAngle(value: number);
        /**
         * @en The range of the spotlight.
         * @zh 聚光灯的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * @ignore
         * @en Creats an instance of SpotLightCom.
         * @zh 创建一个 SpotLightCom 的实例。
         */
        constructor();
        protected _creatModuleData(): void;
        protected _addToLightQueue(): void;
        protected _removeFromLightQueue(): void;
        /**
         * @internal
         */
        _cloneTo(dest: SpotLightCom): void;
    }
    /**
     * @en The BlinnPhongMaterial class is used to implement Blinn-Phong materials.
     * @zh BlinnPhongMaterial 类用于实现Blinn-Phong材质。
     */
    class BlinnPhongMaterial extends Material {
        /**
         * @en Specular intensity data source: Alpha channel of the diffuse map.
         * @zh 高光强度数据源：漫反射贴图的 Alpha 通道。
         */
        static SPECULARSOURCE_DIFFUSEMAPALPHA: number;
        /**
         * @en Specular intensity data source: RGB channels of the specular map.
         * @zh 高光强度数据源：高光贴图的 RGB 通道。
         */
        static SPECULARSOURCE_SPECULARMAP: number;
        /**
         * @en Render mode: Opaque.
         * @zh 渲染状态：不透明。
         */
        static RENDERMODE_OPAQUE: number;
        /**
         * @en Render mode: Alpha test.
         * @zh 渲染状态：Alpha 测试。
         */
        static RENDERMODE_CUTOUT: number;
        /**
         * @en Render mode: Transparent blend.
         * @zh 渲染状态：透明混合。
         */
        static RENDERMODE_TRANSPARENT: number;
        /**@internal */
        static SHADERDEFINE_DIFFUSEMAP: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_NORMALMAP: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SPECULARMAP: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ENABLEVERTEXCOLOR: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ENABLETRANSMISSION: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_THICKNESSMAP: ShaderDefine;
        /**@internal */
        static ALBEDOTEXTURE: number;
        /**@internal */
        static NORMALTEXTURE: number;
        /**@internal */
        static SPECULARTEXTURE: number;
        /**@internal */
        static ALBEDOCOLOR: number;
        /**@internal */
        static MATERIALSPECULAR: number;
        /**@internal */
        static SHININESS: number;
        /**@internal */
        static TILINGOFFSET: number;
        /**@internal */
        static TRANSMISSIONRATE: number;
        /**@internal */
        static IBACKDIFFUSE: number;
        /**@internal */
        static IBACKSCALE: number;
        /**@internal */
        static THINKNESSTEXTURE: number;
        /**@internal */
        static TRANSMISSIONCOLOR: number;
        /**@internal */
        static AlbedoIntensity: number;
        /**
         * @en The default material, prohibit modification.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: BlinnPhongMaterial;
        /**
         * @internal
         */
        static __initDefine__(): void;
        /**
         * @en The render mode.
         * @zh 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Albedo color.
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo intensity
         * @zh 漫反射强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * @en Specular color.
         * @zh 高光颜色。
         */
        get specularColor(): Color;
        set specularColor(value: Color);
        /**
         * @en Specular intensity, ranging from 0 to 1.
         * @zh 高光强度,范围为0到1。
         */
        get shininess(): number;
        set shininess(value: number);
        /**
         * @en Albedo texture.
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Normal texture.
         * @zh 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * @en Specular texture.
         * @zh 高光贴图。
         */
        get specularTexture(): BaseTexture;
        set specularTexture(value: BaseTexture);
        /**
         * @en Does it support transparency.
         * @zh 是否支持透光。
         */
        get enableTransmission(): boolean;
        set enableTransmission(value: boolean);
        /**
         * @en Transmittance, which affects diffuse reflection and transmittance intensity
         * @zh 透光率，会影响漫反射以及透光强度
         */
        get transmissionRata(): number;
        set transmissionRata(value: number);
        /**
         * @en Transmission influence range index
         * @zh 透射影响范围指数
         */
        get backDiffuse(): number;
        set backDiffuse(value: number);
        /**
         * @en Transmitted light intensity
         * @zh 透射光强度
         */
        get backScale(): number;
        set backScale(value: number);
        /**
         * @en Thickness texture, which affects the perspective light. The thicker the material, the weaker the transmitted light.
         * @zh 厚度贴图，会影响透射光。材质越厚，透射光越弱。
         */
        get thinknessTexture(): BaseTexture;
        set thinknessTexture(value: BaseTexture);
        /**
         * @en Transmission color. Simulates the internal color absorption rate of translucent materials.
         * @zh 透光颜色。模拟透光物质内部颜色吸收率。
         */
        get transmissionColor(): Color;
        set transmissionColor(value: Color);
        /**
         * 请使用transmissionRata
         * @deprecated
         */
        get transmissionRate(): number;
        /**
         * @ignore
         * @en Creates an instance of BlinnPhongMaterial.
         * @zh 创建一个 BlinnPhongMaterial 的实例。
         */
        constructor();
        /**
         * @en Clone.
         * @returns Clone Copy.
         * @zh 克隆。
         * @returns 克隆的副本。
         */
        clone(): BlinnPhongMaterial;
        /**
         * @en Clone the properties of this material to another material.
         * @param destObject The target material to clone to.
         * @zh 将此材质的属性克隆到另一个材质。
         * @param destObject 要克隆到的目标材质。
         */
        cloneTo(destObject: BlinnPhongMaterial): void;
    }
    /**
     * @en The AffectMaterial class is used to implement Mesh effect materials.
     * @zh EffectMaterial 类用于实现Mesh特效材质。
     */
    class EffectMaterial extends Material {
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: EffectMaterial;
        /**
         * @en The color of the material.
         * @zh 材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en The texture of the material.
         * @zh 材质的贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The tiling and offset values for the material's textures.
         * @zh 材质纹理的平铺和偏移值。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @ignore
         * @en Creates an instance of EffectMaterial.
         * @zh 创建EffectMaterial实例。
         */
        constructor();
        /**
         * @en Clone the material.
         * @returns A clone of the material.
         * @zh 克隆材质。
         * @returns 克隆的材质副本。
         */
        clone(): EffectMaterial;
        /**
         * @deprecated
         * 渲染状态_加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染状态_透明混合。*/
        static RENDERMODE_ALPHABLENDED: number;
        /**
         * @deprecated
         * 设置渲染模式。
         * 可以使用新的渲染状态
         */
        set renderMode(value: number);
    }
    /**
     * @internal
     * @deprecated
     */
    class ExtendTerrainMaterial extends Material {
        /**渲染状态_不透明。*/
        static RENDERMODE_OPAQUE: number;
        /**渲染状态_透明混合。*/
        static RENDERMODE_TRANSPARENT: number;
        /**@internal */
        static SPLATALPHATEXTURE: number;
        /**@internal */
        static DIFFUSETEXTURE1: number;
        /**@internal */
        static DIFFUSETEXTURE2: number;
        /**@internal */
        static DIFFUSETEXTURE3: number;
        /**@internal */
        static DIFFUSETEXTURE4: number;
        /**@internal */
        static DIFFUSETEXTURE5: number;
        /**@internal */
        static DIFFUSESCALEOFFSET1: number;
        /**@internal */
        static DIFFUSESCALEOFFSET2: number;
        /**@internal */
        static DIFFUSESCALEOFFSET3: number;
        /**@internal */
        static DIFFUSESCALEOFFSET4: number;
        /**@internal */
        static DIFFUSESCALEOFFSET5: number;
        /**地形细节宏定义。*/
        /**@internal */
        static SHADERDEFINE_DETAIL_NUM1: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAIL_NUM2: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAIL_NUM3: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAIL_NUM4: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAIL_NUM5: ShaderDefine;
        /**
         * @internal
         */
        static __initDefine__(): void;
        /**
         * splatAlpha贴图。
         */
        get splatAlphaTexture(): BaseTexture;
        set splatAlphaTexture(value: BaseTexture);
        /**
         * 第一层贴图。
         */
        get diffuseTexture1(): BaseTexture;
        set diffuseTexture1(value: BaseTexture);
        /**
         * 第二层贴图。
         */
        get diffuseTexture2(): BaseTexture;
        set diffuseTexture2(value: BaseTexture);
        /**
         * 第三层贴图。
         */
        get diffuseTexture3(): BaseTexture;
        set diffuseTexture3(value: BaseTexture);
        /**
         * 第四层贴图。
         */
        get diffuseTexture4(): BaseTexture;
        set diffuseTexture4(value: BaseTexture);
        /**
         * 第五层贴图。
         */
        get diffuseTexture5(): BaseTexture;
        set diffuseTexture5(value: BaseTexture);
        /**
         * 第一层贴图缩放偏移。
         */
        set diffuseScaleOffset1(scaleOffset1: Vector4);
        /**
         * 第二层贴图缩放偏移。
         */
        set diffuseScaleOffset2(scaleOffset2: Vector4);
        /**
         * 第三层贴图缩放偏移。
         */
        set diffuseScaleOffset3(scaleOffset3: Vector4);
        /**
         * 第四层贴图缩放偏移。
         */
        set diffuseScaleOffset4(scaleOffset4: Vector4);
        /**
         * 第五层贴图缩放偏移。
         */
        set diffuseScaleOffset5(scaleOffset5: Vector4);
        /**
         * 设置渲染模式。
         */
        set renderMode(value: number);
        /**
         * 创建一个 <code>ExtendTerrainMaterial</code> 实例。
         */
        constructor();
        private _setDetailNum;
        /**
        * 克隆。
        * @return	 克隆副本。
        */
        clone(): ExtendTerrainMaterial;
    }
    /**
     * @en Enum representing the different render modes used in PBR (Physically Based Rendering) materials.
     * @zh 表示 PBR（基于物理的渲染）材质中使用的不同渲染模式的枚举。
     */
    enum PBRRenderMode {
        /**
         * @en Opaque render mode.
         * @zh 不透明渲染模式。
         */
        Opaque = 0,
        /**
         * @en Cutout render mode.
         * @zh 裁剪透明渲染模式。
         */
        Cutout = 1,
        /**
         * @en Transparent Mixing: Transparent commonly used in games
         * @zh 透明混合_游戏中经常使用的透明。
         */
        Fade = 2,
        /**
         * @en Transparent Mixing: Physically Seemingly Reasonable Transparency
         * @zh 透明混合_物理上看似合理的透明。
         */
        Transparent = 3
    }
    /**
     * @en The parent class of PBR material, which is an abstract class.
     * @zh PBR材质的父类,该类为抽象类。
     */
    class PBRMaterial extends Material {
        /** @internal */
        static SHADERDEFINE_ALBEDOTEXTURE: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_NORMALTEXTURE: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_OCCLUSIONTEXTURE: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_PARALLAXTEXTURE: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_EMISSIONTEXTURE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAILALBEDO: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DETAILNORMAL: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_ENABLEVERTEXCOLOR: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ANISOTROPYTEXTURE: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_TRANSPARENTBLEND: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_LAYA_PBR_BRDF_HIGH: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_LAYA_PBR_BRDF_LOW: ShaderDefine;
        /** @internal */
        static ALBEDOTEXTURE: number;
        /** @internal */
        static ALBEDOCOLOR: number;
        /** @internal */
        static TILINGOFFSET: number;
        /** @internal */
        static NORMALTEXTURE: number;
        /** @internal */
        static NORMALSCALE: number;
        /** @internal */
        static SMOOTHNESS: number;
        /** @internal */
        static SMOOTHNESSSCALE: number;
        /** @internal */
        static OCCLUSIONTEXTURE: number;
        /** @internal */
        static OCCLUSIONSTRENGTH: number;
        /** @internal */
        static PARALLAXTEXTURE: number;
        /** @internal */
        static PARALLAXSCALE: number;
        /** @internal */
        static EMISSIONTEXTURE: number;
        /** @internal */
        static EMISSIONCOLOR: number;
        /**@internal */
        static EMISSIONIntensity: number;
        /** @internal */
        static DETAILALBEDOTEXTURE: number;
        /**@internal */
        static DETAILNORMALTEXTURE: number;
        /**@internal */
        static DETAILTILLINGOFFSET: number;
        /**@internal */
        static DETAILNORMALSCALE: number;
        /**@internal */
        static CLEARCOAT: number;
        /**@internal */
        static SHADERDEFINE_CLEARCOATTEXTURE: ShaderDefine;
        /**@internal */
        static CLEARCOATTEXTURE: number;
        /**@internal */
        static CLEARCOATROUGHNESS: number;
        /**@internal */
        static SHADERDEFINE_CLEARCOATROUGHNESSTEXTURE: ShaderDefine;
        /**@internal */
        static CLEARCOATROUGHNESSTEXTURE: number;
        /** @internal */
        static CLEARCOATNORMALTEXTURE: number;
        /** @internal */
        static ANISOTROPY: number;
        /** @internal */
        static ANISOTROPYTEXTURE: number;
        /** @internal */
        static ANISOTROPYROTATION: number;
        /**
         * @en render quality
         * @zh 渲染质量。
         * */
        static renderQuality: PBRRenderQuality;
        /**
         * @private
         */
        static __init__(): void;
        /**
         * @en Albedo color
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo texture
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Normal texture
         * @zh 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * @en Normal texture scaling factor.
         * @zh 法线贴图缩放系数。
         */
        get normalTextureScale(): number;
        set normalTextureScale(value: number);
        /**
         * @en Parallax texture
         * @zh 视差贴图。
         */
        get parallaxTexture(): BaseTexture;
        set parallaxTexture(value: BaseTexture);
        /**
         * @en Parallax texture scaling factor.
         * @zh 视差贴图缩放系数。
         */
        get parallaxTextureScale(): number;
        set parallaxTextureScale(value: number);
        /**
         * @en Occlusion texture
         * @zh 遮挡贴图。
         */
        get occlusionTexture(): BaseTexture;
        set occlusionTexture(value: BaseTexture);
        /**
         * @en Occlusion texture strength, the range is from 0 to 1.
         * @zh 遮挡贴图强度，范围为0到1。
         */
        get occlusionTextureStrength(): number;
        set occlusionTextureStrength(value: number);
        /**
         * @en The smoothness of the material, the range is from 0 to 1.
         * @zh 材质的光滑度，范围为0到1。
         */
        get smoothness(): number;
        set smoothness(value: number);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @en Whether to enable emission.
         * @zh 是否开启自发光。
         */
        get enableEmission(): boolean;
        set enableEmission(value: boolean);
        /**
         * @en Emission color.
         * @zh 自发光颜色。
         */
        get emissionColor(): Color;
        set emissionColor(value: Color);
        /**
         * @en Emission intensity
         * @zh 自发光强度
         */
        get emissionIntensity(): number;
        set emissionIntensity(value: number);
        /**
         * @en Emission texture.
         * @zh 自发光贴图。
         */
        get emissionTexture(): BaseTexture;
        set emissionTexture(value: BaseTexture);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Detail texture.
         * @zh 细节贴图。
         */
        get detailAlbedoTexture(): BaseTexture;
        set detailAlbedoTexture(value: BaseTexture);
        /**
         * @en Detail normal texture.
         * @zh 细节法线贴图。
         */
        get detailNormalTexture(): BaseTexture;
        set detailNormalTexture(value: BaseTexture);
        /**
         * @en The tiling and offset values for the detail textures.
         * @zh 细节图纹理平铺和偏移。
         */
        get detailTilingOffset(): Vector4;
        set detailTilingOffset(value: Vector4);
        /**
         * @en The scale factor for the detail normal textures.
         * @zh 细节法线贴图缩放系数。
         */
        get detailNormalScale(): number;
        set detailNormalScale(value: number);
        /**
         * @en Render mode.
         * @zh 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @en Whether to enable anisotropy
         * @zh 是否开启各向异性
         */
        get anisotropyEnable(): boolean;
        set anisotropyEnable(value: boolean);
        /**
         * @en The strength of the anisotropy effect.
         * @zh 各向异性强度
         */
        get anisotropy(): number;
        set anisotropy(value: number);
        /**
         * @en Anisotropy strength texture.
         * @zh 各向异性强度贴图。
         */
        get anisotropyTexture(): Texture2D;
        set anisotropyTexture(value: Texture2D);
        /**
         * @en Anisotropy rotation in tangent space.
         * @zh 各向异性在切线空间中的旋转。
         */
        get anisotropyRotation(): number;
        set anisotropyRotation(value: number);
        /**
         * @en Whether to enable clear coat
         * @zh 是否开启透明涂层
         */
        get clearCoatEnable(): boolean;
        set clearCoatEnable(value: boolean);
        /**
         * @en The strength of the clear coat effect.
         * @zh 透明涂层强度
         */
        get clearCoat(): number;
        set clearCoat(value: number);
        /**
         * @en Clear coat strength texture.
         * @zh 透明涂层强度贴图
         */
        get clearCoatTexture(): BaseTexture;
        set clearCoatTexture(value: BaseTexture);
        /**
         * @en Clear coat roughness.
         * @zh 透明涂层粗糙度。
         */
        get clearCoatRoughness(): number;
        set clearCoatRoughness(value: number);
        /**
         * @en Clear coat roughness texture.
         * @zh 透明涂层粗糙度贴图。
         */
        get clearCoatRoughnessTexture(): BaseTexture;
        set clearCoatRoughnessTexture(value: BaseTexture);
        /**
         * @en Clear coat normal texture.
         * @zh 透明涂层法线贴图。
         */
        get clearCoatNormalTexture(): BaseTexture;
        set clearCoatNormalTexture(value: BaseTexture);
        constructor();
        /**
         * @deprecated
         * 光滑度缩放系数,范围为0到1。
         */
        get smoothnessTextureScale(): number;
        set smoothnessTextureScale(value: number);
    }
    /**
     * @en PBR material rendering quality.
     * @zh PBR材质渲染质量。
     */
    enum PBRRenderQuality {
        /**
         * @en High quality.
         * @zh 高质量。
         */
        High = 0,
        /**
         * @en Low quality.
         * @zh 低质量
         */
        Low = 1
    }
    /**
     * @en Metallic PBR material smoothness data source.
     * @zh 金属度PBR材质光滑度数据源。
     */
    enum PBRMetallicSmoothnessSource {
        /**
         * @en Alpha channel for metallicity mapping.
         * @zh 金属度贴图的Alpha通道。
         */
        MetallicGlossTextureAlpha = 0,
        /**
         * @en Alpha channel of albedo texture.
         * @zh 漫反射贴图的Alpha通道。
         */
        AlbedoTextureAlpha = 1
    }
    /**
     * @en The PBRStandardMaterial class is used to implement PBR materials.
     * @zh PBRStandardMaterial 类用于实现PBR材质。
     */
    class PBRStandardMaterial extends PBRMaterial {
        /** @internal */
        static SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA: ShaderDefine;
        /** @internal */
        static SHADERDEFINE_METALLICGLOSSTEXTURE: ShaderDefine;
        /** @internal */
        static METALLICGLOSSTEXTURE: number;
        /** @internal */
        static METALLIC: number;
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: PBRStandardMaterial;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        private _smoothnessSource;
        /**
         * @en Metallic gloss texture.
         * @zh 金属光滑度贴图。
         */
        get metallicGlossTexture(): BaseTexture;
        set metallicGlossTexture(value: BaseTexture);
        /**
         * @en The metallic value, ranging from 0 to 1.
         * @zh 金属度，范围为0到1。
         */
        get metallic(): number;
        set metallic(value: number);
        /**
         * @en The smoothness data source, 0 or 1.
         * @zh 光滑度数据源，0或1。
         */
        get smoothnessSource(): PBRMetallicSmoothnessSource;
        set smoothnessSource(value: PBRMetallicSmoothnessSource);
        /**
         * @ignore
         * @en Creates an instance of PBRStandardMaterial.
         * @zh 创建一个 PBRStandardMaterial 的实例。
         */
        constructor();
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): PBRStandardMaterial;
    }
    /**
     * @en The SkyBoxMaterial class is used to implement the SkyBoxMaterial material.
     * @zh SkyBoxMaterial 类用于实现天空盒材质。
     */
    class SkyBoxMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURECUBE: number;
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: SkyBoxMaterial;
        /**
        * @internal
        */
        static __initDefine__(): void;
        /**
         * @en Tint color of the skybox.
         * @zh 天空盒的颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * @en Exposure intensity of the skybox.
         * @zh 天空盒的曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @en Rotation angle of the skybox.
         * @zh 天空盒的旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en Texture of the skybox.
         * @zh 天空盒的纹理。
         */
        get textureCube(): TextureCube;
        set textureCube(value: TextureCube);
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): SkyBoxMaterial;
        /**
         * @ignore
         * @en Creates an instance of SkyBoxMaterial.
         * @zh 创建一个 SkyBoxMaterial 实例。
         */
        constructor();
    }
    /**
     * @en The SkyPanoramicMaterial class is used to implement SkyPanoramicMaterial material.
     * @zh SkyPanoramicMaterial 类用于实现全景天空材质。
     */
    class SkyPanoramicMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURE: number;
        static TEXTURE_HDR_PARAMS: number;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        private _textureHDRParams;
        /**
         * @en Tint color of the panoramic sky.
         * @zh 全景天空的颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * @en Exposure intensity of the panoramic sky.
         * @zh 全景天空的曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @en Rotation angle of the panoramic sky.
         * @zh 全景天空的旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en Panoramic sky texture.
         * @zh 全景天空纹理。
         */
        get panoramicTexture(): Texture2D;
        set panoramicTexture(value: Texture2D);
        /**
         * @ignore
         * @en Creates an instance of SkyPanoramicMaterial.
         * @zh 创建一个 SkyPanoramicMaterial 的实例。
         */
        constructor();
    }
    /**
     * @en The SkyProceduralMaterial class is used to implement the SkyProceduralMaterial material.
     * @zh SkyProceduralMaterial 类用于实现程序化天空材质。
     */
    class SkyProceduralMaterial extends Material {
        /**
         * @en Sun: None
         * @zh 太阳：无
         */
        static SUN_NODE: number;
        /**
         * @en Sun: Simple
         * @zh 太阳：简单
         */
        static SUN_SIMPLE: number;
        /**
         * @en Sun: High quality
         * @zh 太阳：高质量
         */
        static SUN_HIGH_QUALITY: number;
        /**@internal */
        static SUNSIZE: number;
        /**@internal */
        static SUNSIZECONVERGENCE: number;
        /**@internal */
        static ATMOSPHERETHICKNESS: number;
        /**@internal */
        static SKYTINT: number;
        /**@internal */
        static GROUNDTINT: number;
        /**@internal */
        static EXPOSURE: number;
        /**@internal */
        static SHADERDEFINE_SUN_HIGH_QUALITY: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SUN_SIMPLE: ShaderDefine;
        /** 默认材质，禁止修改*/
        static defaultMaterial: SkyProceduralMaterial;
        /**
         * @internal
         */
        static __initDefine__(): void;
        /**@internal */
        private _sunDisk;
        /**
         * @en Sun state.
         * @zh 太阳状态。
         */
        get sunDisk(): number;
        set sunDisk(value: number);
        /**
         * @en Sun size, range is 0 to 1.
         * @zh 太阳尺寸，范围是0到1。
         */
        get sunSize(): number;
        set sunSize(value: number);
        /**
         * @en Sun size convergence, range is 0 to 20.
         * @zh 太阳尺寸收缩，范围是0到20。
         */
        get sunSizeConvergence(): number;
        set sunSizeConvergence(value: number);
        /**
         * @en Atmosphere thickness, range is 0 to 5.
         * @zh 大气厚度，范围是0到5。
         */
        get atmosphereThickness(): number;
        set atmosphereThickness(value: number);
        /**
         * @en Sky color.
         * @zh 天空颜色。
         */
        get skyTint(): Color;
        set skyTint(value: Color);
        /**
         * @en Ground color.
         * @zh 地面颜色。
         */
        get groundTint(): Color;
        set groundTint(value: Color);
        /**
         * @en Exposure intensity, range is 0 to 8.
         * @zh 曝光强度，范围是0到8。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * @ignore
         * @en Creates an instance of SkyProceduralMaterial.
         * @zh 创建一个 SkyProceduralMaterial 的实例。
         */
        constructor();
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): SkyProceduralMaterial;
    }
    /**
     * @en The UnlitMaterial class is used to implement materials that are not affected by lighting.
     * @zh UnlitMaterial 类用于实现不受光照影响的材质。
     */
    class UnlitMaterial extends Material {
        static SHADERDEFINE_ALBEDOTEXTURE: ShaderDefine;
        static SHADERDEFINE_ENABLEVERTEXCOLOR: ShaderDefine;
        static ALBEDOTEXTURE: number;
        static ALBEDOCOLOR: number;
        static TILINGOFFSET: number;
        static defaultMaterial: UnlitMaterial;
        /**
         * @internal
         */
        static __initDefine__(): void;
        private _albedoIntensity;
        /**
         * @en Albedo color
         * @zh 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * @en Albedo intensity
         * @zh 漫反射强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * @en Albedo texture
         * @zh 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * @en Texture tiling and offsetting.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Whether to support vertex color.
         * @zh 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * @ignore
         * @en Creates an instance of UnlitMaterial.
         * @zh 创建一个 UnlitMaterial 的实例。
         */
        constructor();
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): UnlitMaterial;
        /**
         * @deprecated
         * 渲染状态_不透明。
         */
        static RENDERMODE_OPAQUE: number;
        /**
         * @deprecated
         * 渲染状态_阿尔法测试。
        */
        static RENDERMODE_CUTOUT: number;
        /**
         * @deprecated
         * 渲染状态__透明混合。
         */
        static RENDERMODE_TRANSPARENT: number;
        /**
         * @deprecated
         * 渲染状态__加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式，使用materialRenderMode代替。
         */
        set renderMode(value: number);
    }
    /**
     * @en The `MeshFilter` class is used to create mesh filters.
     * @zh `MeshFilter` 类用于创建网格过滤器。
     */
    class MeshFilter extends Component {
        /** @internal */
        static _meshVerticeDefine: Array<ShaderDefine>;
        /** @internal */
        private _sharedMesh;
        constructor();
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDisable(): void;
        /**
         * @en The shared mesh of the MeshFilter.
         * @zh 共享网格。
         */
        get sharedMesh(): Mesh;
        set sharedMesh(value: Mesh);
        /**
         * @internal
         */
        protected _onDestroy(): void;
        /**
         * @internal
         * @en Clone the component to another object.
         * @param dest The destination component.
         * @zh 克隆组件到另一个对象。
         * @param dest 目标组件。
         */
        _cloneTo(dest: MeshFilter): void;
    }
    /**
     * @en The `MeshRenderer` class is used for mesh rendering.
     * @zh `MeshRenderer` 类用于网格渲染器。
     */
    class MeshRenderer extends BaseRender {
        protected _revertStaticBatchDefineUV1: boolean;
        protected _projectionViewWorldMatrix: Matrix4x4;
        protected _mesh: Mesh;
        _baseRenderNode: IMeshRenderNode;
        /**
         * @internal
         */
        static __init__(): void;
        private morphTargetActiveCount;
        private morphTargetActiveData;
        /**@internal */
        morphTargetWeight: Float32Array;
        private morphtargetChannels;
        private _morphWeightChange;
        /**
         * @ignore
         * @en Creates an instance of MeshRenderer.
         * @zh 创建一个 MeshRenderer 的实例。
         */
        constructor();
        protected _createBaseRenderNode(): IBaseRenderNode;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * @internal
         */
        _createRenderElement(): RenderElement;
        /**
         * @internal
         * @en Get the mesh object.
         * @returns The mesh object.
         * @zh 获取网格对象。
         * @returns 网格对象。
         */
        getMesh(): Mesh;
        protected _onEnable(): void;
        /**
         * @param mesh
         * @param out
         */
        protected _getMeshDefine(mesh: Mesh, out: Array<ShaderDefine>): number;
        /**
         * @param mesh
         */
        protected _changeVertexDefine(mesh: Mesh): void;
        private _morphTargetValues;
        /**
         * @internal
         */
        get morphTargetValues(): Record<string, number>;
        /**
         * @internal
         */
        set morphTargetValues(value: Record<string, number>);
        /**
         * @internal
         * @param key
         */
        _changeMorphTargetValue(key: string): void;
        /**
         * @en Set the weight of a morph target channel.
         * @param channelName The name of the morph target channel.
         * @param weight The weight value to set for the channel.
         * @zh 设置变形目标通道的权重。
         * @param channelName 变形目标通道的名称。
         * @param weight 要设置的通道权重值。
         */
        setMorphChannelWeight(channelName: string, weight: number): void;
        /**
         * @internal
         * @en Update morph target data.
         * @zh 更新变形目标数据。
         */
        protected _applyMorphdata(): void;
        _setBelongScene(scene: any): void;
        /**
         * @internal
         */
        _setUnBelongScene(): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
        /**
         * @en Update morph target data (shader define) when updating mesh.
         * @param mesh The mesh to update.
         * @zh 更新网格时更新变形目标数据（着色器定义）。
         * @param mesh 要更新的网格。
         */
        protected _changeMorphData(mesh: Mesh): void;
        protected _meshChange: boolean;
        /**
         * @internal
         */
        _onMeshChange(mesh: Mesh): void;
        /**
         * @internal
         * BaseRender motion
         */
        protected _onWorldMatNeedChange(flag: number): void;
        /**
         * @en Update the rendering state of the mesh renderer.
         * @param context The 3D render context.
         * @zh 更新网格渲染器的渲染状态。
         * @param context 3D渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        protected _onDestroy(): void;
        /**
         * @internal
         * @param dest
         */
        _cloneTo(dest: MeshRenderer): void;
    }
    /**
     * @deprecated
     * <code>MeshSprite3D</code> 类用于创建网格。
     */
    class MeshSprite3D extends RenderableSprite3D {
        private _meshFilter;
        /**
         * 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * 网格渲染器。
         */
        get meshRenderer(): MeshRenderer;
        /**
         * 创建一个 <code>MeshSprite3D</code> 实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
    }
    /**
     * @en Class used to record sprite data macros
     * @zh 类用来记录精灵数据宏
     */
    class MeshSprite3DShaderDeclaration {
        /**
         * @en Shader define for UV0 channel vertex data
         * @zh UV0通道顶点数据宏
         */
        static SHADERDEFINE_UV0: ShaderDefine;
        /**
         * @en Shader define for vertex color data
         * @zh 顶点色顶点数据宏
         */
        static SHADERDEFINE_COLOR: ShaderDefine;
        /**
         * @en Shader define for UV1 channel vertex data
         * @zh UV1通道顶点数据宏
         */
        static SHADERDEFINE_UV1: ShaderDefine;
        /**
         * @en Shader define for Tangent channel vertex data
         * @zh Tangent 通道顶点数据宏
         */
        static SHADERDEFINE_TANGENT: ShaderDefine;
        static SHADERDEFINE_BONEW: ShaderDefine;
        static SHADERDEFINE_BONEI: ShaderDefine;
        /**
         * @en Using instance
         * @zh instance调用宏
         */
        static SHADERDEFINE_GPU_INSTANCE: ShaderDefine;
    }
    /**
     * @en The `PixelLineData` class is used to represent line data.
     * @zh `PixelLineData` 类用于表示线数据。
     */
    class PixelLineData {
        /**
         * @en The starting position of the line.
         * @zh 线的起始位置。
         */
        startPosition: Vector3;
        /**
         * @en The ending position of the line.
         * @zh 线的结束位置。
         */
        endPosition: Vector3;
        /**
         * @en The color at the start of the line.
         * @zh 线的起始颜色。
         */
        startColor: Color;
        /**
         * @en The color at the end of the line.
         * @zh 线的结束颜色。
         */
        endColor: Color;
        /**
         * @en Line start normal
         * @zh 线开始法线
         */
        startNormal: Vector3;
        /**
         * @en Line end normal
         * @zh 线结束法线
         */
        endNormal: Vector3;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: PixelLineData): void;
    }
    /**
     * @en The `PixelLineFilter` class is used for line filtering.
     * @zh `PixelLineFilter` 类用于线过滤器。
     */
    class PixelLineFilter extends GeometryElement {
        private static _type;
        private _floatCountPerVertices;
        private _vertexBuffer;
        private _vertices;
        private _minUpdate;
        private _maxUpdate;
        private _floatBound;
        private _calculateBound;
        /** @internal */
        _ownerRender: PixelLineRenderer;
        /** @internal */
        _bounds: Bounds;
        /** @internal */
        _maxLineCount: number;
        /** @internal */
        _lineCount: number;
        /**
         * @ignore
         * @en initialize pixeLineFilter instance.
         * @param owner The rendering sprite node.
         * @param maxLineCount The maximum line count.
         * @zh 初始化pixeLineFilter实例。
         * @param owner 渲染精灵节点。
         * @param maxLineCount 最大线段数量。
         */
        constructor(owner: PixelLineRenderer, maxLineCount: number);
        /**
         *  @internal
         */
        _getType(): number;
        /**
         * @internal
         */
        _resizeLineData(maxCount: number): void;
        private _updateLineVertices;
        /**
         * @internal
         */
        _reCalculateBound(): void;
        /**
         * @internal
         */
        _removeLineData(index: number): void;
        /**
         * @internal
         */
        _updateLineData(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color, startNormal?: Vector3, endNormal?: Vector3): void;
        /**
         * @internal
         */
        _updateLineDatas(index: number, data: PixelLineData[]): void;
        /**
         * @en Get the line segment data.
         * @param index The index of the line segment.
         * @param out The output PixelLineData object.
         * @zh 获取线段数据。
         * @param index 线段的索引。
         * @param out 输出的PixelLineData对象。
         */
        _getLineData(index: number, out: PixelLineData): void;
        /**
         * @internal
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @internal
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Destroy the PixelLineFilter instance.
         * @zh 销毁PixelLineFilter实例。
         */
        destroy(): void;
    }
    /**
     * @en The PixelLineMaterial class is used to implement pixel line material.
     * @zh PixelLineMaterial 类用于实现像素线材质。
     */
    class PixelLineMaterial extends Material {
        /**@internal */
        static COLOR: number;
        /**
         * @en Default material, no modification allowed
         * @zh 默认材质，禁止修改
         */
        static defaultMaterial: Material;
        /**
        * @internal
        */
        static __initDefine__(): void;
        /**
         * @en The color of the pixel line.
         * @zh 像素线的颜色。
         */
        get color(): Vector4;
        set color(value: Vector4);
        /**
         * @ignore
         * @en Initialize PixelLineMaterial instance.
         * @zh 初始化PixelLineMaterial实例
         */
        constructor();
        /**
         * @internal
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): PixelLineMaterial;
    }
    /**
     * @en PixelLineRenderer class for line rendering.
     * @zh PixelLineRenderer 类用于线渲染器。
     */
    class PixelLineRenderer extends BaseRender {
        protected _projectionViewWorldMatrix: Matrix4x4;
        /**@internal */
        _pixelLineFilter: PixelLineFilter;
        /**  是否调用active */
        private _isRenderActive;
        /**  是否加入渲染队列*/
        private _isInRenders;
        private _needUpdatelines;
        /**
         * @ignore
         * @en Initialize PixelLineRenderer instance.
         * @zh 初始化PixelLineRenderer实例。
         */
        constructor();
        /**
         * @en The bounds of the line renderer.
         * @zh 线渲染器的包围盒。
         */
        get bounds(): Bounds;
        private _lines;
        /**
         * @en The line segment data.
         * @zh 线段数据。
         */
        get pixelLinesDatas(): PixelLineData[];
        set pixelLinesDatas(value: PixelLineData[]);
        /**
         * @en The maximum number of lines.
         * @zh 最大线数量。
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * @en The current number of lines.
         * @zh 当前线数量。
         */
        get lineCount(): number;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _createBaseRenderNode(): IMeshRenderNode;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * @internal
         * BaseRender motion
         */
        protected _onWorldMatNeedChange(flag: number): void;
        /**
         * @en Update the render context.
         * @param context The render context.
         * @zh 更新渲染上下文。
         * @param context 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @internal
         */
        _changeRenderObjects(index: number, material: Material): void;
        /**
         * @internal //animator data set call
         * @param key
         */
        _pixelLinesDataChange(key: string): void;
        /**
         * @en Add a line.
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @zh 增加一条线。
         * @param startPosition 初始点位置
         * @param endPosition 结束点位置
         * @param startColor 初始点颜色
         * @param endColor 结束点颜色
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Add a line with normal.
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @param startNormal Initial point normal
         * @param endNormal End point normal
         * @zh 增加一条带有法线的线。
         * @param startPosition 初始点位置
         * @param endPosition 结束点位置
         * @param startColor 初始点颜色
         * @param endColor 结束点颜色
         * @param startNormal 初始点法线
         * @param endNormal 结束点法线
         */
        addLineWithNormal(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color, startNormal: Vector3, endNormal: Vector3): void;
        /**
         * @en Add multiple line segments.
         * @param lines Line segment data
         * @zh 添加多条线段。
         * @param lines 线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * @en Remove a line segment.
         * @param index Index of the line to remove
         * @zh 移除一条线段。
         * @param index 线段索引。
         */
        removeLine(index: number): void;
        /**
         * @en Update a line.
         * @param index Index of the line to update
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @zh 更新线。
         * @param index 线段索引。
         * @param startPosition 初始点位置。
         * @param endPosition 结束点位置。
         * @param startColor 初始点颜色。
         * @param endColor 结束点颜色。
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Update a line with normal.
         * @param index Index of the line to update
         * @param startPosition Initial point position
         * @param endPosition End point position
         * @param startColor Initial point color
         * @param endColor End point color
         * @param startNormal Initial point normal
         * @param endNormal End point normal
         * @zh 更新带有法线的线。
         * @param index 线段索引。
         * @param startPosition 初始点位置。
         * @param endPosition 结束点位置。
         * @param startColor 初始点颜色。
         * @param endColor 结束点颜色。
         * @param startNormal 初始点法线。
         * @param endNormal 结束点法线。
         */
        setLineWithNormal(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color, startNormal: Vector3, endNormal: Vector3): void;
        /**
         * @en Get line segment data.
         * @param index Index of the line to get
         * @param out Output line segment data
         * @zh 获取线段数据。
         * @param index 线段索引。
         * @param out 线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        private _updateLineDatas;
        /**
         * @en Clear all line segments.
         * @zh 清除所有线段。
         */
        clear(): void;
        protected _onDestroy(): void;
        _cloneTo(dest: PixelLineRenderer): void;
    }
    /**
     * @en PixelLineSprite3D class is used for pixel line rendering sprites.
     * @zh PixelLineSprite3D 类用于像素线渲染精灵。
     */
    class PixelLineSprite3D extends RenderableSprite3D {
        _render: PixelLineRenderer;
        /** 是否调用active */
        private _isRenderActive;
        /** 是否加入渲染队列*/
        private _isInRenders;
        /** @internal */
        _geometryFilter: PixelLineFilter;
        /**
         * @en The maximum line count.
         * @zh 最大线数量。
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * @en The current line count.
         * @zh 当前线数量。
         */
        get lineCount(): number;
        /**
         * @en The pixel line renderer.
         * @zh 像素线渲染器。
         */
        get pixelLineRenderer(): PixelLineRenderer;
        /**
         * @ignore
         * @en Initaialize pixelLineSprite3D instance.
         * @param maxCount Maximum number of line segments.
         * @param name Name of the instance.
         * @zh 初始化PixeLineSprite3D实例。
         * @param maxCount 最大线段数量。
         * @param name  实例的名称。
         */
        constructor(maxCount?: number, name?: string);
        /**
         * @en Add a single line.
         * @param startPosition  Start position of the line.
         * @param endPosition  End position of the line.
         * @param startColor  Start color of the line.
         * @param endColor  End color of the line.
         * @zh 增加一条线。
         * @param startPosition  线段起点位置。
         * @param endPosition  线段终点位置。
         * @param startColor  线段起点颜色。
         * @param endColor  线段终点颜色。
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Add multiple line segments.
         * @param lines  Array of line segment data.
         * @zh 添加多条线段。
         * @param lines  线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * @en Remove a line segment.
         * @param index Index of the line to remove.
         * @zh 移除一条线段。
         * @param index 要移除的线段索引。
         */
        removeLine(index: number): void;
        /**
         * @en Update a line segment.
         * @param index  Index of the line to update.
         * @param startPosition  New start position of the line.
         * @param endPosition  New end position of the line.
         * @param startColor - New start color of the line.
         * @param endColor  New end color of the line.
         * @zh 更新一条线段。
         * @param index  要更新的线段索引。
         * @param startPosition  新的线段起点位置。
         * @param endPosition  新的线段终点位置。
         * @param startColor  新的线段起点颜色。
         * @param endColor  新的线段终点颜色。
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * @en Get line segment data.
         * @param index  Index of the line to get.
         * @param out  Output object to store the line data.
         * @zh 获取线段数据。
         * @param index  要获取的线段索引。
         * @param out  输出对象，用于存储线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        /**
         * @en Clear all line segments.
         * @zh 清除所有线段。
         */
        clear(): void;
    }
    /**
     * @internal
     */
    class PixelLineVertex {
        private static _vertexDeclaration;
        static get vertexDeclaration(): VertexDeclaration;
        /**
         * @internal
         */
        static __init__(): void;
        get vertexDeclaration(): VertexDeclaration;
        constructor();
    }
    enum RenderBitFlag {
        RenderBitFlag_CullFlag = 0,
        RenderBitFlag_Batch = 1,
        RenderBitFlag_Editor = 2,
        RenderBitFlag_InstanceBatch = 3,
        RenderBitFlag_VertexMergeBatch = 4
    }
    enum IrradianceMode {
        LightMap = 0,
        VolumetricGI = 1,
        Common = 2
    }
    /**
     * @en The `BaseRender` class is the parent class for renderers and is an abstract class that should not be instantiated.
     * @zh `BaseRender` 类是渲染器的父类，是一个抽象类，不允许实例化。
     */
    class BaseRender extends Component {
        /** @internal */
        static _meshVerticeDefine: Array<ShaderDefine>;
        private static _uniqueIDCounter;
        /**@internal */
        static _tempBoundBoxCorners: Vector3[];
        /**@internal */
        static _defaultLightmapScaleOffset: Vector4;
        /**
         * @en Initialize the BaseRender class.
         * @zh 初始化 BaseRender 类。
         * @internal
         */
        static __init__(): void;
        /**
         * @internal
         * @en Get mesh definitions and store them in the output array.
         * @param mesh The input mesh.
         * @param out The output array to store shader definitions.
         * @zh 获取网格定义并存储在输出数组中。
         * @param mesh 输入网格。
         * @param out 输出数组用于存储着色器定义。
         */
        static getMeshDefine(mesh: Mesh, out: Array<ShaderDefine>): number;
        /**
         * @en Change vertex shader definitions based on mesh changes.
         * @param oldMesh The old mesh.
         * @param mesh The new mesh.
         * @param defineDatas The shader data containing definitions.
         * @zh 根据网格变化更改顶点着色器宏定义。
         * @param oldMesh 旧的网格。
         * @param mesh 新的网格。
         * @param defineDatas 包含着色器定义的着色器数据。
         */
        static changeVertexDefine(oldMesh: Mesh, mesh: Mesh, defineDatas: ShaderData): void;
        /**
         * @en Macro definition initialization
         * @zh 宏定义初始化
         */
        static shaderValueInit(): void;
        /**@internal renderData*/
        _baseRenderNode: IBaseRenderNode;
        /** @internal */
        _sharedMaterials: Material[];
        /** @internal */
        _scene: any;
        /** @internal */
        _sceneUpdateMark: number;
        /** @internal 属于相机的标记*/
        _updateMark: number;
        /** @internal 是否需要反射探针*/
        _probReflection: ReflectionProbe;
        /** @internal 材质是否支持反射探针*/
        _surportReflectionProbe: boolean;
        /** @internal */
        _lightProb: VolumetricGI;
        /**@internal */
        _supportVolumetricGI: boolean;
        /**@internal motion list index，not motion is -1*/
        _motionIndexList: number;
        /**@internal TODO*/
        _LOD: number;
        /**@internal TODO*/
        _batchRender: BatchRender;
        /**@interface */
        _receiveShadow: boolean;
        /**@internal */
        _inRenderList: boolean;
        protected _bounds: Bounds;
        protected _transform: Transform3D;
        /** 如果这个值不是0,说明有一些条件使他不能加入渲染队列，例如如果是1，证明此节点被lod淘汰*/
        private _volume;
        protected _asynNative: boolean;
        private _materialsInstance;
        private _renderid;
        private _lightmapScaleOffset;
        _renderElements: RenderElement[];
        readonly owner: Sprite3D;
        /**
         * @en Whether to enable the renderer.
         * @zh 是否启用。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en The sorting fudge value.
         * @zh 排序矫正值。
         */
        get sortingFudge(): number;
        set sortingFudge(value: number);
        /**
         * @en The render bit flag of the render node.
         * @zh 渲染节点的渲染禁用位。
         */
        get renderbitFlag(): number;
        /**
         * @en Whether the bounds have changed.
         * @zh 包围盒是否更新。
         */
        get boundsChange(): boolean;
        set boundsChange(value: boolean);
        /**
         * @en The render node.
         * @zh 渲染节点。
         */
        get renderNode(): IBaseRenderNode;
        /**
         * @en The distance used for sorting.
         * @zh 排序距离。
         */
        get distanceForSort(): number;
        set distanceForSort(value: number);
        /**
         * @en The Geometry Bounds.
         * If this bounds is set, the render bounding box will be updated based on geometryBounds and transform, and the native layer will be sunk.
         * @zh 几何包围盒，
         * 如果设置了此包围盒，渲染包围盒会根据 geometryBounds 和变换来更新，并且原生层会下沉。
         */
        get geometryBounds(): Bounds;
        set geometryBounds(value: Bounds);
        /**
         * @en The lightmap index.
         * @zh 光照贴图的索引。
         */
        get lightmapIndex(): number;
        set lightmapIndex(value: number);
        /**
         * @internal
         * @en Sets the lightmap index.
         * @param value The new lightmap index.
         * @zh 设置光照贴图的索引。
         * @param value 新的光照贴图索引。
         */
        setLightmapIndex(value: number): void;
        /**
         * @en The irradient mode.
         * @zh 间接光照功能。
         */
        get irradientMode(): IrradianceMode;
        /**
         * @en The lightmap scale and offset.
         * @zh 光照贴图的缩放和偏移。
         */
        get lightmapScaleOffset(): Vector4;
        set lightmapScaleOffset(value: Vector4);
        /**
         * @en The first material.
         * @zh 第一个材质。
         */
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        /**
         * @en All shared materials.
         * @zh 所有渲染材质。
         */
        get sharedMaterials(): Material[];
        set sharedMaterials(value: Material[]);
        /**
         * @en The bounds. Read-only, do not modify its value.
         * @zh 包围盒。只读，不允许修改其值。
         */
        get bounds(): Bounds;
        /**
         * @en Whether the object receives shadows.
         * @zh 是否接收阴影属性。
         */
        get receiveShadow(): boolean;
        set receiveShadow(value: boolean);
        /**
         * @en Whether the object casts shadows.
         * @zh 是否产生阴影。
         */
        get castShadow(): boolean;
        set castShadow(value: boolean);
        /**
         * @en The reflection mode.
         * @zh 反射模式。
         */
        get reflectionMode(): ReflectionProbeMode;
        set reflectionMode(value: ReflectionProbeMode);
        /**
         * @en The volume light probe.
         * @zh 体积光探针。
         */
        get volume(): Volume;
        set volume(value: Volume);
        /**
         * @internal
         * @en The reflection probe.
         * @zh 反射探针。
         */
        get probReflection(): ReflectionProbe;
        set probReflection(value: ReflectionProbe);
        /**
         * @en The light probe.
         * @zh 光照探针。
         */
        get lightProbe(): VolumetricGI;
        set lightProbe(volumetricGI: VolumetricGI);
        /**
         * 设置自定义的渲染数据
         * @param dataSlot
         * @param data
         */
        setNodeCustomData(dataSlot: ENodeCustomData, data: number): void;
        /**
         * @ignore
         * @en consructor of BaseRender.
         * @zh 构造函数，初始化BaseRender。
         */
        constructor();
        /**
         * @en The function called by the bounding box calculation for each frame.
         * @zh 每一帧计算包围盒会调用的函数
         */
        _calculateBoundingBox?(): void;
        /**
         * @en Update the calling function of SpriteShaderData before rendering each frame.
         * @param context3D The 3D rendering context.
         * @zh 每一帧渲染前更新SpriteShaderData的调用函数。
         * @param context3D 3D渲染上下文。
         */
        _renderUpdate?(context3D: IRenderContext3D): void;
        /**
         * set BaseRenderElement
         */
        protected _setRenderElements(): void;
        /**
         * BaseRender motion
         */
        protected _onWorldMatNeedChange(flag: number): void;
        protected _getcommonUniformMap(): Array<string>;
        protected _createBaseRenderNode(): IBaseRenderNode;
        /**
         * @param context
         */
        renderUpdate(context: RenderContext3D): void;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**
         * 确定间接光模式
         */
        private _getIrradientMode;
        private _changeLayer;
        private _changeStaticMask;
        private _changeMaterialReference;
        /**
         * @internal
         */
        private _getInstanceMaterial;
        /**
         * @internal
         */
        private _isSupportRenderFeature;
        /**
         * @internal
         * @en Adds the renderer to the update reflection probe queue.
         * @zh 渲染器添加到更新反射探针队列。
         */
        _addReflectionProbeUpdate(): void;
        /**
         * @internal
         * @en Sets the scene to which this object belongs.
         * @zh 设置所属 Scene 调用此方法。
         */
        _setBelongScene(scene: any): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
        /**
         * @internal
         * @en This method is called when the object is removed from the Scene.
         * @zh 从 Scene 移除会调用此方法。
         */
        _setUnBelongScene(): void;
        /**
         * @internal
         * @param boundFrustum 裁剪。
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        _cloneTo(dest: BaseRender): void;
        /**
         * @en Sets the rendering flag, where each bit represents a different culling reason, 1 indicates LOD culling.
         * @param flag The flag to set, refer to RenderBitFlag for related flags or define custom bit flags.
         * @param pass Whether to set the flag.
         * @zh 设置渲染标志，每一位都代表不同的淘汰原因，1表示LOD淘汰。
         * @param flag 标记，可以查RenderBitFlag相关，也可以自定义标签位
         * @param pass 设置标签值
         */
        setRenderbitFlag(flag: number, pass: boolean): void;
        /**
         * @deprecated 请使用shareMaterial接口
         * 返回第一个实例材质,第一次使用会拷贝实例对象。
         */
        get material(): Material;
        protected _isMaterialVaild(value: Material): boolean;
        set material(value: Material);
        get materials(): Material[];
        set materials(value: Material[]);
    }
    /**
     * @internal
     */
    class BatchMark {
        /**@internal */
        updateMark: number;
        /**@internal */
        indexInList: number;
        /**@internal */
        batched: boolean;
        /**@internal */
        _curBindElementIndex: number;
        _cacheRenderElement: IRenderElement3D[];
    }
    /**
     * @en Class used for creating instructions to output from a render source to a render target.
     * @zh 类用于创建从渲染源输出到渲染目标的指令。
     */
    class BlitFrameBufferCMD {
        private static readonly _pool;
        /** @internal */
        static shaderdata: ShaderData;
        /** @internal */
        static __init__(): void;
        /**
         * @en Create a render command set.
         * @param source The source texture.
         * @param dest The destination render texture.
         * @param viewport The viewport for rendering.
         * @param offsetScale The offset and scale vector. Default is null.
         * @param shader The shader to use. Default is null.
         * @param shaderData The shader data to use. Default is null.
         * @param subShader The sub-shader index. Default is 0.
         * @returns The created BlitFrameBufferCMD instance.
         * @zh 创建渲染命令集。
         * @param source 源纹理。
         * @param dest 目标渲染纹理。
         * @param viewport 渲染视口。
         * @param offsetScale 偏移和缩放向量。默认为 null。
         * @param shader 要使用的着色器。默认为 null。
         * @param shaderData 要使用的着色器数据。默认为 null。
         * @param subShader 子着色器索引。默认为 0。
         * @returns 创建的 BlitFrameBufferCMD 实例。
         */
        static create(source: BaseTexture, dest: RenderTexture, viewport: Viewport, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): BlitFrameBufferCMD;
        /** source 原始贴图*/
        private _source;
        /** dest 目标 如果为null，将会默认为主画布*/
        private _dest;
        /** 偏移缩放*/
        private _offsetScale;
        /** */
        _texture_size: Vector4;
        /** 渲染shader*/
        private _shader;
        /** 渲染数据*/
        private _shaderData;
        /** subshader的节点*/
        private _subShader;
        /** 渲染设置*/
        private _viewPort;
        private _renderElement;
        private _transform3D;
        /**@ignore */
        constructor();
        /**
         * @en The shader data for the command.
         * @zh 命令的着色器数据。
         */
        set shaderData(value: ShaderData);
        /**
         * @en Set the shader, sub-shader, and shader data for the command.
         * @param shader The shader to set. If null, uses the default screen shader.
         * @param subShader The sub-shader index. Default is 0.
         * @param shaderData The shader data to set.
         * @zh 设置命令的着色器、子着色器和着色器数据。
         * @param shader 要设置的着色器。如果为 null，则使用默认屏幕着色器。
         * @param subShader 子着色器索引。默认为 0。
         * @param shaderData 要设置的着色器数据。
         */
        setshader(shader: Shader3D, subShader: number, shaderData: ShaderData): void;
        /**
         * @en Execute the render command.
         * @zh 执行渲染命令。
         */
        run(): void;
        /**
         * @en Recycle the command instance.
         * @zh 回收命令实例。
         */
        recover(): void;
    }
    /**
     * @en The BlitScreenQuadCMD class is used to create render the source texture to the destination render texture by using the full screen quad command.
     * @zh BlitScreenQuadCMD 类用于创建通过全屏四边形将源纹理渲染到目标渲染纹理的指令
     */
    class BlitScreenQuadCMD extends Command {
        /**@internal */
        static readonly SCREENTYPE_QUAD: number;
        /**@internal */
        static readonly SCREENTYPE_TRIANGLE: number;
        private static readonly _pool;
        /**
         * @en Create command stream
         * @param source  The source texture. If set to null, it will use the default RenderTexture from the Camera process.
         * @param dest  The destination texture. If set to null, it will use the default rendering target of the camera.
         * @param offsetScale  Offset scaling.
         * @param shader  The shader to use for rendering.
         * @param shaderData  The shader data for rendering.
         * @param subShader  The subShader index. Default is 0.
         * @param screenType  The screen type for rendering.
         * @param commandbuffer  The command buffer to use.
         * @zh 创建命令流
         * @param source 原始贴图 如果设置为null  将会使用默认的Camera流程中的原RenderTexture
         * @param dest 目标贴图 如果设置为null，将会使用默认的camera渲染目标
         * @param offsetScale 偏移缩放
         * @param shader 用于渲染的着色器。。
         * @param shaderData 用于渲染的着色器数据。
         * @param subShader subshader的节点
         * @param screenType 渲染的屏幕类型
         * @param commandbuffer 命令缓冲
         */
        static create(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number, screenType?: number, commandbuffer?: CommandBuffer): BlitScreenQuadCMD;
        private _source;
        private _dest;
        private _offsetScale;
        private _shader;
        private _shaderData;
        private _internalShaderData;
        private _subShader;
        private _renderElement;
        private _transform3D;
        /**@internal */
        _blitQuadCMDData: BlitQuadCMDData;
        /**@ignore */
        constructor();
        /**
         * @en The offset and scale for rendering.
         * @zh 渲染的偏移和缩放。
         */
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        /**
         * @en The destination render texture.
         * @zh 目标渲染纹理。
         */
        get dest(): RenderTexture;
        set dest(value: RenderTexture);
        /**
         * @en The shader data for rendering.
         * @zh 渲染的着色器数据。
         */
        set shaderData(value: ShaderData);
        /**
         * @internal
         */
        getRenderCMD(): BlitQuadCMDData;
        /**
         * @param shader
         * @param subShader
         * @param shaderData
         */
        setshader(shader: Shader3D, subShader: number, shaderData: ShaderData): void;
        /**
         * @en Execute the command.
         * @zh 执行命令。
         */
        run(): void;
        /**
         * @en Recover the command for reuse.
         * @zh 回收命令以重复使用。
         */
        recover(): void;
        /**
         * @en Destroy the command and release resources.
         * @zh 销毁命令并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `Command` class is used to create commands.
     * @zh `Command` 类用于创建指令。
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    class Command {
        /** @internal */
        static _screenShader: Shader3D;
        /** @internal */
        static readonly SCREENTEXTURE_NAME: string;
        /** @internal */
        static readonly SCREENTEXTUREOFFSETSCALE_NAME: string;
        /** @internal */
        static readonly MAINTEXTURE_TEXELSIZE_NAME: string;
        /** @internal */
        static SCREENTEXTURE_ID: number;
        /** @internal */
        static SCREENTEXTUREOFFSETSCALE_ID: number;
        /** @internal */
        static MAINTEXTURE_TEXELSIZE_ID: number;
        /**@internal */
        _commandBuffer: CommandBuffer;
        /**@internal */
        _context: RenderContext3D;
        /**
        * @internal
        */
        static __init__(): void;
        /**@ignore */
        constructor();
        /**
         * @en Organizes rendering commands.
         * @zh 组织渲染指令。
         */
        run?(): void;
        /**
         * @en Recycles the rendering command.
         * @zh 回收渲染指令。
         */
        recover(): void;
        /**
         * @internal
         */
        getRenderCMD?(): IRenderCMD;
        /**
         * @internal
         */
        destroy(): void;
    }
    /**
     * @en The `CommandBuffer` Class used to create command buffer
     * @zh `CommandBuffer` 类用于创建命令缓冲区。
     * @blueprintIgnore
     */
    class CommandBuffer {
        static instance: CommandBuffer;
        /**@internal */
        _name: string;
        /**@internal */
        private _shadow;
        /**@internal */
        _camera: Camera;
        /**@internal */
        _context: RenderContext3D;
        /**@internal */
        private _commands;
        /**@internal */
        _renderCMDs: any[];
        /** @ignore */
        constructor(name?: string, shadowCaster?: boolean);
        /**
         * @en The name of the command buffer.
         * @zh 命令缓冲区的名称。
         */
        get name(): string;
        /**
         * @en Whether the command buffer casts shadows.
         * @zh 命令缓冲区是否投射阴影。
         */
        get casterShadow(): boolean;
        /**
         * @en The rendering context for the command buffer.
         * @zh 命令缓冲区的渲染上下文。
         */
        get context(): RenderContext3D;
        set context(value: RenderContext3D);
        /**
         * @en Executes all rendering commands.
         * @zh 调用所有渲染指令。
         */
        _apply(render?: boolean): void;
        /**
         * @en Executes a single command from the command buffer.
         * @zh 从命令缓冲区执行单个命令。
         */
        _applyOne(): boolean;
        /**
         * @en Gets the number of commands contained in the command buffer
         * @zh 获取命令缓冲区包含的命令数量
         */
        getCommandsSize(): number;
        /**
         * @en Sets the texture data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The Uniform ID for the texture.
         * @param source The source of the texture.
         * @zh 设置着色器的纹理数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 纹理的 Uniform ID。
         * @param source 纹理源。
         */
        setShaderDataTexture(shaderData: ShaderData, nameID: number, source: BaseTexture): void;
        /**
         * @en Sets the global texture data.
         * @param nameID The Uniform ID for the texture.
         * @param source The source of the texture.
         * @zh 设置全局纹理数据。
         * @param nameID 纹理的 Uniform ID。
         * @param source 纹理源。
         */
        setGlobalTexture(nameID: number, source: BaseTexture): void;
        /**
         * @en Sets the color data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The color value.
         * @zh 设置着色器的颜色数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据 ID。
         * @param value 颜色值。
         */
        setShaderDataColor(shaderData: ShaderData, nameID: number, value: Color): void;
        /**
         * @en Sets the global color.
         * @param nameID The ID of the data.
         * @param source The color data to be set.
         * @zh 设置全局颜色。
         * @param nameID 数据ID。
         * @param source 要设置的颜色数据。
         */
        setGlobalColor(nameID: number, source: Color): void;
        /**
         * @en Sets the Vector4 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector4 data to be set.
         * @zh 设置着色器的 Vector4 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector4数据。
         */
        setShaderDataVector(shaderData: ShaderData, nameID: number, value: Vector4): void;
        /**
         * @en Sets the global Vector4 data.
         * @param nameID The ID of the data.
         * @param source The Vector4 data to be set.
         * @zh 设置全局 Vector4 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector4数据。
         */
        setGlobalVector(nameID: number, source: Vector4): void;
        /**
         * @en Sets the Vector3 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector3 data to be set.
         * @zh 设置着色器的 Vector3 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector3数据。
         */
        setShaderDataVector3(shaderData: ShaderData, nameID: number, value: Vector3): void;
        /**
         * @en Sets the global Vector3 data.
         * @param nameID The ID of the data.
         * @param source The Vector3 data to be set.
         * @zh 设置全局 Vector3 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector3数据。
         */
        setGlobalVector3(nameID: number, source: Vector3): void;
        /**
         * @en Sets the Vector2 data for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Vector2 data to be set.
         * @zh 设置着色器的 Vector2 数据。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Vector2数据。
         */
        setShaderDataVector2(shaderData: ShaderData, nameID: number, value: Vector2): void;
        /**
         * @en Sets the global Vector2 data.
         * @param nameID The ID of the data.
         * @param source The Vector2 data to be set.
         * @zh 设置全局 Vector2 数据。
         * @param nameID 数据ID
         * @param source 要设置的Vector2数据。
         */
        setGlobalVector2(nameID: number, source: Vector2): void;
        /**
         * @en Sets the Number property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Number data to be set.
         * @zh 设置着色器的 Number 属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Number数据。
         */
        setShaderDataNumber(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * @en Sets the global Number property.
         * @param nameID The ID of the data.
         * @param source The Number data to be set.
         * @zh 设置全局 Number 属性。
         * @param nameID 数据ID
         * @param source 要设置的Number数据。
         */
        setGlobalNumber(nameID: number, source: number): void;
        /**
         * @en Sets the Int property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Int data to be set.
         * @zh 设置着色器的 Int 属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID
         * @param value 要设置的Int数据。
         */
        setShaderDataInt(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * @en Sets the global integer property.
         * @param nameID The ID of the data.
         * @param source The data to be set.
         * @zh 设置全局的整型属性。
         * @param nameID 数据ID
         * @param source 要设置的数据。
         */
        setGlobalInt(nameID: number, source: number): void;
        /**
         * @en Sets the Matrix property for a shader.
         * @param shaderData The collection of shader data.
         * @param nameID The ID of the data.
         * @param value The Matrix data to be set.
         * @zh 设置着色器的矩阵属性。
         * @param shaderData 着色器数据集合。
         * @param nameID 数据ID。
         * @param value 要设置的矩阵数据。
         */
        setShaderDataMatrix(shaderData: ShaderData, nameID: number, value: Matrix4x4): void;
        /**
         * @en Sets a shader define.
         * @param shaderData The collection of shader data.
         * @param define The shader define to be set.
         * @param value A boolean value indicating whether to add (true) or remove (false) the define.
         * @zh 设置着色器的定义。
         * @param shaderData 着色器数据集合。
         * @param define 要设置的着色器定义。
         * @param value 布尔值，表示是添加（true）还是移除（false）该定义。
         */
        setShaderDefine(shaderData: ShaderData, define: ShaderDefine, value: boolean): void;
        /**
         * @en Sets the global Matrix property.
         * @param nameID The ID of the data.
         * @param source The Matrix data to be set.
         * @zh 设置全局的矩阵属性。
         * @param nameID 数据ID
         * @param source 要设置的矩阵数据。
         */
        setGlobalMatrix(nameID: number, source: number): void;
        /**
         * @en Adds a fullscreen quad rendering command to the command buffer.
         * @param source The source texture. If null, the previous render result is used as the original texture.
         * @param dest The destination texture. If null, it renders directly to the final canvas.
         * @param offsetScale Offset scaling
         * @param shader The shader. If null, the internal copy shader is used without any processing.
         * @param shaderData The shader data. If null, only the sourceTexture is accepted.
         * @param subShader The subShader index, defaults to 0.
         * @zh 向命令缓冲区添加一条通过全屏四边形渲染命令。
         * @param source 源纹理。如果为null，则使用之前的渲染结果作为原纹理。
         * @param dest 目标纹理。如果为null，直接渲染到最终画布。
         * @param offsetScale 偏移缩放。
         * @param shader 着色器。如果为null，则使用内部拷贝着色器，不进行任何处理。
         * @param shaderData 着色器数据。如果为null，只接受sourceTexture。
         * @param subShader SubShader索引，默认值为0。
         */
        blitScreenQuad(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        /**
         * @en Add a command to render the source texture to the target texture through a full screen quadrilateral.
         * @param source The source texture. If null, the previous render result is used as the original texture.
         * @param dest The destination texture. If null, it renders directly to the final canvas.
         * @param offsetScale Offset scaling.
         * @param material The material.
         * @param subShader The shader index.
         * @zh 添加一条通过全屏四边形将源纹理渲染到目标渲染纹理指令。
         * @param source 源纹理。如果为null，则使用之前的渲染结果作为原纹理。
         * @param dest 目标纹理。如果为null，直接渲染到最终画布。
         * @param offsetScale 偏移缩放。
         * @param material 材质。
         * @param subShader Shader索引。
         */
        blitScreenQuadByMaterial(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, material?: Material, subShader?: number): void;
        /**
         * @en Add a command to render the source texture to the target texture through full screen triangles.
         * @param source The source texture.
         * @param dest The destination texture.
         * @param offsetScale Offset scaling.
         * @param shader The shader. If null, the internal copy shader is used without any processing.
         * @param shaderData The shader data. If null, only the sourceTexture is accepted.
         * @param subShader The subShader index, defaults to 0.
         * @zh 添加一条通过全屏三角形将源纹理渲染到目标渲染纹理指令。
         * @param source 源纹理。
         * @param dest 目标纹理。
         * @param offsetScale 偏移缩放。
         * @param shader 着色器。如果为null，则使用内部拷贝着色器，不进行任何处理。
         * @param shaderData 着色器数据。如果为null，只接受sourceTexture。
         * @param subShader SubShader索引，默认值为0。
         */
        blitScreenTriangle(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        appatchComputeCommand(source: ComputeCommandBuffer): void;
        /**
         * @en Sets the render target for the command buffer.
         * @param renderTexture The render target texture.
         * @param clearColor Whether to clear the color buffer.
         * @param clearDepth Whether to clear the depth buffer.
         * @param backgroundColor The background color when clearing. Defaults to black.
         * @param depth The depth value when clearing. Defaults to 1.
         * @zh 设置命令缓冲区的渲染目标。
         * @param renderTexture 渲染目标纹理。
         * @param clearColor 是否清除颜色缓冲区。
         * @param clearDepth 是否清除深度缓冲区。
         * @param backgroundColor 清除时的背景颜色，默认为黑色。
         * @param depth 清除时的深度值，默认为1。
         */
        setRenderTarget(renderTexture: RenderTexture, clearColor: boolean, clearDepth: boolean, backgroundColor?: Color, depth?: number): void;
        /**
         * @en Renders a Mesh.
         * @param mesh The original mesh information.
         * @param matrix The world matrix of the mesh.
         * @param material The material applied to the mesh.
         * @param submeshIndex The index of the submesh.
         * @param subShaderIndex The index of the sub-shader, generally 0.
         * @zh 渲染一个网格。
         * @param mesh 原始网格信息。
         * @param matrix 网格的世界矩阵。
         * @param material 应用到网格的材质。
         * @param submeshIndex 子网格的索引。
         * @param subShaderIndex 子着色器的索引，默认为0。
         */
        drawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, subShaderIndex: number): void;
        /**
         * @en Renders a Render object.
         * @param render The renderer object to be rendered.
         * @param material The material applied to the renderer.
         * @param subMeshIndex The index of the sub-shader, defaults to 0.
         * @zh 渲染一个渲染对象。
         * @param render 要渲染的渲染器对象。
         * @param material 应用到渲染器的材质。
         * @param subMeshIndex 子着色器的索引，默认为0。
         */
        drawRender(render: BaseRender, material: Material, subMeshIndex?: number): void;
        /**
         * @en Renders a RenderElement.
         * @param renderElement The RenderElement to be rendered.
         * @zh 渲染一个渲染元素。
         * @param renderElement 要渲染的渲染元素。
         */
        drawRenderElement(renderElement: RenderElement): void;
        /**
         * @en Renders a Mesh using instanced rendering for dynamic batching.
         * @param mesh The original mesh information.
         * @param subMeshIndex The index of the mesh.
         * @param matrixs An array of world matrices for rendering, describing the position of each Mesh to be rendered. If null, no world matrix buffer will be created or updated.
         * @param material The material used for rendering.
         * @param subShaderIndex The shader index of the rendering material.
         * @param instanceProperty Custom properties for the instance.
         * @param drawnums The number of instances to render.
         * @zh 使用实例化渲染动态合批方式渲染网格。
         * @param mesh 原始网格信息。
         * @param subMeshIndex 网格索引。
         * @param matrixs 渲染的世界矩阵数组，描述每个网格需要渲染的位置。如果为null，则不会创建或更新世界矩阵缓冲区。
         * @param material 渲染材质。
         * @param subShaderIndex 渲染材质的着色器索引。
         * @param instanceProperty 实例的自定义属性。
         * @param drawnums 要渲染的实例数量。
         */
        drawMeshInstance(mesh: Mesh, subMeshIndex: number, matrixs: Matrix4x4[], material: Material, subShaderIndex: number, instanceProperty: MaterialInstancePropertyBlock, drawnums: number): any;
        /**
         * @en Adds a custom render command.
         * @param command The custom command to add.
         * @zh 添加一个自定义的渲染命令。
         * @param command 要添加的自定义命令。
         */
        addCustomCMD(command: Command): void;
        /**
         * @internal
         * @en Clears the command buffer.
         * @zh 清除命令缓冲区。
         */
        clear(): void;
    }
    class ComputeCommandBufferCMD extends Command {
        /**@internal */
        private static readonly _pool;
        private _computeCMD;
        private _computeBuffer;
        /**
         * @internal
         */
        static create(value: ComputeCommandBuffer): ComputeCommandBufferCMD;
        constructor();
        set computeBuffer(value: ComputeCommandBuffer);
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): ComputeCommandAppatchCMD;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    /**
     * @internal
     * <code>SetShaderDataTextureCMD</code> 类用于创建设置渲染目标指令。
     */
    class DrawMeshCMD extends Command {
        private static readonly _pool;
        /**
         * @internal
         */
        static create(mesh: Mesh, matrix: Matrix4x4, material: Material, subMeshIndex: number, subShaderIndex: number, commandBuffer: CommandBuffer): DrawMeshCMD;
        /**@internal */
        private _material;
        /**@internal */
        private _matrix;
        /**@internal */
        private _subMeshIndex;
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        private _subShaderIndex;
        private _mesh;
        private _renderElemnts;
        /**@internal */
        _meshRender: MeshRenderer;
        private _transform;
        private _drawRenderCMDDData;
        constructor();
        /**
         * @internal
         */
        set material(value: Material);
        get material(): Material;
        /**
         * @internal
         */
        set mesh(value: Mesh);
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): DrawElementCMDData | DrawNodeCMDData;
        /**
         * @inheritDoc
         * @override
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    /**
     * @en DrawMeshInstancedCMD class for instanced mesh drawing command.
     * @zh DrawMeshInstancedCMD 类，用于实例化网格绘制命令。
     */
    class DrawMeshInstancedCMD extends Command {
        private static readonly _pool;
        /**
         * @en Maximum number of draw instances.
         * @zh 设置最大DrawInstance数。
         */
        static maxInstanceCount: number;
        /**
         * @internal
         * @en Create a command stream.
         * @param mesh The mesh to be drawn.
         * @param subMeshIndex The index of the sub-mesh.
         * @param matrixs Array of transformation matrices.
         * @param material The material to be used.
         * @param subShaderIndex The index of the sub-shader.
         * @param instanceProperty Material instance property block.
         * @param drawnums Number of instances to be drawn.
         * @param commandBuffer The command buffer.
         * @returns A new DrawMeshInstancedCMD instance.
         * @zh 创建一个命令流。
         * @param mesh 要绘制的网格。
         * @param subMeshIndex 子网格索引。
         * @param matrixs 变换矩阵数组。
         * @param material 要使用的材质。
         * @param subShaderIndex 子着色器索引。
         * @param instanceProperty 材质实例属性块。
         * @param drawnums 要绘制的实例数量。
         * @param commandBuffer 命令缓冲区。
         * @return 一个新的 DrawMeshInstancedCMD 实例。
         */
        static create(mesh: Mesh, subMeshIndex: number, matrixs: Matrix4x4[], material: Material, subShaderIndex: number, instanceProperty: MaterialInstancePropertyBlock, drawnums: number, commandBuffer: CommandBuffer): DrawMeshInstancedCMD;
        /**@internal */
        private _material;
        /**@internal */
        private _matrixs;
        /**@internal */
        private _subMeshIndex;
        /**@internal */
        private _subShaderIndex;
        /**@internal */
        private _mesh;
        /**@internal */
        private _instanceProperty;
        /** @internal */
        private _instanceBufferState;
        /** @internal */
        private _drawnums;
        /**@internal 世界矩阵数据*/
        private _instanceWorldMatrixData;
        /**@internal 世界矩阵buffer*/
        private _instanceWorldMatrixBuffer;
        /**@internal */
        private _instanceGeometryArray;
        /**@internal */
        private _instanceRenderElementArray;
        /**@internal */
        _byteCount: number;
        /**@internal */
        _transform: Transform3D;
        /**@internal */
        _render: BaseRender;
        /**@internal */
        _drawElementCMDData: DrawElementCMDData;
        constructor();
        /**
         * @en The material for the command.
         * @zh 命令的材质。
         */
        set material(value: Material);
        /**
         * @en The buffer state.
         * @zh 缓冲状态。
         */
        get bufferState(): VertexBuffer3D;
        /**
         * @en The mesh of the command.
         * @zh 命令的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        /**
         * @internal
         */
        private _setInstanceBuffer;
        /**
         * 更新世界矩阵buffer
         * @internal
         */
        private _updateWorldMatrixBuffer;
        /**
         * @en Reset the world matrix array for DrawInstance.
         * @param worldMatrixArray Array of world matrices.
         * @zh 重置DrawInstance的世界矩阵数组。
         * @param worldMatrixArray 世界矩阵数组
         */
        setWorldMatrix(worldMatrixArray: Matrix4x4[]): void;
        /**
         * @en Reset the number of instances to draw.
         * @param drawNums Number of instances to draw.
         * @zh 重置渲染个数。
         * @param drawNums 渲染个数。
         */
        setDrawNums(drawNums: number): void;
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): DrawElementCMDData;
        /**
         * @en Update the render element.
         * @param renderElement The render element to update.
         * @param context The render context.
         * @returns The updated IRenderElement3D.
         * @zh 更新渲染元素。
         * @param renderElement 要更新的渲染元素。
         * @param context 渲染上下文。
         * @return 更新后的IRenderElement3D。
         */
        renderUpdateElement(renderElement: RenderElement, context: RenderContext3D): IRenderElement3D;
        /**
         * @en Execute the command.
         * @zh 执行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recycle the command.
         * @zh 回收命令。
         */
        recover(): void;
        /**
         * @internal
         * @en Destroy the command.
         * @zh 销毁命令。
         */
        destroy(): void;
    }
    /**
     * @en Represents a draw render command.
     * @zh 表示一个绘制渲染命令。
     */
    class DrawRenderCMD extends Command {
        private static readonly _pool;
        /**
         * @internal
         */
        static create(render: BaseRender, material: Material, subMeshIndex: number, commandBuffer: CommandBuffer): DrawRenderCMD;
        /**@internal */
        private _render;
        /**
         * @en The render object.
         * @zh 渲染对象。
         */
        get render(): BaseRender;
        set render(render: BaseRender);
        /**@internal */
        private _material;
        /**
         * @en The material.
         * @zh 材质。
         */
        get material(): Material;
        set material(value: Material);
        private _subMeshIndex;
        /**
         * @en The sub-mesh index.
         * @zh 子网格索引。
         */
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        /**@internal */
        private _prematerial;
        /**@internal */
        _drawNodeCMDData: DrawNodeCMDData;
        constructor();
        /**
         * @en Gets the render command data.
         * @zh 获取渲染命令数据。
         */
        getRenderCMD(): DrawNodeCMDData;
        /**
         * @en Runs the  command.
         * @zh 运行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the render command for reuse.
         * @zh 回收渲染命令以供重用。
         */
        recover(): void;
        /**
         * @en Destroys the render command.
         * @zh 销毁渲染命令。
         */
        destroy(): void;
    }
    /**
     * @en Represents a draw render element command.
     * @zh 表示一个绘制渲染元素命令。
     */
    class DrawRenderElementCMD extends Command {
        private static readonly _pool;
        /**
         * @en Creates a new instance of the command or retrieves one from the pool.
         * @param renderElement The render element associated with this command.
         * @returns A new or pooled instance of `DrawRenderElementCMD`.
         * @zh 创建命令的新实例或从池中检索一个实例。
         * @param renderElement 与此命令关联的渲染元素。
         * @return 一个新的或从池中检索到的 `DrawRenderElementCMD` 实例。
         */
        static create(renderElement: RenderElement): DrawRenderElementCMD;
        /**@internal */
        _drawElementCMDData: DrawElementCMDData;
        /**@internal */
        private _renderElement;
        /**
         * @en The render element of this command.
         * @zh 此命令的渲染元素。
         */
        get renderElement(): RenderElement;
        set renderElement(value: RenderElement);
        constructor();
        /**
         * @inheritDoc
         * @override
         * @en Recovers the command for reuse.
         * @zh 回收命令以供重用。
         */
        recover(): void;
        /**
         * @override
         * @internal
         * @en Gets the render command data.
         * @zh 获取渲染命令数据。
         */
        getRenderCMD(): DrawElementCMDData;
        /**
         * @en Destroys the command.
         * @zh 销毁命令。
         */
        destroy(): void;
    }
    /**
     * @ignore
     * @en The `ScreenQuad` class is used to create a fullscreen quad.
     * @zh `ScreenQuad` 类用于创建全屏四边形。
     */
    class ScreenQuad extends GeometryElement {
        static instance: ScreenQuad;
        static InvertInstance: ScreenQuad;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        private _vertexBuffer;
        /** @internal */
        protected _bufferState: BufferState;
        /** @internal */
        private _vertexBufferInvertUV;
        /** @internal */
        private _bufferStateInvertUV;
        /**
         * @ignore
         * @en Construcutor method, do not use.
         * @zh 构造方法，禁止使用。
         */
        constructor();
        /**
         * @en Sets whether to invert the Y-axis and selects the corresponding buffer state.
         * @param value Whether to invert the Y-axis
         * @zh 设置Y轴是否反转，并选择相应的缓冲状态。
         * @param value 是否反转Y轴
         */
        set invertY(value: boolean);
        /**
         * @internal
         * UpdateGeometry Data
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Destroys the ScreenQuad instance.
         * @zh 销毁ScreenQuad实例。
         */
        destroy(): void;
    }
    /**
     * @internal
     * <code>Mesh</code> 类用于创建CustomInstance属性。
     */
    class MaterialInstanceProperty {
        /**@internal instanceProperty name*/
        _name: string;
        /**@internal property Data*/
        _value: Vector4[] | Vector3[] | Vector2[] | Float32Array;
        /**@internal vertex Declaration */
        _vertexDeclaration: VertexDeclaration;
        /**@internal */
        _isNeedUpdate: boolean;
        /**@internal */
        _vertexStride: number;
        /**@internal */
        _instanceData: Float32Array;
        /**@internal */
        _vertexBuffer: VertexBuffer3D;
        /**
         * @internal
         * 创建instance顶点Buffer
         */
        createInstanceVertexBuffer3D(): void;
        /**
         * @internal
         * 更新顶点数据
         */
        updateVertexBufferData(drawNums: number): void;
        destroy(): void;
    }
    enum InstanceLocation {
        CUSTOME0 = 12,
        CUSTOME1 = 13,
        CUSTOME2 = 14,
        CUSTOME3 = 15
    }
    /**
     * @en Material instance property block.
     * @zh 材质实例属性块。
     */
    class MaterialInstancePropertyBlock {
        /**Instance合并方案 */
        /**
         * @en Attribute instance rendering scheme. Advantages: High merge quantity, high merge efficiency, good rendering performance. Disadvantages: Few instance variable elements.
         * @zh 属性实例渲染方案。优点：合并数量多，合并效率高，渲染性能优。缺点：实例变量元素少。
         */
        static INSTANCETYPE_ATTRIBUTE: number;
        /**
         * @en Uniform instance rendering scheme. Advantages: Many instance variables, flexible. Disadvantages: Merge quantity affected by WebGLContext._maxUniformFragmentVectors, low merge efficiency.
         * @zh 统一实例渲染方案。优点：实例变量多，灵活。缺点：合并数量受 WebGLContext._maxUniformFragmentVectors 的影响，合并效率低。
         */
        static INSTANCETYPE_UNIFORMBUFFER: number;
        /**@internal instance type*/
        protected _type: number;
        /**@internal property map*/
        _propertyMap: {
            [key: number]: MaterialInstanceProperty;
        };
        constructor();
        /**
         * @internal 检查传入的参数是否符合规则
         * @param vertexElementFormat 顶点元素
         * @param propertyName 属性名
         * @param attributeLocation attribute位置
         * @param prob 材质属性
         */
        private _checkPropertyLegal;
        /**
         * 创建instance属性
         * @param attributeName name
         * @param arrays data
         * @param vertexStride vertex size
         * @param vertexformat vertexFormat
         * @param attributeLocation  attribute location
         */
        private _creatProperty;
        /**
         * @en Set Vector4 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector4 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVectorArray(attributeName: string, arrays: Vector4[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Vector3 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector3 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVector3Array(attributeName: string, arrays: Vector3[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Vector2 material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Vector2 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setVector2Array(attributeName: string, arrays: Vector2[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Set Number material array property.
         * @param attributeName The attribute name (should correspond to the Shader).
         * @param arrays The data.
         * @param attributeLocation The attribute Shader location (needs to correspond one-to-one with the Attribute declaration in the shader).
         * @zh 设置 Number 材质数组属性。
         * @param attributeName 属性名称（要对应到 Shader 中）。
         * @param arrays 数据。
         * @param attributeLocation 属性 Shader 位置（需要与 shader 中的声明 Attribute 一一对应）。
         */
        setNumberArray(attributeName: string, arrays: Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * @en Get property data.
         * @param attributeLocation The attribute Shader location.
         * @zh 获得属性数据。
         * @param attributeLocation 属性 Shader 位置。
         */
        getPropertyArray(attributeLocation: InstanceLocation): Vector4[] | Vector3[] | Vector2[] | Float32Array;
        /**
         * @en Clear all properties.
         * @zh 清除所有属性。
         */
        clear(): void;
    }
    /**
     * @internal
     * @en SetGlobalShaderDataCMD class is used to create a command for setting global shader data.
     * @zh SetGlobalShaderDataCMD 类用于创建设置全局着色器数据的指令。
     */
    class SetGlobalShaderDataCMD extends Command {
        /**
         * @internal
         * @en Creates a SetGlobalShaderDataCMD instance.
         * @param nameID The ID of the shader property name.
         * @param value The value to set for the shader property.
         * @param shaderDataType The type of shader data.
         * @param commandBuffer The command buffer to which this command will be added.
         * @returns A new SetGlobalShaderDataCMD instance.
         * @zh 创建一个 SetGlobalShaderDataCMD 实例。
         * @param nameID 着色器属性名称的ID。
         * @param value 要为着色器属性设置的值。
         * @param shaderDataType 着色器数据的类型。
         * @param commandBuffer 将添加此命令的命令缓冲区。
         * @returns 一个新的 SetGlobalShaderDataCMD 实例。
         */
        static create(nameID: number, value: any, shaderDataType: ShaderDataType, commandBuffer: CommandBuffer): SetGlobalShaderDataCMD;
    }
    /**
     * @internal
     * @en SetRTCMD used to create a command to set the render target.
     * @zh SetRTCMD 类用于创建设置渲染目标指令。
     */
    class SetRTCMD extends Command {
        private static readonly _pool;
        /**
         * @internal
         * @en Creates a SetRTCMD instance.
         * @param renderTexture The render texture to set.
         * @param clearColor Whether to clear the color buffer.
         * @param clearDepth Whether to clear the depth buffer.
         * @param clearStencil Whether to clear the stencil buffer.
         * @param backgroundColor The background color to clear with.
         * @param depth The depth value to clear with. Default is 1.
         * @param stencil The stencil value to clear with. Default is 0.
         * @param commandBuffer The command buffer to which this command will be added.
         * @zh 创建一个 SetRTCMD 实例。
         * @param renderTexture 要设置的渲染纹理。
         * @param clearColor 是否清除颜色缓冲区。
         * @param clearDepth 是否清除深度缓冲区。
         * @param clearStencil 是否清除模板缓冲区。
         * @param backgroundColor 用于清除的背景颜色。
         * @param depth 用于清除的深度值。默认为1。
         * @param stencil 用于清除的模板值。默认为0。
         * @param commandBuffer 将添加此命令的命令缓冲区。
         */
        static create(renderTexture: RenderTexture, clearColor: boolean, clearDepth: boolean, clearStencil: boolean, backgroundColor: Color, depth: number, stencil: number, commandBuffer: CommandBuffer): SetRTCMD;
        /**@internal */
        private _renderTexture;
        /**@internal */
        _setRenderTargetCMD: SetRenderTargetCMD;
        /**
         * @en The render texture.
         * @zh 渲染纹理。
         */
        get renderTexture(): RenderTexture;
        set renderTexture(value: RenderTexture);
        constructor();
        /**
         * @override
         * @internal
         * @en Retrieves the render command.
         * @zh 获取渲染命令。
         */
        getRenderCMD(): SetRenderTargetCMD;
        /**
         * @inheritDoc
         * @override
         * @en Recycles the command object for later use.
         * @zh 回收命令以便复用。
         */
        recover(): void;
    }
    /**
     * @internal
     * <code>SetShaderDataTextureCMD</code> 类用于创建设置渲染目标指令。
     */
    class SetShaderDataCMD extends Command {
        static readonly ShaderDataType_define: number;
        /**@internal */
        private static readonly _pool;
        /**@internal */
        _setRenderDataCMD: SetRenderDataCMD;
        /**
         * @internal
         */
        static create(shaderData: ShaderData, nameID: number, value: ShaderDataItem, shaderDataType: ShaderDataType, commandBuffer: CommandBuffer): SetShaderDataCMD;
        constructor();
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): SetRenderDataCMD;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    class SetDefineCMD extends Command {
        private static readonly _pool;
        /**@internal */
        _setRenderDefineCMD: SetShaderDefineCMD;
        /**
         * @internal
         */
        static create(shaderData: ShaderData, define: ShaderDefine, addDefine: boolean, commandBuffer: CommandBuffer): SetDefineCMD;
        constructor();
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): SetShaderDefineCMD;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    /**
     * @en The `InstanceRenderElement` is used for instanced rendering.
     * @zh `InstanceRenderElement` 类用于实例化渲染。
     */
    class InstanceRenderElement extends RenderElement {
        /** @internal */
        static readonly maxInstanceCount: number;
        private static readonly _pool;
        /**
         * @en Creates an instance of `InstanceRenderElement`, reusing from the pool if available.
         * @zh 创建 `InstanceRenderElement` 的实例，如果池中有可用的实例则重用。
         */
        static create(): InstanceRenderElement;
        /**@internal */
        _instanceBatchElementList: FastSinglelist<RenderElement>;
        /**@internal */
        _isInPool: boolean;
        /**
         * @internal
         * 判断是否需要更新数据
         * */
        _isUpdataData: boolean;
        /** @internal */
        _invertFrontFace: boolean;
        /**@internal recover renderData*/
        private oriRendertype;
        /**@internal */
        private _InvertFront;
        constructor();
        /**
         * @internal
         */
        getInvertFront(): boolean;
        set InvertFront(value: boolean);
        protected _createRenderElementOBJ(): void;
        /** @ignore */
        compileShader(context: IRenderContext3D): void;
        /**@ignore */
        _renderUpdatePre(context: RenderContext3D): void;
        /**@ignore */
        updateInstanceData(mesh: Mesh): void;
        /**
         * @en Clears the instance render element.
         * @zh 清除实例渲染元素。
         */
        clear(): void;
        /**
         * @en Recovers the render element to its original state.
         * @zh 恢复渲染元素到原始状态。
         */
        recover(): void;
    }
    /**
     * @en The `PostProcess` class is used to create post-processing components.
     * @zh `PostProcess` 类用于创建后期处理组件。
     */
    class PostProcess {
        /**@internal */
        static SHADERDEFINE_BLOOM_LOW: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_BLOOM: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FINALPASS: ShaderDefine;
        /**@internal */
        static SHADERVALUE_MAINTEX: number;
        /**@internal */
        static SHADERVALUE_BLOOMTEX: number;
        /**@internal */
        static SHADERVALUE_AUTOEXPOSURETEX: number;
        /**@internal */
        static SHADERVALUE_BLOOM_DIRTTEX: number;
        /**@internal */
        static SHADERVALUE_BLOOMTEX_TEXELSIZE: number;
        /**@internal */
        static SHADERVALUE_BLOOM_DIRTTILEOFFSET: number;
        /**@internal */
        static SHADERVALUE_BLOOM_SETTINGS: number;
        /**@internal */
        static SHADERVALUE_BLOOM_COLOR: number;
        /**
         * @internal
         */
        static __init__(): void;
        /**@internal */
        private _compositeShaderData;
        /**@internal */
        private _effects;
        /**@internal */
        private _enable;
        /**@internal */
        private _depthtextureFlag;
        /**
         * @internal
         * @en Color Effect
         * @zh 调色Effect
         */
        _ColorGradEffect: ColorGradEffect;
        /**
         * @internal
         * @en Whether to enable the color effect.
         * @zh 是否开启调色Effect
         */
        _enableColorGrad: boolean;
        /**@internal */
        _context: PostProcessRenderContext;
        /**
         * 重新计算CameraFlag
         */
        private recaculateCameraFlag;
        /**
         * @en Add a post-process effect.
         * @zh 构造方法，添加后期处理效果。
         */
        constructor();
        /**
         * @en The enable property of the post-process.
         * @zh 启用后期处理。
         */
        get enable(): boolean;
        set enable(value: boolean);
        /**
         * 设置渲染状态
         * @internal
         */
        set commandContext(oriContext: RenderContext3D);
        /**
         * @en Set the array of post-process effects.IDE main
         * @zh 设置后期处理效果数组。
         */
        get effects(): PostProcessEffect[];
        set effects(value: PostProcessEffect[]);
        /**
         * @en The camera depth texture mode required for post-processing.
         * @zh 后期处理所需的相机深度纹理模式。
         */
        get cameraDepthTextureMode(): DepthTextureMode;
        /**
         *@internal
         */
        _init(camera: Camera): void;
        /**
         * @internal
         */
        _render(camera: Camera): void;
        /**
         * @en Add a post-processing effect.
         * @param effect The post-processing effect to add.
         * @zh 添加后期处理效果。
         * @param effect 后期处理效果
         */
        addEffect<T extends PostProcessEffect>(effect: T): T | null;
        /**
         * @en Get a post-processing instance based on its type.
         * @param classReg The registered post-processing class type.
         * @returns The post-processing effect instance, or null if not found.
         * @zh 根据类型获取后期处理实例。
         * @param classReg 注册的后期处理类型
         * @returns 后期处理效果实例，如果没有找到则返回null
         */
        getEffect<T extends PostProcessEffect>(classReg: new () => T): T;
        /**
         * @en Remove a post-processing effect.
         * @param effect The post-processing effect to remove.
         * @zh 移除后期处理效果。
         * @param effect 后期处理效果
         */
        removeEffect(effect: PostProcessEffect): void;
        /**
         * @en Clear all post-processing effects.
         * @zh 清理所有后期处理效果。
         */
        clearEffect(): void;
        /**
         * @internal
         * @en Call the instruction set.
         * @zh 调用指令集。
         */
        _applyPostProcessCommandBuffers(): void;
    }
    /**
     * @en Used to create post-processing rendering effects.
     * @zh 后期处理渲染效果的基类。
     * @blueprintable @blueprintableSubclasses
     */
    class PostProcessEffect {
        protected _active: boolean;
        protected _singleton: boolean;
        /**
         * @ignore
         */
        constructor();
        /**
         * @internal
         * @en Whether only one instance of the effect can be added.
         * @zh 是否只能添加一个效果实例。
         */
        get singleton(): boolean;
        /**
         * @en Whether the effect is enabled.
         * @zh 效果是否开启。
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en Gets the camera depth texture mode flag based on post-processing settings.
         * @zh 根据后期处理设置获取摄像机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag(): number;
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing component.
         * @zh 在添加到后期处理栈时调用。
         * @param postprocess 后期处理组件。
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * @en Releases the effect.
         * @param postprocess The post-processing component.
         * @zh 释放效果。
         * @param postprocess 后期处理组件。
         */
        release(postprocess: PostProcess): void;
        /**
         * @en Renders the effect.
         * @param context The post-processing rendering context.
         * @zh 渲染效果。
         * @param context 后期处理渲染上下文。
         */
        render(context: PostProcessRenderContext): void;
    }
    /**
     * @en The `PostProcessRenderContext` class is used to create a post-processing rendering context.
     * @zh `PostProcessRenderContext` 类用于创建后期处理渲染上下文。
     * @blueprintIgnore
     */
    class PostProcessRenderContext {
        /**
         * @en The original RenderTexture that is rendered to initially. Do not modify this RT.
         * @zh 原始渲染 RenderTexture (RT)，禁止改变此 RT。
         */
        source: RenderTexture | null;
        /**
         * @en forward effect target
         * @zh 上个后期处理的结果
         */
        indirectTarget: RenderTexture | null;
        /**
         * @en The RenderTexture where the processed result should be drawn to.
         * @zh 需要将处理后的结果画入此 RenderTexture。
         */
        destination: RenderTexture | null;
        /**
         * @en The rendering camera.
         * @zh 渲染相机。
         */
        camera: Camera | null;
        /**
         * @en The composite shader data.
         * @zh 合成着色器数据。
         */
        compositeShaderData: ShaderData | null;
        /**
         * @en The post-processing command buffer.
         * @zh 后期处理指令流。
         */
        command: CommandBuffer | null;
        /**
         * @en Temporary texture array. You can put created textures here or select an RT to use from here to save memory.
         * @zh 临时纹理数组。可以将创建的纹理放入此数组，也可以从这里选取要用的 RT 来节省显存。
         */
        deferredReleaseTextures: RenderTexture[];
        /**
         * @en Selects an RT from recycled RTs to save memory.
         * @param width The width of the RenderTexture.
         * @param height The height of the RenderTexture.
         * @param colorFormat The color format of the RenderTexture.
         * @param depthFormat The depth format of the RenderTexture.
         * @param mipmap Whether to generate mipmaps.
         * @param multiSamples The number of multisamples.
         * @param depthTexture Whether to generate a depth texture.
         * @param sRGB Whether the RenderTexture is in sRGB color space.
         * @returns The selected RenderTexture or null if no match is found.
         * @zh 从回收的 RT 中选择一个 RT 用来节省内存。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param colorFormat 纹理的颜色格式。
         * @param depthFormat 纹理的深度格式。
         * @param mipmap 是否生成 mipmap。
         * @param multiSamples 多重采样数。
         * @param depthTexture 是否生成深度纹理。
         * @param sRGB 纹理是否在 sRGB 色彩空间。
         * @returns 选择到的 RenderTexture，如果没有匹配的，则返回 null。
         */
        createRTByContextReleaseTexture(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean): RenderTexture;
    }
    /**
     * @en Used to implement rendering states.
     * @zh 用于实现渲染状态。
     * @blueprintIgnore
     */
    class RenderContext3D {
        /**
         * @en The singleton instance of the RenderContext3D.
         * @zh RenderContext3D的单例实例。
         */
        static _instance: RenderContext3D;
        /**
         * @en The width of the rendering area.
         * @zh 渲染区域的宽度。
         */
        static clientWidth: number;
        /**
         * @en The height of the rendering area.
         * @zh 渲染区域的高度。
         */
        static clientHeight: number;
        /** @internal */
        static GammaCorrect: ShaderDefine;
        /**@internal */
        static __init__(): void;
        /** @internal */
        viewMatrix: Matrix4x4;
        /**@internal */
        customShader: Shader3D;
        /**@internal */
        replaceTag: string;
        /** @internal */
        projectionMatrix: Matrix4x4;
        /** @internal */
        projectionViewMatrix: Matrix4x4;
        private _camera;
        get camera(): Camera;
        set camera(value: Camera);
        /**@internal */
        _scene: Scene3D;
        /**
         * @en The rendering pipeline mode.
         * @zh 渲染管线模式
         */
        configPipeLineMode: PipelineMode;
        /**@internal contextOBJ*/
        _contextOBJ: IRenderContext3D;
        /**
         * @internal
         * @en The destination render target.
         * @zh 目标渲染目标。
         */
        set destTarget(value: IRenderTarget);
        /**
         * @en The viewport for rendering.
         * @zh 渲染视口。
         */
        set viewport(value: Viewport);
        /**
         * @en The scissor rectangle for rendering.
         * @zh 渲染裁剪矩形。
         */
        set scissor(value: Vector4);
        /** @internal */
        get invertY(): boolean;
        set invertY(value: boolean);
        /** @internal */
        get pipelineMode(): PipelineMode;
        set pipelineMode(value: PipelineMode);
        /**
         * @en The camera shader data.
         * @zh 相机着色器数据。
         */
        get cameraShaderValue(): ShaderData;
        set cameraShaderValue(value: ShaderData);
        /**
         * @internal
         * @en The current scene.
         * @zh 当前场景。
         */
        get scene(): Scene3D;
        set scene(value: Scene3D);
        /**
         * @en Changes the viewport.
         * @param x The x-coordinate of the viewport.
         * @param y The y-coordinate of the viewport.
         * @param width The width of the viewport.
         * @param height The height of the viewport.
         * @zh 更改视口。
         * @param x 视口 x 坐标。
         * @param y 视口 y 坐标。
         * @param width 视口的宽度。
         * @param height 视口的高度。
         */
        changeViewport(x: number, y: number, width: number, height: number): void;
        /**
         * @en Changes the scissor rectangle.
         * @param x The x-coordinate of the scissor rectangle.
         * @param y The y-coordinate of the scissor rectangle.
         * @param width The width of the scissor rectangle.
         * @param height The height of the scissor rectangle.
         * @zh 更改裁剪矩形。
         * @param x 裁剪矩形的 x 坐标。
         * @param y 裁剪矩形的 y 坐标。
         * @param width 裁剪矩形的宽度。
         * @param height 裁剪矩形的高度。
         */
        changeScissor(x: number, y: number, width: number, height: number): void;
        /**
         * @en Applies the context with the given camera update mark.
         * @param cameraUpdateMark The camera update mark.
         * @zh 应用具有给定相机更新标记的上下文。
         * @param cameraUpdateMark 相机更新标记。
         */
        applyContext(cameraUpdateMark: number): void;
        /**
         * @en Draws a single render element.
         * @param renderelemt The render element to draw.
         * @zh 渲染单个渲染元素。
         * @param renderelemt 要绘制的渲染元素。
         */
        drawRenderElement(renderelemt: IRenderElement3D): void;
        /**@ignore */
        constructor();
    }
    /**
     * @en RenderElement class is used to implement rendering elements.
     * @zh RenderElement 类用于实现渲染元素。
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    class RenderElement {
        /**
         * @en Can submit underlying rendering nodes
         * @zh 可提交底层的渲染节点
         */
        _renderElementOBJ: IRenderElement3D;
        /** @internal */
        _geometry: GeometryElement;
        /** @internal */
        _material: Material;
        /** @internal */
        _baseRender: BaseRender;
        /**@internal */
        _subShader: SubShader;
        /**@internal */
        _subShaderIndex: number;
        /**@internal */
        _transform: Transform3D;
        /**
         * @internal
         * @en The transform of the render element.
         * @zh 渲染元素的变换。
         */
        get transform(): Transform3D;
        set transform(value: Transform3D);
        /**
         * @en The material of the render element.
         * @zh 渲染元素的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The SubShader of the render element.
         * @zh 渲染元素的 SubShader。
         */
        get renderSubShader(): SubShader;
        set renderSubShader(value: SubShader);
        /**
         * @en The SubShader index of the render element.
         * @zh 渲染元素的 SubShader 索引。
         */
        get subShaderIndex(): number;
        set subShaderIndex(value: number);
        /**
         * @internal
         * @en The BaseRender of the render element.
         * @zh 渲染元素的 BaseRender。
         */
        get render(): BaseRender;
        set render(value: BaseRender);
        /**@ignore */
        constructor();
        protected _createRenderElementOBJ(): void;
        /**
         * @en Set the transform of the render element.
         * @param transform The transform to set.
         * @zh 设置渲染元素的位置变换。
         * @param transform 要设置的变换。
         */
        setTransform(transform: Transform3D): void;
        /**
         * @en Set the geometry information of the render element.
         * @param geometry The geometry to set.
         * @zh 设置渲染元素的几何信息。
         * @param geometry 要设置的几何信息。
         */
        setGeometry(geometry: GeometryElement): void;
        /**
         * @internal
         */
        destroy(): void;
    }
    /**
     * @internal
     */
    class SkinRenderElement extends RenderElement {
        /**
         * 可提交底层的渲染节点
         */
        _renderElementOBJ: WebGLSkinRenderElement3D;
        setSkinData(value: Float32Array[]): void;
        constructor();
        protected _createRenderElementOBJ(): void;
        _render(context: IRenderContext3D): void;
    }
    /**
     * @en The `SkyRenderElement` class is a render element that represents the sky.
     * @zh `SkyRenderElement` 类表示天空渲染元素。
     */
    class SkyRenderElement extends RenderElement {
        /**
         * @en The render element object that is declared for rendering.
         * @zh 声明用于渲染的渲染元素对象。
         */
        _renderElementOBJ: IRenderElement3D;
        private _viewMatrix;
        private _projectionMatrix;
        private _projectViewMatrix;
        constructor();
        /**
         * @en Calculates the view matrix based on the camera's view matrix.
         * @param cameraViewMat The camera's view matrix.
         * @zh 根据摄像机的视图矩阵计算视图矩阵。
         * @param cameraViewMat 摄像机的视图矩阵。
         */
        calculateViewMatrix(cameraViewMat: Matrix4x4): void;
        /**
         * @en Calculates the projection matrix based on the camera's projection matrix and other parameters.
         * @param cameraProjMat The camera's projection matrix.
         * @param aspectRatio The aspect ratio of the projection.
         * @param nearPlane The near plane distance of the projection.
         * @param farPlane The far plane distance of the projection.
         * @param fov The field of view for the perspective projection.
         * @param orthographic Whether to use an orthographic projection.
         * @zh 根据摄像机的投影矩阵和其他参数计算投影矩阵。
         * @param cameraProjMat 摄像机的投影矩阵。
         * @param aspectRatio 投影的纵横比。
         * @param nearPlane 投影的近平面距离。
         * @param farPlane 投影的远平面距离。
         * @param fov 透视投影的视场角。
         * @param orthographic 是否使用正交投影。
         */
        caluclateProjectionMatrix(cameraProjMat: Matrix4x4, aspectRatio: number, nearPlane: number, farPlane: number, fov: number, orthographic: boolean): void;
        /**
         * @en Prepares for rendering by setting up matrices and lighting information for sky rendering.
         * @param context The rendering context.
         * @zh 渲染前的准备工作，设置天空渲染所需的矩阵和光照信息。
         * @param context 渲染上下文。
         */
        renderpre(context: RenderContext3D): void;
    }
    /**
     * @en The `Sprite3DRenderDeclaration` class contains shader defines used in 3D sprite rendering.
     * @zh `Sprite3DRenderDeclaration` 类包含了3D精灵渲染中使用的着色器定义。
     */
    class Sprite3DRenderDeclaration {
        /**@internal */
        static SHADERDEFINE_GI_LEGACYIBL: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_IBL_RGBD: ShaderDefine;
        /**
         * @en Box reflection macro
         * @zh 盒子反射宏 */
        static SHADERDEFINE_SPECCUBE_BOX_PROJECTION: ShaderDefine;
    }
    /**
     * @internal
     */
    class SubMeshRenderElement extends RenderElement {
        private _dynamicWorldPositionNormalNeedUpdate;
        /** @internal */
        staticBatchIndexStart: number;
        /** @internal */
        staticBatchIndexEnd: number;
        /** @internal */
        staticBatchElementList: FastSinglelist<SubMeshRenderElement>;
        /** @internal */
        instanceSubMesh: SubMesh;
        /** @internal */
        instanceBatchElementList: FastSinglelist<SubMeshRenderElement>;
        /** @internal */
        vertexBatchElementList: FastSinglelist<SubMeshRenderElement>;
        /** @internal */
        vertexBatchVertexDeclaration: VertexDeclaration;
        /**
         * @ignore
         * 创建一个 <code>SubMeshRenderElement</code> 实例。
         */
        constructor();
        private _onWorldMatrixChanged;
        setTransform(transform: Transform3D): void;
        setGeometry(geometry: GeometryElement): void;
        destroy(): void;
    }
    /**
     * @deprecated
     * <code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
     */
    class RenderableSprite3D extends Sprite3D {
        /**精灵级着色器宏定义,接收阴影。*/
        static SHADERDEFINE_RECEIVE_SHADOW: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图。*/
        static SAHDERDEFINE_LIGHTMAP: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图方向。 */
        static SHADERDEFINE_LIGHTMAP_DIRECTIONAL: ShaderDefine;
        /**着色器变量名，光照贴图缩放和偏移。*/
        static LIGHTMAPSCALEOFFSET: number;
        /**着色器变量名，光照贴图。*/
        static LIGHTMAP: number;
        /**着色器变量名，光照贴图方向。*/
        static LIGHTMAP_DIRECTION: number;
        /**拾取颜色。*/
        static PICKCOLOR: number;
        static SHADERDEFINE_MORPHTARGET: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_POSITION: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_NORMAL: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_TANGENT: ShaderDefine;
        /** @internal */
        static MorphTex: number;
        /** @internal */
        static MorphParams: number;
        /** @internal */
        static MorphAttriOffset: number;
        /** @internal */
        static MorphActiceTargets: number;
        /** @internal */
        static MorphActiveCount: number;
        /**
         * @deprecated
         * @internal
         */
        static AMBIENTSHAR: number;
        /**
         * @deprecated
         * @internal
         */
        static AMBIENTSHAG: number;
        /**
         * @deprecated
         * @internal
         */
        static AMBIENTSHAB: number;
        /**
         * @deprecated
         * @internal
         */
        static AMBIENTSHBR: number;
        /**
        * @deprecated
        * @internal
        */
        static AMBIENTSHBG: number;
        /**
        * @deprecated
        * @internal
        */
        static AMBIENTSHBB: number;
        /**
        * @deprecated
        * @internal
        */
        static AMBIENTSHC: number;
        /**
         * @deprecated
         *  反射贴图
         */
        static REFLECTIONTEXTURE: number;
        /**
         * @deprecated
         *  反射贴图参数
         */
        static REFLECTIONCUBE_HDR_PARAMS: number;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        _render: BaseRender;
        /**
         * @deprecated
         * 创建一个 <code>RenderableSprite3D</code> 实例。
         */
        constructor(name: string);
        /**
         * @internal
         * @inheritDoc
         */
        protected _onInActive(): void;
        /**
         * @internal
         * @inheritDoc
         */
        protected _onActive(): void;
        /**
         * @internal
         * @inheritDoc
         */
        protected _onActiveInScene(): void;
        /**
         * @internal
         */
        _addToInitStaticBatchManager(): void;
        /**
         * @inheritDoc
         * @internal
         */
        _setBelongScene(scene: Node): void;
        /**
         * @inheritDoc
         * @internal
         */
        _setUnBelongScene(): void;
    }
    /**
     * @en Environment light mode.
     * @zh 环境光模式。
     */
    enum AmbientMode {
        /**
         * @en Fixed color
         * @zh 固定颜色。
         */
        SolidColor = 0,
        /**
         * @en Spherical harmonic illumination generates spherical harmonic data through the sky box.
         * @zh 球谐光照, 通过天空盒生成的球谐数据。
         */
        SphericalHarmonics = 1
    }
    /**
     * @en Lightmap.
     * @zh 光照贴图。
     */
    class Lightmap {
        /**@internal */
        static ApplyLightmapEvent: string;
        /**@internal */
        _dataModule: ILightMapData;
        private _lightmapColor;
        /**
         * @en The color of the lightmap.
         * @zh 光照贴图的颜色。
         */
        get lightmapColor(): Texture2D;
        set lightmapColor(value: Texture2D);
        /** 光照贴图方向。 */
        private _lightmapDirection;
        /**
         * @en The direction of the lightmap.
         * @zh 光照贴图的方向。
         */
        get lightmapDirection(): Texture2D;
        set lightmapDirection(value: Texture2D);
        /**
         * @internal
         */
        constructor();
    }
    enum FogMode {
        Linear = 0,
        EXP = 1,
        EXP2 = 2
    }
    /**
     * @en The Scene3D class is used to create a 3D scene.
     * @zh Scene3D类用于实现3D场景。
     */
    class Scene3D extends Sprite {
        private static _lightTexture;
        private static _lightPixles;
        /** @internal */
        static _shadowCasterPass: ShadowCasterPass;
        /**@internal */
        static physicsSettings: PhysicsSettings;
        /** Scene UniformPropertyID */
        /** @internal */
        static FOGCOLOR: number;
        /** @internal */
        static FOGPARAMS: number;
        /** @internal */
        static DIRECTIONLIGHTCOUNT: number;
        /** @internal */
        static LIGHTBUFFER: number;
        /** @internal */
        static CLUSTERBUFFER: number;
        /** @internal */
        static SUNLIGHTDIRECTION: number;
        /** @internal */
        static SUNLIGHTDIRCOLOR: number;
        /** @internal */
        static AMBIENTCOLOR: number;
        /** @internal */
        static TIME: number;
        /**@internal */
        static GIRotate: number;
        /**Scene3D UniformMap */
        static sceneUniformMap: CommandUniformMap;
        /** @internal */
        static LIGHTDIRECTION: number;
        /** @internal */
        static LIGHTDIRCOLOR: number;
        /** @internal */
        static LIGHTMODE: number;
        /** @internal */
        static POINTLIGHTPOS: number;
        /** @internal */
        static POINTLIGHTRANGE: number;
        /** @internal */
        static POINTLIGHTCOLOR: number;
        /** @internal */
        static POINTLIGHTMODE: number;
        /** @internal */
        static SPOTLIGHTPOS: number;
        /** @internal */
        static SPOTLIGHTDIRECTION: number;
        /** @internal */
        static SPOTLIGHTSPOTANGLE: number;
        /** @internal */
        static SPOTLIGHTRANGE: number;
        /** @internal */
        static SPOTLIGHTCOLOR: number;
        /** @internal */
        static SPOTLIGHTMODE: number;
        /**@internal */
        static mainCavansViewPort: Viewport;
        /**
         * @en Scene component management table
         * @zh 场景组件管理表
         */
        static componentManagerMap: Map<string, new () => IElementComponentManager>;
        /**
         * @en The update mark of the scene.
         * @zh 场景更新标记。
         */
        static get _updateMark(): number;
        /** @internal 场景更新标记 */
        static set _updateMark(value: number);
        /**
         * @en Registers a manager within the scene.
         * @param type The type of the manager to register.
         * @param cla The instance of the manager.
         * @zh 注册场景内的管理器。
         * @param type 要注册的管理器类型。
         * @param cla 管理器实例。
         */
        static regManager(type: string, cla: new () => IElementComponentManager): void;
        /**
         * @en init shaderData
         * @zh 着色器数据初始化
         * @internal
         */
        static shaderValueInit(): void;
        /**
         * @en Initializes legacy lighting values for the ShaderData.
         * This function sets up the uniform mappings between the shader and the scene for various types of lights,
         * including directional lights, point lights, and spotlights.
         * @zh 初始化 ShaderData 的传统光照值。
         * 此函数为各种类型的灯光（包括方向光、点光源和聚光灯）设置着色器与场景之间的统一映射。
         * @internal
         */
        static legacyLightingValueInit(): void;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Loads the scene, note: not cached.
         * @param url The template address.
         * @param complete The completion callback.
         * @zh 加载场景,注意:不缓存。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**@internal ide配置文件使用 */
        _reflectionsSource: number;
        /**@internal ide配置文件使用 */
        _reflectionsResolution: string;
        /**@internal ide配置文件使用 */
        _reflectionsIblSamples: number;
        /** @internal */
        private _group;
        /** @internal */
        _lightCount: number;
        /** @internal */
        _pointLights: LightQueue<PointLightCom>;
        /** @internal */
        _spotLights: LightQueue<SpotLightCom>;
        /** @internal */
        _directionLights: LightQueue<DirectionLightCom>;
        /** @internal */
        _alternateLights: AlternateLightQueue;
        /** @internal */
        private _lightmaps;
        /** @internal */
        private _skyRenderer;
        /** @internal */
        private _enableFog;
        /** @internal */
        private _timer;
        /** @internal */
        private _time;
        /** @internal */
        private _fogParams;
        /** @internal */
        private _fogMode;
        /**@internal */
        private _sceneReflectionProb;
        /**@internal */
        private _physicsStepTime;
        /**@internal */
        _sunColor: Color;
        /**@internal */
        _sundir: Vector3;
        /** @internal */
        _mainDirectionLight: DirectionLightCom;
        /** @internal */
        _mainSpotLight: SpotLightCom;
        /** @internal */
        _mainPointLight: PointLightCom;
        /** @internal */
        _physicsManager: IPhysicsManager;
        /** @internal 只读,不允许修改。*/
        _collsionTestList: number[];
        /** @internal */
        _shaderValues: ShaderData;
        /** @internal */
        _key: SubmitKey;
        /** @internal */
        _cameraPool: BaseCamera[];
        /** @internal */
        _volumeManager: VolumeManager;
        /**@internal */
        _UI3DManager: UI3DManager;
        /**@internal */
        _sceneRenderManager: SceneRenderManager;
        /**
         * @en The mask layer to which the sprite belongs is currently being created.
         * @zh 当前创建精灵所属遮罩层。
         */
        currentCreationLayer: number;
        /**
         * @en Whether to enable lighting.
         * @zh 是否启用灯光。
         */
        enableLight: boolean;
        /**lightShadowMap 更新频率 @internal */
        _ShadowMapupdateFrequency: number;
        /** @internal */
        _nativeObj: any;
        /** @internal 由IDE负责调用渲染 */
        _renderByEditor: boolean;
        /** @internal */
        _scene2D: Scene;
        /** @internal */
        _sceneModuleData: ISceneNodeData;
        /** @internal */
        componentElementMap: Map<string, IElementComponentManager>;
        /** @internal */
        private _componentElementDatasMap;
        /** @ts-ignore **/
        _children: Sprite3D[];
        /** @ts-ignore **/
        _scene: Scene3D;
        /**
         * @en The 2D scene to which the Scene3D belongs, used when the scene is loaded by the IDE editor.
         * @zh Scene3D所属的2D场景，使用IDE编辑的场景载入后具有此属性。
         */
        get scene2D(): Scene;
        /**
         * @en The SceneRenderableManager.
         * @zh 场景渲染管理器。
         */
        get sceneRenderableManager(): SceneRenderManager;
        set sceneRenderableManager(manager: SceneRenderManager);
        /**
         * @en Whether fog is enabled.
         * @zh 是否启用雾化效果。
         */
        get enableFog(): boolean;
        set enableFog(value: boolean);
        /**
         * @en The fog mode.
         * @zh 雾化模式。
         */
        get fogMode(): FogMode;
        set fogMode(value: FogMode);
        /**
         * @en The fog color.
         * @zh 雾化颜色。
         */
        get fogColor(): Color;
        set fogColor(value: Color);
        /**
         * @en The fog start position.
         * @zh 雾化起始位置。
         */
        get fogStart(): number;
        set fogStart(value: number);
        /**
         * @en The fog end range.
         * @zh 雾化结束范围。
         */
        get fogEnd(): number;
        set fogEnd(value: number);
        /**
         * @en The fog density.
         * @zh 雾化密度。
         */
        get fogDensity(): number;
        set fogDensity(value: number);
        /**
         * @internal
         * @en The fog effect parameters.
         * @zh 雾效参数。
         */
        get fogParams(): Vector4;
        set fogParams(value: Vector4);
        /**
         * @en The GI rotation value. The value should be between 0 and 2PI.
         * @zh 全局光照旋转值。 值应在 0 到 2PI 之间。
         */
        get GIRotate(): number;
        set GIRotate(value: number);
        /**
         * @en The ambient light mode.
         * If the value is AmbientMode.SolidColor, the ambientColor is generally used as the ambient light source. If the value is AmbientMode.SphericalHarmonics, the ambientSphericalHarmonics is generally used as the ambient light source.
         * @zh 环境光模式。
         * 如果值为 AmbientMode.SolidColor，则通常使用 ambientColor 作为环境光源。如果值为 AmbientMode.SphericalHarmonics，则通常使用 ambientSphericalHarmonics 作为环境光源。
         */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        /**
         * @en The scene reflection probe.
         * @zh 场景反射探针。
         */
        get sceneReflectionProb(): ReflectionProbe;
        /**
         * @internal
         * @en The scene reflection probe.
         * @zh 场景反射探针。
         */
        set sceneReflectionProb(value: ReflectionProbe);
        /**
         * @en The fixed color ambient light.
         * @zh 固定颜色环境光。
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * @en The ambient light intensity.
         * @zh 环境漫反射的强度。
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * @en The reflection probe intensity.
         * @zh 反射探针强度。
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        /**
         * @en The ambient spherical harmonics coefficients.
         * @zh 环境光球谐系数。
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
         * @en The IBL texture .
         * @zh IBL纹理。
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * @en Checks if the ambient IBL texture is using RGBD compression.
         * @zh 检查环境光贴图是否使用 RGBD 压缩。
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        /**
         * @en The sky renderer.
         * @zh 天空渲染器。
         */
        get skyRenderer(): SkyRenderer;
        /**
         * @en The physics simulation.
         * @zh 物理模拟器。
         */
        get physicsSimulation(): IPhysicsManager;
        /**
         * @en The scene timer.
         * @zh 场景时钟。
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * @en The array of lightmaps. The returned value is a shallow copy of the array.
         * @zh 光照贴图数组。返回的是一个浅拷贝数组。
         */
        get lightmaps(): Lightmap[];
        set lightmaps(value: Lightmap[]);
        /**
         * @en The shadow map update frequency. Increasing the frequency can optimize performance if there are no self-shadows.
         * @zh 阴影图更新频率。如果没有自阴影，增加频率可以优化性能。
         */
        get shadowMapFrequency(): number;
        set shadowMapFrequency(value: number);
        /**
         * @ignore
         * @en Creates an instance of the Scene3D class.
         * @zh 创建一个Scene3D的实例。
         */
        constructor();
        /**
         * @en The component element data map.
         * @zh 组件元素数据映射表。
         */
        get componentElementDatasMap(): any;
        /** @internal */
        set componentElementDatasMap(value: any);
        /** @internal */
        _setStructParent(value: Sprite): void;
        /**
         * @internal
         */
        _update(): void;
        /**
         * @internal
         */
        private _binarySearchIndexInCameraPool;
        /**
         * @internal
         */
        _getGroup(): string;
        /**
         * @internal
         */
        _setGroup(value: string): void;
        protected _onActive(): void;
        protected _onInActive(): void;
        private _prepareSceneToRender;
        private _cullInfoCamera;
        /**
         * @en The culling camera used for determining the visibility of scene elements.
         * @zh 用于确定场景元素可见性的剔除摄像机。
         */
        get cullInfoCamera(): Camera;
        /**
         * @internal
         * scence外的Camera渲染场景,需要设置这个接口
         * @param camera
         */
        _setCullCamera(camera: Camera): void;
        /**
         * @en Recalculate the culling camera.
         * @zh 重新计算剔除摄像机。
         */
        recaculateCullCamera(): void;
        /**
         * @internal
         */
        _addCamera(camera: BaseCamera): void;
        /**
         * @internal
         */
        _removeCamera(camera: BaseCamera): void;
        /**
         * @internal
         */
        _addRenderObject(render: BaseRender): void;
        /**
         * @internal
         */
        _removeRenderObject(render: BaseRender): void;
        _setBelongScene(scene: Node): void;
        /**
         * @en Destroys the scene.
         * @param destroyChild Whether to destroy the child node.
         * @zh 销毁场景。
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Gets the manager for a specific component type.
         * @param type The type of the component manager.
         * @zh 根据组件类型获取对应的管理器。
         * @param type 组件管理器的类型。
         */
        getComponentElementManager(type: string): IElementComponentManager;
        /**
         * @en The rendering entry.
         * @zh 渲染入口
         */
        renderSubmit(): void;
        /**
         * @internal
         * @param source
         * @param normalizeViewPort
         * @param camera
         * @returns
         */
        blitMainCanvas(source: BaseTexture, normalizeViewPort: Viewport, camera: Camera): void;
        /**
         * @en Sets a global shader value for rendering.
         * @param name The name corresponding to the shader.
         * @param type The type of the shader data.
         * @param value The value of the rendering data.
         * @zh 设置全局渲染着色器值。
         * @param name 数据对应着色器名字
         * @param type 渲染数据类型
         * @param value 渲染数据值
         */
        setGlobalShaderValue(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @deprecated
         * 雾效范围
         */
        get fogRange(): number;
        set fogRange(value: number);
        /**
         * @deprecated
         * 设置光照贴图。
         * @param value 光照贴图。
         */
        setlightmaps(value: Texture2D[]): void;
        /**
         * @deprecated
         * 获取光照贴图浅拷贝列表。
         * @returns 获取光照贴图浅拷贝列表。
         */
        getlightmaps(): Texture2D[];
    }
    /**
     * @internal
     * @en The collection of scene shader macros.
     * @zh 场景宏集合
     */
    class Scene3DShaderDeclaration {
        /**@internal */
        static SHADERDEFINE_FOG: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FOG_LINEAR: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FOG_EXP: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FOG_EXP2: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_DIRECTIONLIGHT: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_POINTLIGHT: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SPOTLIGHT: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_CASCADE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_SPOT: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH: ShaderDefine;
    }
    /**
     * @en The class is used to implement scene rendering node management.
     * @zh 该类用于实现场景渲染节点的管理。
     * @blueprintIgnore
     */
    class SceneRenderManager {
        /**@internal */
        _sceneManagerOBJ: ISceneRenderManager;
        /**
         * @ignore
         * @en Creates an instance of SceneRenderManager.
         * @zh 创建一个 SceneRenderManager 的实例。
         */
        constructor();
        /**
         * @en The render list.
         * @zh 渲染列表。
         */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        /**
         * @en Adds a render node to the manager.
         * @param object The render object to add.
         * @zh 向管理器添加渲染节点。
         * @param object 要添加的渲染对象。
         */
        addRenderObject(object: BaseRender): void;
        /**
         * @en Removes a render node from the manager.
         * @param object The render object to remove.
         * @zh 从管理器移除渲染节点。
         * @param object 要移除的渲染对象。
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * @en Removes a motion object from the manager.
         * @param object The motion object to remove.
         * @zh 从管理器移除运动对象。
         * @param object 要移除的运动对象。
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * @en Updates all motion render data.
         * @zh 更新所有运动渲染数据。
         */
        updateMotionObjects(): void;
        /**
         * @en Updates the scene render.
         * @zh 更新场景渲染。
         */
        renderUpdate(): void;
        /**
         * @en Adds motion render data to the manager.
         * @param object The motion render object to add.
         * @zh 向管理器添加运动渲染数据。
         * @param object 要添加的运动渲染对象。
         */
        addMotionObject(object: BaseRender): void;
        /**
         * @en Destroys and cleans up the manager resources.
         * @zh 销毁并清理管理器资源。
         */
        destroy(): void;
    }
    class SimpleSkinnedMeshRenderer extends SkinnedMeshRenderer {
        private _simpleAnimatorTexture;
        /**@internal */
        _simpleAnimatorParams: Vector4;
        private _simpleAnimatorTextureSize;
        /**  x simpleAnimation offset,y simpleFrameOffset*/
        private _simpleAnimatorOffset;
        /**@internal */
        _bonesNums: number;
        private _ownerSimpleRenderNode;
        /**
         * @internal
         * @en The animator texture
         * @zh 动画帧贴图
         */
        get simpleAnimatorTexture(): Texture2D;
        /**
         * @internal
         */
        set simpleAnimatorTexture(value: Texture2D);
        /**
         * @internal
         * @en The animator params
         * @zh 设置动画帧数参数
         */
        get simpleAnimatorOffset(): Vector2;
        /**
         * @internal
         */
        set simpleAnimatorOffset(value: Vector2);
        protected _isISkinRenderNode(): any;
        /**
         * @ignore
         * @en Creates an instance of SimpleSkinnedMeshRenderer.
         * @zh 创建一个 SimpleSkinnedMeshRenderer 的实例。
         */
        constructor();
        protected _createBaseRenderNode(): IBaseRenderNode;
        protected _getcommonUniformMap(): string[];
        protected _computeSkinnedData(): void;
        /**
         * @perfTag PerformanceDefine.T_SkinBoneUpdate
         * @en Update the render state of the skinned mesh.
         * @param context The 3D render context
         * @zh 更新蒙皮网格的渲染状态。
         * @param context 3D 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         *@internal
         */
        _createRenderElement(): SubMeshRenderElement;
        /**
         * @internal
         */
        _computeAnimatorParamsData(): void;
        /**
         * @en Set custom data
         * @param value1 Custom data 1
         * @param value2 Custom data 2
         * @zh 自定义数据
         * @param value1 自定义数据1
         * @param value2 自定义数据1
         */
        setCustomData(value1: number, value2?: number): void;
        /**
        *@internal
        */
        _onMeshChange(value: Mesh): void;
        /**
         * @internal
         * 克隆到目标
         * @param dest 目标
         */
        _cloneTo(dest: SimpleSkinnedMeshRenderer): void;
        /**
         * 删除节点
         */
        protected _onDestroy(): void;
    }
    /**
     * @en The `SimpleSkinnedMeshSprite3D` class is used to create a simple skinned mesh.
     * @zh `SimpleSkinnedMeshSprite3D` 类用于创建简单网格。
     */
    class SimpleSkinnedMeshSprite3D extends RenderableSprite3D {
        /**@internal */
        static _tempArray0: any[];
        /** */
        static SIMPLE_SIMPLEANIMATORTEXTURE: number;
        static SIMPLE_SIMPLEANIMATORPARAMS: number;
        static SIMPLE_SIMPLEANIMATORTEXTURESIZE: number;
        /**
         * @internal
         */
        static __init__(): void;
        private _meshFilter;
        /**
         * @en The mesh filter component.
         * @zh 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * @en The simple skinned mesh renderer component.
         * @zh 网格渲染器。
         */
        get simpleSkinnedMeshRenderer(): SimpleSkinnedMeshRenderer;
        /**
         * @en Constructor function.
         * @param mesh The mesh to use. The default material for the mesh will also be loaded.
         * @param name The name of the instance.
         * @zh 构造函数。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The `SkinnedMeshRenderer` class is used for skinned mesh rendering.
     * @zh `SkinnedMeshRenderer` 类用于蒙皮网格渲染。
     */
    class SkinnedMeshRenderer extends MeshRenderer {
        /**
          * @en Shader variable name for skinned animation.
          * @zh 着色器变量名，用于蒙皮动画。
          * @internal
          */
        static BONES: number;
        /**
         * @internal
         */
        static __init__(): void;
        protected _cacheMesh: Mesh;
        protected __bones: Sprite3D[];
        /**@internal 不可删  IDE数据在这里*/
        get _bones(): Sprite3D[];
        /**@internal */
        set _bones(value: Sprite3D[]);
        /**@internal */
        _renderElements: RenderElement[];
        /** @internal */
        _skinnedData: any[];
        protected _localBounds: Bounds;
        protected _cacheRootBone: Sprite3D;
        protected _worldParams: Vector4;
        private _ownerSkinRenderNode;
        /**
         * @en Local bounds.
         * @zh 局部边界。
         */
        get localBounds(): Bounds;
        set localBounds(value: Bounds);
        /**
         * @en Root node.
         * @zh 根节点。
         */
        get rootBone(): Sprite3D;
        set rootBone(value: Sprite3D);
        /**
         * @en The bones used for skinning.
         * @zh 用于蒙皮的骨骼。
         */
        get bones(): Sprite3D[];
        set bones(value: Sprite3D[]);
        /**
         * @ignore
         * @en Creates an instance of SkinnedMeshRenderer.
         * @zh 创建一个 SkinnedMeshRenderer 的实例。
         */
        constructor();
        /**
         * override it
         */
        protected _createBaseRenderNode(): IBaseRenderNode;
        protected _getcommonUniformMap(): Array<string>;
        /**
        * @inheritDoc
        * @internal
        */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         *@inheritDoc
         *@internal
         */
        _createRenderElement(): RenderElement;
        protected _isISkinRenderNode(): any;
        /**
         * @internal
         */
        _onSkinMeshChange(mesh: Mesh): void;
        /**
        *@internal
        */
        _onMeshChange(value: Mesh): void;
        /**
         * @internal
         * @param scene 场景类
         */
        _setBelongScene(scene: Scene3D): void;
        /**
         * @internal
         */
        _setUnBelongScene(): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
        /**
         * @en Updates the render state of the skinned mesh renderer.
         * @param context The 3D render context.
         * @zh 更新蒙皮网格渲染器的渲染状态。
         * @param context 3D渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        _cloneTo(dest: SkinnedMeshRenderer): void;
        protected _onDestroy(): void;
    }
    /**
     * @en The `SkinnedMeshSprite3D` class is used for sprite with skinned mesh and bone nodes.
     * @zh `SkinnedMeshSprite3D` 类用于绑点骨骼节点精灵。
     */
    class SkinnedMeshSprite3D extends RenderableSprite3D {
        /**@internal */
        static _tempArray0: any[];
        private _meshFilter;
        /**
         * @en Mesh filter component.
         * @zh 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * @en Skinned mesh renderer component.
         * @zh 网格渲染器。
         */
        get skinnedMeshRenderer(): SkinnedMeshRenderer;
        /**
         * @ignore
         * @en Creates an instance of SkinnedMeshSprite3D.
         * @param mesh The mesh to be used. The default material for the mesh will also be loaded.
         * @param name The name of the sprite.
         * @zh 创建一个 SkinnedMeshSprite3D 的实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        /**
         * @en Destroy the SkinnedMeshSprite3D instance.
         * @param destroyChild Whether to destroy child nodes.
         * @zh 销毁 SkinnedMeshSprite3D 实例。
         * @param destroyChild 是否销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en Class for Skinned Mesh Sprite3D Shader Declarations
     * @zh 蒙皮网格3D精灵着色器声明类
     */
    class SkinnedMeshSprite3DShaderDeclaration {
        /**
         * @en Sprite-level shader macro definition for skinned animation.
         * @zh 精灵级着色器宏定义，用于蒙皮动画。
         */
        static SHADERDEFINE_BONE: ShaderDefine;
        /**
         * @en Sprite-level shader macro definition for simple bone animation.
         * @zh 精灵级着色器宏定义，用于简单骨骼动画。
         */
        static SHADERDEFINE_SIMPLEBONE: ShaderDefine;
    }
    /**
     * @internal
     */
    enum StaticFlag {
        Normal = 1,
        StaticBatch = 2
    }
    /**
     * @en The `Sprite3D` class is used to implement 3D sprites.
     * @zh `Sprite3D` 类用于实现3D精灵。
     */
    class Sprite3D extends Node {
        /**
         * @en Shader variable name for world matrix.
         * @zh 着色器变量名，世界矩阵。
         * @readonly
         */
        static WORLDMATRIX: number;
        /**
         * @en Indicates the front face direction. -1 for inverted back face, 1 for normal situation.
         * @zh -1 表示翻转了背面，1 表示正常情况。
         * @readonly
         */
        static WORLDINVERTFRONT: number;
        /** @internal */
        static sprite3DCommandUniformMap: CommandUniformMap;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @en Create a clone instance of the sprite.
         * @param original The original sprite.
         * @param parent The parent node. Default is null.
         * @param worldPositionStays Whether to maintain its own world transformation. Default is true.
         * @param position World position, effective when worldPositionStays is false. Default is null.
         * @param rotation World rotation, effective when worldPositionStays is false. Default is null.
         * @returns The cloned instance.
         * @zh 创建精灵的克隆实例。
         * @param original 原始精灵。
         * @param parent 父节点。默认为 null。
         * @param worldPositionStays 是否保持自身世界变换。默认为 true。
         * @param position 世界位置，worldPositionStays 为 false 时生效。默认为 null。
         * @param rotation 世界旋转，worldPositionStays 为 false 时生效。默认为 null。
         * @returns 克隆实例。
         * @blueprintIgnore
         */
        static instantiate(original: Sprite3D, parent?: Node, worldPositionStays?: boolean, position?: Vector3, rotation?: Quaternion): Sprite3D;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Load mesh template.
         * @param url The template URL.
         * @param complete The completion callback.
         * @zh 加载网格模板。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        private _id;
        /** @internal */
        _isStatic: number;
        /** @internal */
        _layer: number;
        /**@internal */
        _transform: Transform3D;
        /**@internal 0表示不是渲染节点*/
        _isRenderNode: number;
        _children: Sprite3D[];
        _scene: Scene3D;
        /**
         * @en Unique identifier ID.
         * @zh 唯一标识ID。
         */
        get id(): number;
        /**
         * @en Mask layer.
         * @zh 蒙版层。
         */
        get layer(): number;
        set layer(value: number);
        /**
         * @en Whether the sprite is static.
         * @zh 是否为静态。
         */
        get isStatic(): boolean;
        /**@internal IDE only*/
        set isStatic(value: boolean);
        /**
         * @en Sprite transformation.
         * @zh 精灵变换。
         */
        get transform(): Transform3D;
        /**
         * @en Get the scene to which the sprite belongs.
         * @zh 获取精灵所属的场景。
         */
        get scene(): Scene3D;
        /**
         * @en Creates an instance of the Sprite3D class.
         * @param name Sprite name.
         * @param isStatic Whether it is static.
         * @zh 创建 Sprite3D 类的实例。
         * @param name 精灵名称。
         * @param isStatic 是否为静态。
         */
        constructor(name?: string, isStatic?: boolean);
        protected _onActive(): void;
        protected _onInActive(): void;
        protected _onAdded(): void;
        protected _onRemoved(): void;
        protected onStartListeningToType(type: string): void;
        /**
         * @internal
         * 克隆。
         * @param destObject 克隆源。
         */
        _cloneTo(destObject: Sprite3D, srcRoot: Node, dstRoot: Node): void;
        private static _createSprite3DInstance;
        private static _parseSprite3DInstance;
        /**
         * @en clone.
         * @returns clone instance.
         * @zh 克隆。
         * @returns	克隆副本。
         */
        clone(): Sprite3D;
        /**
         * @en destroy
         * @param destroyChild whether to destroy the child node.
         * @zh 销毁
         * @param destroyChild 是否销毁子节点
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The `Transform3D` class is used to implement 3D transformations.
     * @zh `Transform3D` 类用于实现3D变换。
     */
    class Transform3D extends EventDispatcher {
        /**@internal */
        static TRANSFORM_LOCALQUATERNION: number;
        /**@internal */
        static TRANSFORM_LOCALEULER: number;
        /**@internal */
        static TRANSFORM_LOCALMATRIX: number;
        /**@internal */
        static TRANSFORM_WORLDPOSITION: number;
        /**@internal */
        static TRANSFORM_WORLDQUATERNION: number;
        /**@internal */
        static TRANSFORM_WORLDSCALE: number;
        /**@internal */
        static TRANSFORM_WORLDMATRIX: number;
        /**@internal */
        static TRANSFORM_WORLDEULER: number;
        /**@internal */
        static TRANSFORM_LOCALPOS: number;
        /**@internal */
        static TRANSFORM_LOCALSCALE: number;
        /**@internal */
        static _angleToRandin: number;
        /** @internal */
        protected _owner: Sprite3D;
        /** @internal */
        protected _localPosition: Vector3;
        /** @internal */
        protected _localRotation: Quaternion;
        /** @internal */
        protected _localScale: Vector3;
        /**@internal */
        protected _localRotationEuler: Vector3;
        /** @internal */
        protected _localMatrix: Matrix4x4;
        /** @internal */
        protected _position: Vector3;
        /** @internal */
        protected _rotation: Quaternion;
        /** @internal */
        protected _scale: Vector3;
        /**@internal */
        protected _rotationEuler: Vector3;
        /** @internal */
        protected _worldMatrix: Matrix4x4;
        /** @internal */
        _children: Transform3D[] | null;
        /**@internal 如果为true 表示自身相对于父节点并无任何改变，将通过这个参数忽略计算*/
        protected _isDefaultMatrix: boolean;
        /**@internal */
        protected _faceInvert: boolean;
        /**@internal */
        protected _frontFaceValue: number;
        /** @internal */
        _parent: Transform3D | null;
        /**@internal */
        private _transformFlag;
        /**
         * @en Whether it is the default matrix. If `true`, it indicates that there is no change relative to the parent node, and calculations will be skipped based on this parameter.
         * @zh 是否为默认矩阵，如果为true，表示自身相对于父节点并无任何改变，将通过这个参数忽略计算。
         */
        get isDefaultMatrix(): boolean;
        /**
         * @internal
         */
        get _isFrontFaceInvert(): boolean;
        /**
         * @en Whether the front face is clockwise.
         * @zh 获取是否前向顺时针面。
         */
        getFrontFaceValue(): number;
        /**
         * @en The sprite to which this transform belongs.
         * @zh 所属精灵。
         */
        get owner(): Sprite3D;
        /**
         * @en Whether the world matrix needs to be updated.
         * @zh 世界矩阵是否需要更新。
         */
        get worldNeedUpdate(): boolean;
        /**
         * @en The X component of the local position.
         * @zh 局部位置X轴分量。
         */
        get localPositionX(): number;
        set localPositionX(x: number);
        /**
         * @en The Y component of the local position.
         * @zh 局部位置Y轴分量。
         */
        get localPositionY(): number;
        set localPositionY(y: number);
        /**
         * @en The Z component of the local position.
         * @zh 局部位置Z轴分量。
         */
        get localPositionZ(): number;
        set localPositionZ(z: number);
        /**
         * @en The local position.
         * @zh 局部位置。
         */
        get localPosition(): Vector3;
        set localPosition(value: Vector3);
        /**
         * @en The X component of the local rotation quaternion.
         * @zh 局部旋转四元数X分量。
         */
        get localRotationX(): number;
        set localRotationX(x: number);
        /**
         * @en The Y component of the local rotation quaternion.
         * @zh 局部旋转四元数Y分量。
         */
        get localRotationY(): number;
        set localRotationY(y: number);
        /**
         * @en The Z component of the local rotation quaternion.
         * @zh 局部旋转四元数Z分量。
         */
        get localRotationZ(): number;
        set localRotationZ(z: number);
        /**
         * @en The W component of the local rotation quaternion.
         * @zh 局部旋转四元数W分量。
         */
        get localRotationW(): number;
        set localRotationW(w: number);
        /**
         * @en The local rotation.
         * @zh 局部旋转。
         */
        get localRotation(): Quaternion;
        set localRotation(value: Quaternion);
        /**
         * @en The X component of the local scale.
         * @zh 局部缩放X。
         */
        get localScaleX(): number;
        set localScaleX(value: number);
        /**
         * @en The Y component of the local scale.
         * @zh 局部缩放Y。
         */
        get localScaleY(): number;
        set localScaleY(value: number);
        /**
         * @en The Z component of the local scale.
         * @zh 局部缩放Z。
         */
        get localScaleZ(): number;
        set localScaleZ(value: number);
        /**
         * @en The local scale of the transform.
         * @zh 局部缩放。
         */
        get localScale(): Vector3;
        set localScale(value: Vector3);
        /**
         * @en The X component of the local rotation euler angles.
         * @zh 局部空间的X轴欧拉角。
         */
        get localRotationEulerX(): number;
        set localRotationEulerX(value: number);
        /**
         * @en The Y component of the local rotation euler angles.
         * @zh 局部空间的Y轴欧拉角。
         */
        get localRotationEulerY(): number;
        set localRotationEulerY(value: number);
        /**
         * @en The Z component of the local rotation euler angles.
         * @zh 局部空间的Z轴欧拉角。
         */
        get localRotationEulerZ(): number;
        set localRotationEulerZ(value: number);
        /**
         * @en The local rotation euler angles of the transform.
         * @zh 局部空间欧拉角。
         */
        get localRotationEuler(): Vector3;
        set localRotationEuler(value: Vector3);
        /**
         * @en The local matrix.
         * @zh 局部矩阵。
         */
        get localMatrix(): Matrix4x4;
        set localMatrix(value: Matrix4x4);
        /**
         * @en World position.
         * @zh 世界位置。
         */
        get position(): Vector3;
        set position(value: Vector3);
        /**
         * @en World rotation.
         * @zh 世界旋转。
         */
        get rotation(): Quaternion;
        set rotation(value: Quaternion);
        /**
         * @en Rotation angles in world space, in the order of x, y, z.
         * @zh 世界空间的旋转角度，顺序为x、y、z。
         */
        get rotationEuler(): Vector3;
        set rotationEuler(value: Vector3);
        /**
         * @en World matrix.
         * @zh 世界矩阵。
         */
        get worldMatrix(): Matrix4x4;
        set worldMatrix(value: Matrix4x4);
        /**
         * @internal
         * @en Creates an instance of Transform3D.
         * @param owner The sprite of the owner.
         * @zh 创建一个 Transform3D 的实例。
         * @param owner 所属精灵。
         */
        constructor(owner: Sprite3D);
        protected _initProperty(): void;
        /**
         * @internal
         */
        _getScaleMatrix(): Matrix3x3;
        /**
         * @internal
         */
        protected _setTransformFlag(type: number, value: boolean): void;
        /**
         * @internal
         */
        protected _getTransformFlag(type: number): boolean;
        /**
         * @internal
         */
        _setParent(value: Transform3D): void;
        /**
         * @internal
         */
        protected _onWorldPositionRotationTransform(): void;
        /**
         * @internal
         */
        protected _onWorldPositionScaleTransform(): void;
        /**
         * @internal
         */
        protected _onWorldPositionTransform(): void;
        /**
         * @internal
         */
        protected _onWorldRotationTransform(): void;
        /**
         * @internal
         */
        protected _onWorldScaleTransform(): void;
        /**
         * @internal
         */
        _onWorldTransform(): void;
        /**
         * @en Perform translation transformation.
         * @param translation The distance to move.
         * @param isLocal Whether to use local space. Default is true.
         * @zh 平移变换。
         * @param translation 移动距离。
         * @param isLocal 是否局部空间。默认为 true。
         */
        translate(translation: Vector3, isLocal?: boolean): void;
        /**
         * @en Perform rotation transformation.
         * @param rotation The rotation amount.
         * @param isLocal Whether to use local space. Default is true.
         * @param isRadian Whether the rotation is in radians. Default is true.
         * @zh 旋转变换。
         * @param rotation 旋转幅度。
         * @param isLocal 是否局部空间。默认为 true。
         * @param isRadian 是否弧度制。默认为 true。
         */
        rotate(rotation: Vector3, isLocal?: boolean, isRadian?: boolean): void;
        /**
         * @en Get the forward direction.
         * @param forward The vector to the forward direction.
         * @zh 获取向前方向。
         * @param forward 前方向。
         */
        getForward(forward: Vector3): void;
        /**
         * @en Get the up direction.
         * @param up The vector to the up direction.
         * @zh 获取向上方向。
         * @param up 上方向。
         */
        getUp(up: Vector3): void;
        /**
         * @en Get the right direction.
         * @param right The vector to the right direction.
         * @zh 获取向右方向。
         * @param right 右方向。
         */
        getRight(right: Vector3): void;
        /**
         * @en Look at a target position.
         * @param target The target to look at.
         * @param up The up vector.
         * @param isLocal Whether to use local space. Default is false.
         * @param isCamera Whether it's a camera. Default is true.
         * @zh 观察目标位置。
         * @param target 观察目标。
         * @param up 向上向量。
         * @param isLocal 是否局部空间。默认为 false。
         * @param isCamera 是否为相机。默认为 true。
         */
        lookAt(target: Vector3, up: Vector3, isLocal?: boolean, isCamera?: boolean): void;
        /**
         * @en Make the object face towards a target.
         * @param target The target position to face.
         * @param up The up vector.
         * @param isLocal Whether to use local space. Default is false.
         * @zh 对象朝向目标。
         * @param target 朝向目标位置。
         * @param up 向上向量。
         * @param isLocal 是否局部空间。默认为 false。
         */
        objLookat(target: Vector3, up: Vector3, isLocal?: boolean): void;
        /**
         * @en The world scale.
         * Under certain conditions, obtaining this value may not be accurate (e.g., when the parent node has scaling and the child node has rotation).
         * The scaling may be skewed and cannot be correctly represented using Vector3. A Matrix3x3 matrix must be used for correct representation.
         * @returns The world scale.
         * @zh 世界缩放。
         * 某种条件下获取该值可能不正确（例如：父节点有缩放，子节点有旋转）。
         * 缩放会倾斜，无法使用Vector3正确表示，必须使用Matrix3x3矩阵才能正确表示。
         * @returns 世界缩放。
         */
        getWorldLossyScale(): Vector3;
        private _updateFaceInvertFromScale;
        /**
         * @en Set the world scale.
         * Under certain conditions, setting this value may not be accurate (e.g., when the parent node has scaling and the child node has rotation).
         * The scaling may be skewed and cannot be correctly represented using Vector3. A Matrix3x3 matrix must be used for correct representation.
         * @param value The world scale to set.
         * @return The world scale.
         * @zh 设置世界缩放。
         * 某种条件下设置该值可能不正确（例如：父节点有缩放，子节点有旋转）。
         * 缩放会倾斜，无法使用Vector3正确表示，必须使用Matrix3x3矩阵才能正确表示。
         * @param value 要设置的世界缩放。
         * @return	世界缩放。
         */
        setWorldLossyScale(value: Vector3): void;
        /**
         * @en Transform a local vector to global space.
         * @param value The local vector to transform.
         * @param out The output global vector.
         * @zh 将局部向量转换为全局向量。
         * @param value 要转换的局部向量。
         * @param out 输出的全局向量。
         */
        localToGlobal(value: Vector3, out: Vector3): void;
        /**
         * @en Transform a global position to local space.
         * @param pos The world position to transform.
         * @param out The output local position.
         * @zh 将世界坐标转换为局部坐标。
         * @param pos 要转换的世界坐标。
         * @param out 输出的局部坐标。
         */
        globalToLocal(pos: Vector3, out: Vector3): void;
        /**
         * @en Transform a global normal vector to local space.
         * @param pos The global normal vector to transform.
         * @param out The output local normal vector.
         * @zh 将全局法线向量转换为局部空间。
         * @param pos 要转换的全局法线向量。
         * @param out 输出的局部法线向量。
         */
        toLocalNormal(pos: Vector3, out: Vector3): void;
        /**
         * @en Rotate to face a specified direction.
         * @param forward The forward vector.
         * @param dir The target direction to face.
         * @zh 朝向指定方向。
         * @param forward 前向向量。
         * @param dir 目标朝向方向。
         */
        toDir(forward: Vector3, dir: Vector3): void;
        /**
         * @en This is a function from glmatrix. Sets a quaternion to represent the shortest rotation from one vector to another.
         * Both vectors are assumed to be unit length.
         * @param out The receiving quaternion.
         * @param a The initial vector (normalized).
         * @param b The destination vector (normalized).
         * @returns {boolean} True if a rotation was applied, false if the vectors are already aligned.
         * @zh 这是一个 glmatrix 中的函数。设置一个四元数来表示从一个向量到另一个向量的最短旋转。
         * 假设两个向量都是单位长度。
         * @param out 接收结果的四元数。
         * @param a 初始向量（已归一化）。
         * @param b 目标向量（已归一化）。
         * @returns {boolean} 如果应用了旋转则返回 true，如果向量已经对齐则返回 false。
         */
        rotationTo(out: Quaternion, a: Vector3, b: Vector3): boolean;
        /**
         * 世界坐标系缩放。
         * @deprecated
         */
        get scale(): Vector3;
        /**
         * @deprecated
         */
        set scale(value: Vector3);
        /** @internal @blueprintEvent */
        Transform3D_bpEvent: {
            [Event.TRANSFORM_CHANGED]: (flag: number) => void;
        };
    }
    /**
     * @en UI3D class, used to create 3D UI components.
     * @zh UI3D类，用于创建3D UI组件。
     */
    class UI3D extends BaseRender {
        /**@internal */
        static DEBUG: boolean;
        /**@internal */
        static _ray: Ray;
        private _shellSprite;
        private _uisprite;
        private _ui3DMat;
        private _rendertexure2D;
        private _geometry;
        private _size;
        private _sizeChange;
        private _resolutionRate;
        private _view;
        private _bindPropertyName;
        private _hit;
        private _prefab;
        /** 计算矩阵*/
        private _matrix;
        /** 缩放 */
        private _scale;
        private _cameraSpace;
        private _camera;
        protected _worldParams: Vector4;
        private _cameraPlaneDistance;
        private _genMipMap;
        /**
         * @en Whether to generate mipmap when rendering UI content, which will increase the memory usage
         * @zh 绘制UI内容时是否生成mipmap，会增加显存占用
         */
        get genMipMap(): boolean;
        set genMipMap(value: boolean);
        /**
         * @en UI nodes for 3D rendering
         * @zh 3D渲染的UI节点
         */
        get sprite(): Sprite;
        set sprite(value: Sprite);
        /**
         * @en The 3D rendering UI prefab.
         * @zh 3D渲染的UI预制体。
         */
        get prefab(): Prefab;
        set prefab(value: Prefab);
        /**
         * @en Mesh scale for 3D UI.
         * @zh 3D UI的网格缩放。
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * @en The UI render mode.
         * @zh UI渲染模式。
         */
        get renderMode(): MaterialRenderMode;
        set renderMode(value: MaterialRenderMode);
        /**
         * @en The UI culling mode.
         * @zh UI剔除模式。
         */
        get cull(): number;
        set cull(value: number);
        /**
         * @en The resolution rate.
         * @zh 分辨率比例。
         */
        get resolutionRate(): number;
        set resolutionRate(value: number);
        /**
         * @en The UI3D component is billboard mode.
         * @zh 面向相机模式
         */
        get billboard(): boolean;
        set billboard(value: boolean);
        /**
         * @en Detect mouse events, disable optimization performance, enable to trigger mouse events.
         * @zh 检测鼠标事件，关闭优化性能，开启可以触发鼠标事件
         */
        get enableHit(): boolean;
        set enableHit(value: boolean);
        /**
         * @en use the mode that fits the camera
         * @zh 是否使用贴合相机的模式
         */
        set cameraSpace(value: boolean);
        get cameraSpace(): boolean;
        /**
         * @en In cameraSpace mode, the distance from the camera
         * @zh cameraSpace模式下，距离相机的距离
         */
        set cameraPlaneDistance(value: number);
        get cameraPlaneDistance(): number;
        /**
         * @en Camera bind in cameraSpace mode
         * @zh cameraSpace模式下绑定的相机
         */
        set attachCamera(value: Camera);
        get attachCamera(): Camera;
        /** @ignore
         * @en constructor method, initialize 3D UI.
         * @zh 构造方法，初始化3D UI。
        */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        private _creatDefaultMat;
        /**
         * @internal add renderelement
         */
        private _addRenderElement;
        private _isCameraSpaceMode;
        /**
       * 分析碰撞点
       * @param hit
       */
        private _parseHit;
        /**
         * @internal
         */
        private _resizeRT;
        /**
         * @internal
         */
        onPreRender(): void;
        /**
         * @en Get the UI rendering texture.
         * @zh 获得ui渲染图
         */
        getUITexture(): BaseTexture;
        /**
         * @internal
         * get camera distance
         * @param rayOri
         * @returns
         */
        _getCameraDistance(rayOri: Vector3): number;
        /**
         * @internal
         */
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @internal
         * @param context
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @internal
         * 更新Sprite的RT
         */
        _submitRT(): void;
        /**
         * @internal
         * 设置材质纹理
         */
        _setMaterialTexture(): void;
        /**
         * 检测UI事件
         * @internal
         * @param ray
         * @returns
         */
        _checkUIPos(ray: Ray): false | Sprite;
        /**
         * @internal
         */
        _calculateBoundingBox(): void;
        protected _onAdded(): void;
        protected _onDisable(): void;
        protected _onEnable(): void;
        protected _onDestroy(): void;
        private _transByRotate;
    }
    /**
     * @en UI3DGeometry class is used to create and manage the geometry structure of 3D UI elements.
     * @zh UI3DGeometry 类用于创建和管理 3D UI元素的几何结构的类。
     */
    class UI3DGeometry extends GeometryElement {
        private static _type;
        private _vertexBuffer;
        private _vertex;
        /**@en indexbuffer */
        private _indexBuffer;
        /**@zh index数据 */
        private _index;
        private _bound;
        /**@internal */
        _positionArray: Vector3[];
        /**
         * @internal
         * @en Constructor method.
         * @zh 构造方法。
         */
        constructor(owner: UI3D);
        /**@internal */
        get bounds(): Bounds;
        private _createBuffer;
        /**
         * @internal
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Destroys the instance and releases resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en UI3DManager calss is used to create 3D UI manager, which manages all 3D UI objects.
     * @zh UI3DManager 类用于创建3D-UI管理器，管理所有3D-UI对象。
     */
    class UI3DManager {
        /**
         * @en A list to store 3D UI elements.
         * @zh 存储3D-UI元素的列表。
         */
        _UI3Dlist: FastSinglelist<UI3D>;
        /** @ignore */
        constructor();
        /**
         * @en Adds a 3D UI element to the manager.
         * @param value The 3D UI element to add.
         * @zh 向管理器添加一个3D-UI元素。
         * @param value 要添加的3D-UI元素。
         */
        add(value: UI3D): void;
        /**
         * @en Removes a 3D UI element from the manager.
         * @param value The 3D UI element to remove.
         * @zh 从管理器中移除一个3D-UI元素。
         * @param value 要移除的3D-UI元素。
         */
        remove(value: UI3D): void;
        /**
         * @en Updates the 3D UI elements in the scene.
         * @zh 更新场景中的3D-UI元素。
         */
        update(): void;
        /**
         * @en Performs a ray cast to determine if there is a collision with any 3D UI elements.
         * @param ray The ray for the ray casting.
         * @returns The hit result or null if no collision occurs.
         * @zh 执行射线投射以判断是否与任何3D-UI元素发生碰撞。
         * @param ray 射线投射的射线。
         * @returns 返回碰撞结果或如果没有碰撞发生则返回null。
         */
        rayCast(ray: Ray): any;
        /**
         * @en Destroys the 3D UI elements managed by the list.
         * @zh 销毁列表中存储的3D-UI元素。
         */
        destory(): void;
    }
    /**
     * @en The `DepthPass` class is responsible for handling depth rendering and shadow mapping in a 3D scene.
     * @zh `DepthPass` 类负责处理3D场景中的深度渲染和阴影映射。
     */
    class DepthPass {
        static SHADOW_BIAS: Vector4;
        /** @internal */
        static DEPTHPASS: ShaderDefine;
        /** @internal */
        static DEFINE_SHADOW_BIAS: number;
        /**@internal */
        static DEPTHTEXTURE: number;
        /**@internal */
        static DEPTHNORMALSTEXTURE: number;
        /**@internal */
        static DEPTHZBUFFERPARAMS: number;
        private _zBufferParams;
        static __init__(): void;
        /**@internal */
        private _depthTexture;
        /**@internal */
        private _depthNormalsTexture;
        /**@internal */
        private _viewPort;
        /** @ignore */
        constructor();
        /**
         * @en Creates and assigns the appropriate render texture for capturing depth information based on the specified depth texture mode. This method configures the camera's properties to hold newly created textures prepared for depth or depth normals rendering.
         * @param camera The camera for which the depth texture is being prepared.
         * @param depthType The type of depth texture to create, which determines the kind of data the texture will capture (e.g., depth only, depth and normals).
         * @param depthTextureFormat The format of the depth texture, defining how the data is represented.
         * @zh 根据指定的深度纹理模式创建并分配相应的渲染纹理，用于捕捉深度信息。
         * 此方法配置相机的属性，以保存为深度或深度法线渲染准备的新创建的纹理。
         * @param camera 准备深度纹理的相机。
         * @param depthType 要创建的深度纹理类型，决定纹理将捕捉的数据种类（如仅深度，深度加法线等）。
         * @param depthTextureFormat 深度纹理的格式，定义数据的表示方式。
         */
        getTarget(camera: Camera, depthType: DepthTextureMode, depthTextureFormat: RenderTargetFormat): void;
        /**
         * @internal
         * @en Parameters passed after rendering is complete.
         * @zh 渲染完后传入使用的参数。
         */
        _setupDepthModeShaderValue(depthType: DepthTextureMode, camera: Camera): void;
        /**
         * @internal
         * @en Clear the depth data.
         * @zh 清理深度数据
         */
        cleanUp(camera: Camera): void;
    }
    /**
     * @internal
     */
    class InstanceBatchManager {
        /** @internal */
        static instance: InstanceBatchManager;
        /**@internal */
        private _instanceBatchOpaqueMarks;
        /**@internal [只读]*/
        updateCountMark: number;
        constructor();
        /**
         * get batch index
         */
        private _getData;
        getInstanceBatchOpaquaMark(element: RenderElement): BatchMark;
    }
    /**
     * @internal
     * @en The `FrustumCulling` class is used for performing frustum culling calculations to determine visibility of objects within the camera's view.
     * @zh `FrustumCulling` 类用于执行视锥体剔除计算，以确定对象是否在相机视图中可见。
     */
    class FrustumCulling {
        /**
         * @en Calculates whether the given bounds are culled based on the provided culling information.
         * @param bounds The bounds to test for culling.
         * @param cullInfo The culling information containing plane data.
         * @returns  True if the bounds are not culled and are therefore visible, otherwise false.
         * @zh 根据提供的剔除信息，计算给定的边界是否被剔除。
         * @param bounds 要测试剔除的边界。
         * @param cullInfo 包含剔除平面数据的剔除信息。
         * @returns 如果边界没有被剔除并且因此可见，则返回 true，否则返回 false。
         */
        static cullingRenderBounds(bounds: Bounds, cullInfo: any): boolean;
    }
    /**
     * @en IndexBuffer3D class is used to create index buffer. Please use LayaGL.RenderOBJCreate.createIndexBuffer3D to create.
     * @zh IndexBuffer3D 类用于创建索引缓冲。请使用LayaGL.RenderOBJCreate.createIndexBuffer3D来创建。
     * @blueprintIgnore
     */
    class IndexBuffer3D {
        /** @internal */
        private _canRead;
        private _indexType;
        /** @internal */
        private _indexTypeByteCount;
        /** @internal */
        private _indexCount;
        _byteLength: number;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        /**@internal */
        _deviceBuffer: IIndexBuffer;
        bufferUsage: BufferUsage;
        /**
         * @en The index type.
         * @zh 索引类型。
         */
        get indexType(): IndexFormat;
        /**
         * @en The byte count of the index type.
         * @zh 索引类型字节数量。
         */
        get indexTypeByteCount(): number;
        /**
         * @en The number of indices.
         * @zh 索引个数。
         */
        get indexCount(): number;
        /**
         * @en Whether the buffer can be read.
         * @zh 是否可读。
         */
        get canRead(): boolean;
        /**
         * @en Constructor method, create index buffer.
         * @param indexType Index type.
         * @param indexCount Index count.
         * @param bufferUsage IndexBuffer3D usage type.
         * @param canRead Whether the buffer can be read.
         * @zh 构造方法,创建索引缓冲。
         * @param indexType 索引类型。
         * @param indexCount 索引个数。
         * @param bufferUsage IndexBuffer3D用途类型。
         * @param canRead 是否可读。
         */
        constructor(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean);
        /**
         * @en Sets the data for the index buffer.
         * @param data The index data.
         * @param bufferOffset The offset within the index buffer.
         * @param dataStartIndex The offset within the data.
         * @param dataCount The number of indices to set.
         * @zh 设置索引缓冲区的数据。
         * @param data 索引数据。
         * @param bufferOffset 索引缓冲中的偏移。
         * @param dataStartIndex 索引数据的偏移。
         * @param dataCount 索引数据的数量。
         */
        setData(data: any, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * @en Gets the index data.
         * @returns The index data.
         * @zh 获取索引数据。
         * @returns 返回索引数据。
         */
        getData(): Uint16Array | Uint32Array;
        /**
         * @inheritDoc
         * @override
         * @en Destroys this IndexBuffer3D.
         * @zh 销毁此索引缓冲。
         */
        destroy(): void;
    }
    /**
     * @internal
     */
    class MeshInstanceGeometry extends GeometryElement {
        private _subMesh;
        constructor(subMesh: SubMesh);
        set subMesh(value: SubMesh);
        get subMesh(): SubMesh;
        /**
         * @internal
         * UpdateGeometry Data
         */
        _updateRenderParams(state: RenderContext3D): void;
    }
    /**
     * @internal
     */
    class Cluster {
        static instance: Cluster;
        private _xSlices;
        private _ySlices;
        private _zSlices;
        private _clusterDatas;
        private _clusterPixels;
        private _updateMark;
        private _depthSliceParam;
        _clusterTexture: Texture2D;
        constructor(xSlices: number, ySlices: number, zSlices: number, maxLightsPerClusterAverage: number);
        private _placePointLightToClusters;
        private _placeSpotLightToClusters;
        private _insertConePlane;
        private _shrinkSphereLightZPerspective;
        private _shrinkSpotLightZPerspective;
        private _shrinkSphereLightByBoundOrth;
        private _shrinkSpotLightByBoundOrth;
        private _shrinkXYByRadiusPerspective;
        private _shrinkSpotXYByConePerspective;
        private _updatePointLightPerspective;
        private _updateSpotLightPerspective;
        private _updatePointLightOrth;
        private _updateSpotLightOrth;
        update(camera: Camera, scene: Scene3D): void;
    }
    /**
     * @en Second-order spherical harmonics function.
     * @zh 二阶球谐函数。
     */
    class SphericalHarmonicsL2 {
        /** @internal */
        static _default: SphericalHarmonicsL2;
        /** @internal */
        private _coefficients;
        /**
         * @en Gets the coefficient for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param j The coefficient index, ranging from 0 to 8.
         * @returns The coefficient value.
         * @zh 获取特定颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         * @returns 系数值。
         */
        getCoefficient(i: number, j: number): number;
        /**
         * @en Sets the coefficient for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param j The coefficient index, ranging from 0 to 8.
         * @param coefficient The coefficient value to set.
         * @zh 设置特定颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         * @param coefficient 要设置的系数值。
         */
        setCoefficient(i: number, j: number, coefficient: number): void;
        /**
         * @en Sets the coefficients for a specific color channel.
         * @param i The channel index, ranging from 0 to 2.
         * @param coefficient0 Coefficient 0
         * @param coefficient1 Coefficient 1
         * @param coefficient2 Coefficient 2
         * @param coefficient3 Coefficient 3
         * @param coefficient4 Coefficient 4
         * @param coefficient5 Coefficient 5
         * @param coefficient6 Coefficient 6
         * @param coefficient7 Coefficient 7
         * @param coefficient8 Coefficient 8
         * @zh 设置颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param coefficient0 系数0
         * @param coefficient1 系数1
         * @param coefficient2 系数2
         * @param coefficient3 系数3
         * @param coefficient4 系数4
         * @param coefficient5 系数5
         * @param coefficient6 系数6
         * @param coefficient7 系数7
         * @param coefficient8 系数8
         */
        setCoefficients(i: number, coefficient0: number, coefficient1: number, coefficient2: number, coefficient3: number, coefficient4: number, coefficient5: number, coefficient6: number, coefficient7: number, coefficient8: number): void;
        /**
         * @en Clones the spherical harmonics data to another instance.
         * @param dest The destination instance to which the data is cloned.
         * @zh 克隆球谐函数数据到另一个实例。
         * @param dest 克隆数据的目标实例。
         */
        cloneTo(dest: SphericalHarmonicsL2): void;
    }
    /**
     * @internal
     * @en The `SphericalHarmonicsL2Generater` class is used for generating second-order spherical harmonics coefficients.
     * @zh `SphericalHarmonicsL2Generater` 类用于生成二阶球谐系数。
     */
    class SphericalHarmonicsL2Generater {
        /**
         * k0: 1/2  * sqrt(1/Pi)
         * k1: 1/3  * sqrt(3/Pi)
         * k2: 1/8  * sqrt(15/Pi)
         * k3: 1/16 * sqrt(5/Pi)
         * k4: 1/16 * sqrt(15/Pi)
         * [
         *  k0,
         * -k1, k1, k1
         * k2, -k2, k3, -k2, k4
         * ]
         */
        private static readonly k;
        /** @internal */
        static readonly GradientSimulateSize: number;
        /** @internal */
        static readonly SH_Count: number;
        private static _tempSkyPixels;
        private static _tempEquatorPixels;
        private static _tempGroundPixels;
        /**
         * @internal
         * @en Calculates the surface area corresponding to the uv coordinates on a sphere.
         * @param u The u coordinate.
         * @param v The v coordinate.
         * @returns The surface area.
         * @zh 计算球面上uv坐标对应的立体角。
         * @param u u坐标。
         * @param v v坐标。
         * @returns 立体角。
         */
        static surfaceArea(u: number, v: number): number;
        /**
         * @en Converts uv coordinates to a direction vector based on the cube face.
         * @param u The u coordinate.
         * @param v The v coordinate.
         * @param face The cube map face.
         * @param out_dir The resulting direction vector.
         * @zh 根据立方体贴图面将uv坐标转换为方向向量。
         * @param u u坐标。
         * @param v v坐标。
         * @param face 立方体贴图面。
         * @param out_dir 输出的方向向量。
         */
        static uv2Dir(u: number, v: number, face: TextureCubeFace, out_dir: Vector3): void;
        /**
         * @internal
         * @en Evaluates the spherical harmonics function for given coefficients.
         * @param i The coefficient index.
         * @param x The x component of the direction vector.
         * @param y The y component of the direction vector.
         * @param z The z component of the direction vector.
         * @returns The evaluated value.
         * @zh 根据给定的系数评估球谐函数。
         * @param i 系数索引。
         * @param x 方向向量的x分量。
         * @param y 方向向量的y分量。
         * @param z 方向向量的z分量。
         * @returns 评估值。
         */
        static sh_eval_9(i: number, x: number, y: number, z: number): number;
        /**
         * @internal
         * @en Calculates the ambient light coefficients from cubemap pixel values.
         * @param cubemapPixels The cubemap pixel data for each face.
         * @param pixelComponentSize The number of components per pixel.
         * @param cubemapSize The size of the cubemap.
         * @param isGamma Whether the pixel data is in gamma color space.
         * @zh 从立方体贴图像素值计算环境光照系数。
         * @param cubemapPixels 立方体贴图的每个面的像素数据。
         * @param pixelComponentSize 每像素数据量。
         * @param cubemapSize 立方体贴图的大小。
         * @param isGamma 像素数据是否为伽马颜色空间。
         */
        static CalCubemapSH(cubemapPixels: Float32Array[], pixelComponentSize: number, cubemapSize: number, isGamma?: boolean): SphericalHarmonicsL2;
        /**
         * @internal
         * @en Calculate the ambient lighting coefficient based on sky color, horizon color, and ground color
         * @param skyColor The color of the sky.
         * @param equatorColor The color of the equator.
         * @param groundColor The color of the ground.
         * @param isGamma Whether the colors are in gamma color space.
         * @zh 通过 天空颜色, 地平线颜色, 地面颜色计算环境光照系数
         * @param skyColor 天空颜色。
         * @param equatorColor 地平线颜色。
         * @param groundColor 地面颜色。
         * @param isGamma 颜色是否为伽马空间。
         */
        static CalGradientSH(skyColor: Vector3, equatorColor: Vector3, groundColor: Vector3, isGamma?: boolean): SphericalHarmonicsL2;
    }
    /**
     * 是否要删除
     * @internal
     */
    class SubMeshInstanceBatch extends GeometryElement {
        /** @internal */
        static instance: SubMeshInstanceBatch;
        /** @internal */
        static maxInstanceCount: number;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        instanceWorldMatrixData: Float32Array;
        /** @internal */
        instanceWorldMatrixBuffer: VertexBuffer3D;
        /**SimpleAnimator */
        /** @internal */
        instanceSimpleAnimatorData: Float32Array;
        /** @internal */
        instanceSimpleAnimatorBuffer: VertexBuffer3D;
        /**
         * 创建一个 <code>InstanceSubMesh</code> 实例。
         */
        constructor();
        /**
         * @inheritDoc
         * @override
         */
        _updateRenderParams(state: RenderContext3D): void;
    }
    /**
     * @internal
     * <code>VertexPositionNormalTexture</code> 类用于创建位置、纹理顶点结构。
     */
    class VertexPositionTexture {
        private static _vertexDeclaration;
        static get vertexDeclaration(): VertexDeclaration;
        /**
         * @internal
         */
        static __init__(): void;
        private _position;
        private _textureCoordinate0;
        get position(): Vector3;
        get textureCoordinate0(): Vector2;
        get vertexDeclaration(): VertexDeclaration;
        constructor(position: Vector3, textureCoordinate0: Vector2);
    }
    /**
     * @en The `VertexBuffer3D` class is used to create vertex buffers. To create an instance of `VertexBuffer3D`, use `LayaGL.RenderOBJCreate.createIndexBuffer3D`.
     * @zh `VertexBuffer3D` 类用于创建顶点缓冲。要创建 `VertexBuffer3D` 的实例，请使用 `LayaGL.RenderOBJCreate.createIndexBuffer3D`。
     * @blueprintIgnore
     */
    class VertexBuffer3D {
        /** @internal */
        private _canRead;
        _byteLength: number;
        /**@internal */
        _deviceBuffer: IVertexBuffer;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        /** @internal */
        _float32Reader: Float32Array | null;
        bufferUsage: BufferUsage;
        /**
         * @en The vertex declaration.
         * @zh 顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        /**
         * @en Whether this is an instance buffer.
         * @zh 是否是实例缓冲区。
         */
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        /**
         * @en Whether the buffer is readable.
         * @zh 缓冲区是否可读。
         */
        get canRead(): boolean;
        /**
         * @en Constructor method.
         * @param byteLength The byte length of the buffer.
         * @param bufferUsage The usage type of the VertexBuffer3D.
         * @param canRead Whether the buffer is readable.
         * @zh 构造方法。
         * @param byteLength 字节长度。
         * @param bufferUsage VertexBuffer3D用途类型。
         * @param canRead 是否可读。
         */
        constructor(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean);
        /**
         * @en Sets the data for the vertex buffer.
         * @param buffer The data to set.
         * @param bufferOffset The offset within the vertex buffer, in bytes.
         * @param dataStartIndex The starting index within the data, in bytes.
         * @param dataCount The number of bytes to set.
         * @zh 设置顶点缓冲区的数据。
         * @param buffer 要设置的数据。
         * @param bufferOffset 顶点缓冲中的偏移,以字节为单位。
         * @param dataStartIndex 顶点数据的偏移,以字节为单位。
         * @param dataCount 顶点数据的长度,以字节为单位。
         */
        setData(buffer: ArrayBuffer, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * @en Gets the vertex data as a `Uint8Array`.
         * @zh 以 `Uint8Array` 形式获取顶点数据。
         */
        getUint8Data(): Uint8Array;
        /**
         * @ignore
         * @en Gets the vertex data as a `Float32Array`, if the buffer is readable.
         * @zh 如果缓冲区可读，以 `Float32Array` 形式获取顶点数据。
         */
        getFloat32Data(): Float32Array | null;
        /**
         * @ignore
         * @en Marks the buffer as unreadable and releases the data.
         * @zh 将缓冲区标记为不可读并释放数据。
         */
        markAsUnreadbale(): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the vertex buffer and releases the resources.
         * @zh 销毁顶点缓冲区并释放资源。
         */
        destroy(): void;
    }
    /**
     * @ignore
     * @en Used for loading cubemap textures.
     * @zh 用于加载立方体纹理资源。
     */
    class CubemapLoader implements IResourceLoader {
        constructor();
        /**
         * @en Load a cubemap texture resource.
         * @param task The load task.
         * @returns A Promise, when loaded successfully, it is resolves with the loaded texture or null if loading fails.
         * @zh 加载立方体贴图资源。
         * @param task 加载任务。
         * @returns 一个Promise, 加载成功时解析为加载的纹理，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<TextureCube>;
        private move;
    }
    /**
     * @internal
     * @en `LoadModelV04` class is used for loading model data.
     * @zh `LoadModelV04` 类用于加载模型数据。
     */
    class LoadModelV04 {
        /**@internal */
        private static _BLOCK;
        /**@internal */
        private static _DATA;
        /**@internal */
        private static _strings;
        /**@internal */
        private static _readData;
        /**@internal */
        private static _version;
        /**@internal */
        private static _mesh;
        /**@internal */
        private static _subMeshes;
        /**
         * @internal
         */
        static parse(readData: Byte, version: string, mesh: Mesh, subMeshes: SubMesh[]): void;
        /**
         * @internal
         */
        private static _readString;
        /**
         * @internal
         */
        private static READ_DATA;
        /**
         * @internal
         */
        private static READ_BLOCK;
        /**
         * @internal
         */
        private static READ_STRINGS;
        /**
         * @internal
         */
        private static READ_MESH;
        /**
         * @internal
         */
        private static READ_SUBMESH;
    }
    /**
     * @internal
     * @en `LoadModelV05` class is used for loading model data.
     * @zh `LoadModelV05` 类用于加载模型数据。
     */
    class LoadModelV05 {
        /**@internal */
        private static _BLOCK;
        /**@internal */
        private static _DATA;
        /**@internal */
        private static _strings;
        /**@internal */
        private static _readData;
        /**@internal */
        private static _version;
        /**@internal */
        private static _mesh;
        /**@internal */
        private static _subMeshes;
        /**
         * @internal
         */
        static parse(readData: Byte, version: string, mesh: Mesh, subMeshes: SubMesh[]): void;
        /**
         * @internal
         */
        private static _readString;
        /**
         * @internal
         */
        private static READ_DATA;
        /**
         * @internal
         */
        private static READ_BLOCK;
        /**
         * @internal
         */
        private static READ_STRINGS;
        /**
         * @internal
         */
        private static READ_MESH;
        /**
         * @internal
         */
        private static READ_SUBMESH;
        private static READ_MORPH;
        private static READ_UVSIZE;
    }
    /**
     * @internal
     */
    class MeshReader {
        static parse(readData: Byte, version: string): Mesh;
        /**
         */
        static _parse(data: ArrayBuffer): Mesh;
        static read(data: ArrayBuffer, mesh: Mesh, subMeshes: SubMesh[]): void;
    }
    /**
     * @ignore
     * @en Used for loading 2D texture array resources(.tex2darray).
     * @zh 用于加载纹理数组资源（.tex2darray）。
     */
    class Texture2DArrayLoader implements IResourceLoader {
        constructor();
        /**
         * @en Load a 2D texture array from the specified URL.
         * @param task The load task that contains the URL and other loading options.
         * @returns A promise that resolves with the loaded texture array or null if loading fails.
         * @zh 加载指定的纹理数组资源。
         * @param task 包含 URL 和其他加载选项的加载任务。
         * @returns 一个Promise，加载成功时解析为加载的纹理数组，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<any>;
    }
    /**
     * @en The `BoundBox` class is used for creating a bounding box.
     * @zh `BoundBox` 类用于创建包围盒。
     */
    class BoundBox implements IClone {
        /**
         * @en The minimum vertex of the bounding box.
         * @zh 包围盒的最小顶点。
         */
        min: Vector3;
        /**
         * @en The maximum vertex of the bounding box.
         * @zh 包围盒的最大顶点。
         */
        max: Vector3;
        /**
         * @en Constructor method of the bounding box.
         * @param min The minimum vertex of the bounding box.
         * @param max The maximum vertex of the bounding box.
         * @zh 包围盒的构造方法。
         * @param min 包围盒的最小顶点。
         * @param max 包围盒的最大顶点。
         */
        constructor(min: Vector3, max: Vector3);
        /**
         * @internal
         */
        private _rotateExtents;
        /**
         * @en Retrieves the 8 corner vertices of the bounding box.
         * @param corners The array to store the corner vertices.
         * @zh 获取包围盒的8个角顶点。
         * @param corners 角顶点的输出数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Retrieves the center point of the bounding box.。
         * @param out The vector to store the center point.
         * @zh 获取包围盒的中心点。
         * @param out 存储中心点的向量。
         */
        getCenter(out: Vector3): void;
        /**
         * @en Retrieves the extents of the bounding box.
         * @param out The vector to store the extents.
         * @zh 获取包围盒的范围。
         * @param out 存储轴半径的向量。
         */
        getExtent(out: Vector3): void;
        /**
         * @en Sets the center and extents of the bounding box.
         * @param center The center point of the bounding box.
         * @param extent The axis radius of the bounding box.
         * @zh 设置包围盒的中心点和范围
         * @param center 包围盒的中心点。
         * @param extent 包围盒的轴半径
         */
        setCenterAndExtent(center: Vector3, extent: Vector3): void;
        /**
         * @internal
         * @en Transforms the bounding box using the given matrix.
         * @param matrix The transformation matrix.
         * @param out The bounding box to store the result.
         * @zh 使用给定的矩阵变换包围盒。
         * @param matrix 变换矩阵。
         * @param out 存储结果的包围盒。
         */
        tranform(matrix: Matrix4x4, out: BoundBox): void;
        /**
         * @en Resets the bounding box to its default values.
         * @zh 将包围盒重置为其默认值。
         */
        toDefault(): void;
        /**
         * @en Creates a bounding box from a set of points.
         * @param points The set of points.
         * @param out The resulting bounding box.
         * @zh 从一组顶点生成包围盒。
         * @param points 所需顶点队列。
         * @param out 生成的包围盒。
         */
        static createfromPoints(points: Vector3[], out: BoundBox): void;
        /**
         * @en Merges two bounding boxes into one.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @param out The merged bounding box
         * @zh 合并两个包围盒为一个。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @param out 合并后的包围盒。
         */
        static merge(box1: BoundBox, box2: BoundBox, out: BoundBox): void;
        /**
         * @en Clones this bounding box to another object.
         * @param destObject The object to receive the clone.
         * @zh 克隆这个包围盒到另一个对象。
         * @param destObject 接收克隆的对象。
         */
        cloneTo(destObject: BoundBox): void;
        /**
         * @en Creates a clone of this bounding box.
         * @return The cloned bounding box.
         * @zh 创建这个包围盒的克隆。
         * @return 克隆的包围盒。
         */
        clone(): BoundBox;
    }
    /**
     * @en The corner of frustum.
     * @zh 锥体角点。
     */
    enum FrustumCorner {
        FarBottomLeft = 0,
        FarTopLeft = 1,
        FarTopRight = 2,
        FarBottomRight = 3,
        nearBottomLeft = 4,
        nearTopLeft = 5,
        nearTopRight = 6,
        nearBottomRight = 7,
        unknown = 8
    }
    /**
     * @en The BoundFrustum class is used to create a frustum.
     * @zh BoundFrustum 类用于创建截锥体。
     */
    class BoundFrustum implements IClone {
        /**
         * @en Obtain 6 enclosing planes based on the matrix.
         * @param  m The matrix that describes the frustum.
         * @param  np The near plane.
         * @param  fp The far plane.
         * @param  lp The left plane.
         * @param  rp The right plane.
         * @param  tp The top plane.
         * @param  bp The bottom plane.
         * @zh 根据矩阵获取6个包围平面。
         * @param  m 描述矩阵。
         * @param  np 近平面。
         * @param  fp 远平面。
         * @param  lp 左平面。
         * @param  rp 右平面。
         * @param  tp 顶平面。
         * @param  bp 底平面。
         */
        static getPlanesFromMatrix(m: Matrix4x4, np: Plane, fp: Plane, lp: Plane, rp: Plane, tp: Plane, bp: Plane): void;
        /** @internal */
        protected _matrix: Matrix4x4;
        /** @internal */
        protected _near: Plane;
        /** @internal */
        protected _far: Plane;
        /** @internal */
        protected _left: Plane;
        /** @internal */
        protected _right: Plane;
        /** @internal */
        protected _top: Plane;
        /** @internal */
        protected _bottom: Plane;
        /**
         * @en Constructor method.
         * @param matrix The 4x4 matrix that describes the frustum.
         * @zh 构造方法。
         * @param matrix 锥截体的描述4x4矩阵。
         */
        constructor(matrix: Matrix4x4);
        protected initBoundingPlane(): void;
        /**
         * @en The matrix that describes the frustum.
         * @zh 描述矩阵。
         */
        get matrix(): Matrix4x4;
        set matrix(matrix: Matrix4x4);
        /**
         * @en The near plane.
         * @zh 近平面。
         */
        get near(): Plane;
        /**
         * @en The far plane.
         * @zh 远平面。
         */
        get far(): Plane;
        /**
         * @en The left plane.
         * @zh 左平面。
         */
        get left(): Plane;
        /**
         * @en The right plane.
         * @zh 右平面。
         */
        get right(): Plane;
        /**
         * @en The top plane.
         * @zh 顶平面。
         */
        get top(): Plane;
        /**
         * @en The bottom plane.
         * @zh 底平面。
         */
        get bottom(): Plane;
        /**
         * @en Determines whether this bound frustum is equal to another bound frustum.
         * @param other The other bound frustum to compare.
         * @zh 判断这个截锥体是否与另一个截锥体相等。
         * @param other 要比较的另一个截锥体。
         */
        equalsBoundFrustum(other: BoundFrustum): boolean;
        /**
         * @en Determines whether this object is equal to another object.
         * @param obj The object to compare.
         * @zh 判断此对象是否等于另一个对象。
         * @param obj 要比较的另一个对象。
         */
        equalsObj(obj: any): boolean;
        /**
         * @en Gets a specific plane of the frustum.
         * @param index The index of the plane to retrieve. Indices:
         * - 0: Near plane
         * - 1: Far plane
         * - 2: Left plane
         * - 3: Right plane
         * - 4: Top plane
         * - 5: Bottom plane
         * @returns The requested plane or `null` if the index is out of range.
         * @zh 获取截锥体的特定平面。
         * @param index 要检索的平面的索引。索引：
         * - 0: 近平面
         * - 1: 远平面
         * - 2: 左平面
         * - 3: 右平面
         * - 4: 顶平面
         * - 5: 底平面
         * @returns 所请求的平面或 `null` 如果索引超出范围。
         */
        getPlane(index: number): Plane;
        /**
         * @en Calculates the intersection point of three planes within the frustum.
         * @param p1 The first plane.
         * @param p2 The second plane.
         * @param p3 The third plane.
         * @param out The vector to store the intersection point.
         * @zh 计算截锥体中三个平面的交点。
         * @param p1 第一个平面。
         * @param p2 第二个平面。
         * @param p3 第三个平面。
         * @param out 存储交点的向量。
         */
        static get3PlaneInterPoint(p1: Plane, p2: Plane, p3: Plane, out: Vector3): void;
        /**
         * @en Retrieves the eight corner points of the frustum.
         * @param corners The array to store the corner points.
         * @zh 获取截锥体的八个角点
         * @param corners 存储角点的数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Determines the relationship between the frustum and a point.
         * @param point The point to test.
         * @returns The relationship between the point and the frustum:
         * - 1: The point is inside the frustum.
         * - 2: The point intersects the frustum.
         * - 0: The point is outside and does not intersect the frustum.
         * @zh 确定截锥体与点的关系。
         * @param point  要测试的点。
         * @returns 点与截锥体之间的关系：
         * - 1: 点在截锥体内。
         * - 2: 点与截锥体相交。
         * - 0: 点在截锥体外且不相交。
         */
        containsPoint(point: Vector3): number;
        /**
         * @en Determines whether this frustum intersects with a bounding box.
         * @param box The bounding box to test against.
         * @returns `true` if they intersect; otherwise, `false`.
         * @zh 判断这个截锥体是否与包围盒相交。
         * @param box 要测试的包围盒。
         * @returns 如果相交返回 `true`；否则返回 `false`。
         */
        intersects(box: BoundBox | Bounds): boolean;
        /**
         * @en Determines the spatial relationship between this frustum and a bounding box.
         * @param box The bounding box to test.
         * @returns The spatial relationship:
         * - 1: The bounding box is inside the frustum.
         * - 2: The bounding box intersects the frustum.
         * - 0: The bounding box is outside and does not intersect the frustum.
         * @zh 确定这个截锥体和包围盒之间的空间关系。
         * @param box 要测试的包围盒。
         * @returns 关系类型：
         * - 1: 包围盒在截锥体内。
         * - 2: 包围盒与截锥体相交。
         * - 0: 包围盒在截锥体外且不相交。
         */
        containsBoundBox(box: BoundBox | Bounds): number;
        /**
         * @en Determines the spatial relationship between this frustum and a bounding sphere.
         * @param sphere The bounding sphere to test.
         * @returns The relationship type:
         * - 1: The sphere is inside the frustum.
         * - 2: The sphere intersects the frustum.
         * - 0: The sphere is outside and does not intersect the frustum.
         * @zh 确定这个截锥体和包围球之间的空间关系。
         * @param sphere 要测试的包围球。
         * @returns 关系类型：
         * - 1: 包围球在截锥体内。
         * - 2: 包围球与截锥体相交。
         * - 0: 包围球在截锥体外且不相交。
         */
        containsBoundSphere(sphere: BoundSphere): number;
        /**
         * @en Clones this frustum into another object.
         * @param dest The destination BoundFrustum to copy the values into.
         * @zh 克隆这个截锥体到另一个对象。
         * @param dest 目标对象，用以复制值。
         */
        cloneTo(dest: BoundFrustum): void;
        /**
         * @en Creates a clone of this frustum.
         * @returns A new BoundFrustum that is a clone of this one.
         * @zh 创建这个截锥体的克隆。
         * @returns 一个克隆自当前截锥体的新的 BoundFrustum。
         */
        clone(): BoundFrustum;
    }
    /**
     * @en used for creating a bounding volume.
     * @zh 用于创建包围体。
     */
    class Bounds implements IClone {
        /**
         * @en Merges two bounding boxes into one.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @param out The merged bounding box.
         * @zh 合并两个包围盒。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @param out 生成的包围盒。
         */
        static merge(box1: Bounds, box2: Bounds, out: Bounds): void;
        /**
         * @en Determines whether the bounding box contains a point.
         * @param box The bounding box.
         * @param point The point to check.
         * @returns `true` if the point is inside the bounding box; otherwise, `false`.
         * @zh 判断包围盒是否包含一个点。
         * @param box 包围盒。
         * @param point 需要检测的点。
         * @return 如果点在包围盒内返回 `true`；否则返回 `false`。
         */
        static containPoint(box: Bounds, point: Vector3): boolean;
        /**@internal */
        static _UPDATE_MIN: number;
        /**@internal */
        static _UPDATE_MAX: number;
        /**@internal */
        static _UPDATE_CENTER: number;
        /**@internal */
        static _UPDATE_EXTENT: number;
        /**@internal	*/
        _imp: any;
        /**
         * @en The minimum point of the bounding box.
         * @zh 包围盒的最小点
         */
        get min(): Vector3;
        set min(value: Vector3);
        /**
         * @en The maximum point of the bounding box.
         * @zh 包围盒的最大点
         */
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * @en The center point of the bounding box.
         * @param value The new center point of the bounding box.
         * @zh 设置包围盒的最小点。
         * @param value	包围盒的新最小点。
         */
        setMin(value: Vector3): void;
        /**
         * @en Gets the minimum point of the bounding box.
         * @return The minimum point of the bounding box.
         * @zh 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * @en Sets the maximum point of the bounding box.
         * @param value The new maximum point of the bounding box.
         * @zh 设置包围盒的最大点。
         * @param value	包围盒的新最大点。
         */
        setMax(value: Vector3): void;
        /**
         * @en Gets the maximum point of the bounding box.
         * @return The maximum point of the bounding box.
         * @zh 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * @en Sets the center point of the bounding box.
         * @param value The new center point of the bounding box.
         * @zh 设置包围盒的中心点。
         * @param value	包围盒的新中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * @en Gets the center point of the bounding box.
         * @return The center point of the bounding box.
         * @zh 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * @en Sets the range of the bounding box.
         * @param value The new range of the bounding box.
         * @zh 设置包围盒的范围。
         * @param value	包围盒的新范围。
         */
        setExtent(value: Vector3): void;
        /**
         * @en Gets the range of the bounding box.
         * @return The range of the bounding box.
         * @zh 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * @en Constructor method.
         * @param min  The minimum point of the bounding box.
         * @param max  The maximum point of the bounding box.
         * @zh 构造方法。
         * @param min  min 最小坐标
         * @param max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        /**
         * 获得更新标志
         * @internal
         * @param type 类型
         * @return void
         */
        protected _getUpdateFlag(type: number): boolean;
        /**
         * 设置更新标志
         * @internal
         * @param type 类型
         * @param value 值
         * @return void
         */
        protected _setUpdateFlag(type: number, value: boolean): void;
        /**
         * 获得包围盒中心值
         * @internal
         * @param min 最小值
         * @param max 最大值
         * @param out 返回值
         * @return void
         */
        protected _getCenter(min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * 获得包围盒范围
         * @internal
         * @param min 最小值
         * @param max 最大值
         * @param out 返回值
         * @return void
         */
        protected _getExtent(min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * 获得包围盒最小值
         * @internal
         * @param center 中心点
         * @param extent 范围
         * @param out 返回值
         * @return void
         */
        protected _getMin(center: Vector3, extent: Vector3, out: Vector3): void;
        /**
         * 获得包围盒最大值
         * @internal
         * @param center 中心点
         * @param extent 范围
         * @param out 返回值
         * @return void
         */
        protected _getMax(center: Vector3, extent: Vector3, out: Vector3): void;
        /**
        * 旋转范围
        * @internal
        * @param extent 范围
        * @param rotation 旋转矩阵
        * @param out 返回值
        * @return void
        */
        protected _rotateExtents(extents: Vector3, rotation: Matrix4x4, out: Vector3): void;
        /**
         * 转换包围盒
         * @internal
         * @param matrix 转换矩阵
         * @param out 输出包围盒
         */
        _tranform(matrix: Matrix4x4, out: Bounds): void;
        /**
         * @en Retrieves the eight corner vertices of the bounding box.
         * @param corners The array to store the corner vertices.
         * @zh 获取包围盒的八个角顶点
         * @param corners 存储角顶点的数组。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * @en Gets the bounding box.
         * @param box The bounding box to store the result.
         * @zh 获取包围盒
         * @param box 用于存储结果的包围盒。
         */
        getBoundBox(box: BoundBox): void;
        /**
         * @en Calculate whether two bounding boxes intersect
         * @param bounds The bounding box to calculate the intersection volume.
         * @return -1 if the two bounding boxes do not intersect; when not 0, the return value is the intersecting volume
         * @zh 计算两个包围盒是否相交
         * @param bounds 需要计算包围盒
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: Bounds): number;
        /**
         * @en Clones this bounds into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆这个边界到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: Bounds): void;
        /**
         * @en Creates a clone of this bounds.
         * @return A new `Bounds` instance that is a clone of this one.
         * @zh 创建这个边界的克隆。
         * @return 一个新的 `Bounds` 实例，是当前边界的克隆。
         */
        clone(): Bounds;
    }
    /**
     * @en BoundsImpl class is used to create a bounding box.
     * @zh BoundsImpl 类用于创建包围体。
     */
    class BoundsImpl implements IClone {
        /**@internal */
        static _UPDATE_MIN: number;
        /**@internal */
        static _UPDATE_MAX: number;
        /**@internal */
        static _UPDATE_CENTER: number;
        /**@internal */
        static _UPDATE_EXTENT: number;
        /**@internal	*/
        protected _updateFlag: number;
        /**@internal	*/
        _center: Vector3;
        /**@internal	*/
        _extent: Vector3;
        /**@internal	*/
        _boundBox: BoundBox;
        /**
         * @en The minimum point of the bounding box.
         * @zh 包围盒的最小点。
         */
        get min(): Vector3;
        set min(value: Vector3);
        /**
         * @en The maximum point of the bounding box.
         * @zh 包围盒的最大点。
         */
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * @en Sets the minimum point of the bounding box.
         * @param value The new minimum point to set for the bounding box.
         * @zh 设置包围盒的最小点。
         * @param value 为包围盒设置的新最小点。
         */
        setMin(value: Vector3): void;
        /**
         * @en Gets the minimum point of the bounding box.
         * @return The minimum point of the bounding box.
         * @zh 获取包围盒的最小点。
         * @return 包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * @en Sets the maximum point of the bounding box.
         * @param value The new maximum point to set for the bounding box.
         * @zh 设置包围盒的最大点。
         * @param value	要设置的包围盒的新最大点。
         */
        setMax(value: Vector3): void;
        /**
         * @en Gets the maximum point of the bounding box.
         * @return The maximum point of the bounding box.
         * @zh 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * @en Sets the center point of the bounding box.
         * @param value The new center point to set for the bounding box.
         * @zh 设置包围盒的中心点。
         * @param value	要设置的包围盒的新中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * @en Gets the center point of the bounding box.
         * @return The center point of the bounding box.
         * @zh 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * @en Sets the range of the bounding box.
         * @param value The new range to set for the bounding box.
         * @zh 设置包围盒的范围。
         * @param value	要设置的包围盒的新范围。
         */
        setExtent(value: Vector3): void;
        /**
         * @en Gets the range of the bounding box.
         * @return The range of the bounding box.
         * @zh 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * @en Constructor method.
         * @param min  The minimum point of the bounding box.
         * @param max  The maximum point of the bounding box.
         * @zh 构造方法。
         * @param min  min 最小坐标
         * @param max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        /**
         * 获得跟新标志
         * @internal
         * @param type 类型
         * @return void
         */
        protected _getUpdateFlag(type: number): boolean;
        /**
         * 设置跟新标志
         * @internal
         * @param type 类型
         * @param value 值
         * @return void
         */
        protected _setUpdateFlag(type: number, value: boolean): void;
        /**
         * 获得包围盒中心值
         * @internal
         * @param min 最小值
         * @param max 最大值
         * @param out 返回值
         * @return void
         */
        protected _getCenter(min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * 获得包围盒范围
         * @internal
         * @param min 最小值
         * @param max 最大值
         * @param out 返回值
         * @return void
         */
        protected _getExtent(min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * 获得包围盒最小值
         * @internal
         * @param center 中心点
         * @param extent 范围
         * @param out 返回值
         * @return void
         */
        protected _getMin(center: Vector3, extent: Vector3, out: Vector3): void;
        /**
          * 获得包围盒最大值
          * @internal
          * @param center 中心点
          * @param extent 范围
          * @param out 返回值
          * @return void
          */
        protected _getMax(center: Vector3, extent: Vector3, out: Vector3): void;
        /**
         * 旋转范围
         * @internal
         * @param extent 范围
         * @param rotation 旋转矩阵
         * @param out 返回值
         * @return void
         */
        protected _rotateExtents(extents: Vector3, rotation: Matrix4x4, out: Vector3): void;
        /**
         * 转换包围盒
         * @internal
         * @param matrix 转换矩阵
         * @param out 输出包围盒
         */
        _tranform(matrix: Matrix4x4, out: BoundsImpl): void;
        /**
         * 获得实际的包围值
         * @internal
         * @returns BoundBox
         */
        _getBoundBox(): BoundBox;
        /**
         * @en Calculates the intersection volume between this bounds implementation and another `BoundsImpl` instance.
         * @param bounds The `BoundsImpl` instance to calculate the intersection with.
         * @returns -1 if the bounds do not intersect; when not 0, the return value is the intersecting volume
         * @zh 计算此边界实现与另一个 `BoundsImpl` 实例之间的相交体积。
         * @param bounds 要计算相交的 `BoundsImpl` 实例。
         * @returns -1 如果边界不相交；不为0的时候返回值为相交体积。
         */
        calculateBoundsintersection(bounds: BoundsImpl): number;
        /**
         * @en Clones the current bounding box into another object.
         * @param destObject The destination object to clone into.
         * @zh 将当前包围体克隆到另一个对象中。
         * @param destObject  克隆的目标对象。
         */
        cloneTo(destObject: BoundsImpl): void;
        /**
         * @en Creates a clone of the bounding box.
         * @return A new `BoundsImpl` instance that is a clone of the current bounding box.
         * @zh 创建当前包围体的克隆。
         * @return 一个新的 `BoundsImpl` 实例，是当前包围体的克隆。
         */
        clone(): BoundsImpl;
    }
    /**
     * @en The BoundSphere class is used to create bounding balls.
     * @zh BoundSphere 类用于创建包围球。
     */
    class BoundSphere implements IClone {
        /** @internal 包围球的中心。*/
        _center: Vector3;
        /** @internal 包围球的半径。*/
        _radius: number;
        /**
         * @en The center of the bounding sphere.
         * @zh 包围球的中心。
         */
        get center(): Vector3;
        set center(value: Vector3);
        /**
         * @en The radius of the bounding sphere.
         * @zh 包围球的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en Constructor method.
         * @param center The center of the bounding sphere.
         * @param radius The radius of the bounding sphere.
         * @zh 构造方法
         * @param center 包围球的中心。
         * @param radius 包围球的半径。
         */
        constructor(center?: Vector3, radius?: number);
        /**
         * @en Resets the bound sphere to its default state.
         * @zh 将包围球重置为其默认状态。
         */
        toDefault(): void;
        /**
         * @en Generates a bounding sphere from a subset of vertex points.
         * @param points The array of vertex points.
         * @param start The starting offset of the vertex subset.
         * @param count The number of vertices in the subset.
         * @param out The resulting bounding sphere.
         * @zh 从顶点的子队列生成包围球。
         * @param points 顶点的队列。
         * @param start 顶点子队列的起始偏移。
         * @param count 顶点子队列的顶点数。
         * @param out 生成的包围球。
         */
        static createFromSubPoints(points: Vector3[], start: number, count: number, out: BoundSphere): void;
        /**
         * @en Generates a bounding sphere from a vertex point array.
         * @param points The array of vertex points.
         * @param out The resulting bounding sphere.
         * @zh 从顶点队列生成包围球。
         * @param points 顶点的队列。
         * @param out 生成的包围球。
         */
        static createfromPoints(points: Vector3[], out: BoundSphere): void;
        /**
         * @en Determines whether a ray intersects with the bounding sphere and returns the distance to the intersection point.
         * @param ray The ray.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回到交点的距离。
         * @param ray 射线。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        intersectsRayDistance(ray: Ray): number;
        /**
         * @en Determines whether a ray intersects with the bounding sphere and returns the intersection point.
         * @param ray The ray.
         * @param outPoint The intersection point.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回交点。
         * @param ray 射线。
         * @param outPoint 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        intersectsRayPoint(ray: Ray, outPoint: Vector3): number;
        /**
         * @en Clones this bounding sphere into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆这个包围球到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: BoundSphere): void;
        /**
         * @en Creates a clone of this bounding sphere.
         * @return A new `BoundSphere` instance that is a clone of this one.
         * @zh 创建这个包围球的克隆。
         * @return 一个新的 `BoundSphere` 实例，是当前包围球的克隆。
         */
        clone(): BoundSphere;
    }
    /**
     * @en Collision class is used to detect collisions
     * @zh Collision 类用于检测碰撞。
     */
    class CollisionUtils {
        /**
         * @en constructor
         * @zh 构造方法
         */
        constructor();
        /**
         * @en Calculates the distance from a point to a plane in space.
         * @param plane The plane.
         * @param point The point.
         * @returns The distance from the point to the plane.
         * @zh 计算空间中点到平面的距离。
         * @param plane 平面。
         * @param point 点。
         * @returns 点到平面的距离。
         */
        static distancePlaneToPoint(plane: Plane, point: Vector3): number;
        /**
         * @en Calculates the distance from a point to a bounding box in space.
         * @param box The bounding box.
         * @param point The point.
         * @returns The distance from the point to the bounding box.
         * @zh 计算空间中点到包围盒的距离。
         * @param box 包围盒。
         * @param point 点。
         * @returns 点到包围盒的距离。
         */
        static distanceBoxToPoint(box: BoundBox, point: Vector3): number;
        /**
         * @en Calculates the distance between two bounding boxes in space.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns The distance between the two bounding boxes.
         * @zh 计算空间中两个包围盒之间的距离。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 两个包围盒之间的距离。
         */
        static distanceBoxToBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * @en Calculates the distance from a point to a bounding sphere in space.
         * @param sphere The bounding sphere.
         * @param point The point in space.
         * @returns The distance from the point to the bounding sphere.
         * @zh 计算空间中点到包围球的距离。
         * @param sphere 包围球。
         * @param point 空间中的点。
         * @returns 点到包围球的距离
         */
        static distanceSphereToPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * @en Calculates the distance between two bounding spheres in space.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns The distance between the two bounding spheres.
         * @zh 计算空间中两个包围球之间的距离。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 两个包围球之间的距离。
         */
        static distanceSphereToSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * @en Determines whether a ray intersects with a triangle and outputs the distance to the intersection.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The distance to the intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与三角形相交，并输出到交点的距离。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 点和三角面间距离。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndTriangleRD(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: number): boolean;
        /**
         * @en Determines whether a ray intersects with a triangle and outputs the intersection point.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与三角形相交，并输出交点。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndTriangleRP(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): boolean;
        /**
         * @en Determines whether a ray intersects with a point.
         * @param ray The ray.
         * @param point The point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与点相交。
         * @param ray 射线。
         * @param point 点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndPoint(ray: Ray, point: Vector3): boolean;
        /**
         * @en Determines whether two rays intersect and outputs the intersection point.
         * @param ray1 The first ray.
         * @param ray2 The second ray.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断两条射线是否相交，并输出交点。
         * @param ray1 第一个射线。
         * @param ray2 第二个射线。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndRay(ray1: Ray, ray2: Ray, out: Vector3): boolean;
        /**
         * @en Determines whether a plane intersects with a triangle in space and returns the spatial relationship.
         * @param plane The plane.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The spatial relationship between the plane and the triangle：
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断空间中的平面是否与三角形相交，并返回空间位置关系。
         * @param plane 平面。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 平面与三角面的相交类型：
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndTriangle(plane: Plane, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Determines whether a ray intersects with a plane and returns the distance to the intersection.
         * @param ray The ray.
         * @param plane The plane.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与平面相交，并返回到交点的距离。
         * @param ray 射线。
         * @param plane 平面。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndPlaneRD(ray: Ray, plane: Plane): number;
        /**
         * @en Determines whether a ray intersects with a plane and outputs the intersection point.
         * @param ray The ray.
         * @param plane The plane.
         * @param out The intersection point.
         * @returns True if there is an intersection, otherwise false.
         * @zh 判断射线是否与平面相交，并输出交点。
         * @param ray 射线。
         * @param plane 平面。
         * @param out 交点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsRayAndPlaneRP(ray: Ray, plane: Plane, out: Vector3): boolean;
        /**
         * @en Determines whether a ray intersects with a bounding box and outputs the distance to the intersection.
         * @param ray The ray.
         * @param box The bounding box.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围盒相交，并输出到交点的距离。
         * @param ray 射线。
         * @param box 包围盒。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndBoxRD(ray: Ray, box: BoundBox): number;
        /**
         * @en Determines whether a ray intersects with a bounding box and returns the intersection point.
         * @param ray The ray.
         * @param box The bounding box.
         * @param out The intersection point.
         * @returns The distance to the intersection, or -1 if there is no intersection.
         * @zh 判断射线是否与包围盒相交，并返回交点。
         * @param ray 射线。
         * @param box 包围盒。
         * @param out 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndBoxRP(ray: Ray, box: BoundBox, out: Vector3): number;
        /**
         * @en Determines whether a ray intersects with a bounding sphere and returns the distance to the intersection.
         * @param ray The ray.
         * @param sphere The bounding sphere.
         * @returns The distance to the intersection point, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交，并返回到交点的距离。
         * @param ray 射线。
         * @param sphere 包围球。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndSphereRD(ray: Ray, sphere: BoundSphere): number;
        /**
         * @en Determines whether a ray intersects with a bounding sphere and returns the distance to the intersection.
         * @param ray The ray.
         * @param sphere The bounding sphere.
         * @param out The intersection point.
         * @returns The distance to the intersection, or -1 if there is no intersection.
         * @zh 判断射线是否与包围球相交并返回到交点的距离。
         * @param ray 射线。
         * @param sphere 包围球。
         * @param out 交点。
         * @returns 到交点的距离，如果没有交点则为 -1。
         */
        static intersectsRayAndSphereRP(ray: Ray, sphere: BoundSphere, out: Vector3): number;
        /**
         * @en Determines whether a bounding sphere intersects with a triangle.
         * @param sphere The bounding sphere.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns True if they intersect, otherwise false.
         * @zh 判断包围球是否与三角形相交。
         * @param sphere 包围球。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsSphereAndTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): boolean;
        /**
         * @en Determines the intersection status between a point and a plane.
         * @param plane The plane.
         * @param point The point.
         * @returns The type of intersection between a point and a plane:
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断点与平面之间的相交状态。
         * @param plane 平面。
         * @param point 点。
         * @returns 点与平面的相交类型：
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndPoint(plane: Plane, point: Vector3): number;
        /**
         * @en Determines whether two planes intersect.
         * @param plane1 The first plane.
         * @param plane2 The second plane.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个平面是否相交。
         * @param plane1 第一个平面。
         * @param plane2 第二个平面。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsPlaneAndPlane(plane1: Plane, plane2: Plane): boolean;
        /**
         * @en Determines whether two planes intersect and outputs the line of intersection.
         * @param plane1 The first plane.
         * @param plane2 The second plane.
         * @param line The line representing the intersection.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个平面是否相交并输出相交线。
         * @param plane1 第一个平面。
         * @param plane2 第二个平面。
         * @param line 相交线。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsPlaneAndPlaneRL(plane1: Plane, plane2: Plane, line: Ray): boolean;
        /**
         * @en Determines the intersection status between a plane and a bounding box.
         * @param plane The plane.
         * @param box The bounding box.
         * @returns The intersection type of the plane and the bounding box:
         * - 0(PlaneIntersectionType_Back): back,
         * - 1(PlaneIntersectionType_Front): front,
         * - 2(PlaneIntersectionType_Intersecting): intersecting.
         * @zh 判断平面与包围盒之间的相交状态。
         * @param plane 平面。
         * @param box 包围盒。
         * @returns 平面与包围盒的相交类型:
         * - 0(PlaneIntersectionType_Back): 背面，
         * - 1(PlaneIntersectionType_Front): 正面，
         * - 2(PlaneIntersectionType_Intersecting): 相交。
         */
        static intersectsPlaneAndBox(plane: Plane, box: BoundBox): number;
        /**
         * @en Determines the intersection status between a plane and a bounding sphere.
         * @param plane The plane.
         * @param sphere The bounding sphere.
         * @returns The intersection type of the plane and the bounding sphere: 0-back, 1-front, 2-intersecting.
         * @zh 判断平面与包围球之间的相交状态。
         * @param plane 平面。
         * @param sphere 包围球。
         * @returns 平面与包围球的相交类型:  0-背面，1-正面，2-相交。
         */
        static intersectsPlaneAndSphere(plane: Plane, sphere: BoundSphere): number;
        /**
         * @en Determines whether two bounding boxes intersect.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns True if they intersect, otherwise false.
         * @zh 判断两个包围盒是否相交。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsBoxAndBox(box1: BoundBox, box2: BoundBox): boolean;
        /**
         * @en Determines whether a bounding box intersects with a bounding sphere.
         * @param box The bounding box.
         * @param sphere The bounding sphere.
         * @returns True if they intersect, otherwise false.
         * @zh 判断包围盒是否与包围球是否相交。
         * @param box 包围盒。
         * @param sphere 包围球。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsBoxAndSphere(box: BoundBox, sphere: BoundSphere): boolean;
        /**
         * @en Determines whether one bounding sphere intersects with another bounding sphere.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns True if they intersect, otherwise false.
         * @zh 判断一个包围球是否与另一个包围球相交。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 如果相交返回真，否则返回假。
         */
        static intersectsSphereAndSphere(sphere1: BoundSphere, sphere2: BoundSphere): boolean;
        /**
         * @en Determines the spatial relationship between a bounding box and a point.
         * @param box The bounding box.
         * @param point The point.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围盒和点之间的空间关系。
         * @param box 包围盒。
         * @param point 点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsPoint(box: BoundBox, point: Vector3): number;
        /**
         * @en Determines the spatial relationship between two bounding boxes.
         * @param box1 The first bounding box.
         * @param box2 The second bounding box.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定两个包围盒之间的空间关系。
         * @param box1 第一个包围盒。
         * @param box2 第二个包围盒。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * @en Determines the spatial relationship between a bounding box and a bounding sphere.
         * @param box The bounding box.
         * @param sphere The bounding sphere.
         * @returns The relationship type:  0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围盒和包围球之间的空间关系。
         * @param box 包围盒。
         * @param sphere 包围球。
         * @returns 位置关系: 0 表示不相交，1 表示包含，2 表示相交。
         */
        static boxContainsSphere(box: BoundBox, sphere: BoundSphere): number;
        /**
         * @en Determines the spatial relationship between a bounding sphere and a point.
         * @param sphere The bounding sphere.
         * @param point The point.
         * @returns The relationship type: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围球和点之间的空间关系。
         * @param sphere 包围球。
         * @param point 点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * @en Determines the spatial relationship between a bounding sphere and a triangle.
         * @param sphere The bounding sphere.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The relationship type:  0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 确定包围球和三角形之间的空间关系。
         * @param sphere 包围球。
         * @param vertex1 第一个顶点。
         * @param vertex2 第二个顶点。
         * @param vertex3 第三个顶点。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Determines whether a bounding sphere contains a bounding box.
         * @param sphere The bounding sphere.
         * @param box The bounding box.
         * @returns The spatial relationship: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 判断包围球是否包含包围盒。
         * @param sphere 包围球。
         * @param box 包围盒。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsBox(sphere: BoundSphere, box: BoundBox): number;
        /**
         * @en Determines whether one bounding sphere contains another bounding sphere.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @returns The spatial relationship: 0 for disjoint, 1 for contains, 2 for intersecting.
         * @zh 判断一个包围球是否包含另一个包围球。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @returns 位置关系：0 表示不相交，1 表示包含，2 表示相交。
         */
        static sphereContainsSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * @en Finds the closest point on a triangle to a given point in space.
         * @param point The point in space.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @param out The closest point on the triangle.
         * @zh 找到空间中点到三角形的最近点。
         * @param point 空间中的点。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @param out 三角形上的最近点。
         */
        static closestPointPointTriangle(point: Vector3, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a plane to a given point in space.
         * @param plane The plane.
         * @param point The point in space.
         * @param out The closest point on the plane.
         * @zh 找到空间中点到平面的最近点。
         * @param plane 平面。
         * @param point 空间中的点。
         * @param out 平面上的最近点。
         */
        static closestPointPlanePoint(plane: Plane, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a bounding box to a given point in space.
         * @param box The bounding box.
         * @param point The point in space.
         * @param out The closest point on the bounding box.
         * @zh 找到空间中点到包围盒的最近点。
         * @param box 包围盒。
         * @param point 空间中的点。
         * @param out 包围盒上的最近点。
         */
        static closestPointBoxPoint(box: BoundBox, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest point on a bounding sphere to a given point in space.
         * @param sphere The bounding sphere.
         * @param point The point in space.
         * @param out The closest point on the bounding sphere.
         * @zh 找到空间中点到包围球的最近点。
         * @param sphere 包围球。
         * @param point 空间中的点。
         * @param out 包围球上的最近点。
         */
        static closestPointSpherePoint(sphere: BoundSphere, point: Vector3, out: Vector3): void;
        /**
         * @en Finds the closest points between two bounding spheres.
         * @param sphere1 The first bounding sphere.
         * @param sphere2 The second bounding sphere.
         * @param out The closest point on the first bounding sphere to the second.
         * @zh 找到两个包围球之间的最近点。
         * @param sphere1 第一个包围球。
         * @param sphere2 第二个包围球。
         * @param out 第一个包围球上到第二个包围球的最近点。
         */
        static closestPointSphereSphere(sphere1: BoundSphere, sphere2: BoundSphere, out: Vector3): void;
    }
    /**
     * @en ContainmentType class defines the space object position relationship.
     * @zh ContainmentType 类用于定义空间物体位置关系。
     */
    class ContainmentType {
        /**
         * @en Disjoint.
         * @zh 不相交
         */
        static Disjoint: number;
        /**
         * @en Contains.
         * @zh 包含
         */
        static Contains: number;
        /**
         * @en Intersects.
         * @zh 相交
         */
        static Intersects: number;
    }
    /**
     * @en Plane in 3D space.
     * @zh 三维空间中的平面。
     */
    class Plane {
        /**
         * @en Intersection type of the plane with other geometries, indicating the back side.
         * @zh 平面与其他几何体相交类型，表示背面。
         */
        static readonly PlaneIntersectionType_Back: number;
        /**
         * @en Intersection type of the plane with other geometries, indicating the front side.
         * @zh 平面与其他几何体相交类型，表示正面。
         */
        static readonly PlaneIntersectionType_Front: number;
        /**
         * @en Intersection type of the plane with other geometries, indicating intersection.
         * @zh 平面与其他几何体相交类型，表示相交。
         */
        static readonly PlaneIntersectionType_Intersecting: number;
        /**
         * @internal
         * @en The normal vector of the plane.
         * @zh 平面的法线向量。
         */
        normal: Vector3;
        /**
         * @internal
         * @en The distance from the plane to the origin of the coordinate system.
         * @zh 平面到坐标系原点的距离。
         */
        distance: number;
        /**
         * @en Constructor method of the plane.
         * @param normal The normal vector of the plane.
         * @param d The distance from the plane to the origin of the coordinate system.
         * @zh 平面的构造方法
         * @param normal 平面的向量
         * @param d  平面到原点的距离
         */
        constructor(normal?: Vector3, d?: number);
        /**
         * @en Creates a plane defined by three points.
         * @param point0 The first point.
         * @param point1 The second point.
         * @param point2 The third point.
         * @param out The plane to store the result.
         * @zh 通过三个点创建一个平面。
         * @param point0 第一个点。
         * @param point1 第二个点。
         * @param point2 第三个点。
         * @param out 存储结果的平面。
         */
        static createPlaneBy3P(point0: Vector3, point1: Vector3, point2: Vector3, out: Plane): void;
        /**
         * @en Normalizes the plane's normal vector to unit length.
         * @zh 使平面的法线向量成为单位长度。
         */
        normalize(): void;
        /**
         * @en Clones the plane into another object.
         * @param destObject The destination object to clone into.
         * @zh 克隆平面到另一个对象。
         * @param destObject 克隆目标对象。
         */
        cloneTo(destObject: Plane): void;
        /**
         * @en Creates a clone of this plane.
         * @return A new Plane instance that is a clone of this one.
         * @zh 创建这个平面的克隆。
         * @return 一个新的 Plane 实例，是当前平面的克隆。
         */
        clone(): Plane;
    }
    /**
     * @en The Rand class is used to create random numbers using a 32-bit unsigned integer seed.
     * @zh Rand 类用于通过32位无符号整型随机种子创建随机数。
     */
    class Rand {
        /**
         * @en Obtain unsigned 32-bit floating-point random numbers through unsigned 32-bit shaping
         * @param v The unsigned 32-bit integer random number.
         * @returns The 32-bit floating-point random number.
         * @zh 通过无符号32位整形，获取32位浮点随机数。
         * @param v 无符号32位整数随机数。
         * @returns 32位浮点随机数。
         */
        static getFloatFromInt(v: number): number;
        /**
         * @en Obtain an unsigned 8-bit byte random number through unsigned 32-bit shaping.
         * @param v The unsigned 32-bit integer random number.
         * @returns The unsigned 8-bit byte random number.
         * @zh 通过无符号32位整形，获取无符号8位字节随机数。
         * @param v 无符号32位整数随机数。
         * @returns 无符号8位字节随机数。
         */
        static getByteFromInt(v: number): number;
        /**@internal */
        private _temp;
        /**
         * @en Obtain random seeds
         * @zh 获取随机种子。
         */
        seeds: Uint32Array;
        /**
         * @en The random seed.
         * @zh 随机种子。
         */
        get seed(): number;
        set seed(seed: number);
        /**
         * @en Constructor method.
         * @param seed  32bit unsigned integer random seed.
         * @zh 构造方法。
         * @param seed  32位无符号整型随机种子。
         */
        constructor(seed: number);
        /**
         * @en Gets an unsigned 32-bit integer random number.
         * @returns The unsigned 32-bit integer random number.
         * @zh 获取无符号32位整数随机数
         * @returns 无符号32位整数随机数。
         */
        getUint(): number;
        /**
         * @en Gets a floating-point random number between 0 and 1.
         * @returns The floating-point random number between 0 and 1.
         * @zh 获取0到1之间的浮点随机数。
         * @returns 0到1之间的浮点随机数。
         */
        getFloat(): number;
        /**
         * @en Gets a floating-point random number between -1 and 1.
         * @returns The floating-point random number between -1 and 1.
         * @zh 获取-1到1之间的浮点随机数。
         * @returns -1到1之间的浮点随机数。
         */
        getSignedFloat(): number;
    }
    /**
     * @en The `RandX` class is used to generate random numbers using a 128-bit integer seed. The algorithm comes from the provided link: https://github.com/AndreasMadsen/xorshift
     * @zh `RandX` 类用于通过128位整型种子创建随机数。算法来自提供的链接：https://github.com/AndreasMadsen/xorshift
     */
    class RandX {
        /**@internal */
        private static _CONVERTION_BUFFER;
        /**@internal */
        private _state0U;
        /**@internal */
        private _state0L;
        /**@internal */
        private _state1U;
        /**@internal */
        private _state1L;
        /**
         * @en A random number generator seeded based on the current time.
         * @zh 基于当前时间种子的随机数生成器。
         */
        static defaultRand: RandX;
        /**
         * @en Constructor method.
         * @param seed  Random seed.
         * @zh 构造方法
         * @param seed  随机种子。
         */
        constructor(seed: any[]);
        /**
         * @en Return a 64 bit random number through a 2x32-bit array.
         * @returns 64 bit random number.
         * @zh 通过2x32位的数组，返回64位的随机数。
         * @returns 64位的随机数。
         */
        randomint(): any[];
        /**
         * @en Returns a random number in the range [0, 1).
         * @returns A random number in the range [0, 1).
         * @zh 返回一个介于[0, 1)范围内的随机数。
         * @returns 介于[0, 1)范围内的随机数。
         */
        random(): number;
    }
    /**
     * @en Ray class used to create a ray.
     * @zh Ray 类用于创建射线。
     */
    class Ray {
        /**
         * @en The origin point of the ray.
         * @zh 射线的原点。
         */
        origin: Vector3;
        /**
         * @en The direction of the ray.
         * @zh 射线的方向。
         */
        direction: Vector3;
        /**
         * @en Constructor method of the ray class.
         * @param origin The origin point of the ray.
         * @param direction The direction vector of the ray.
         * @zh 射线的构造方法
         * @param origin 射线的起点
         * @param direction 射线的方向
         */
        constructor(origin: Vector3, direction: Vector3);
        /**
         * @en Calculates a point on the ray at the specified parameter t.
         * @param t The parameter along the ray at which to calculate the point.
         * @param out The `Vector3` object to store the result.
         * @zh 计算在指定参数 t 处的射线上的点。
         * @param t 沿射线计算点的参数。
         * @param out 存储结果的 `Vector3` 对象。
         */
        at(t: number, out: Vector3): void;
    }
    /**
     * @en CharacterController class is used to create a character controller.
     * @zh CharacterController 类用于创建角色控制器。
     */
    class CharacterController extends PhysicsColliderComponent {
        /**@internal */
        protected _collider: ICharacterController;
        /** @internal */
        private _stepHeight;
        /** @internal */
        private _upAxis;
        /**@internal */
        private _maxSlope;
        /** @internal */
        private _gravity;
        /**@internal */
        private _radius;
        /**@internal */
        private _height;
        /**@internal */
        private _offset;
        /**@internal */
        private _contactOffset;
        /**@internal */
        private _minDistance;
        /**@internal */
        private _simGravity;
        /**@internal */
        private _pushForce;
        /**@internal */
        private _jumpSpeed;
        /**
         * @override
         * @internal
         */
        protected _initCollider(): void;
        protected _onEnable(): void;
        /**
         * @en The frame loop.
         * @zh 帧循环
         */
        onUpdate(): void;
        /**
         * @en The capsule radius.
         * @zh 胶囊半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The capsule height.
         * @zh 胶囊高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The minimum distance
         * @zh 最小距离。
         */
        get minDistance(): number;
        set minDistance(value: number);
        /**
         * @en The center offset of the capsule.
         * @zh 胶囊的本地偏移
         */
        get centerOffset(): Vector3;
        set centerOffset(value: Vector3);
        /**
         * @en gravity.
         * @zh 重力。
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
         * @en The skin width of the CharacterController.
         * - This property is only effective in the PhysX engine.
         * - It defines the distance between the collider surface and where collision detection actually occurs. This helps in triggering collision detection and response earlier, improving the stability and reliability of the object's physical simulation.
         * @zh 碰撞器外表的宽度;
         * - 该属性仅在 PhysX 引擎中有效。
         * - 用于定义碰撞器表面与实际发生碰撞检测的距离，用于提前触发碰撞检测和响应，从而提高物体在物理模拟中的稳定性和可靠性。
         */
        get skinWidth(): number;
        set skinWidth(value: number);
        /**
         * @en The maximum slope angle that the character can climb.
         * If the slope angle exceeds the set value, the character will be unable to continue moving upward and may start sliding down or stop at the bottom of the slope.
         * @zh 角色行走的最大坡度。
         * 如果坡度角度超过设定的值，角色将无法继续向上移动，可能会开始滑落或停在斜坡下方。
         */
        get maxSlope(): number;
        set maxSlope(value: number);
        /**
         * @en The height of the character's step. It represents the maximum height that the character can step over.
         * @zh 角色行走的脚步高度，表示可跨越的最大高度。
         */
        get stepHeight(): number;
        set stepHeight(value: number);
        /**
         * @en The up axis of the character.
         * @zh 角色的Up轴。
         */
        get upAxis(): Vector3;
        set upAxis(value: Vector3);
        /**
         * @en The character's position.
         * @zh 角色位置
         */
        get position(): Vector3;
        set position(v: Vector3);
        /**
         * @en The magnitude of the push force.
         * @zh 推动力的大小。
         */
        get pushForce(): number;
        set pushForce(value: number);
        /**
         * @en The jump speed.
         * @zh 起跳速度。
         */
        get jumpSpeed(): number;
        set jumpSpeed(value: number);
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Gets the velocity.
         * @zh 获取速度。
         */
        getVerticalVel(): number;
        /**
         * @en Moves the character by the specified movement vector.
         * @param movement The movement vector.
         * @zh 通过指定移动向量移动角色。
         * @param movement 移动向量。
         */
        move(movement: Vector3): void;
        /**
         * @en Jumps.
         * @param velocity The jump velocity.
         * @zh 跳跃。
         * @param velocity 跳跃速度。
         */
        jump(velocity?: Vector3): void;
        /**
         * @en Whether the character is on the ground.
         * @returns Whether the character is on the ground.
         * @zh 是否在地面上。
         * @returns 是否在地面上。
         */
        isOnGround(): boolean;
        /**
         * @inheritDoc
         * @override
         * @internal
         */
        _cloneTo(dest: CharacterController): void;
        /**
         * @internal
         */
        protected _setEventFilter(): void;
    }
    /**
     * @en The Collision class is used to create physical collision information.
     * @zh Collision 类用于创建物理碰撞信息。
     */
    class Collision {
        /**@internal */
        _lastUpdateFrame: number;
        /**@internal */
        _updateFrame: number;
        /**@internal */
        _isTrigger: boolean;
        /**@internal */
        _colliderA: ICollider;
        /**@internal */
        _colliderB: ICollider;
        /**
         * @readonly
         * @en List of collision information generated by collision.
         * @zh 碰撞产生的碰撞信息列表。
         */
        contacts: ContactPoint[];
        /**
         * @readonly
         * @en Another collision object involved in the collision.
         * @zh 碰撞中涉及的另一个碰撞体组件。
         */
        other: PhysicsColliderComponent;
        /**@internal */
        _inPool: boolean;
        /**
         * @en constructor of Collision.
         * @zh Collision构造方法。
         */
        constructor();
        /**
         * @internal
         */
        _setUpdateFrame(farme: number): void;
    }
    /**
     * @en The ConfigurableConstraint class is used for configurable constraint components.
     * @zh ConfigurableConstraint类用于可设置的约束组件
     */
    class ConfigurableConstraint extends ConstraintComponent {
        /**@internal */
        _joint: ID6Joint;
        /** @internal */
        private _axis;
        /** @internal */
        private _secondaryAxis;
        /** @internal */
        private _xMotion;
        /** @internal */
        private _yMotion;
        /** @internal */
        private _zMotion;
        /** @internal */
        private _angularXMotion;
        /** @internal */
        private _angularYMotion;
        /** @internal */
        private _angularZMotion;
        /** @internal */
        private _distanceLimit;
        /** @internal */
        private _distanceBounciness;
        /** @internal */
        private _distanceBounceThreshold;
        /** @internal */
        private _distanceSpring;
        /** @internal */
        private _distanceDamper;
        /**@internal */
        private _twistUper;
        /**@internal */
        private _twistLower;
        /**@internal */
        private _twistBounceness;
        /**@internal */
        private _twistBounceThreshold;
        /**@internal */
        private _twistStiffness;
        /**@internal */
        private _twistDamping;
        /**@internal */
        private _ySwingAngleLimit;
        /**@internal */
        private _zSwingAngleLimit;
        /**@internal */
        private _Swingrestitution;
        /**@internal */
        private _SwingbounceThreshold;
        /**@internal */
        private _SwingStiffness;
        /**@internal */
        private _SwingDamping;
        /**@internal */
        private _targetPosition;
        /**@internal */
        private _targetRotation;
        /**@internal */
        private _targetVelocity;
        /**@internal */
        private _targetAngularVelocity;
        /**@internal */
        private _linearDriveforceLimit;
        /**@internal */
        private _linearDriveForce;
        /**@internal */
        private _linearDriveDamping;
        /**@internal */
        private _angularXDriveForceLimit;
        /**@internal */
        private _angularXDriveForce;
        /**@internal */
        private _angularXDriveDamp;
        /**@internal */
        private _angularYZDriveForceLimit;
        /**@internal */
        private _angularYZDriveForce;
        /**@internal */
        private _angularYZDriveDamp;
        /**@internal */
        private _angularSlerpDriveForceLimit;
        /**@internal */
        private _angularSlerpDriveForce;
        /**@internal */
        private _angularSlerpDriveDamp;
        /** @ignore */
        constructor();
        private _setDriveLinearX;
        private _setDriveLinearY;
        private _setDriveLinearZ;
        private _setAngularXDrive;
        private _setAngularYZDrive;
        private _setAngularSlerpDrive;
        private _setDistanceLimit;
        private _setAngularXLimit;
        private _setSwingLimit;
        private _setTargetTransform;
        /**
         * axis
         */
        private _setAxis;
        private _setTargetVelocirty;
        /**
         * @en Main axis
         * @zh 主轴
         */
        get axis(): Vector3;
        set axis(value: Vector3);
        /**
         * @en Secondary axis
         * @zh 副轴
         */
        get secondaryAxis(): Vector3;
        set secondaryAxis(value: Vector3);
        /**
         * @en The motion type for X translation.
         * @zh X位移运动类型。
         */
        get XMotion(): D6Axis;
        set XMotion(value: D6Axis);
        /**
         * @en The motion type for Y translation.
         * @zh Y位移运动类型。
         */
        get YMotion(): D6Axis;
        set YMotion(value: D6Axis);
        /**
         * @en The motion type for Z translation.
         * @zh Z位移运动类型。
         */
        get ZMotion(): D6Axis;
        set ZMotion(value: D6Axis);
        /**
         * @en The motion type for X-axis rotation.
         * @zh 绕 X 轴旋转的角运动类型
         */
        get angularXMotion(): D6Axis;
        set angularXMotion(value: D6Axis);
        /**
         * @en The motion type for Y-axis rotation.
         * @zh 绕 Y 轴旋转的角运动类型
         */
        get angularYMotion(): D6Axis;
        set angularYMotion(value: D6Axis);
        /**
         * @en The motion type for Z-axis rotation.
         * @zh 绕 Z 轴旋转的角运动类型
         */
        get angularZMotion(): D6Axis;
        set angularZMotion(value: D6Axis);
        /**
         * @en The limit value for joint translation.
         * @zh 关节位移值。
         */
        get distanceLimit(): number;
        set distanceLimit(value: number);
        /**
         * @en The bounciness value after the joint translation limit is reached.
         * @zh 关节位移限制后的弹力值。
         */
        get distanceBounciness(): number;
        set distanceBounciness(value: number);
        /**
         * @en The bounciness threshold after the joint translation limit is reached.
         * @zh 关节位移限制后弹力阈值。
         */
        get distanceBounceThreshold(): number;
        set distanceBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for joint translation.
         * @zh 关节位移的弹簧系数。
         */
        get distanceSpring(): number;
        set distanceSpring(value: number);
        /**
         * @en The damping coefficient value for joint translation.
         * @zh 关节位移的阻尼值。
         */
        get distanceDamper(): number;
        set distanceDamper(value: number);
        /**
         * @en The maximum angle value for the joint's X-axis, ranging from -180° to 180°.
         * @zh 关节X轴的最大角度值，范围从 -180° 到 180°。
         */
        get angularXMaxLimit(): number;
        set angularXMaxLimit(value: number);
        /**
         * @en The minimum angle value for the joint's X-axis.
         * @zh 关节X轴的最小角度值。
         */
        get angularXMinLimit(): number;
        set angularXMinLimit(value: number);
        /**
         * @en The bounciness value after the joint's X-axis angle reaches its maximum value.
         * @zh 关节X轴角度达到最大值后的弹力值。
         */
        get AngleXLimitBounceness(): number;
        set AngleXLimitBounceness(value: number);
        /**
         * @en The bounciness threshold after the joint's X-axis angle reaches its maximum value.
         * @zh 关节X轴角度达到最大值后的弹力阈值。
         */
        get AngleXLimitBounceThreshold(): number;
        set AngleXLimitBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for the joint's X-axis angle.
         * @zh 关节X轴角度弹簧系数。
         */
        get AngleXLimitSpring(): number;
        set AngleXLimitSpring(value: number);
        /**
         * @en The damping value of joint X-axis angle
         * @zh 关节X轴角度阻尼值
         */
        get AngleXLimitDamp(): number;
        set AngleXLimitDamp(value: number);
        /**
         * @en The angle limit value for the joint's Y-axis.
         * @zh 关节Y轴的角度限制值。
         */
        get AngleYLimit(): number;
        set AngleYLimit(value: number);
        /**
         * @en The angle limit value for the joint's Z-axis.
         * @zh 关节Z轴的角度限制值。
         */
        get AngleZLimit(): number;
        set AngleZLimit(value: number);
        /**
         * @en The bounciness value after the joint's YZ-plane angle reaches its maximum limit.
         * @zh 关节YZ平面角度达到最大限制后的弹力值。
         */
        get AngleYZLimitBounciness(): number;
        set AngleYZLimitBounciness(value: number);
        /**
         * @en The bounciness threshold after the joint's YZ-plane angle reaches its maximum limit.
         * @zh 关节YZ平面角度达到最大限制后的弹力阈值。
         */
        get AngleYZLimitBounceThreshold(): number;
        set AngleYZLimitBounceThreshold(value: number);
        /**
         * @en The spring coefficient value for the joint's YZ-axis rotation.
         * @zh 关节YZ轴旋转的弹簧系数。
         */
        get AngleYZLimitSpring(): number;
        set AngleYZLimitSpring(value: number);
        /**
         * @en The damping value for the joint's YZ-axis rotation.
         * @zh 关节YZ轴旋转的阻尼值。
         */
        get AngleYZLimitDamping(): number;
        set AngleYZLimitDamping(value: number);
        /**
         * @en The target position the joint is moving towards.
         * @zh 关节移动到的目标位置。
         */
        get targetPosition(): Vector3;
        set targetPosition(value: Vector3);
        /**
         * @en The target rotation direction for the joint's rotation drive.
         * @zh 关节旋转驱动的目标方向。
         */
        get targetRotation(): Vector3;
        set targetRotation(value: Vector3);
        /**
         * @en The velocity at which the joint moves towards the target position.
         * @zh 关节移动到目标位置的速度。
         */
        get targetPositionVelocity(): Vector3;
        set targetPositionVelocity(value: Vector3);
        /**
         * @en The angular velocity driven by joint rotation to the target angle.
         * @zh 关节旋转到目标角度驱动的角速度。
         */
        get targetAngularVelocity(): Vector3;
        set targetAngularVelocity(value: Vector3);
        /**
         * @en The spring coefficient value for the joint along the X-axis.
         * @zh 关节在X轴方向上的弹簧系数。
         */
        get XDriveSpring(): number;
        set XDriveSpring(value: number);
        /**
         * @en The spring coefficient value for the joint along the Y-axis.
         * @zh 关节在Y轴方向上的弹簧系数。
         */
        get YDriveSpring(): number;
        set YDriveSpring(value: number);
        /**
         * @en The spring coefficient value for the joint along the Z-axis.
         * @zh 关节在Z轴方向上的弹簧系数。
         */
        get ZDriveSpring(): number;
        set ZDriveSpring(value: number);
        /**
         * @en The damping value along the X-axis of the joint drive.
         * @zh 关节在X轴方向上的阻尼值。
         */
        get XDriveDamp(): number;
        set XDriveDamp(value: number);
        /**
         * @en The damping value along the Y-axis of the joint drive.
         * @zh 关节在Y轴方向上的阻尼值。
         */
        get YDriveDamp(): number;
        set YDriveDamp(value: number);
        /**
         * @en The damping value along the Z-axis of the joint drive.
         * @zh 关节在Z轴方向上的阻尼值。
         */
        get ZDriveDamp(): number;
        set ZDriveDamp(value: number);
        /**
         * @en The maximum force limit along the X-axis of the joint drive.
         * @zh 关节在X轴方向上的最大驱动力值。
         */
        get XDriveForceLimit(): number;
        set XDriveForceLimit(value: number);
        /**
         * @en The maximum force limit along the Y-axis of the joint drive.
         * @zh 关节在Y轴方向上的最大驱动力值。
         */
        get YDriveForceLimit(): number;
        set YDriveForceLimit(value: number);
        /**
         * @en The maximum force limit along the Z-axis of the joint drive.
         * @zh 关节在Z轴方向上的最大驱动力值。
         */
        get ZDriveForceLimit(): number;
        set ZDriveForceLimit(value: number);
        /**
         * @en The maximum rotational driving force of the joint on the X-axis.
         * @zh 关节在X轴上的最大旋转驱动力。
         */
        get angularXDriveForceLimit(): number;
        set angularXDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's rotation around the X-axis.
         * @zh 关节在X轴上的旋转驱动力。
         */
        get angularXDriveForce(): number;
        set angularXDriveForce(value: number);
        /**
         * @en The rotational damping value of the joint in the X-axis direction.
         * @zh 关节在X轴方向上的旋转阻尼值。
         */
        get angularXDriveDamp(): number;
        set angularXDriveDamp(value: number);
        /**
         * @en The maximum drive force for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面旋转驱动力的最大值。
         */
        get angularYZDriveForceLimit(): number;
        set angularYZDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面上的旋转驱动力。
         */
        get angularYZDriveForce(): number;
        set angularYZDriveForce(value: number);
        /**
         * @en The damping for the joint's rotation in the YZ-plane.
         * @zh 关节在YZ平面上的阻尼。
         */
        get angularYZDriveDamp(): number;
        set angularYZDriveDamp(value: number);
        /**
         * @en The maximum drive force for the joint's angular slerp interpolation.
         * @zh 关节的角度插值驱动力的最大值。
         */
        get angularSlerpDriveForceLimit(): number;
        set angularSlerpDriveForceLimit(value: number);
        /**
         * @en The drive force for the joint's angular slerp interpolation.
         * @zh 关节的角度插值驱动力。
         */
        get angularSlerpDriveForce(): number;
        set angularSlerpDriveForce(value: number);
        /**
         * @en The damping for the joint's angular slerp interpolation.
         * @zh 角度插值阻尼。
         */
        get angularSlerpDriveDamp(): number;
        set angularSlerpDriveDamp(value: number);
        /**
         * @internal
         */
        _initAllConstraintInfo(): void;
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDisable(): void;
        /**
         * @internal
         * create joint
         */
        protected _initJoint(): void;
    }
    /**
     * @en ConstraintComponent class is the base class for creating constraints.
     * @zh ConstraintComponent 类用于创建约束的父类。
     */
    class ConstraintComponent extends Component {
        /**@internal */
        _joint: IJoint;
        private _enableCollison;
        protected _physicsManager: IPhysicsManager;
        protected _ownCollider: PhysicsColliderComponent;
        protected _connectCollider: PhysicsColliderComponent;
        protected _breakForce: number;
        protected _breakTorque: number;
        protected _ownColliderLocalPos: Vector3;
        protected _connectColliderLocalPos: Vector3;
        private _isJointInit;
        readonly owner: Sprite3D;
        /**
         * @en Initializes the joint instance.
         * @zh 初始化关节实例。
         */
        initJoint(): void;
        protected _initJoint(): void;
        /**
         * @en Physical components of joint connections rigid body
         * @zh 关节连接的物理组件刚体
         */
        get connectedBody(): PhysicsColliderComponent;
        set connectedBody(value: PhysicsColliderComponent);
        /**
         * @en The owner rigid body of the joint, which is the physical component that the joint is attached to.
         * @zh 关节所属的物理组件刚体。
         */
        get ownBody(): PhysicsColliderComponent;
        set ownBody(value: PhysicsColliderComponent);
        /**
         * @en The total force applied to the joint.
         * @zh 作用在关节上的总力。
         */
        get currentForce(): Vector3;
        /**
         * @en The total torque applied to the joint.
         * @zh 作用在关节上的总力矩。
         */
        get currentTorque(): Vector3;
        /**
         * @en The maximum force the joint can withstand before breaking.
         * @zh 关节在断裂前能承受的最大力。
         */
        get breakForce(): number;
        set breakForce(value: number);
        /**
         * @en The maximum torque the joint can withstand before breaking.
         * @zh 关节在断裂前能承受的最大扭矩。
         */
        get breakTorque(): number;
        set breakTorque(value: number);
        /**
         * @en The anchor point.
         * @zh 锚点
         */
        get anchor(): Vector3;
        set anchor(value: Vector3);
        /**
         * @en The connected anchor point.
         * @zh 连接锚点位置
         */
        get connectAnchor(): Vector3;
        set connectAnchor(value: Vector3);
        /**
         * @en Enables or disables collision between the connected bodies of the joint.
         * @zh 是否启用关节连接体之间的碰撞。
         */
        get enableCollison(): boolean;
        set enableCollison(value: boolean);
        /** @ignore */
        constructor();
        protected _onAdded(): void;
        /**
         * @en Sets the number of solver iterations used to resolve the constraint. Higher values increase the precision but may reduce performance.
         * @param overideNumIterations The number of iterations to override with.
         * @zh 设置用于解决约束的求解器迭代次数。次数越高，精度越准确，但可能会降低性能。
         * @param overideNumIterations 要使用的迭代次数。
         */
        setOverrideNumSolverIterations(overideNumIterations: number): void;
        /**
         * @en Enables or disables the constraint.
         * @param enable True to enable the constraint, false to disable it.
         * @zh 启用或禁用约束。
         * @param enable 是否启用约束。
         */
        setConstraintEnabled(enable: boolean): void;
        protected _onEnable(): void;
        protected _onDestroy(): void;
        /**
         * @internal
         * @en Checks if the constraint is broken, indicating whether the joint has exceeded its limits and is no longer constrained.
         * @zh 检查约束是否被破坏，表明关节是否超出了其限制并且不再受约束。
         */
        isBreakConstrained(): Boolean;
    }
    /**
     * @en Fixed constraint. Used to fix two rigidbodies together.
     * @zh 固定约束，用于将两个刚体固定在一起。
     */
    class FixedConstraint extends ConstraintComponent {
        /** @ignore */
        constructor();
        /**
         * @inheritDoc
         * @override
         * @internal
         */
        protected _initJoint(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
    }
    /**
     * @en Represents a hinge constraint between two rigid bodies.
     * @zh 两个刚体之间的铰链约束。
     */
    class HingeConstraint extends ConstraintComponent {
        /**@internal */
        _joint: IHingeJoint;
        /**@internal */
        private _axis;
        /**@internal */
        private _motor;
        /**@internal */
        private _targetVelocity;
        /**@internal */
        private _freeSpin;
        /**@internal */
        private _limit;
        /**@internal */
        private _lowerLimit;
        /**@internal */
        private _uperLimit;
        /**@internal */
        private _bounciness;
        /**@internal */
        private _bounceMinVelocity;
        /**@internal */
        private _contactDistance;
        /** @ignore */
        constructor();
        protected _initJoint(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @en Main axis. Set Hinge Rotation Axis, value by rigidbody0.
         * @zh 主轴。设置铰链旋转轴，值由刚体0决定。
         */
        get Axis(): Vector3;
        set Axis(value: Vector3);
        /**
         * @en The minimum limit value for joints.
         * @zh 关节的最小限制值。
         */
        get lowerLimit(): number;
        set lowerLimit(value: number);
        /**
         * @en The maximum limit value of the joint.
         * @zh 关节的最大限制值。
         */
        get uperLimit(): number;
        set uperLimit(value: number);
        /**
         * @en Bounciness value after joint limit.
         * @zh 关节限制值后的弹力值。
         */
        get bounceness(): number;
        set bounceness(value: number);
        /**
         * @en Minimum velocity for bounce after joint limit.
         * @zh 关节限制值后弹力反弹的最小速度。
         */
        get bouncenMinVelocity(): number;
        set bouncenMinVelocity(value: number);
        /**
         * @en Contact distance value of the joint, continuous collision within this distance.
         * @zh 关节的接触距离值，在此距离内持续碰撞。
         */
        get contactDistance(): number;
        set contactDistance(value: number);
        /**
         * @en Rotation limit of the joint.
         * @zh 关节的旋转限制。
         */
        get limit(): boolean;
        set limit(value: boolean);
        /**
         * @en Whether it is a motor (self-driven).
         * @zh 是否为马达（自驱动）。
         */
        get motor(): boolean;
        set motor(value: boolean);
        /**
         * @en Self driving acceleration (not maintaining a constant driving speed)
         * @zh 自驱动加速（不保持恒定驱动速度）。
         */
        get freeSpin(): boolean;
        set freeSpin(value: boolean);
        /**
         * @en The target velocity for the drive model.
         * @zh 驱动模型的目标速度。
         */
        get targetVelocity(): number;
        set targetVelocity(velocity: number);
        /**
         * @en Get the current angle in degrees of the joint relative to its rest position.
         * @zh 获取关节相对于其静止位置的当前角度(度)。
         */
        getAngle(): number;
        /**
         * @en The angular velocity of the joint in degrees per second.
         * @zh 获取关节的角速度，单位为度每秒。
         */
        getVelocity(): Vector3;
    }
    /**
     * @en The `SpringConstraint` class represents a type of constraint that simulates spring behavior in a physics simulation.
     * @zh `SpringConstraint` 类表示一种在物理模拟中模拟弹簧行为的约束类型。
     */
    class SpringConstraint extends ConstraintComponent {
        /**@internal */
        _joint: ISpringJoint;
        /**@internal */
        private _minDistance;
        /**@internal */
        private _damping;
        /**@internal */
        private _maxDistance;
        /**@internal */
        private _tolerance;
        /**@internal */
        private _stiffness;
        /**
         * @internal
         */
        protected _initJoint(): void;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @en the minimum distance at which a spring constraint begins to exert a separating force when the distance between objects reaches or falls below this value.
         * If the objects get closer than this, the spring applies a separating force to push them apart to a safe distance. When the distance is at or above the set value, the spring doesn't exert any stretching force.
         * @zh 弹簧关节在物体间距达到或小于此值时开始施加分离力的最小距离。
         * 如果物体间距小于这个值，弹簧会施加分离力将它们推开到安全距离。而当距离达到或超过设定值时，弹簧不会施加任何拉伸力。
         */
        get minDistance(): number;
        set minDistance(value: number);
        /**
         * @en the maximum distance in a spring constraint, where the spring starts pulling the objects together if they exceed this distance.
         * @zh 两个物体之间的最大允许距离。当物体间距超过这个值时，弹簧会施加拉力使物体靠近。
         */
        get maxDistance(): number;
        set maxDistance(value: number);
        /**
         * @en refers to the allowable margin of error in a physics engine, used to handle contact or constraints between objects, ensuring the system has a certain degree of tolerance in calculations.
         * @zh 弹簧的误差容限。
         * 用于处理物体之间的接触或约束时，确保系统在计算中具有一定的容忍度，以避免由于数值计算精度问题导致的不稳定或错误行为。
         */
        get tolerance(): number;
        set tolerance(value: number);
        /**
         * @en used to set the stiffness of a spring or constraint, adjusting the strength of the force or constraint between objects.
         * @zh 弹簧的刚度，以控制物体之间的弹力或约束强度。
         */
        get spring(): number;
        set spring(value: number);
        /**
         * @en The damping of the spring.
         * @zh 弹簧的阻尼值。
         */
        get damping(): number;
        set damping(value: number);
    }
    /**
     * @en ContactPoint class used to create physical contact information.
     * @zh ContactPoint 类用于创建物理碰撞信息。
     */
    class ContactPoint {
        /**@internal */
        _idCounter: number;
        /**@internal */
        _id: number;
        /**
         * @en Collider A.
         * @zh 碰撞器A。
         */
        _colliderA: ICollider;
        /**
         * @en Collider B.
         * @zh 碰撞器B。
         */
        _colliderB: ICollider;
        /**
         * @en Distance.
         * @zh 距离。
         */
        distance: number;
        /**
         * @en Normal.
         * @zh 法线。
         */
        normal: Vector3;
        /**
         * @en Collider A's contact point.
         * @zh 碰撞器A的碰撞点。
         */
        positionOnA: Vector3;
        /**
         * @en Collider B's contact point.
         * @zh 碰撞器B的碰撞点。
         */
        positionOnB: Vector3;
        /**
         * @en constructor of ContactPoint.
         * @zh ContactPoint 构造函数。
         */
        constructor();
    }
    /**
     * @en The HitResult class is used to store the result of raycasting or shape scanning.
     * @zh HitResult 类用于实现射线检测或形状扫描的结果。
     */
    class HitResult {
        /**
         * @en Whether the raycast or shape scan is successful.
         * @zh 射线检测或形状扫描是否成功。
         */
        succeeded: boolean;
        /**
         * @en The collider that was hit.
         * @zh 发生碰撞的碰撞组件。
         */
        collider: ICollider;
        /**
         * @en The Collision point.
         * @zh 碰撞点。
         */
        point: Vector3;
        /**
         * @en Collision normals.
         * @zh 碰撞法线。
         */
        normal: Vector3;
        /**
         * @en Hit Fraction
         * @zh 碰撞分数。
         */
        hitFraction: number;
        /**@internal */
        _inPool: boolean;
        /** @ignore */
        constructor();
    }
    /**
     * @en PhysicsCollider is a class used to create physical collider.
     * @zh PhysicsCollider 类用于创建物理碰撞器。
     */
    class PhysicsCollider extends PhysicsColliderComponent {
        /** @internal */
        private _isTrigger;
        /** @internal */
        private _allowSleep;
        /**@override @internal */
        _collider: IStaticCollider;
        /**
         * @internal
         * @override
         */
        protected _initCollider(): void;
        /** @ignore */
        constructor();
        _onEnable(): void;
        /**
         * @en If this collider is a trigger.
         * @zh 此碰撞器是否为触发器。
         */
        get isTrigger(): boolean;
        set isTrigger(value: boolean);
        /**
         * @en Whether the collider allows sleep.
         * @zh 是否允许碰撞器睡眠。
         */
        get allowSleep(): boolean;
        set allowSleep(value: boolean);
        /**
         * @internal
         */
        protected _setEventFilter(): void;
    }
    /**
     * @en Describes how the physics materials of colliding objects are combined.
     * @zh 描述碰撞对象的物理材料是如何组合的。
     */
    enum PhysicsCombineMode {
        /**
         * @en Averages the friction/bounce of the two colliding materials.
         * @zh 平均值，对两个碰撞材料的摩擦力/反弹力取平均值。
         */
        Average = 0,
        /**
         * @en Uses the smaller friction/bounce of the two colliding materials.
         * @zh 最小值，使用两个碰撞材料中较小的摩擦力/反弹力。
         */
        Minimum = 1,
        /**
         * @en Multiplies the friction/bounce of the two colliding materials.
         * @zh 乘积，将两个碰撞材料的摩擦力/反弹力相乘，得到最终的摩擦系数。
         */
        Multiply = 2,
        /**
         * @en Uses the larger friction/bounce of the two colliding materials.
         * @zh 最大值，使用两个碰撞材料中较大的摩擦力/反弹力。
         */
        Maximum = 3
    }
    /**
     * @en Describes the mode of applying physics forces.
     * @zh 描述应用物理力的模式。
     */
    enum PhysicsForceMode {
        /**
         * @en Applies a continuous force to the object.
         * @zh 对物体施加持续的力。
         */
        Force = 0,
        /**
         * @en Applies an instantaneous velocity change to the object, equivalent to an impulse.
         * @zh 对物体施加瞬时速度变化，相当于冲量。
         */
        Impulse = 1
    }
    /**
     * @en PhysicsColliderComponent is the base class for creating physics components.
     * @zh PhysicsColliderComponent 类用于创建物理组件的父类。
     */
    class PhysicsColliderComponent extends Component {
        /** @internal */
        protected _restitution: number;
        /** @internal */
        protected _friction: number;
        /** @internal */
        protected _rollingFriction: number;
        /**@internal */
        protected _dynamicFriction: number;
        /**@internal */
        protected _staticFriction: number;
        /**@internal */
        protected _frictionCombine: number;
        /**@internal */
        protected _restitutionCombine: number;
        /** @internal */
        protected _collisionGroup: number;
        /** @internal */
        protected _canCollideWith: number;
        /** @internal */
        protected _colliderShape: Physics3DColliderShape;
        /** @internal */
        protected _transformFlag: number;
        /** @internal 是否只接受物理引擎的模拟变化 Rigidbody为true*/
        protected _controlBySimulation: boolean;
        /**@internal */
        protected _physicsManager: IPhysicsManager;
        /**@internal */
        protected _collider: ICollider;
        /**@internal */
        protected _eventsArray: string[];
        private _isColliderInit;
        readonly owner: Sprite3D;
        /**
         * @en The collider object.
         * @zh 碰撞器对象。
         */
        get collider(): ICollider;
        /**
         * @en The restitution of the collider (also known as bounciness).
         * @zh 碰撞器的弹力（也叫Bounciness）。
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * @en The friction of the collider.
         * @zh 碰撞器的摩擦力。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @en The rolling friction of the collider.
         * @zh 碰撞器的滚动摩擦力。
         */
        get rollingFriction(): number;
        set rollingFriction(value: number);
        /**
         * @en The dynamic friction of the collider.
         * @zh 碰撞器的动态摩擦力。
         */
        get dynamicFriction(): number;
        set dynamicFriction(value: number);
        /**
         * @en The static friction of the collider.
         * @zh 碰撞器的静态摩擦力。
         */
        get staticFriction(): number;
        set staticFriction(value: number);
        /**
         * @en Friction combination mode, used to define how the friction coefficients of two objects are combined during a collision to determine the final friction force.
         * The values include:
         * - Average: The friction coefficients of the two objects are averaged.
         * - Minimum: The minimum friction coefficient of the two objects is used.
         * - Maximum: The maximum friction coefficient of the two objects is used.
         * - Multiply: The friction coefficients of the two objects are multiplied to get the final friction coefficient.
         * @zh 摩擦力组合模式，用于定义在两个物体发生碰撞时，如何组合它们的摩擦系数，以确定最终的摩擦力。
         * 值包括：
         * - Average（平均值）：两个物体的摩擦系数取平均值。
         * - Minimum（最小值）：使用两个物体摩擦系数中的最小值。
         * - Maximum（最大值）：使用两个物体摩擦系数中的最大值。
         * - Multiply（乘积）：将两个物体的摩擦系数相乘，得到最终的摩擦系数。
         */
        get frictionCombine(): PhysicsCombineMode;
        set frictionCombine(value: PhysicsCombineMode);
        /**
         * @en The restitution mode of the collider.
         * The values include:
         * - Average: The friction coefficients of the two objects are averaged.
         * - Minimum: The minimum friction coefficient of the two objects is used.
         * - Maximum: The maximum friction coefficient of the two objects is used.
         * - Multiply: The friction coefficients of the two objects are multiplied to get the final friction coefficient.
         * @zh 弹力组合模式，用于定义在两个物体发生碰撞时，如何组合它们的弹力系数，以确定最终的弹力。
         * 值为：
         * - Average（平均值）：两个物体的摩擦系数取平均值。
         * - Minimum（最小值）：使用两个物体摩擦系数中的最小值。
         * - Maximum（最大值）：使用两个物体摩擦系数中的最大值。
         * - Multiply（乘积）：将两个物体的摩擦系数相乘，得到最终的摩擦系数。
         */
        get restitutionCombine(): PhysicsCombineMode;
        set restitutionCombine(value: PhysicsCombineMode);
        /**
         * @en The collider shape of the physics collider.
         * @zh 物理碰撞器的碰撞形状。
         */
        get colliderShape(): Physics3DColliderShape;
        set colliderShape(value: Physics3DColliderShape);
        /**
         * @en The collision group this collider belongs to.
         * @zh 此碰撞器所属的碰撞组。
         */
        get collisionGroup(): number;
        set collisionGroup(value: number);
        /**
         * @en The collision groups this collider can collide with, based on bitwise operations.
         * @zh 此碰撞器可以与之碰撞的碰撞组，基于位运算。
         */
        get canCollideWith(): number;
        set canCollideWith(value: number);
        /** @ignore */
        constructor();
        /**
         * @internal
         * @en Initializes the collider and configures its properties.
         * @zh 初始化碰撞器并配置其属性。
         */
        initCollider(): void;
        protected _initCollider(): void;
        protected _setEventFilter(): void;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**
         * @internal
         */
        _onTransformChanged(flag: number): void;
        /**
         * @internal
         */
        _cloneTo(dest: PhysicsColliderComponent): void;
    }
    /**
     * @en The PhysicsSettings class is used to create physics configuration information.
     * @zh PhysicsSettings 类用于创建物理配置信息。
     */
    class PhysicsSettings {
        /**
         * @en Flags that determine the behavior of the physics engine.
         * @zh 标志位，用于确定物理引擎的行为。
         */
        flags: number;
        /**
         * @en Used in the physics engine to specify the maximum number of substeps allowed per frame to improve the accuracy and stability of the physics simulation.
         * @zh 最大子步数,在物理引擎中用于指定每一帧允许的最大子步骤数，以提高物理模拟的精度和稳定性。
         */
        maxSubSteps: number;
        /**
         * @en The time step of the physics simulation.
         * @zh 固定时间步长，物理模拟器帧的间隔时间。
         */
        fixedTimeStep: number;
        /**
         * @en Whether to enable continuous collision detection.
         * @zh 是否开启连续碰撞检测
         */
        enableCCD: boolean;
        /**
         * @en The threshold for Continuous Collision Detection (CCD).
         * @zh 连续碰撞检测的阈值。
         */
        ccdThreshold: number;
        /**
         * @en The radius of the sphere used for Continuous Collision Detection.
         * @zh 连续碰撞检测的球体半径。
         */
        ccdSphereRadius: number;
    }
    /**
     * @en The `PhysicsUpdateList` class is used to manage the physics update queue.
     * @zh `PhysicsUpdateList` 类用于实现物理更新队列。
     */
    class PhysicsUpdateList extends SingletonList<ICollider> {
        /** @ignore */
        constructor();
        /**
         * @internal
         * @en Adds an element to the physics update list.
         * @param element The collider element to add.
         * @zh 将元素添加到物理更新列表中。
         * @param element 要添加的碰撞器元素。
         */
        add(element: ICollider): void;
        /**
         * @internal
         * @en Removes an element from the physics update list.
         * @param element The collider element to remove.
         * @zh 从物理更新列表中移除元素。
         * @param element 要移除的碰撞器元素。
         */
        remove(element: ICollider): void;
    }
    /**
     * @en Rigidbody3D is a component that creates a rigidbody collider.
     * @zh Rigidbody3D 类用于创建刚体碰撞器。
     */
    class Rigidbody3D extends PhysicsColliderComponent {
        /**@internal */
        protected _collider: IDynamicCollider;
        /** @internal */
        private _isKinematic;
        /** @internal */
        private _mass;
        /** @internal */
        private _gravity;
        /** @internal */
        private _angularDamping;
        /** @internal */
        private _linearDamping;
        /** @internal */
        private _linearVelocity;
        /** @internal */
        private _angularVelocity;
        /** @internal */
        private _linearFactor;
        /** @internal */
        private _angularFactor;
        /**@internal */
        private _sleepThreshold;
        /**@internal */
        private _sleepAngularThreshold;
        /**@internal */
        private _trigger;
        /**@internal */
        private _collisionDetectionMode;
        /**@internal */
        private _allowSleep;
        /**
         * @override
         * @internal
         */
        protected _initCollider(): void;
        /**
         * @en The mass of the rigidbody.
         * @zh 刚体的质量。
         */
        get mass(): number;
        set mass(value: number);
        /**
         * @en Determines if the rigidbody is kinematic. If true, the rigidbody can only be moved by transform property, not by other force-related properties.
         * @zh 确定刚体是否为运动物体。如果为true仅可通过transform属性移动物体,而非其他力相关属性。
         */
        get isKinematic(): boolean;
        set isKinematic(value: boolean);
        /**
         * @en The linear damping of the rigidbody.
         * @zh 刚体的线阻力。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * @en The angular damping of the rigidbody. It simulates angular resistance and other environmental factors to make the object's rotation slow down gradually.
         * @zh 刚体的角速度阻尼。控制刚体旋转运动的阻尼系数，使旋转逐渐减速，防止永久旋转。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * @en The gravity applied to the rigidbody.
         * @zh 应用于刚体的重力。
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
         * @en The linear motion scaling factor for each axis of the rigidbody.
         * If the value of any axis is 0, it means that the linear motion is frozen on that axis.
         * If the value is 1, it means that linear motion on that axis is not restricted.
         * @zh 限制刚体在特定轴向的线性运动, 如果某一轴的值为0表示冻结在该轴的线性运动。为1表示在该轴的线性运动不受限制。
         */
        get linearFactor(): Vector3;
        set linearFactor(value: Vector3);
        /**
         * @en The linear velocity of the rigidbody.
         * It is represented by a three-dimensional vector (x, y, z) that corresponds to the linear velocity components of the rigidbody on the X, Y, and Z axes.
         * This value not only represents the magnitude but also includes direction.
         * @zh 刚体的线速度。由一个三维向量（x, y, z）表示，分别对应刚体在X、Y、Z 轴上的速度分量，该分量值既有大小又有方向。
         */
        get linearVelocity(): Vector3;
        set linearVelocity(value: Vector3);
        /**
         * @en The angular motion scaling factor for each axis of the rigidbody. If the value of any axis is 0, it means that the angular motion is frozen on that axis.
         * @zh 刚体每个轴的角度运动缩放因子。如果某一轴的值为0表示冻结在该轴的角度运动。
         */
        get angularFactor(): Vector3;
        set angularFactor(value: Vector3);
        /**
         * @en The angular velocity of the rigidbody.
         * It is represented by a three-dimensional vector (x, y, z) that corresponds to the angular velocity components of the rigidbody around X, Y, and Z axes.
         * This value not only represents the magnitude but also includes direction. The unit is **radians per second**.
         * @zh 刚体的角速度。由一个三维向量（Vector3）表示，分别对应刚体围绕X、Y、Z 轴的旋转速率分量，该分量值既有大小又有方向。单位是**弧度/秒**。
         */
        get angularVelocity(): Vector3;
        set angularVelocity(value: Vector3);
        /**
         * @en Set whether the rigidbody allows sleep.
         * @zh 设置刚体是否允许睡眠。
         */
        set allowSleep(value: boolean);
        get allowSleep(): boolean;
        /**
        * @en Whether it is sleeping.
        * @zh 是否处于睡眠状态。
        */
        get isSleeping(): boolean;
        /**
         * @en The linear velocity threshold below which the rigidbody will go to sleep.
         * @zh 刚体进入睡眠状态的线速度阈值。
         */
        get sleepThreshold(): number;
        set sleepThreshold(value: number);
        /**
         * @en The angular velocity threshold below which the rigidbody will go to sleep.
         * @zh 刚体进入睡眠状态的角速度阈值。
         */
        get sleepAngularThreshold(): number;
        set sleepAngularThreshold(value: number);
        /**
         * @en Directly sets the physical position of the rigidbody.
         * @zh 直接设置刚体的物理位置。
         */
        set position(pos: Vector3);
        /**
         * @en Directly sets the physical rotation of the rigidbody.
         * @zh 直接设置刚体的物理旋转。
         */
        set orientation(q: Quaternion);
        /**
         * @en If the rigidbody is a trigger.
         * @zh 刚体是否为触发器。
         */
        get trigger(): boolean;
        set trigger(value: boolean);
        /**
         * @en The collision detection mode of the rigidbody.
         * @zh 刚体的碰撞检测模式。
         */
        get collisionDetectionMode(): number;
        set collisionDetectionMode(value: number);
        /** @ignore */
        constructor();
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDestroy(): void;
        /**
         * @inheritDoc
         * @override
         * @internal
         */
        _cloneTo(dest: Rigidbody3D): void;
        /**
         * @en Applies a force to the rigidbody.
         * @param force The force to apply.
         * @param localOffset The offset, if it is null, it is the center point.
         * @zh 应用作用力。
         * @param force 作用力。
         * @param localOffset 偏移,如果为null则为中心点
         */
        applyForce(force: Vector3, localOffset?: Vector3): void;
        /**
         * @en Applies a torque to the rigidbody.
         * @param torque The torque vector to apply.
         * @zh 对刚体应用扭转力。
         * @param torque 扭转力
         */
        applyTorque(torque: Vector3): void;
        /**
         * @en Applies an impulse to the rigidbody.
         * @param impulse The impulse vector to apply.
         * @param localOffset The offset at which the impulse is applied, relative to the rigidbody's center of mass. If null, the impulse is applied at the center.
         * @zh 对刚体应用冲量。
         * @param impulse 冲量。
         * @param localOffset 冲量相对于质心的偏移。如果为null，则冲量应用在质心处。
         */
        applyImpulse(impulse: Vector3, localOffset?: Vector3): void;
        /**
         * @en Applies a torque impulse (rotational impulse) to the rigidbody.
         * @param torqueImpulse The torque impulse vector to apply.
         * @zh 对刚体应用扭转冲量（旋转冲量）。
         * @param torqueImpulse 扭转冲量
         */
        applyTorqueImpulse(torqueImpulse: Vector3): void;
        /**
         * @en Wakes up the rigidbody.
         * @zh 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @deprecated
         * 刚体睡眠的线速度阈值。
         */
        get sleepLinearVelocity(): number;
        set sleepLinearVelocity(value: number);
        /**
         * @deprecated
         * 刚体睡眠的角速度阈值。
         */
        get sleepAngularVelocity(): number;
        set sleepAngularVelocity(value: number);
        /**
         * @deprecated
         * 应用作用力
         * @param fx x轴方向的力
         * @param fy y轴方向的力
         * @param fz z轴方向的力
         * @param localOffset 受力点距离质点的偏移
         */
        applyForceXYZ(fx: number, fy: number, fz: number, localOffset?: Vector3): void;
        /**
         * @internal
         */
        protected _setEventFilter(): void;
    }
    /**
     * @en BoxColliderShape class is used to create box collider shape.
     * @zh BoxColliderShape 类用于创建盒子形状碰撞器。
     */
    class BoxColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: IBoxColliderShape;
        private _size;
        /**
         * @en Constructor method, initializes the box collider shape with a specified size.
         * @param sizeX The size of the box along the X-axis.
         * @param sizeY The size of the box along the Y-axis.
         * @param sizeZ The size of the box along the Z-axis.
         * @zh 盒形碰撞器的构造方法，初始化为指定尺寸。
         * @param sizeX 盒子X轴尺寸。
         * @param sizeY 盒子Y轴尺寸。
         * @param sizeZ 盒子Z轴尺寸。
         */
        constructor(sizeX?: number, sizeY?: number, sizeZ?: number);
        protected _createShape(): void;
        /**
         * @en Box size
         * @zh 盒子尺寸
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * @inheritDoc
         * @override
         * @en Clone a new BoxColliderShape object.
         * @zh 克隆一个新的 BoxColliderShape 对象。
         */
        clone(): BoxColliderShape;
        /**
         * @en Clone data to target object.
         * @param destObject target object.
         * @zh 克隆数据到目标对象
         * @param destObject 目标对象
         */
        cloneTo(destObject: BoxColliderShape): void;
        /**
         * @en X-axis size.
         * @zh X轴尺寸。
         */
        get sizeX(): number;
        set sizeX(value: number);
        /**
         * @en Y-axis size.
         * @zh Y轴尺寸。
         */
        get sizeY(): number;
        set sizeY(value: number);
        /**
         * @en Z-axis size.
         * @zh Z轴尺寸。
         */
        get sizeZ(): number;
        set sizeZ(value: number);
    }
    /**
     * @en CapsuleColliderShape class is used to create capsule collider shape.
     * @zh CapsuleColliderShape 类用于创建胶囊形状碰撞器。
     */
    class CapsuleColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: ICapsuleColliderShape;
        private _radius;
        private _length;
        private _orientation;
        /**
         * @en The radius of the capsule collider.
         * @zh 胶囊碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The length of the capsule collider.
         * @zh 胶囊碰撞器的长度。
         */
        get length(): number;
        set length(value: number);
        /**
         * @en The orientation of the capsule collider.
         * @zh 胶囊碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en initialize the capsule collider radius, length and direction.
         * @param radius The radius of the capsule collider.
         * @param length The length of the capsule collider.
         * @param orientation The orientation of the capsule collider.
         * @zh 初始化胶囊碰撞器的半径、长度和方向。
         * @param radius 胶囊半径。
         * @param length 胶囊长度。
         * @param orientation 胶囊体方向。
         */
        constructor(radius?: number, length?: number, orientation?: number);
        protected _createShape(): void;
        /**
         * @en Clone a new CapsuleColliderShape object.
         * @returns Clone CapsuleColliderShape object.
         * @zh 克隆一个新的 胶囊形状碰撞器 对象。
         * @returns 克隆的 胶囊形状碰撞器 对象。
         */
        clone(): CapsuleColliderShape;
        /**
         * @en Clone data to target.
         * @param destObject Clone target.
         * @zh 克隆数据到目标
         * @param destObject 克隆目标
         */
        cloneTo(destObject: CapsuleColliderShape): void;
    }
    /**
     * @en use to create compound collider.
     * @zh 用于创建组合碰撞器。
     */
    class CompoundColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: ICompoundColliderShape;
        /**@internal */
        private _childColliderShapes;
        /**
         * @en create a new instance of CompoundColliderShape.
         * @zh 创建一个新的组合碰撞形状实例。
         */
        constructor();
        protected _createShape(): void;
        /**
         * @en set the physics shape array.
         * @zh 设置物理形状数组。
         */
        set shapes(value: Physics3DColliderShape[]);
        get shapes(): Physics3DColliderShape[];
        /**
         * @en add a child collider shape.
         * @param shape The shape to be added as a child collider.
         * @zh 添加一个子碰撞器形状。
         * @param shape 子碰撞器形状。
         */
        addChildShape(shape: Physics3DColliderShape): void;
        /**
         * @en remove a child collider shape.
         * @param shape The shape to be removed from the child collider.
         * @zh 移除一个子碰撞器形状。
         * @param shape 子碰撞器形状。
         */
        removeChildShape(shape: Physics3DColliderShape): void;
        /**
         * @en clear the child collider shape.
         * @zh 清空子碰撞器形状。
         */
        clearChildShape(): void;
        /**
         * @en get the child shape count.
         * @zh 获取子形状数量。
         */
        getChildShapeCount(): number;
        /**
         * @en clone the data to the destination node.
         * @zh 将数据克隆到目标节点。
         */
        cloneTo(destObject: CompoundColliderShape): void;
        /**
         * @en clone the data to the destination node.
         * @zh 将数据克隆到目标节点。
         */
        clone(): CompoundColliderShape;
        /**
         * @en destroy the instance.
         * @zh 销毁实例。
         */
        destroy(): void;
    }
    /**
     * @en ConeColliderShape class is used to create cone collider.
     * @zh ConeColliderShape 类用于创建圆锥碰撞器。
     */
    class ConeColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: IConeColliderShape;
        /**@internal */
        private _orientation;
        /**@internal */
        private _radius;
        /**@internal */
        private _height;
        /**
         * @en The radius of the cone collider.
         * @zh 圆锥碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The height of the cone collider.
         * @zh 圆锥碰撞器的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The orientation of the cone collider.
         * @zh 圆锥碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en Constructor method, initialize ConeColliderShape.
         * @param radius The radius of the cone collider.
         * @param height The height of the cone collider.
         * @param orientation The orientation of the cone collider.
         * @zh 构造方法，初始化圆锥碰撞器。
         * @param radius 半径。
         * @param height 圆锥的高度。
         * @param orientation 圆锥的朝向。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * @internal
         * @override
         */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone a new ConeColliderShape object.
         * @return A new ConeColliderShape object.
         * @zh 克隆一个新的 圆锥碰撞器 对象。
         * @return 一个新的 圆锥碰撞器 对象。
         */
        clone(): ConeColliderShape;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: ConeColliderShape): void;
    }
    /**
     * @en CylinderColliderShape class is used to create a cylinder collider.
     * @zh CylinderColliderShape 类用于创建圆柱碰撞器。
     */
    class CylinderColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: ICylinderColliderShape;
        /**@internal */
        private _orientation;
        /**@internal */
        private _radius;
        /**@internal */
        private _height;
        /**
         * @en The radius of the cylinder collider.
         * @zh 圆柱碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The height of the cylinder collider.
         * @zh 圆柱碰撞器的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The orientation of the cylinder collider.
         * @zh 圆柱碰撞器的方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * @en Constructor method, initialize a cylinder collider.
         * @param radius The radius of the cylinder collider.
         * @param height The height of the cylinder collider.
         * @param orientation The orientation of the cylinder collider.
         * @zh 构造方法，初始化圆柱碰撞器。
         * @param radius 圆柱的半径。
         * @param height 圆柱的高度。
         * @param orientation 圆柱的朝向。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * @internal
         * @override
         */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone a new CylinderColliderShape object.
         * @return A new CylinderColliderShape object.
         * @zh 克隆一个新的 圆柱碰撞器 对象。
         * @return 一个新的 圆柱碰撞器 对象。
         */
        clone(): CylinderColliderShape;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: CylinderColliderShape): void;
    }
    /**
     * @en Interface for height field data.
     * @zh 高度场数据接口。
     */
    interface heightFieldData {
        /**
         * @en The number of rows in the height field.
         * @zh 高度场中的行数。
         */
        numRows: number;
        /**
         * @en The number of columns in the height field.
         * @zh 高度场中的列数。
         */
        numCols: number;
        /**
         * @en The height data of the field.
         * @zh 高度场的高度数据。
         */
        heightData: Float32Array;
        /**
         * @en The tessellation flags for the height field, where 0 and 1 indicate whether the terrain triangle faces left or right.
         * @zh 镶嵌标志，0 和 1 分别表示地形三角形朝向左还是朝右。
         */
        flag: Uint8Array;
        /**
         * @en The scale of the height field.
         * @zh 高度场的缩放。
         */
        scale: Vector3;
    }
    /**
     * @en Class describing the physics collision of a height field.
     * @zh 描述高度场物理碰撞的类。
     */
    class HeightFieldColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: IHeightFieldShape;
        /**@internal */
        _terrainData: heightFieldData;
        /**
         * @ignore
         * @en Constructor method, initialize height field data.
         * @param heightFieldData Height field data.
         * @zh 构造方法, 初始化高度场数据。
         * @param heightFieldData 高度场数据。
         */
        constructor(heightFieldData: heightFieldData);
        /**
         * @internal
         */
        protected _createShape(): void;
    }
    /**
     * @en The `MeshColliderShape` class is used to create mesh colliders.
     * @zh `MeshColliderShape` 类用于创建网格碰撞器。
     */
    class MeshColliderShape extends Physics3DColliderShape {
        /** @internal */
        private _mesh;
        /** @internal */
        private _convex;
        /** @internal */
        private _convexVertexMax;
        /**@internal */
        _shape: IMeshColliderShape;
        /**
         * @en The mesh of the collider.
         * @zh 碰撞器的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        private _changeShape;
        /**
         * @en The maximum number of convex vertices.
         * @zh 凸多边形顶点的最大数量。
         */
        get convexVertexMax(): number;
        set convexVertexMax(value: number);
        /**
         * @en Whether the collider uses a convex shape.
         * @zh 碰撞器是否使用凸多边形形状。
         */
        get convex(): boolean;
        set convex(value: boolean);
        /** @ignore */
        constructor();
        /**
         * @internal
         * @override
         */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: MeshColliderShape): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone a new MeshColliderShape object.
         * @return A new MeshColliderShape object.
         * @zh 克隆一个新的 网格碰撞器 对象。
         * @return 一个新的 网格碰撞器 对象。
         */
        clone(): MeshColliderShape;
    }
    /**
     * @en The Physics3DColliderShape class serves as the base class for creating collider shapes and is an abstract class.
     * @zh 类是用于创建形状碰撞器的父类，该类为抽象类。
     * @blueprintable @blueprintableSubclasses
     */
    class Physics3DColliderShape implements IClone {
        /**
         * @en Shape orientation: along the positive X-axis.
         * @zh 形状方向：沿 X 轴正向。
         */
        static readonly SHAPEORIENTATION_UPX: number;
        /**
         * @en Shape orientation: along the positive Y-axis.
         * @zh 形状方向：沿 Y 轴正向。
         */
        static readonly SHAPEORIENTATION_UPY: number;
        /**
         * @en Shape orientation: along the positive Z-axis.
         * @zh 形状方向：沿 Z 轴正向。
         */
        static readonly SHAPEORIENTATION_UPZ: number;
        /**@internal */
        _shape: IColliderShape;
        /**
         * @en The physics component of the collider.
         * @zh 碰撞器的物理组件。
         */
        private _physicsComponent;
        /**
         * @en The shape of the collider.
         * @zh 碰撞器的形状。
         */
        get shape(): IColliderShape;
        /**@internal */
        protected _localOffset: Vector3;
        /**
         * @en The local offset of the shape.
         * @zh 形状的本地偏移。
         */
        get localOffset(): Vector3;
        set localOffset(value: Vector3);
        /**
         * @en The physics component of the collider.
         * @zh 碰撞器的物理组件。
         */
        get physicsComponent(): PhysicsColliderComponent;
        set physicsComponent(value: PhysicsColliderComponent);
        /**@ignore */
        constructor();
        /**
         * @internal
         * @protected
         */
        protected _createShape(): void;
        /**
         * @en Clone this object to a destination object.
         * @param destObject The destination object.
         * @zh 将此对象克隆到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Physics3DColliderShape): void;
        /**
         * @en Clone.
         * @return A clone of this object.
         * @zh 克隆。
         * @return 此对象的克隆
         */
        clone(): any;
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
    }
    /**
     * @en The `SphereColliderShape` class is used to create spherical colliders.
     * @zh `SphereColliderShape` 类用于创建球形碰撞器。
     */
    class SphereColliderShape extends Physics3DColliderShape {
        /**@internal */
        _shape: ISphereColliderShape;
        /** @internal */
        private _radius;
        /**
         * @en The radius of the sphere collider.
         * @zh 球形碰撞器的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en Constructor method, initialize the sphere collider.
         * @param radius The radius of the sphere collider.
         * @zh 构造方法，初始化球形碰撞器。
         * @param radius 球形碰撞器的半径。
         */
        constructor(radius?: number);
        /**@internal */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         * @en Clone a new SphereColliderShape object.
         * @return A new SphereColliderShape object.
         * @zh 克隆一个新的 球形碰撞器 对象。
         * @return 一个新的 球形碰撞器 对象。
         */
        clone(): SphereColliderShape;
        /**
         * @internal
         * @en Clone data to target object.
         * @param destObject Target object.
         * @zh 将数据克隆到目标对象
         * @param destObject 目标对象。
         */
        cloneTo(destObject: SphereColliderShape): void;
    }
    /**
     * @en The BloomEffect class is used to create a flood effect.
     * @zh BloomEffect 类用于创建泛光效果。
     */
    class BloomEffect extends PostProcessEffect {
        /** @internal */
        static SHADERVALUE_MAINTEX: number;
        /**@internal */
        static SHADERVALUE_AUTOEXPOSURETEX: number;
        /**@internal */
        static SHADERVALUE_SAMPLESCALE: number;
        /**@internal */
        static SHADERVALUE_THRESHOLD: number;
        /**@internal */
        static SHADERVALUE_PARAMS: number;
        /**@internal */
        static SHADERVALUE_BLOOMTEX: number;
        /**@internal */
        static SUBSHADER_PREFILTER13: number;
        /**@internal */
        static SUBSHADER_PREFILTER4: number;
        /**@internal */
        static SUBSHADER_DOWNSAMPLE13: number;
        /**@internal */
        static SUBSHADER_DOWNSAMPLE4: number;
        /**@internal */
        static SUBSHADER_UPSAMPLETENT: number;
        /**@internal */
        static SUBSHADER_UPSAMPLEBOX: number;
        /**@internal */
        private static MAXPYRAMIDSIZE;
        /**
         * @en Bloom resource initialize
         * @zh 泛光资源初始化
         * @internal
         */
        static init(): void;
        /**
         * @internal
         * @en Shader initialize
         * @zh 着色器初始化
         */
        static CompositeInit(): void;
        /**
         * @internal
         * 初始化宏定义
         */
        static __initDefine__(): void;
        /**@internal */
        private _shader;
        /**@internal */
        private _shaderData;
        /**@internal */
        private _linearColor;
        /**@internal */
        private _bloomTextureTexelSize;
        /**@internal */
        private _shaderThreshold;
        /**@internal */
        private _shaderParams;
        /**@internal */
        private _pyramid;
        /**@internal */
        private _intensity;
        /**@internal */
        private _threshold;
        /**@internal */
        private _softKnee;
        /**@internal */
        private _diffusion;
        /**@internal */
        private _anamorphicRatio;
        /**@internal */
        private _dirtIntensity;
        /**@internal */
        private _shaderSetting;
        /**@internal */
        private _dirtTileOffset;
        /**@internal*/
        private _clamp;
        /**泛光颜色。*/
        private _color;
        /**是否开启快速模式。该模式通过降低质量来提升性能。*/
        private _fastMode;
        /**镜头污渍纹路,用于为泛光特效增加污渍灰尘效果*/
        private _dirtTexture;
        /**
         * @en The number of the bloom pixel, this value is in gamma space
         * @zh 泛光像素的数量,该值在伽马空间
         */
        get clamp(): number;
        set clamp(value: number);
        /**
         * @en Flood color.
         * @zh 泛光颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en Fast mode.
         * @zh 快速模式
         */
        get fastMode(): boolean;
        set fastMode(value: boolean);
        /**
         * @en Dirty texture
         * @zh 脏迹贴图
         */
        get dirtTexture(): BaseTexture;
        set dirtTexture(value: BaseTexture);
        /**
         * @en Intensity of floodlight filter, the minimum value is 0.
         * @zh 泛光过滤器强度,最小值为0。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The flood threshold, below which pixels with brightness will be filtered out, is in gamma space.
         * @zh 泛光阈值,在该阈值亮度以下的像素会被过滤掉,该值在伽马空间。
         */
        get threshold(): number;
        set threshold(value: number);
        /**
         * @en Soft knee transition strength. Gradual transition occurs below the threshold (0 for completely hard transition, 1 for completely soft transition).
         * @zh 软膝盖过渡强度，在阈值以下进行渐变过渡（0为完全硬过度，1为完全软过度）。
         */
        get softKnee(): number;
        set softKnee(value: number);
        /**
         * @en Diffusion value, changes the bloom spread range. It's best to use integer values for the best effect. This value changes the internal iteration count, range is 1 to 10.
         * @zh 扩散值，改变泛光的扩散范围。最好使用整数值以保证效果，该值会改变内部的迭代次数，范围是1到10。
         */
        get diffusion(): number;
        set diffusion(value: number);
        /**
         * @en Anamorphic ratio, distorts the bloom to produce a visual deformation. Negative values for vertical distortion, positive values for horizontal distortion. Range: -1 to 1.
         * @zh 形变比，通过扭曲泛光产生视觉上的形变。负值为垂直扭曲，正值为水平扭曲。范围：-1到1。
         */
        get anamorphicRatio(): number;
        set anamorphicRatio(value: number);
        /**
         * @en Dirt intensity. Range: 0 to 1.
         * @zh 污渍强度。范围：0到1。
         */
        get dirtIntensity(): number;
        set dirtIntensity(value: number);
        /**
         * @en initializate the bloom effect instance.
         * @zh 初始化泛光效果实例。
         */
        constructor();
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing component.
         * @zh 添加到后期处理栈时调用。
         * @param postprocess 后期处理组件。
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * @inheritDoc
         * @override
         * @en Get the camera depth texture mode flag according to the post-processing settings.
         * @returns The camera depth texture mode flag.
         * @zh 根据后期处理设置获取相机深度纹理模式标志。
         * @returns 相机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag(): number;
        /**
         * @en Release the Effect.
         * @param postprocess The post-processing component.
         * @zh 释放Effect。
         * @param postprocess 后期处理组件。
         */
        release(postprocess: PostProcess): void;
        /**
         * @inheritDoc
         * @override
         * @internal
         * @en Render the effect.
         * @param context The post-processing render context.
         * @zh 渲染效果。
         * @param context 后期处理渲染上下文。
         */
        render(context: PostProcessRenderContext): void;
    }
    enum ToneMappingType {
        None = 0,
        ACES = 1
    }
    /**
     * @en Class of ColorGradEffect used to create tone mapping effect.
     * @zh ColorGradEffect 类用于创建调色效果
     */
    class ColorGradEffect extends PostProcessEffect {
        /**
         * @internal
         * @en ACES macro
         * @zh ACES宏
         */
        static SHADERDEFINE_ACES: ShaderDefine;
        /**
         * @internal
         * @en Custom LUT macro
         * @zh 自定义LUT宏
         */
        static SHADERDEFINE_CUSTOMLUT: ShaderDefine;
        /**@internal */
        static SHADERVALUE_LUT: number;
        /**@internal */
        static SHADERVALUE_LUTPARAMS: number;
        /**@internal */
        static SHADERVALUE_CUSTOMLUT: number;
        /**@internal */
        static SHADERVALUE_CUSTOMLUTPARAMS: number;
        /**
         * @internal
         * @en Initialize shader configurations and rendering state settings.
         * @zh 初始化着色器配置和渲染状态设置。
         */
        static init(): void;
        private static lutBuilderInit;
        /**
         * @en Initialize shader definitions.
         * @zh 初始化着色器定义。
         */
        static __initDefine__(): void;
        private _needBuildLUT;
        /**@internal */
        _lutTex: RenderTexture;
        private _lutBuilderMat;
        private _LUTShader;
        private _lutShaderData;
        private _blitlutParams;
        /**color Tone */
        /**@internal */
        private _toneMapping;
        /**@internal lut height size */
        private _lutSize;
        /**@internal */
        private _enableSplitTone;
        private _splitShadow;
        private _splitBalance;
        private _splithighlights;
        private _u_SplitShadow;
        private _enableSMH;
        /**@internal */
        private _shadows;
        /**@internal */
        private _midtones;
        /**@internal */
        private _highlights;
        /**@internal */
        private _limits;
        private _enableLiftGammaGain;
        /**@internal */
        private _lift;
        /**@internal */
        private _gamma;
        /**@internal */
        private _gain;
        private _enableBalance;
        /**@internal tint,temperature */
        private _balance;
        private _tint;
        private _temperature;
        /**@internal */
        private _enableColorAdjust;
        /**@internal 自动曝光,默认值是1 */
        private _postExposure;
        /**@internal */
        private _contrast;
        /**@internal */
        private _colorFilter;
        /**@internal */
        private _HueShift;
        /**@internal */
        private _saturation;
        /**@internal _HueShift,_saturation,_contrast*/
        private _HueSatCon;
        /**
         * @en the tone mapping type.
         * @zh 色调映射类型
         */
        get toneMapping(): ToneMappingType;
        set toneMapping(value: ToneMappingType);
        /**
         * @en Whether split tone effect is enabled.
         * @zh 是否启用分离色调效果。
         */
        get enableSplitTone(): boolean;
        set enableSplitTone(value: boolean);
        /**
       * @en The color of shadows in split tone effect.
       * @zh 分离色调效果中阴影的颜色。
       */
        get splitShadow(): Vector3;
        set splitShadow(value: Vector3);
        /**
         * @en The color of highlights in split tone effect.
         * @zh 分离色调效果中高光的颜色。
         */
        get splithighlights(): Vector3;
        set splithighlights(value: Vector3);
        /**
        * @en The balance between shadow and highlight coloring in split tone effect.
        * @zh 分离色调效果中阴影和高光着色的平衡。
        */
        get splitBalance(): number;
        set splitBalance(value: number);
        /**
         * @en wheather to enable shadows, midtones, highlights
         * @zh 是否启用阴影，中亮，高亮调节
         */
        get enableSMH(): boolean;
        set enableSMH(value: boolean);
        /**
         * @en Shadows value, range 0-5.
         * @zh 阴影值，取值范围0-5
         */
        get shadows(): Vector3;
        set shadows(value: Vector3);
        /**
         * @en Midtones value, range 0-5.
         * @zh 中亮值，取值范围0-5
         */
        get midtones(): Vector3;
        set midtones(value: Vector3);
        /**
         * @en Highlights value, range 0-5.
         * @zh 高亮值，取值范围0-5
         */
        get highlights(): Vector3;
        set highlights(value: Vector3);
        /**
         * @en Shadow limit start 0-1
         * @zh 阴影限界起点，取值范围0-1
         */
        get shadowLimitStart(): number;
        set shadowLimitStart(value: number);
        /**
         * @en Shadow limit end 0-1
         * @zh 阴影限界终点，取值范围0-1
         */
        get shadowLimitEnd(): number;
        set shadowLimitEnd(value: number);
        /**
         * @en HighLight limit start 0-1
         * @zh 高光限界起点，取值范围0-1
         */
        get highLightLimitStart(): number;
        set highLightLimitStart(value: number);
        /**
         * @en HighLight limit end 0-1
         * @zh 高光限界终点，取值范围0-1
         */
        get highLightLimitEnd(): number;
        set highLightLimitEnd(value: number);
        /**
         * @en Whether lift, gamma, gain adjustments are enabled.
         * @zh 是否启用暗部、中间调、亮部调整。
         */
        get enableLiftGammaGain(): boolean;
        set enableLiftGammaGain(value: boolean);
        /**
         * @en The lift adjustment value. Primarily affects the shadow areas of the image, with a range of -1-1.
         * @zh 暗部调整值。主要影响图像的阴影区域，范围 -1-1
         */
        get lift(): Vector3;
        set lift(value: Vector3);
        /**
         * @en The gamma adjustment value. Affects the midtones of the image, but also influences shadows and highlights. with a range of 999-0.5.
         * @zh 中间调调整值。影响图像的中间调，范围 999-0.5
         */
        get gamma(): Vector3;
        set gamma(value: Vector3);
        /**
         * @en The gain adjustment value. Primarily affects the highlight areas of the image, with a range of 0-2.
         * @zh 亮部调整值。主要影响图像的高光区域，范围 0-2
         */
        get gain(): Vector3;
        set gain(value: Vector3);
        private _StandardIlluminantY;
        private _CIExyToLMS;
        private _ColorBalanceToLMSCoeffs;
        /**
         * @zh Wheather to enable white balance.
         * @zh 白平衡是否开启
         */
        get enableBalance(): boolean;
        set enableBalance(value: boolean);
        /**
         * @en Controls the white balance color to compensate for a green or magenta tint. Range -100-100.
         * @zh 白平衡颜色，用于补偿绿色或品红色。范围 -100-100。
         */
        get tint(): number;
        set tint(value: number);
        /**
         * @en White Balance Temperature. Range -100-100.
         * @zh 白平衡色温。范围 -100-100.
         */
        get temperature(): number;
        set temperature(value: number);
        /**
         * @en Whether color adjust is enabled.
         * @zh 是否开启颜色调整
         */
        get enableColorAdjust(): boolean;
        set enableColorAdjust(value: boolean);
        /**
         * @en The overall exposure of the scene.
         * @zh 场景的整体曝光
         */
        get postExposure(): number;
        set postExposure(value: number);
        /**
         * @en Color Contrast. Range 0-2.
         * @zh 颜色对比度，范围 0-2
         */
        get contrast(): number;
        set contrast(value: number);
        /**
         * @en The color filter.
         * @zh 颜色过滤器
         */
        get colorFilter(): Color;
        set colorFilter(value: Color);
        /**
         * @en The Hue Shift. Range -0.5-0.5.
         * @zh 色相偏移，范围 -0.5-0.5
         */
        get HueShift(): number;
        set HueShift(value: number);
        /**
         * @en Saturation.
         * @zh 饱和度
         */
        get saturation(): number;
        set saturation(value: number);
        /**
         * @en initialize the color grad effect instance.
         * @zh 初始化调色效果实例
         */
        constructor();
        private get lutSize();
        private set lutSize(value);
        private default_balance;
        private default_splitShadow;
        private default_splithighlights;
        private default_shadow;
        private default_midtones;
        private default_highlight;
        private default_limint;
        private default_lift;
        private default_gamma;
        private default_gain;
        private default_ColorFilter;
        private default_HueSatCon;
        /**
         * @internal
         * 生成LUT纹理
         */
        _buildLUT(): void;
        private _postProcess;
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing node.
         * @zh 在添加到后期处理栈时调用。
         * @param postprocess 后期处理节点。
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * @en Release the Effect.
         * @param postprocess The post-processing node.
         * @zh 释放Effect。
         * @param postprocess 后期处理节点。
         */
        release(postprocess: PostProcess): void;
        /**
         * @inheritDoc
         * @override
         * @internal
         * @en Render the effect.
         * @param context The post-processing rendering context.
         * @zh 渲染效果。
         * @param context 后期处理渲染上下文。
         */
        render(context: PostProcessRenderContext): void;
    }
    /**
     * @en The `GaussianDoF` class is used to create a Gaussian Depth of Field effect.
     * Only supports far field blur.
     * - start: The depth at which the far field begins to blur.
     * - end: The depth at which the far field reaches its maximum blur radius.
     * - maxRadius: The maximum blur radius for the far field.
     * @zh `GaussianDoF` 类用于创建高斯景深效果。
     * 仅支持远景模糊。
     * - start: 开始远景模糊的深度
     * - end: 达到最大模糊半径的远景深度
     * - maxRadius: 远景模糊最大半径
     */
    class GaussianDoF extends PostProcessEffect {
        /**@internal */
        static SOURCESIZE: number;
        /**@internal */
        static COCPARAMS: number;
        /**@internal */
        static DEPTHTEXTURE: number;
        /**@internal */
        static NORMALDEPTHTEXTURE: number;
        /**@internal */
        static FULLCOCTEXTURE: number;
        /**@internal */
        static DOWNSAMPLESCALE: number;
        /**@internal */
        static BLURCOCTEXTURE: number;
        /**@internal */
        static SHADERDEFINE_DEPTHNORMALTEXTURE: ShaderDefine;
        /**
         * @en GaussianDOF resource init
         * @zh 高斯DOF资源初始化
         * @internal
         */
        static init(): void;
        /**@internal */
        private _shader;
        /**@internal */
        private _shaderData;
        /**@internal */
        private _sourceSize;
        /**@internal */
        private _dowmSampleScale;
        /**
         * @ignore
         * @en initialization GaussianDOF effect instance.
         * @zh 初始化高斯DOF效果实例
         */
        constructor();
        /**
         * @en The depth at which far field blur begins.
         * @zh 开始远景模糊的深度。
         */
        get farStart(): number;
        set farStart(value: number);
        /**
         * @en The depth at which maximum blur radius is reached for far field.
         * @zh 达到最大模糊半径的远景深度。
         */
        get farEnd(): number;
        set farEnd(value: number);
        /**
         * @en The maximum blur radius.
         * @zh 最大模糊半径。
         */
        get maxRadius(): number;
        set maxRadius(value: number);
        /**
         * @internal
         * @param context
         */
        private _setupShaderValue;
        /**
         * @internal
         * @override
         * @en Get the camera depth texture mode flag.
         * @zh 获取相机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag(): DepthTextureMode;
        /**
         * @internal
         * @override
         * @en Render the Gaussian DoF effect.
         * @param context The post-process render context.
         * @zh 渲染高斯景深效果。
         * @param context 后处理渲染上下文。
         */
        render(context: PostProcessRenderContext): void;
    }
    /**
     * @en Represents lens flare command
     * @zh 表示镜头光晕指令
     */
    class LensFlareCMD {
        /**@internal geoemtry */
        private _lensFlareGeometry;
        /**@internal renderElement*/
        private _renderElement;
        /**@internal */
        private _materials;
        /**@internal */
        private _transform3D;
        /**@internal */
        private _lensFlareElementData;
        private _instanceCount;
        /**
         * @en The number of instances drawn
         * @zh instance绘制的个数
         */
        get instanceCount(): number;
        set instanceCount(value: number);
        /**
         * @ignore
         * @en Constructor method, initialize instance.
         * @zh 构造方法，初始化实例
         */
        constructor();
        /**
         * init material
         */
        private _initMaterial;
        /**
         * @internal
         * @en The center position of the lens flare effect.
         * @zh 镜头光晕效果的中心位置。
         */
        set center(value: Vector2);
        /**
         * @internal
         * @en The rotation angle of the lens flare effect.
         * @zh 镜头光晕效果的旋转角度。
         */
        set rotate(value: number);
        /**
         * @internal
         * @en The lens flare element data.
         * @zh 镜头光晕元素数据
         */
        get lensFlareElement(): LensFlareElement;
        set lensFlareElement(value: LensFlareElement);
        /**
         * @en apply element Data
         * @zh 应用元素数据
         */
        applyElementData(): void;
        /**
         * @inheritDoc
         * @override
         * @en Execute the command.
         * @zh 执行命令
         */
        run(cmd: CommandBuffer): void;
        /**
         * @internal
         * @en recover command
         * @zh 回收命令
         */
        recover(): void;
        /**
         * @internal
         * @en Destroy command
         * @zh 销毁命令
         */
        destroy(): void;
    }
    /**
     * @en lens Flare Element
     * @zh 镜头光晕元素
     */
    class LensFlareElement {
        /** active*/
        private _active;
        /** tintColor */
        private _tint;
        /** intensity*/
        private _intensity;
        /** texture*/
        private _texture;
        /** positionOffet In screen space */
        private _positionOffset;
        /** scale in each dimension */
        private _scale;
        /** */
        private _autoRotate;
        /** rotation with angle */
        private _rotation;
        private _startPosition;
        private _angularOffset;
        private _aspectRatio;
        /**@internal */
        private _modulateByLightColor;
        /**@internal */
        private _blendMode;
        /**@internal */
        private _translationScale;
        /**
         * @en Whether the element is active.
         * @zh 是否激活
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en The tint color of the lens flare.
         * @zh 光晕的颜色
         */
        get tint(): Color;
        set tint(value: Color);
        /**
         * @en The intensity of the lens flare.
         * @zh 光晕的强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The texture of the lens flare.
         * @zh 光晕的贴图
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The position offset of the lens flare in screen space.
         * @zh 光晕的位置偏移(屏幕空间下)
         */
        get positionOffset(): Vector2;
        set positionOffset(value: Vector2);
        /**
         * @en The scale of the lens flare in each dimension.
         * @zh 光晕的缩放(每个轴上)
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * @en Whether to enable automatic rotation.
         * @zh 是否开启自动旋转
         */
        get autoRotate(): boolean;
        set autoRotate(value: boolean);
        /**
         * @en The rotation of the lens flare.
         * @zh 光晕的旋转角度
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The start position of the lens flare.
         * @zh 光晕的起始位置
         */
        get startPosition(): number;
        set startPosition(value: number);
        /**
         * @en The angle offset of the lens flare.
         * @zh 光晕的角度偏移
         */
        get angularOffset(): number;
        set angularOffset(value: number);
    }
    /**
     * @en Lens Flare Data
     * @zh 镜头光晕的资源数据
     */
    class LensFlareData extends Resource {
        constructor();
        /**
         * @en Lens Flare Element Collection
         * @zh 镜头光晕元素集合
         */
        elements: LensFlareElement[];
    }
    /**
     * @en Lens Flare Effect
     * @zh 镜头光晕效果
     */
    class LensFlareEffect extends PostProcessEffect {
        /**@internal */
        static SHADERDEFINE_AUTOROTATE: ShaderDefine;
        /**
         * @internal
         * initdefine
         */
        static __initDefine__(): void;
        /**
         * @en Initialize Shader and Geometry
         * @zh 初始化着色器和几何体
         */
        static init(): void;
        private _flareCMDS;
        private _center;
        private _rotate;
        private _light;
        private _effectIntensity;
        private _effectScale;
        private _needUpdate;
        _lensFlareData: LensFlareData;
        /**
         * @en LensFlareData
         * @zh 镜头光晕数据
         */
        get lensFlareData(): LensFlareData;
        set lensFlareData(value: LensFlareData);
        /**
         * @en Bind light
         * @zh 绑定光源
         */
        get bindLight(): Light;
        set bindLight(light: Light);
        /**
         * @en Post-processing effect intensity
         * @zh 后处理效果强度
         */
        get effectIntensity(): number;
        set effectIntensity(value: number);
        /**
         * @en Post-processing effect scale
         * @zh 后处理效果缩放
         */
        get effectScale(): number;
        set effectScale(value: number);
        constructor();
        /**
         * @internal
         * 更新后处理数据
         */
        _updateEffectData(cmd: CommandBuffer): void;
        /**
         * @en Calculate the center point of directional light
         * @param camera The camera
         * @zh 计算直射光中心点
         * @param camera 摄像机
         */
        caculateDirCenter(camera: Camera): void;
        /**
         * @en Calculate point light
         * @param camera The camera
         * @zh 计算点光源
         * @param camera 相机
         */
        caculatePointCenter(camera: Camera): void;
        /**
         * @en Calculate spot light
         * @param value Screen point
         * @zh 计算聚光灯
         * @param value 屏幕点
         */
        caculateSpotCenter(value: Vector2): void;
        /**
         * @en Render process
         * @param context Post-processing render context
         * @zh 渲染流程
         * @param context 后期处理渲染上下文
         */
        render(context: PostProcessRenderContext): void;
        /**
         * @en Release the effect
         * @param postprocess Post-processing node
         * @zh 释放效果
         * @param postprocess 后期处理节点
         */
        release(postprocess: PostProcess): void;
    }
    /**
     * @en Represents the geometry of a lens flare element.
     * @zh 表示镜头光晕元素的几何体。
     */
    class LensFlareElementGeomtry extends GeometryElement {
        /**
         * @en Constant representing the position and UV attributes.
         * @zh 表示位置和UV属性的常量。
         */
        static PositionUV: number;
        /**
         * @en Constant representing the position, rotation, and scale attributes.
         * @zh 表示位置、旋转和缩放属性的常量。
         */
        static PositionRotationScale: number;
        /**@internal */
        static lensQuadVertices: Float32Array;
        /**@internal */
        static lensQuadIndex: Uint16Array;
        /**@internal */
        static vertexDeclaration: VertexDeclaration;
        /**@internal */
        static instanceVertexDeclaration: VertexDeclaration;
        /**@internal 最大instanceData*/
        static lensFlareElementMax: number;
        /**@internal */
        private _vertexBuffer;
        /**@internal */
        private _instanceVertexBuffer;
        /**@internal */
        private _indexBuffer;
        /**@internal */
        private static _type;
        /**
         * @en Initializes the data for lens flare element geometry.
         * @zh 初始化镜头光晕元素几何体的数据。
         */
        static init(): void;
        /**
         * @ignore
         */
        constructor();
        private _createBuffer;
        /**
         * @internal
         */
        get instanceBuffer(): VertexBuffer3D;
        /**
         *  @internal
         */
        _getType(): number;
        /**
         * @internal
         * @return  是否需要渲染。
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @en Destroys the lens flare element geometry and releases its resources.
         * @zh 销毁镜头光晕元素几何体并释放其资源。
         */
        destroy(): void;
        /**
        * @internal
        * UpdateGeometry Data
        */
        _updateRenderParams(state: RenderContext3D): void;
    }
    /**
     * @en Initialize the lens flare element shader.
     * @zh 初始化镜头光晕元素着色器
     */
    class LensFlareShaderInit {
        /**
         * @en Initialize the lens flare element shader.
         * @zh 初始化镜头光晕元素着色器
         */
        static init(): void;
    }
    /**
     * @ignore
     * @en Usedfor loading lens flare.
     * @zh 用于加载镜头光晕数据资源。
     */
    class LensFlareSettingsLoader implements IResourceLoader {
        /**
         * @en Load lens flare from a specified URL.
         * @param task The load task that contains the URL and other loading options.
         * @returns A Promise, when loaded successfully, it is resolves with the loaded `LensFlareData` object or null if loading fails.
         * @zh 加载指定的镜头光晕数据资源。
         * @param task 包含 URL 和其他加载选项的加载任务。
         * @returns 一个Promise，加载成功时解析为加载的 `LensFlareData` 对象，加载失败时为 null。
         */
        load(task: ILoadTask): Promise<LensFlareData>;
    }
    /**
     * @en The quality of AO.
     * @zh AO质量
     */
    enum AOQUALITY {
        /**
         * @en High quality.
         * @zh 高质量
         */
        High = 0,
        /**
         * @en Medium quality.
         * @zh 中质量
         */
        MEDIUM = 1,
        /**
         * @en Low quality.
         * @zh 低质量
         */
        LOWEST = 2
    }
    /**
     * @en The ScalableAO class is used to create ambient occlusion effect.
     * @zh ScalableAO 类用于创建环境光遮罩效果。
     */
    class ScalableAO extends PostProcessEffect {
        /**@internal */
        static SHADERDEFINE_AOHigh: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_AOMEDIUM: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_LOWEST: ShaderDefine;
        /**@internal */
        static BlurDelty: number;
        /**@internal */
        static AOColor: number;
        /**@internal */
        static aoTexture: number;
        /**@internal */
        static AOParams: number;
        /**@internal */
        static SourceTex: number;
        /**@internal */
        static deltyHorizontal: Vector2;
        /**@internal */
        static deltyVector: Vector2;
        /**
         * @internal
         * @en ScaleAO resource init
         * @zh 初始化AO资源
         */
        static init(): void;
        private _shader;
        /** shader data */
        private _shaderData;
        private _aoBlurHorizontalShader;
        private _aoComposition;
        private _aoParams;
        private _aoQuality;
        /**
         * @ignore
         * @en initializes the effect.
         * @zh 构造函数, 初始化实例。
         */
        constructor();
        /**
         * @en The color of ambient occlusion.
         * @zh 环境光遮挡的颜色
         */
        get aoColor(): Color;
        set aoColor(value: Color);
        /**
         * @en The intensity of ambient occlusion.
         * @zh 环境光遮挡的强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en The influence radius of ambient occlusion.
         * @zh 环境光遮挡的影响半径
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en The quality of ambient occlusion.
         * @zh 环境光遮挡的质量
         */
        get aoQuality(): AOQUALITY;
        set aoQuality(value: AOQUALITY);
        /**
         * @en Get the camera depth texture mode flag.
         * @zh 获取相机深度纹理模式标志。
         */
        getCameraDepthTextureModeFlag(): DepthTextureMode;
        /**
         * @en Render the ambient occlusion effect.
         * @param context The post-process render context.
         * @zh 渲染环境光遮挡效果。
         * @param context 后处理渲染上下文。
         */
        render(context: PostProcessRenderContext): void;
    }
    class ACESShaderLib {
        static init(): void;
    }
    class Laya3DRender {
        static Render3DPassFactory: I3DRenderPassFactory;
        static Render3DModuleDataFactory: I3DRenderModuleFactory;
        /**
         * @deprecated
         */
        static renderOBJCreate: IRenderEngine3DOBJFactory;
    }
    /**
     * @internal
     */
    class skinnedMatrixCache {
        readonly subMeshIndex: number;
        readonly batchIndex: number;
        readonly batchBoneIndex: number;
        constructor(subMeshIndex: number, batchIndex: number, batchBoneIndex: number);
    }
    /**
     * @en Mesh class is used to create a template for file mesh data.
     * @zh Mesh 类用于创建文件网格数据模板。
     */
    class Mesh extends Resource implements IClone {
        /**@internal */
        static MESH_INSTANCEBUFFER_TYPE_NORMAL: number;
        /**@internal */
        static MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR: number;
        /**@internal */
        _convexMesh: any;
        /**@internal */
        _triangleMesh: any;
        /**@internal */
        __convexMesh: Mesh;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.MESH)
         * @en Loads a mesh template from the specified URL and calls the complete callback upon completion.
         * @param url The URL of the mesh template.
         * @param complete The callback function to call when the mesh is loaded.
         * @zh 从指定的URL加载网格模板，并在加载完成后执行完成回调。
         * @param url 网格模板的URL。
         * @param complete 加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        private _btTriangleMesh;
        private _minVerticesUpdate;
        private _maxVerticesUpdate;
        private _needUpdateBounds;
        private _bounds;
        /** @internal */
        _isReadable: boolean;
        /** @internal */
        _bufferState: BufferState;
        /** @internal */
        _instanceBufferState: BufferState;
        /** @internal */
        _instanceBufferStateType: number;
        /**@internal */
        _instanceWorldVertexBuffer: VertexBuffer3D;
        /**@internal */
        _instanceSimpleAniVertexBuffer: VertexBuffer3D;
        /**@internal */
        _instanceLightMapVertexBuffer: VertexBuffer3D;
        /** @internal */
        _subMeshes: SubMesh[];
        /** @internal */
        _vertexBuffer: VertexBuffer3D;
        /** @internal */
        _indexBuffer: IndexBuffer3D;
        /** @internal */
        _boneNames: string[];
        /** @internal */
        _inverseBindPoses: Matrix4x4[];
        /** @internal */
        _skinnedMatrixCaches: skinnedMatrixCache[];
        /** @internal */
        _vertexCount: number;
        /** @internal */
        _indexFormat: IndexFormat;
        /** @internal */
        instanceLightMapScaleOffsetData: Float32Array;
        /**
         * @en Morph target data for the mesh.
         * @zh 网格的变形目标数据。
         */
        morphTargetData: MorphTargetData;
        /** @internal */
        _width: number;
        /** @internal */
        _height: number;
        /**
         * @en The array of inverse absolute bind poses for the mesh.
         * @zh 网格的全局默认绑定动作逆矩阵数组。
         */
        get inverseAbsoluteBindPoses(): Matrix4x4[];
        /**
         * @en The number of vertices in the mesh.
         * @zh 网格中的顶点数。
         */
        get vertexCount(): number;
        /**
         * @en The number of indices in the mesh.
         * @zh 网格中的索引个数。
         */
        get indexCount(): number;
        /**
         * @en The number of SubMeshes in the mesh.
         * @zh 子网格的个数。
         */
        get subMeshCount(): number;
        /**
         * @en The bounds of the mesh.
         * @zh 网格的边界
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * @en The index format of the mesh.
         * @zh 网格的索引格式。
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * @en Constructor method, do not use.
         * @param isReadable 是否可读。
         * @zh 构造方法，禁止使用。
         * @param isReadable 是否可读。
         */
        constructor(isReadable?: boolean);
        /**
         * @internal
         */
        private _getPositionElement;
        private _getVerticeElementData;
        private _setVerticeElementData;
        /**
         * @en Destroys the mesh and releases resources.
         * @zh 销毁资源
         */
        protected _disposeResource(): void;
        /**
         *@internal
         */
        _setSubMeshes(subMeshes: SubMesh[]): void;
        /**
         * @internal
         */
        _setBuffer(vertexBuffer: VertexBuffer3D, indexBuffer: IndexBuffer3D): void;
        /**
         * @internal
         */
        _setInstanceBuffer(): void;
        /**
         * @internal
         */
        _uploadVerticesData(): void;
        /**
         * @en Retrieves a sub-mesh based on the index.
         * @param index The index of the sub-mesh.
         * @returns The sub-mesh at the specified index.
         * @zh 根据索引获取子网格。
         * @param index 子网格的索引。
         * @returns 索引处的子网格。
         */
        getSubMesh(index: number): SubMesh;
        /**
         * @en Copies and fills position data into an array.This method is a copy operation, which may be time-consuming.
         * @param positions The array to fill with position data.
         * @zh 拷贝并填充位置数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param positions 用于填充位置数据的数组。
         */
        getPositions(positions: Vector3[]): void;
        /**
         * @en Sets the position data.
         * @param positions The new position data to set.
         * @zh 设置位置数据。
         * @param positions 要设置的新位置数据。
         */
        setPositions(positions: Vector3[]): void;
        /**
         * @en Copies and fills color data into an array.This method is a copy operation, which may be time-consuming.
         * @param colors The array to fill with color data.
         * @zh 拷贝并填充颜色数据至数组。该方法为拷贝操作，比较耗费性
         * @param colors 用于填充颜色数据的数组。
         */
        getColors(colors: Color[]): void;
        /**
         * @en Sets the color data.
         * @param colors The new color data to set.
         * @zh 设置颜色数据。
         * @param colors 要设置的新颜色数据。
         */
        setColors(colors: Color[]): void;
        /**
         * @en Copies and fills texture coordinate data into an array.This method is a copy operation, which may be time-consuming.
         * @param uvs The array to fill with texture coordinate data.
         * @param channel The texture coordinate channel.
         * @zh 拷贝并填充纹理坐标数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param uvs 纹理坐标数组。
         * @param channel 纹理坐标通道。
         */
        getUVs(uvs: Vector2[], channel?: number): void;
        /**
         * @en Sets the texture coordinate data.
         * @param uvs The new texture coordinate data to set.
         * @param channel The texture coordinate channel.
         * @zh 设置纹理坐标数据。
         * @param uvs 要设置的新纹理坐标数据。
         * @param channel 纹理坐标通道。
         */
        setUVs(uvs: Vector2[], channel?: number): void;
        /**
         * @en Copies and fills normal data into an array. This method is a copy operation, which may be time-consuming.
         * @param normals The array to fill with normal data.
         * @zh 拷贝并填充法线数据至数组。该方法为拷贝操作，比较耗费性能。
         * @param normals 用于填充法线数据的数组。
         */
        getNormals(normals: Vector3[]): void;
        /**
         * @en Sets the normal data.
         * @param normals The new normal data to set.
         * @zh 设置法线数据。
         * @param normals 要设置的新法线数据。
         */
        setNormals(normals: Vector3[]): void;
        /**
         * @en Copies and fills tangent data into an array.
         * @param tangents The array to fill with tangent data.
         * @zh 拷贝并填充切线数据至数组。
         * @param tangents 用于填充切线数据的数组。
         */
        getTangents(tangents: Vector4[]): void;
        /**
         * @en Sets the tangent data.
         * @param tangents The new tangent data to set.
         * @zh 设置切线数据。
         * @param tangents 要设置的新切线数据。
         */
        setTangents(tangents: Vector4[]): void;
        /**
         * @en Copies and fills bone weight data into an array.
         * @param boneWeights The array to fill with bone weight data.
         * @zh 拷贝并填充骨骼权重数据至数组。
         * @param boneWeights 用于填充骨骼权重数据的数组。
         */
        getBoneWeights(boneWeights: Vector4[]): void;
        /**
         * @en Copy and fill the bone weight data into the array.
         * @param boneWeights Bone weight data.
         * @zh 拷贝并填充骨骼权重数据至数组。
         * @param boneWeights 骨骼权重。
         */
        setBoneWeights(boneWeights: Vector4[]): void;
        /**
         * @en Gets the bone indices.
         * @param boneIndices The bone indices
         * @zh 获取骨骼索引。
         * @param boneIndices 骨骼索引。
         */
        getBoneIndices(boneIndices: Vector4[]): void;
        /**
         * @en Sets the bone index data.
         * @param boneIndices The new bone index data to set.
         * @zh 设置骨骼索引数据。
         * @param boneIndices 要设置的新骨骼索引数据。
         */
        setBoneIndices(boneIndices: Vector4[]): void;
        /**
         * @en Marks the Mesh as non-readable, which can reduce memory usage. Once marked, no read methods can be called.
         * @zh 将Mesh标记为不可读，可以减少内存使用。标记后，不能再调用任何读取方法。
         */
        markAsUnreadbale(): void;
        /**
         * @en Gets the vertex declaration.
         * @zh 获取顶点声明。
         */
        getVertexDeclaration(): VertexDeclaration;
        /**
         * @en Copies and retrieves a copy of the vertex data.
         * @returns A copy of the vertex data.
         * @zh 拷贝并获取顶点数据的副本。
         * @returns 顶点数据副本。
         */
        getVertices(): ArrayBuffer;
        /**
         * @en Sets the vertex data.
         * @param vertices The vertex data to set.
         * @zh 设置顶点数据。
         * @param vertices 要设置的顶点数据。
         */
        setVertices(vertices: ArrayBuffer): void;
        /**
         * @en Copies and retrieves a copy of the mesh indices.
         * @returns A copy of the mesh indices.
         * @zh 拷贝并获取网格索引的副本。
         * @returns 网格索引的副本。
         */
        getIndices(): Uint8Array | Uint16Array | Uint32Array;
        /**
         * @en Sets the mesh indices.
         * @param indices The mesh indices to set.
         * @zh 设置网格索引。
         * @param indices 要设置的网格索引。
         */
        setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void;
        /**
         * @en Generates a bounding box from the model's position data.
         * @zh 从模型位置数据生成包围盒。
         */
        calculateBounds(): void;
        /**
         * @en Gets the convex model.
         * @returns The convex mesh.
         * @zh 获取凸包模型。
         * @returns 凸包网格。
         */
        getCorveMesh(): Mesh;
        /**
         * @en Clones this mesh to the destination object.
         * @param destObject The destination object to clone to.
         * @zh 克隆当前网格到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Mesh): void;
        /**
         * @en Clones this mesh.
         * @returns A clone of the current mesh.
         * @zh 克隆当前网格。
         * @return 当前网格的克隆副本。
         */
        clone(): Mesh;
        /** @internal */
        _inverseBindPosesBuffer: ArrayBuffer;
    }
    /**
     * @en Utility class for mesh operations
     * @zh Mesh操作的实用工具类
     */
    class MeshUtil {
        /**
         * @en Get the shader defines for a mesh
         * @param mesh The mesh to analyze
         * @param out Array to store the resulting shader defines
         * @zh 获取mesh的着色器宏定义
         * @param mesh 输入的Mesh对象
         * @param out 用于存储着色器宏定义的输出数组
         */
        static getMeshDefine(mesh: Mesh, out: Array<ShaderDefine>): void;
    }
    /**
     * @en Represents a morph target in 3D modeling
     * @zh 表示3D建模中的变形目标
     */
    class MorphTarget {
        /** @internal */
        _index: number;
        /**
         * @en The name of the morph target
         * @zh 变形目标的名称
         */
        name: string;
        /**
         * @en The full weight of the morph target
         * @zh 变形目标的完整权重
         */
        fullWeight: number;
        /**
         * @en The data of the morph target
         * @zh 变形目标的数据
         */
        data: Float32Array;
        /** @ignore */
        constructor();
    }
    /**
     * @en Represents a channel of morph targets
     * @zh 表示变形目标的通道
     */
    class MorphTargetChannel {
        /** @internal */
        _index: number;
        /**
         * @en The name of the morph target channel
         * @zh 变形目标通道的名称
         */
        name: string;
        /**
         * @en The list of morph targets in this channel.
         * @zh 此通道中的变形目标列表。
         */
        targets: Array<MorphTarget>;
        /**
         * @en The count of targets in this channel
         * @zh 此通道中目标的数量
         */
        targetCount: number;
        constructor();
        /**
         * @en Get a target by its index
         * @param index The index of the target
         * @returns The MorphTarget at the specified index
         * @zh 通过索引获取目标
         * @param index 目标的索引
         * @returns 指定索引处的MorphTarget
         */
        getTargetByIndex(index: number): MorphTarget;
        /**
         * @en Add a target to this channel
         * @param target The MorphTarget to add
         * @zh 向此通道添加目标
         * @param target 要添加的MorphTarget
         */
        addTarget(target: MorphTarget): void;
    }
    /**
     * @en Morph target data.
     * @zh 变形目标数据。
     */
    class MorphTargetData {
        private targets;
        private channels;
        /**
         * @en The count of vertices in the morph target data.
         * @zh 变形目标数据中的顶点计数。
         */
        vertexCount: number;
        /**
         * @en Removed, replaced by getting it from the VertexDeclaration.
         * @zh 移除，改为从 VertexDeclaration 中获取
         */
        elementCount: number;
        /**
         * @internal
         * @en The attribute offset vector.
         * @zh 属性偏移向量。
         */
        attributeOffset: Vector4;
        /**
         * @internal
         * @en The parameters vector.
         * @zh 参数向量。
         */
        params: Vector4;
        /**
         * @internal
         * @en The target texture for morph targets, used internally.
         * @zh 用于变形目标的内部目标纹理。
         */
        targetTexture: Texture2DArray;
        /**
         * @en The vertex declaration associated with the morph target data.
         * @zh 与变形目标数据关联的顶点声明。
         */
        vertexDec: VertexDeclaration;
        /**
         * @en The bounding box.
         * @zh 包围盒
         */
        bounds: Bounds;
        /** @ignore */
        constructor();
        /**
         * @en Adds a morph target channel to the data.
         * @param channel The morph target channel to add.
         * @zh 向数据添加一个变形目标通道。
         * @param channel 要添加的变形目标通道。
         */
        addMorphChannel(channel: MorphTargetChannel): void;
        /**
         * @en Retrieves a morph target channel by its name.
         * @param name The name of the morph target channel to retrieve.
         * @returns The morph target channel with the specified name.
         * @zh 通过名称检索变形目标通道。
         * @param name 要检索的变形目标通道的名称。
         * @returns 具有指定名称的变形目标通道。
         */
        getMorphChannel(name: string): MorphTargetChannel;
        /**
         * @en Retrieves a morph target channel by its index.
         * @param index The index of the morph target channel to retrieve.
         * @returns The morph target channel at the specified index.
         * @zh 通过索引检索变形目标通道。
         * @param index 要检索的变形目标通道的索引。
         * @returns 在指定索引处的变形目标通道。
         */
        getMorphChannelbyIndex(index: number): MorphTargetChannel;
        /**
         * @internal
         * @en The count of morph targets.
         * @zh 变形目标的计数。
         */
        get targetCount(): number;
        /**
         * @internal
         * @en The count of morph target channels.
         * @zh 变形目标通道的计数。
         */
        get channelCount(): number;
        /**
         * @en Initializes the data for the morph targets.
         * @zh 初始化变形目标的数据。
         */
        initData(): void;
        /**
         * @en Cleans up and destroys the resources associated with the morph target data.
         * @zh 清理并销毁与变形目标数据关联的资源。
         */
        destroy(): void;
        /**
         * @en Clone the morph target data.
         * @returns A cloned instance of the morph target data.
         * @zh 克隆变形目标数据。
         * @returns 变形目标数据的克隆实例。
         */
        clone(): MorphTargetData;
    }
    /**
     * @en The `PrimitiveMesh` class is used to create simple meshes.
     * @zh `PrimitiveMesh` 类用于创建简单的网格。
     */
    class PrimitiveMesh {
        static __init__(): void;
        /**
         * @internal
         */
        static _createMesh(vertexDeclaration: VertexDeclaration, vertices: Float32Array, indices: Uint16Array): Mesh;
        /**
         * @en Creates a box mesh.
         * @param long The length of the box. Default is 1.
         * @param height The height of the box. Default is 1.
         * @param width The width of the box. Default is 1.
         * @return The created Mesh instance.
         * @zh 创建一个立方体网格。
         * @param long 立方体的长度，默认值为1。
         * @param height 立方体的高度，默认值为1。
         * @param width 立方体的宽度，默认值为1。
         * @return 创建的网格实例。
         */
        static createBox(long?: number, height?: number, width?: number): Mesh;
        /**
         * @en Creates a capsule mesh.
         * @param radius The radius of the capsule. Default is 0.5.
         * @param height The height of the capsule. Default is 2.
         * @param stacks The number of stacks, typically half the number of vertical slices. Default is 16.
         * @param slices The number of vertical slices. Default is 32.
         * @zh 创建一个胶囊体网格。
         * @param radius 胶囊的半径，默认值为0.5。
         * @param height 胶囊的高度，默认值为2。
         * @param stacks 水平层数，默认为16，一般设为垂直层数的一半。
         * @param slices 垂直层数，默认为32。
         */
        static createCapsule(radius?: number, height?: number, stacks?: number, slices?: number): Mesh;
        /**
         * @en Creates a cone mesh.
         * @param radius The radius of the base of the cone. Default is 0.5.
         * @param height The height of the cone. Default is 1.
         * @param slices The number of segments around the base of the cone. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个圆锥体网格。
         * @param radius 圆锥底面的半径，默认值为0.5。
         * @param height 圆锥的高度，默认值为1。
         * @param slices 圆锥底面圆周的分段数，默认为32。
         * @return 创建的网格实例。
         */
        static createCone(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * @en Creates a cylinder mesh.
         * @param radius The radius of the cylinder. Default is 0.5.
         * @param height The height of the cylinder. Default is 2.
         * @param slices The number of vertical segments of the cylinder. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个圆柱体网格。
         * @param radius 圆柱的半径，默认值为0.5。
         * @param height 圆柱的高度，默认值为2。
         * @param slices 圆柱的垂直层数，默认为32。
         * @return 创建的网格实例。
         */
        static createCylinder(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * @en Creates a plane mesh.
         * @param long The length of the plane. Default is 10.
         * @param width The width of the plane. Default is 10.
         * @param stacks The number of longitudinal subdivisions. Default is 10.
         * @param slices The number of latitudinal subdivisions. Default is 10.
         * @return The created Mesh instance.
         * @zh 创建一个平面网格。
         * @param long 平面的长。默认值为10。
         * @param width 平面的宽。默认值为10。
         * @param stacks 纵向细分的数量。默认为10。
         * @param slices 横向细分的数量。默认为10。
         * @return 创建的网格实例。
         */
        static createPlane(long?: number, width?: number, stacks?: number, slices?: number): Mesh;
        /**
         * @en Creates a quad mesh.
         * @param long The length of the quad. Default is 1.
         * @param width The width of the quad. Default is 1.
         * @return The created Mesh instance.
         * @zh 创建一个四边形网格。
         * @param long 四边形的长度。默认是1。
         * @param width 四边形的宽度。默认是1。
         * @return 创建的网格实例。
         */
        static createQuad(long?: number, width?: number): Mesh;
        /**
         * @en Creates a sphere mesh.
         * @param radius The radius of the sphere. Default is 0.5.
         * @param stacks The number of stacks, typically used for the vertical slices. Default is 32.
         * @param slices The number of slices, typically used for the horizontal circles. Default is 32.
         * @return The created Mesh instance.
         * @zh 创建一个球体网格。
         * @param radius 球体的半径。默认是0.5。
         * @param stacks 水平层数，通常用作垂直切分。默认是32。
         * @param slices 垂直层数，通常用作水平圆周切分。默认是32。
         * @return 创建的网格实例。
         */
        static createSphere(radius?: number, stacks?: number, slices?: number): Mesh;
    }
    /**
     * @en SkyBox class used to create a skybox.
     * @zh SkyBox 类用于创建天空盒。
     */
    class SkyBox extends GeometryElement {
        /**
         * @en The singleton instance of the SkyBox class.
         * @zh SkyBox类的单例实例。
         */
        static instance: SkyBox;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @ignore
         * @en Creates an instance of SkyBox.
         * @zh 创建 SkyBox 的实例。
         */
        constructor();
        /**
         * @internal
         * UpdateGeometry Data
         */
        _updateRenderParams(state: RenderContext3D): void;
    }
    /**
     * @en SkyDome class is used to create a sky dome.
     * @zh SkyDome 类用于创建天空球。
     */
    class SkyDome extends GeometryElement {
        /**@internal */
        private static _radius;
        /**
         * @en The singleton instance of the SkyDome.
         * @zh SkyDome的实例。
         */
        static instance: SkyDome;
        /**
         * @internal
         */
        static __init__(): void;
        /**@internal */
        private _stacks;
        /**@internal */
        private _slices;
        /**
         * @internal
         * @en The number of stacks of the SkyDome.
         * @zh SkyDome的堆数。
         */
        get stacks(): number;
        /**
         * @internal
         * @en The number of slices of the SkyDome.
         * @zh SkyDome的层数。
         */
        get slices(): number;
        /**
         * @en Creates an instance of SkyDome.
         * @param stacks The number of stacks of the SkyDome.
         * @param slices The number of slices of the SkyDome.
         * @zh 创建一个 SkyDome 的实例。
         * @param stacks SkyDome的堆数。
         * @param slices SkyDome的层数。
         */
        constructor(stacks?: number, slices?: number);
        /**
         * @internal
         * UpdateGeometry Data
         */
        _updateRenderParams(state: RenderContext3D): void;
    }
    /**
     * @en SkyRenderer class used to implement sky rendering.
     * @zh SkyRenderer 类用于实现天空渲染器。
     */
    class SkyRenderer {
        /**@internal */
        static SUNLIGHTDIRECTION: number;
        /**@internal */
        static SUNLIGHTDIRCOLOR: number;
        /**@internal */
        static SKYVIEWMATRIX: number;
        /**@internal */
        static SKYPROJECTIONMATRIX: number;
        /**@internal */
        static SKYPROJECTIONVIEWMATRIX: number;
        /**
         * @internal
         */
        static __init__(): void;
        /** @internal */
        private _material;
        /** @internal */
        private _mesh;
        /** @internal */
        _baseRenderNode: IBaseRenderNode;
        private _renderData;
        private _renderGeometry;
        private _cacheRenderElement;
        /**
         * @en The material.
         * @zh 材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The mesh of the renderer.
         * @zh 渲染器网格。
         */
        get mesh(): GeometryElement;
        set mesh(value: GeometryElement);
        /** @internal */
        private get meshType();
        /** @internal */
        private set meshType(value);
        /**
         * @ignore
         * @en Creates an instance of SkyRenderer.
         * @zh 创建一个 SkyRenderer 的实例。
         */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * @internal
         * 是否可用。
         */
        _isAvailable(): boolean;
        /** @internal */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en Sets the render element for the sky.
         * @param skyRenderElement The render element to set.
         * @zh 设置天空的渲染元素。
         * @param skyRenderElement 要设置的渲染元素。
         */
        setRenderElement(skyRenderElement: SkyRenderElement): void;
        /**
         * @internal
         */
        destroy(): void;
    }
    /**
     * @en SubMesh class used to create submesh data template.
     * @zh SubMesh 类用于创建子网格数据模板。
     * @blueprintIgnore
     */
    class SubMesh extends GeometryElement {
        /**@internal */
        private static _type;
        /** @internal */
        _mesh: Mesh;
        /** @internal */
        _boneIndicesList: Uint16Array[];
        /** @internal */
        _subIndexBufferStart: number[];
        /** @internal */
        _subIndexBufferCount: number[];
        /** @internal */
        _indexInMesh: number;
        /** @internal */
        _indexStart: number;
        /** @internal */
        _indexCount: number;
        /** @internal */
        _indices: Uint16Array | Uint32Array;
        /**@internal [只读]*/
        _vertexBuffer: VertexBuffer3D;
        /**@internal [只读]*/
        _indexBuffer: IndexBuffer3D;
        /**
         * @en The number of indices.
         * @zh 索引的数量。
         */
        get indexCount(): number;
        /**
         * @en Creates an instance of SubMesh.
         * @param mesh  The mesh data template.
         * @zh 创建 SubMesh 实例。
         * @param mesh  网格数据模板。
         */
        constructor(mesh: Mesh);
        /**
         * @internal
         */
        _setIndexRange(indexStart: number, indexCount: number, indexFormat?: IndexFormat): void;
        /**
         * @internal
         * @override
         */
        _getType(): number;
        /**
         * @internal
         * @override
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @internal
         * @override
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Copies and gets a copy of the submesh index data.
         * @returns A copy of the indices.
         * @zh 拷贝并获取子网格索引数据的副本。
         * @returns 索引的副本。
         */
        getIndices(): Uint16Array | Uint32Array;
        /**
         * @en Sets the indices for the submesh.
         * @param indices The indices to set.
         * @zh 设置子网格的索引。
         * @param indices 要设置的索引。
         */
        setIndices(indices: Uint16Array): void;
        /**
         * @override
         * @en Destroys the submesh and releases resources.
         * @zh 销毁子网格并释放资源。
         */
        destroy(): void;
    }
    /**
     * 贴图生成器
     * @internal
     */
    class TextureGenerator {
        constructor();
        static lightAttenTexture(x: number, y: number, maxX: number, maxY: number, index: number, data: Uint8Array): void;
        static haloTexture(x: number, y: number, maxX: number, maxY: number, index: number, data: Uint8Array): void;
        static _generateTexture2D(texture: Texture2D, textureWidth: number, textureHeight: number, func: Function): void;
    }
    class BlinnPhongShaderInit {
        static init(): void;
    }
    /**
     * @internal
     */
    class PBRDefaultDFG {
        private static _defaultDFG;
        static get defaultDFG(): Texture2D;
        static set defaultDFG(value: Texture2D);
        static DefaultDfgTexture(): void;
    }
    class PBRShaderLib {
        /**
         * emission
         */
        static DEFINE_EMISSION: ShaderDefine;
        /**
         * clear coat
         */
        static DEFINE_CLEARCOAT: ShaderDefine;
        static DEFINE_CLEARCOAT_NORMAL: ShaderDefine;
        /**
         * anisotropy
         */
        static DEFINE_ANISOTROPY: ShaderDefine;
        /**
         * ior
         */
        static DEFINE_IOR: ShaderDefine;
        /**
         * iridescence
         */
        static DEFINE_IRIDESCENCE: ShaderDefine;
        /**
         * sheen
         */
        static DEFINE_SHEEN: ShaderDefine;
        /**
         * transmission
         */
        static DEFINE_TRANSMISSION: ShaderDefine;
        /**
         * thick / volume
         */
        static DEFINE_THICKNESS: ShaderDefine;
        static init(): void;
    }
    class PBRStandardShaderInit {
        static init(): void;
    }
    class BlitScreenShaderInit {
        static init(): void;
    }
    /**
     * @internal
     * <code>ShaderInit</code> 类用于初始化内置Shader。
     */
    class ShaderInit3D {
        /**
         * @internal
         */
        static __init__(): void;
    }
    class SkyBoxShaderInit {
        static init(): void;
    }
    class SkyPanoramicShaderInit {
        static init(): void;
    }
    class SkyProceduralShaderInit {
        static init(): void;
    }
    class UnlitShaderInit {
        static init(): void;
    }
    /**
     * @internal
     * @en ShadowCasterPass class used to implement the shadow rendering pipeline.
     * @zh ShadowCasterPass 类用于实现阴影渲染管线。
     */
    class ShadowCasterPass {
        static ShadowUniformMap: CommandUniformMap;
        /** @internal */
        static SHADOW_BIAS: number;
        /** @internal */
        static SHADOW_LIGHT_DIRECTION: number;
        /** @internal */
        static SHADOW_SPLIT_SPHERES: number;
        /** @internal */
        static SHADOW_MATRICES: number;
        /** @internal */
        static SHADOW_MAP_SIZE: number;
        /** @internal */
        static SHADOW_MAP: number;
        /** @internal */
        static SHADOW_PARAMS: number;
        /** @internal */
        static SHADOW_SPOTMAP_SIZE: number;
        /** @internal */
        static SHADOW_SPOTMAP: number;
        /** @internal */
        static SHADOW_SPOTMATRICES: number;
        /**
         * @internal
         * init Scene UniformMap
         */
        static __init__(): void;
        /** @internal */
        private _shadowDirectLightMap;
        /** @internal */
        private _shadowSpotLightMap;
        /**
         * @en Create a new instance of ShadowCasterPass.
         * @zh 创建  ShadowCasterPass 类的新实例。
         */
        constructor();
        /**
         * @en Retrieve the shadow map for a directional light.
         * @param light The directional light component.
         * @returns The shadow map texture for the directional light.
         * @zh 获取方向光的阴影贴图。
         * @param light 方向光组件。
         * @returns 方向光的阴影贴图纹理。
         */
        getDirectLightShadowMap(light: DirectionLightCom): RenderTexture;
        /**
         * @en Retrieve the shadow pass data for a spot light.
         * @param light The spot light component.
         * @returns The shadow map texture for the spot light.
         * @zh 获取聚光灯的阴影通道数据。
         * @param light 聚光灯组件。
         * @returns 聚光灯的阴影贴图纹理。
         */
        getSpotLightShadowPassData(light: SpotLightCom): RenderTexture;
        /**
         * @en Retrieve the shadow pass data for a point light.
         * @zh 获取点光源的阴影通道数据。
         */
        getPointLightShadowPassData(): void;
        /**
         * @internal
         * @en Clean up shadow data.
         * @zh 清理阴影数据。
         */
        cleanUp(): void;
    }
    /**
     * @en Shadow Light enum
     * @zh 阴影光类型
     */
    enum ShadowLightType {
        /**
         * @en Directional Light
         * @zh 方向光
         */
        DirectionLight = 0,
        /**
         * @en Spot Light
         * @zh 聚光
         */
        SpotLight = 1,
        /**
         * @en Point Light
         * @zh 点光
         */
        PointLight = 2
    }
    /**
     * @en Camera culling information class.
     * @zh 摄像机裁剪信息类。
     */
    class CameraCullInfo {
        /**
         * @en Position of the camera in the scene.
         * @zh 摄像机在场景中的位置。
         */
        position: Vector3;
        /**
         * @en Whether to use occlusion culling.
         * @zh 是否遮挡剔除
         */
        useOcclusionCulling: Boolean;
        /**
         * @en Frustum that bounds the camera's view.
         * @zh 摄像机视锥体的包围盒。
         */
        boundFrustum: BoundFrustum;
        /**
         * @en Occlusion Mask
         * @zh 遮挡标记
         */
        cullingMask: number;
        /**
         * @en Static Mask
         * @zh 静态标记
         */
        staticMask: number;
        /**
         * @en Create a new instance of CameraCullInfo.
         * @zh 创建 CameraCullInfo 类的新实例。
         */
        constructor();
    }
    /**
     * @en Shadow culling information.
     * @zh 阴影裁剪信息
     */
    class ShadowCullInfo {
        /**
         * @en Position.
         * @zh 位置。
         */
        position: Vector3;
        /**
         * @en Direction.
         * @zh 方向。
         */
        direction: Vector3;
        /**
         * @en Array of planes used for culling.
         * @zh 用于裁剪的平面数组。
         */
        cullPlanes: Plane[];
        /**
         * @en Sphere used for culling.
         * @zh 用于裁剪的球体。
         */
        cullSphere: BoundSphere;
        /**
         * @en Number of culling planes.
         * @zh 裁剪平面的数量。
         */
        cullPlaneCount: number;
    }
    /**
     * @en Spotlight Shadow Data
     * @zh 聚光灯阴影数据
     */
    class ShadowSpotData {
        /**
         * @en The camera shader data.
         * @zh 摄像机着色器数据。
         */
        cameraShaderValue: ShaderData;
        /**
         * @en Position of the shadow.
         * @zh 阴影的位置。
         */
        position: Vector3;
        /**
         * @en Offset on the X-axis for the shadow map.
         * @zh 阴影贴图在X轴上的偏移。
         */
        offsetX: number;
        /**
         * @en Offset on the Y-axis for the shadow map.
         * @zh 阴影贴图在Y轴上的偏移。
         */
        offsetY: number;
        /**
         * @en Resolution of the shadow map.
         * @zh 阴影贴图的分辨率。
         */
        resolution: number;
        /**
         * @en View matrix of the shadow.
         * @zh 阴影的视图矩阵。
         */
        viewMatrix: Matrix4x4;
        /**
         * @en Projection matrix of the shadow.
         * @zh 阴影的投影矩阵。
         */
        projectionMatrix: Matrix4x4;
        /**
         * @en Combined view and projection matrix of the shadow.
         * @zh 阴影的视图投影矩阵。
         */
        viewProjectMatrix: Matrix4x4;
        /**
         * @en Culling information for the shadow camera.
         * @zh 阴影摄像机的裁剪信息。
         */
        cameraCullInfo: CameraCullInfo;
        /**
         * @en Create a new instance of ShadowSpotData.
         * @zh 创建 ShadowSpotData 类的新实例。
         */
        constructor();
        destroy(): void;
    }
    /**
     * @internal
     * @en Shadow Slice Data.
     * @zh 阴影分割数据。
     */
    class ShadowSliceData {
        /**
         * @en Shader data associated with the shadow slice.
         * @zh 与阴影切片关联的着色器数据。
         */
        cameraShaderValue: ShaderData;
        /**
         * @en Position of the shadow slice in world space.
         * @zh 阴影切片在世界空间中的位置。
         */
        position: Vector3;
        /**
         * @en X-axis offset for the shadow map.
         * @zh 阴影贴图的X轴偏移。
         */
        offsetX: number;
        /**
         * @en Y-axis offset for the shadow map.
         * @zh 阴影贴图的Y轴偏移。
         */
        offsetY: number;
        /**
         * @en Resolution of the shadow map for the slice.
         * @zh 阴影切片的阴影贴图分辨率。
         */
        resolution: number;
        /**
         * @en View matrix of the shadow slice camera.
         * @zh 阴影切片摄像机的视图矩阵。
         */
        viewMatrix: Matrix4x4;
        /**
         * @en Projection matrix of the shadow slice camera.
         * @zh 阴影切片摄像机的投影矩阵。
         */
        projectionMatrix: Matrix4x4;
        /**
         * @en Combined view and projection matrix for the shadow slice camera.
         * @zh 阴影切片摄像机的视图投影矩阵。
         */
        viewProjectMatrix: Matrix4x4;
        /**
         * @en Array of planes used for culling in the shadow slice.
         * @zh 阴影切片中用于裁剪的平面数组。
         */
        cullPlanes: Array<Plane>;
        /**
         * @en Total count of culling planes.
         * @zh 裁剪平面的总数。
         */
        cullPlaneCount: number;
        /**
         * @en Bounding sphere for the shadow slice.
         * @zh 阴影切片的包围球体。
         */
        splitBoundSphere: BoundSphere;
        /**
         * @en Center Z coordinate of the bounding sphere for culling.
         * @zh 用于裁剪的包围球体的中心Z坐标。
         */
        sphereCenterZ: number;
        /**
         * @en Create a new instance of ShadowSliceData.
         * @zh 创建 ShadowSliceData 类的新实例。
         */
        constructor();
        destroy(): void;
    }
    /**
     * @en TextMesh class used to create text mesh.
     * @zh TextMesh 类用于创建文本网格。
     */
    class TextMesh {
        private _text;
        private _fontSize;
        private _color;
        /**
         * @en The text of the TextMesh.
         * @zh 文本网格的文本。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The font size of the TextMesh.
         * @zh 字体尺寸。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en The color of the TextMesh.
         * @zh 文本网格的颜色
         */
        get color(): Color;
        set color(value: Color);
        /** @ignore */
        constructor();
    }
    /**
     * @en Physics3DUtils class represents a 3D physics collision group.
     * @zh Physics3DUtils 类表示3D物理碰撞组。
     */
    class Physics3DUtils {
        /**
         * @en Default collision filter group.
         * @zh 默认碰撞组。
         */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**
         * @en Static collision filter group.
         * @zh 静态碰撞组。
         */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**
         * @en Kinematic rigid body collision filter group.
         * @zh 运动学刚体碰撞组。
         */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**
         * @en Debris collision filter group.
         * @zh 碎片碰撞组。
         */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**
         * @en Sensor trigger filter group.
         * @zh 传感器触发器。
         */
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**
         * @en Character filter group.
         * @zh 字符过滤器。
         */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**
         * @en Custom filter group 1.
         * @zh 自定义过滤1。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**
         * @en Custom filter group 2.
         * @zh 自定义过滤2。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**
         * @en Custom filter group 3.
         * @zh 自定义过滤3。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**
         * @en Custom filter group 4.
         * @zh 自定义过滤4。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**
         * @en Custom filter group 5.
         * @zh 自定义过滤5。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**
         * @en Custom filter group 6.
         * @zh 自定义过滤6。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**
         * @en Custom filter group 7.
         * @zh 自定义过滤7。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**
         * @en Custom filter group 8.
         * @zh 自定义过滤8。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**
         * @en Custom filter group 9.
         * @zh 自定义过滤9。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**
         * @en Custom filter group 10.
         * @zh 自定义过滤10。
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**
         * @en All filter group that includes all other filter groups.
         * @zh 包含所有其他过滤组的所有过滤组。
         */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        /**
         * @en Default mask value used in PhysX.
         * @zh 在PhysX中使用的默认掩码值。
         */
        static PHYSXDEFAULTMASKVALUE: number;
    }
    /**
     * @en Picker class used to create picking.
     * @zh Picker 类用于创建拾取。
     */
    class Picker {
        /** @ignore */
        constructor();
        /**
         * @en Calculates a ray originating from the mouse position.
         * @param point The mouse position in screen space.
         * @param viewPort The viewport dimensions.
         * @param projectionMatrix The projection (perspective) matrix.
         * @param viewMatrix The view matrix.
         * @param world The world offset matrix.
         * @param out The output ray.
         * @zh 根据鼠标位置计算射线。
         * @param point 屏幕空间中的鼠标位置。
         * @param viewPort 视口尺寸。
         * @param projectionMatrix 投影（透视）矩阵。
         * @param viewMatrix 视图矩阵。
         * @param world 世界偏移矩阵。
         * @param out 输出射线。
         */
        static calculateCursorRay(point: Vector2, viewPort: Viewport, projectionMatrix: Matrix4x4, viewMatrix: Matrix4x4, world: Matrix4x4, out: Ray): void;
        /**
         * @en Calculates the intersection of a ray with a triangle and returns the intersection distance.
         * @param ray The ray.
         * @param vertex1 The first vertex of the triangle.
         * @param vertex2 The second vertex of the triangle.
         * @param vertex3 The third vertex of the triangle.
         * @returns The distance from the ray to the triangle, or `Number.NaN` if there is no intersection.
         * @zh 计算射线与三角形的交点并返回交点距离。
         * @param ray 射线。
         * @param vertex1 三角形的第一个顶点。
         * @param vertex2 三角形的第二个顶点。
         * @param vertex3 三角形的第三个顶点。
         * @returns 射线到三角形的距离，如果没有交点则返回 `Number.NaN`。
         */
        static rayIntersectsTriangle(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * @en Detects the intersection point between a ray and a plane.
         * @param ray The ray.
         * @param plane The plane.
         * @returns The intersection point, or `null` if there is no intersection.
         * @zh 检测射线和平面的交点。
         * @param ray 射线。
         * @param plane 平面。
         * @returns 交点，如果没有交点则返回 `null`。
         */
        static rayPlaneIntersection(ray: Ray, plane: Plane): Vector3;
    }
    /**
     * @en The `Size` class represents the dimensions of a rectangle or other shape in 2D space.
     * @zh `Size` 类表示2D空间中矩形或其他形状的尺寸。
     */
    class Size {
        /**
         * @en Gets the screen size of the global scene.
         * @return Returns a `Size` instance with both width and height set to -1, indicating full screen.
         * @zh 获取全局场景的屏幕尺寸。
         * @return 返回一个宽度和高度都设置为 -1 的 `Size` 实例，表示全屏。
         */
        static get fullScreen(): Size;
        private _width;
        private _height;
        /**
         * @en Width.
         * @zh 宽度
         */
        get width(): number;
        /**
         * @en Height.
         * @zh 高度
         */
        get height(): number;
        /**
         * @en Creates an instance of  `Size`.
         * @param width  Width.
         * @param height Height.
         * @zh 创建一个 `Size` 实例。
         * @param width 宽度
         * @param height 高度
         */
        constructor(width: number, height: number);
    }
    /**
     * @en Utils3D is a class used to create 3D tools.
     * @zh Utils3D 类用于创建3D工具。
     */
    class Utils3D {
        /**
         * @internal
         */
        static _createFloatTextureBuffer(width: number, height: number): Texture2D;
        /**
         *通过数平移、旋转、缩放值计算到结果矩阵数组,骨骼动画专用。
         * @param tx left矩阵数组。
         * @param ty left矩阵数组的偏移。
         * @param tz right矩阵数组。
         * @param qx right矩阵数组的偏移。
         * @param qy 输出矩阵数组。
         * @param qz 输出矩阵数组的偏移。
         * @param qw 输出矩阵数组的偏移。
         * @param sx 输出矩阵数组的偏移。
         * @param sy 输出矩阵数组的偏移。
         * @param sz 输出矩阵数组的偏移。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        private static _rotationTransformScaleSkinAnimation;
        /**
         * @en Convert vertices to a billboard
         * @zh 将顶点进行广告牌转换
         */
        static billboardTrans(v0: Vector3, cameraDir: Vector3, cameraUp: Vector3, out: Vector3): void;
        /**
         * @en Determines if point P is within the triangle formed by points A, B, and C. https://mathworld.wolfram.com/BarycentricCoordinates.html
         * @param A The first vertex of the triangle.
         * @param B The second vertex of the triangle.
         * @param C The third vertex of the triangle.
         * @param P The point to check.
         * @returns True if P is inside the triangle, false otherwise.
         * @zh 判断点P是否在由点A、B、C组成的三角形内。https://mathworld.wolfram.com/BarycentricCoordinates.html
         * @param A 三角形的第一个顶点。
         * @param B 三角形的第二个顶点。
         * @param C 三角形的第三个顶点。
         * @param P 需要判断的点。
         * @returns 若P在三角形内，返回true，否则返回false。
         */
        static PointinTriangle(A: Vector3, B: Vector3, C: Vector3, P: Vector3): boolean;
        /** @internal */
        static _computeBoneAndAnimationDatasByBindPoseMatrxix(bones: any, curData: Float32Array, inverGlobalBindPose: Matrix4x4[], outBonesDatas: Float32Array, outAnimationDatas: Float32Array, boneIndexToMesh: number[]): void;
        /** @internal */
        static _computeAnimationDatasByArrayAndMatrixFast(inverGlobalBindPose: Matrix4x4[], bonesDatas: Float32Array, outAnimationDatas: Float32Array, boneIndexToMesh: number[]): void;
        /** @internal */
        static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones: any, curData: Float32Array, inverGlobalBindPose: Matrix4x4[], outBonesDatas: Float32Array, outAnimationDatas: Float32Array): void;
        /** @internal */
        static _computeAnimationDatasByArrayAndMatrixFastOld(inverGlobalBindPose: Matrix4x4[], bonesDatas: Float32Array, outAnimationDatas: Float32Array): void;
        /** @internal */
        static _computeRootAnimationData(bones: any, curData: Float32Array, animationDatas: Float32Array): void;
        /**
         * @en Rotates a 3D vector using a quaternion.
         * @param sourceArray The source vector components in a Float32Array.
         * @param sourceOffset The offset in the source array where the source vector starts.
         * @param rotation The quaternion representing the rotation.
         * @param outArray The array to store the result of the rotation.
         * @param outOffset The offset in the output array where the result will be stored.
         * @zh 使用四元数旋转三维向量。
         * @param sourceArray 源三维向量的数组。
         * @param sourceOffset 源三维向量的偏移。
         * @param rotation 四元数。
         * @param outArray 输出数组。
         * @param outOffset 输出数组的偏移。
         */
        static transformVector3ArrayByQuat(sourceArray: Float32Array, sourceOffset: number, rotation: Quaternion, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies two matrices using array data.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightArray The right-hand side matrix array.
         * @param rightOffset The offset in the right-hand side array.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据计算矩阵乘法。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightArray 右矩阵数组。
         * @param rightOffset 右矩阵数组的偏移。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArray(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies two matrices using array data, with the restriction that rightArray and outArray cannot be the same array reference.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightArray The right-hand side matrix array.
         * @param rightOffset The offset in the right-hand side array.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据计算矩阵乘法，注意 rightArray 和 outArray 不能是同一个数组引用。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightArray 右矩阵数组。
         * @param rightOffset 右矩阵数组的偏移。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArrayFast(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Multiplies a matrix by an array and another matrix, with the restriction that rightArray and outArray cannot be the same array reference.
         * @param leftArray The left-hand side matrix array.
         * @param leftOffset The offset in the left-hand side array.
         * @param rightMatrix The right-hand side matrix.
         * @param outArray The output matrix array where the result will be stored.
         * @param outOffset The offset in the output array.
         * @zh 通过数组数据和一个矩阵计算矩阵乘法，注意 rightArray 和 outArray 不能是同一个数组引用。
         * @param leftArray 左矩阵数组。
         * @param leftOffset 左矩阵数组的偏移。
         * @param rightMatrix 右矩阵。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArrayAndMatrixFast(leftArray: Float32Array, leftOffset: number, rightMatrix: Matrix4x4, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Calculates the result matrix array by the given translation, rotation, and scale values.
         * @param tX X axis translation.
         * @param tY Y axis translation.
         * @param tZ Z axis translation.
         * @param rX X axis rotation.
         * @param rY Y axis rotation.
         * @param rZ Z axis rotation.
         * @param rW W component of the rotation quaternion.
         * @param sX X axis scale.
         * @param sY Y axis scale.
         * @param sZ Z axis scale.
         * @param outArray Output matrix array.
         * @param outOffset Output matrix array offset.
         * @zh 通过数平移、旋转、缩放值计算到结果矩阵数组。
         * @param tX X轴的平移量。
         * @param tY Y轴的平移量。
         * @param tZ Z轴的平移量。
         * @param rX 旋转四元数的X分量。
         * @param rY 旋转四元数的Y分量。
         * @param rZ 旋转四元数的Z分量。
         * @param rW 旋转四元数的实部（W分量）。
         * @param sX X轴的缩放因子。
         * @param sY Y轴的缩放因子。
         * @param sZ Z轴的缩放因子。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static createAffineTransformationArray(tX: number, tY: number, tZ: number, rX: number, rY: number, rZ: number, rW: number, sX: number, sY: number, sZ: number, outArray: Float32Array, outOffset: number): void;
        /**
         * @en Transforms a 3D vector from one array to another using a transformation matrix.
         * @param source The source vector array.
         * @param sourceOffset The offset in the source array.
         * @param transform The transformation matrix.
         * @param result The resulting vector array.
         * @param resultOffset The offset in the resulting array.
         * @zh 使用变换矩阵将一个三维向量从一个数组转换到另一个数组。
         * @param source 源三维向量所在数组。
         * @param sourceOffset 源三维向量数组偏移。
         * @param transform  变换矩阵。
         * @param result 输出三维向量所在数组。
         * @param resultOffset 输出三维向量数组偏移。
         */
        static transformVector3ArrayToVector3ArrayCoordinate(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * @en Transforms a 3D vector array from one array to another using a transformation matrix, and normalizes the resulting vector array.
         * @param source The source normal vector array.
         * @param sourceOffset The offset in the source array.
         * @param transform The transformation matrix.
         * @param result The resulting normal vector array.
         * @param resultOffset The offset in the resulting array.
         * @zh 通过矩阵转换一个三维向量数组到另外一个归一化的三维向量数组。
         * @param source 源三维向量法线所在数组。
         * @param sourceOffset 源三维向量法线数组偏移。
         * @param transform 变换矩阵。
         * @param result 输出三维向量法线所在数组。
         * @param resultOffset 输出三维向量法线数组偏移。
         */
        static transformVector3ArrayToVector3ArrayNormal(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * @internal
         */
        static transformLightingMapTexcoordArray(source: Float32Array, sourceOffset: number, lightingMapScaleOffset: Vector4, result: Float32Array, resultOffset: number): void;
        /**
         * @en Retrieves the version string from a URL.
         * @param url The URL to extract the version from.
         * @returns The version string or null if not found.
         * @zh 从URL中获取版本字符串。
         * @param url 要提取版本的URL。
         * @returns 版本字符串或null。
         */
        static getURLVerion(url: string): string;
        /**
         * @internal
         */
        static _createAffineTransformationArray(trans: Vector3, rot: Quaternion, scale: Vector3, outE: Float32Array): void;
        /**
         * @internal
         */
        static _mulMatrixArray(left: Float32Array, right: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**@internal */
        private static arcTanAngle;
        /**@internal */
        static angleTo(from: Vector3, location: Vector3, angle: Vector3): void;
        /**
         * @en Applies a rotation to a 3D vector using a quaternion.
         * @param source The original 3D vector.
         * @param rotation The quaternion array representing the rotation.
         * @param out The resulting rotated vector.
         * @zh 使用四元数对三维向量应用旋转。
         * @param source 原始三维向量。
         * @param rotation 旋转四元数数组。
         * @param out 结果旋转后的向量。
         */
        static transformQuat(source: Vector3, rotation: Float32Array, out: Vector3): void;
        /**
         * @en Modifies the weight of a quaternion.
         * @param f The original quaternion.
         * @param weight The weight to apply to the quaternion.
         * @param e The target data.
         * @zh 修改四元数的权重。
         * @param f 元数据
         * @param weight 要应用于四元数的权重。
         * @param e 目标数据。
         */
        static quaternionWeight(f: Quaternion, weight: number, e: Quaternion): void;
        /**
         * @internal
         */
        static quaternionConjugate(value: Quaternion, result: Quaternion): void;
        /**
         * @internal
         */
        static scaleWeight(s: Vector3, w: number, out: Vector3): void;
        /**
         * @internal
         */
        static scaleBlend(sa: Vector3, sb: Vector3, w: number, out: Vector3): void;
        /**@internal */
        static matrix4x4MultiplyFFF(a: Float32Array, b: Float32Array, e: Float32Array): void;
        /**@internal */
        static matrix4x4MultiplyMFM(left: Matrix4x4, right: Float32Array, out: Matrix4x4): void;
        /**
         * @internal
         */
        static _buildTexture2D(width: number, height: number, format: number, colorFunc: Function, mipmaps?: boolean): Texture2D;
        /**
         * @internal
         */
        static _drawBound(debugLine: PixelLineSprite3D, boundBox: BoundBox | Bounds, color: Color): void;
        /**
         * @internal
         * @param rootSprite parent Sprite
         * @param checkSprite check Sprite
         * @param path pathArray
         * @returns
         */
        static _getHierarchyPath(rootSprite: Node, checkSprite: Node, path: number[]): any[];
        /**
         * @internal
         * @param rootSprite parentNode
         * @param invPath PathArray
         * @returns
         */
        static _getNodeByHierarchyPath(rootSprite: Node, invPath: number[]): Node;
        static _getParentNodeByHierarchyPath(rootSprite: Node, path: number[]): Node;
        /**
         * @deprecated 请使用uint8ArrayToArrayBufferAsync函数代替
         * 将RenderTexture转换为Base64
         * @param rendertexture 渲染Buffer
         * @returns
         */
        static uint8ArrayToArrayBuffer(rendertexture: RenderTexture): string;
        /**
         * @en Converts a RenderTexture to a Base64 encoded string.
         * @param rendertexture The RenderTexture to convert.
         * @returns A promise that resolves to a Base64 string representing the RenderTexture.
         * @zh 将 RenderTexture 转换为 Base64 编码的字符串。
         * @param rendertexture 要转换的 RenderTexture。
         * @returns 一个 Promise，该 Promise 将解析为表示 RenderTexture 的 Base64 字符串。
         */
        static uint8ArrayToArrayBufferAsync(rendertexture: RenderTexture): Promise<String>;
    }
    /**
     * @ignore 功能还没有实现完，开发者请勿使用。
     * @internal
     * 类用于创建WebXR摄像机。
     */
    class WebXRCamera extends Camera {
        /**
         * @internal
         */
        isWebXR: boolean;
        /**
         * WebXRSessionManager
         */
        private _webXRManager;
        /**
         * override client
         */
        private _clientWidth;
        /**
         * override client
         */
        private _clientHeight;
        /**
         * 自定义渲染场景的渲染目标。
         */
        get renderTarget(): RenderTexture;
        /**
         * @internal
         */
        set renderTarget(value: RenderTexture);
        /**
         * @internal
         */
        set clientWidth(value: number);
        /**
         * @internal
         */
        set clientHeight(value: number);
        /**
         * @internal
         */
        get clientWidth(): number;
        /**
         * @internal
         */
        get clientHeight(): number;
        /**
         * restore view state
         * @internal
         */
        private _restoreView;
        /**
         * 渲染
         * @override
         * @param shader
         * @param replacementTag
         */
        render(): void;
        /**
     * 渲染主流程
     * @internal
     * @param context 渲染上下文
     * @param viewport 视口
     * @param scene 场景
     * @param shader shader
     * @param replacementTag 替换标签
     * @param needInternalRT 是否需要内部RT
     */
        _renderMainPass(context: RenderContext3D, viewport: Viewport, scene: Scene3D, shader: Shader3D, replacementTag: string, needInternalRT: boolean): void;
        /**
         * null function
         */
        protected _calculateProjectionMatrix(): void;
        /**
         * @internal
         */
        clear(gl: WebGLRenderingContext): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * @en This class is used to manage XRCamera
     * @zh 此类用来管理XRCamera
     */
    class WebXRCameraManager {
        /**
         * reference Quaternin
         */
        private _referenceQuaternion;
        /**
         * reference Position
         */
        private _referencedPosition;
        /**
         * WebXR Session Manager
         */
        private _webXRSessionManager;
        /**
         * first Frame Flag
         */
        private _firstFrame;
        /**
         * WebXR RenderTexture
         */
        private _XRRenderTexture;
        /**
         * WebXRCamera Array
         */
        private _rigCameras;
        /**
         * Reference position
         */
        private _position;
        /**
         * @en The parent object that owns this camera manager.
         * @zh 拥有此摄像机管理器的父对象。
         */
        owner: any;
        /**
         * @en The position of the camera.
         * @zh 摄像机的位置。
         */
        get position(): Vector3;
        set position(newPosition: Vector3);
        /**
         * @en The rotation of the camera.
         * @zh 摄像机的旋转
         */
        get rotationQuaternion(): Quaternion;
        set rotationQuaternion(value: Quaternion);
        /**
         * @en The array of rig cameras.
         * @zh 绑定在此摄像机管理器上的摄像机数组。
         */
        get rigCameras(): WebXRCamera[];
        /**
         * @en Creates a new instance of the WebXRCameraManager class.
         * @param camera The parent object that owns this camera manager.
         * @param manager WebXR Session Manager.
         * @zh 创建 WebXRCameraManager 类的新实例。
         * @param camera 父对象，拥有此摄像机管理器。
         * @param manager WebXR管理器。
         */
        constructor(camera: any, manager?: WebXRSessionManager);
        /**
         * @en Updates the frame by the WebXR session, adjusting the camera's position, rotation, and viewport based on the XR session's viewer pose.
         * @zh 通过WebXR会话更新帧，根据XR会话的观察者姿势调整相机的位置、旋转和视口。
         */
        _updateFromXRSession(): void;
        /**
         * update number of WebXRCamera
         * @param viewCount
         */
        private _updateNumberOfRigCameras;
        /**
         * TODO:update of Reference Space
         */
        private _updateReferenceSpace;
        /**
         * @en Destroys and cleans up resources used by the WebXRCameraManager.
         * @zh 销毁 WebXRCameraManager 并清理使用的资源。
         */
        destroy(): void;
    }
    class WebXRCameraInfo {
        /**depth far */
        depthFar: number;
        /**depth near */
        depthNear: number;
        /**camera */
        camera: any;
    }
    /**
     * @en Used to manage WebXR
     * @zh 用来管理WebXR
     */
    class WebXRExperienceHelper {
        /**
         * @en The WebGL instance.
         * @zh WebGL 实例。
         */
        static glInstance: any;
        /**
         * @en The singleton instance of the XR session manager.
         * @zh XR 会话管理器的单例实例。
         */
        static xr_Manager: WebXRSessionManager;
        /**
         * @en Indicates whether WebXR is supported in the current environment.
         * @zh 表示当前环境是否支持 WebXR。
         */
        static supported: boolean;
        /**
         * @en Default options for the XRWebGLLayer.
         * @zh XRWebGLLayer 的默认选项。
         */
        static canvasOptions: {
            antialias: boolean;
            depth: boolean;
            stencil: boolean;
            alpha: boolean;
            multiview: boolean;
            framebufferScaleFactor: number;
        };
        /**
         * @en Checks if a specific XRSession mode is supported.
         * @param sessionMode The session mode to check, e.g., "inline", "immersive-vr", "immersive-ar".
         * @returns A promise that resolves to a boolean indicating whether the mode is supported.
         * @zh 检查是否支持特定的 XRSession 模式。
         * @param sessionMode 要检查的会话模式，例如："inline"、"immersive-vr"、"immersive-ar"。
         * @returns 一个 Promise，该 Promise 将解析为一个布尔值，表示是否支持。
         */
        static supportXR(sessionMode: string): Promise<boolean>;
        /**
         * @en Enters the specified XR session mode and sets up the reference space and WebGL layer.
         * @param sessionMode The session mode, e.g., "inline", "immersive-vr", "immersive-ar".
         * @param referenceSpaceType The reference space type, e.g., "viewer", "local", "local-floor", "unbounded".
         * @param cameraInfo The WebXR camera settings.
         * @returns A promise that resolves to the WebXRSessionManager.
         * @zh 进入指定的 XR 会话模式，并设置引用空间和 WebGL 层。
         * @param sessionMode 要进入的会话模式，例如："inline"、"immersive-vr"、"immersive-ar"。
         * @param referenceSpaceType 要使用的参考空间类型，例如："viewer"、"local"、"local-floor"、"unbounded"。
         * @param cameraInfo WebXR相机设置。
         * @returns 一个 Promise，该 Promise 将解析为 WebXRSessionManager。
         */
        static enterXRAsync(sessionMode: string, referenceSpaceType: string, cameraInfo: WebXRCameraInfo): Promise<WebXRSessionManager>;
        /**
         * @en Configures a WebXRCameraManager with the given camera and session manager.
         * @param camera The camera to configure.
         * @param manager The WebXR session manager.
         * @returns A new WebXRCameraManager instance.
         * @zh 使用给定的摄像机和会话管理器配置 WebXRCameraManager。
         * @param camera 要配置的摄像机。
         * @param manager WebXR 会话管理器。
         * @returns 一个新的 WebXRCameraManager 实例。
         */
        static setWebXRCamera(camera: Camera, manager: WebXRSessionManager): WebXRCameraManager;
        /**
         * @en Configures a WebXRInputManager with the given session and camera managers.
         * @param sessionManager The WebXR session manager.
         * @param cameraManager The WebXR camera manager.
         * @returns A new WebXRInputManager instance.
         * @zh 使用给定的会话和摄像机管理器配置 WebXRInputManager。
         * @param sessionManager WebXR 会话管理器。
         * @param cameraManager WebXR 摄像机管理器。
         * @returns 一个新的 WebXRInputManager 实例。
         */
        static setWebXRInput(sessionManager: WebXRSessionManager, cameraManager: WebXRCameraManager): WebXRInputManager;
    }
    /**
     * @en The class used to describe the gamepad axis
     * @zh 用于描述设备手柄上的摇杆轴
     */
    class AxiGamepad extends EventDispatcher {
        /**
         * @en Static event name for output axis events.
         * @zh 事件名称，用于输出轴事件。
         */
        static EVENT_OUTPUT: string;
        /**
         * @en The name of the axis device.
         * @zh 轴设备名字。
         */
        handness: string;
        /**
         * @en The number of axes.
         * @zh 轴数量。
         */
        axisLength: number;
        /**
         * axis Array
         */
        private axisData;
        /**
         * 类用于创建轴数据
         * @internal
         * @param handness 轴设备名字
         * @param length 轴数量
         */
        constructor(handness: string, length: number);
        /**
         * @internal
         * @param padGameAxi 轴数据
         */
        update(padGameAxi: any): void;
        /**
         * 派发轴事件
         * @internal
         * @param value
         * @param index
         */
        outPutStickValue(value: Vector2, index: number): void;
        /**
         * @en Cleans up and removes all listeners for this gamepad's axis events.
         * @zh 清理并移除此游戏手柄轴的所有事件监听器。
         */
        destroy(): void;
    }
    /**
     * @en The `ButtonGamepad` class is used to describe gamepad buttons.
     * @zh `ButtonGamepad` 类用来描述游戏手柄上的按钮。
     */
    class ButtonGamepad extends EventDispatcher {
        static EVENT_TOUCH_ENTER: string;
        static EVENT_TOUCH_STAY: string;
        static EVENT_TOUCH_OUT: string;
        static EVENT_PRESS_ENTER: string;
        static EVENT_PRESS_STAY: string;
        static EVENT_PRESS_OUT: string;
        static EVENT_PRESS_VALUE: string;
        /**
         * @en The handness of the gamepad.
         * @zh 游戏手柄的名称。
         */
        handness: string;
        /**
         * @en The index of the button on the gamepad.
         * @zh 游戏手柄上按钮的索引。
         */
        index: number;
        /**
         * front touch state
         */
        private lastTouch;
        private lastPress;
        private lastPressValue;
        /**
         * current touch state
         */
        private touch;
        private press;
        private pressValue;
        /**
         * @en Creates a new instance of the `ButtonGamepad` class.
         * @param handness The name of the gamepad.
         * @param index The index of the button on the gamepad.
         * @zh 创建 ButtonGamepad 类的新实例。
         * @param handness 设备名称
         * @param index button索引
         */
        constructor(handness: string, index: number);
        /**
         * @internal
         * GamePadButton update
         */
        update(padButton: any): void;
        /**
         * @internal
         * event touch enter
         */
        private touchEnter;
        /**
         * @internal
         * event touch Stay
         */
        private touchStay;
        /**
         * @internal
         * event touch Out
         */
        private touchOut;
        /**
         * @internal
         * event press enter
         */
        private pressEnter;
        /**
         * @internal
         * event press Stay
         */
        private pressStay;
        /**
         * @internal
         * event press Out
         */
        private pressOut;
        /**
         * @internal
         * event press value
         */
        private outpressed;
        /**
         * @en Cleans up and removes all listeners for this gamepad's button events.
         * @zh 清理并移除此游戏手柄按钮的所有事件监听器。
         */
        destroy(): void;
    }
    /**
     * @en The `WebXRInput` class is used to describe input devices for WebXR.
     * @zh `WebXRInput` 类用来描述 WebXR 的输入设备。
     */
    class WebXRInput extends EventDispatcher {
        static HANDNESS_LEFT: string;
        static HANDNESS_RIGHT: string;
        static EVENT_FRAMEUPDATA_WEBXRINPUT: string;
        private static tempQua;
        /**
         * 预处理Button事件
         */
        private preButtonEventList;
        /**
         * 预处理axis事件
         */
        private preAxisEventList;
        /**
         * @internal
         */
        _inputSource: any;
        /**
         * @en The last XR pose data.
         * @zh 上一次的 XR 姿态数据。
         */
        lastXRPose: any;
        /**
         * @en The handness of the device, "left" or "right".
         * @zh 设备名称，"left" 或 "right"。
         */
        handness: string;
        /**
         * @en The input ray representing the direction of the hand or controller.
         * @zh 表示手或控制器方向的输入射线。
         */
        ray: Ray;
        /**
         * @en The position of the hand or controller.
         * @zh 手或控制器的位置。
         */
        position: Vector3;
        /**
         * @en The rotation of the hand or controller.
         * @zh 手或控制器的旋转。
         */
        rotation: Quaternion;
        /**
         * @en The last position of the input ray.
         * @zh 输入射线的上一个位置。
         */
        _lastXRPose: any;
        /**
         * @en Information about the gamepad buttons.
         * @zh 游戏手柄按钮的信息。
         */
        gamepadButton: Array<ButtonGamepad>;
        /**
         * @en Information about the gamepad axes.
         * @zh 游戏手柄轴的信息。
         */
        gamepadAxis: AxiGamepad;
        /**
         * @ignore
         * @en Creates a new instance of the `WebXRInput` class.
         * @param handness  The handness of the device, "left" or "right".
         * @zh 创建 `WebXRInput` 类的新实例。
         * @param handness 设备名称，"left" 或 "right"。
         */
        constructor(handness: string);
        /**
         * 更新XRInput数据
         * @internal
         * @param xrFrame WebXR帧数据
         * @param referenceSpace 参考空间
         */
        _updateByXRPose(xrFrame: any, referenceSpace: any): void;
        /**
         * handle gamepad Event
         */
        private _handleProcessGamepad;
        /**
         * @en Adds an event listener for a gamepad button.
         * @param index The index of the button.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 为游戏手柄按钮添加事件侦听器
         * @param index 按钮索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Adds an event listener for a gamepad axis.
         * @param index The index of the axis.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 为游戏手柄轴添加事件侦听器。
         * @param index 轴索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Removes an event listener for a gamepad axis.
         * @param index The index of the axis.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 移除游戏手柄轴的事件侦听器。
         * @param index 轴索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Removes an event listener for a gamepad button.
         * @param index The index of the button.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The event listener function.
         * @zh 移除游戏手柄按钮的事件侦听器
         * @param index 按钮索引。
         * @param type 事件类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * @en Destroys and cleans up the WebXR input instance.
         * @zh 销毁并清理 WebXR 输入实例。
         */
        destroy(): void;
    }
    /**
     * @en The `WebXRInputManager` class is responsible for managing input devices in a WebXR environment.
     * - The path of the CDN from which the sample will fetch controller models:
     * - MeshSource https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.9/dist/profiles/
     * @zh `WebXRInputManager` 类用来在 WebXR 环境中管理输入设备。
     * - 样本将从此 CDN 路径获取控制器模型的路径：
     * - MeshSource <https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.9/dist/profiles/>
     */
    class WebXRInputManager {
        /**
         * Session Manager
         */
        private webXRSessionManager;
        /**
         * webXRCamera Manager
         */
        private webXRCameraManager;
        /**
         * array of XRInput
         */
        private controllers;
        /**
         * bind of XRInput Node Render
         */
        private controllerHandMesh;
        /**
         * bind of XRInput Ray Render
         */
        private controllerLineRender;
        /**
         * line Color
         */
        private lineColor;
        /**
         * Ray length
         */
        private rayLength;
        /**
         * @en Creates a new instance of the `WebXRInputManager` class.
         * @param webxrManager WebXR Session manager
         * @param webXRCamera WebXR Manager
         * @zh 创建 WebXRInputManager 类的新实例
         * @param webxrManager WebXR 会话管理器
         * @param webXRCamera WebXR 管理器
         */
        constructor(webxrManager: WebXRSessionManager, webXRCamera: WebXRCameraManager);
        /**
         * 更新输入挂点
         * @param xrInput
         */
        private _updateMeshRender;
        /**
         * WebXRInput帧循环
         * @param xrFrame
         */
        private _updateFromXRFrame;
        /**
         * @en Binds a rendering node to the input device.
         * @param meshSprite The rendering sprite to bind.
         * @param handness The handness of the device, "left" or "right".
         * @zh 将渲染节点绑定到输入设备。
         * @param meshSprite 渲染挂点。
         * @param handness 设备名称，"left" 或 "right"。
         */
        bindMeshNode(meshSprite: Sprite3D, handness: string): void;
        /**
         * @en Binds a ray to the input device for visual representation.
         * @param lineSprite The line sprite to bind as a ray.
         * @param handness The handness of the device, "left" or "right".
         * @zh 为输入设备绑定射线以进行可视化表示。
         * @param lineSprite 作为射线绑定的线条精灵。
         * @param handness 设备名称，"left" 或 "right"。
         */
        bindRayNode(lineSprite: PixelLineSprite3D, handness: string): void;
        /**
         * @en Retrieves the input device based on the specified handness.
         * @param handness The handness of the device, "left" or "right".
         * @returns The WebXRInput instance or null if handness is not valid.
         * @zh 根据指定的设备名称获得输入设备。
         * @param handness 设备名称，"left" 或 "right"。
         * @returns 返回 WebXRInput 实例，如果手部设备名称无效则返回 null。
         */
        getController(handness: string): WebXRInput;
        /**
         * @en Destroys and cleans up the WebXR input manager.
         * @zh 销毁并清理 WebXR 输入管理器。
         */
        destory(): void;
    }
    /**
     * @en The `WebXRRenderTexture` class is used to create a render texture for WebXR rendering.
     * @zh `WebXRRenderTexture` 类用来创建 WebXR 渲染的渲染纹理。
     */
    class WebXRRenderTexture extends RenderTexture {
        /** @internal */
        protected _frameBuffer: any;
        /**
         * @en The frame loop counter for the render texture.
         * @zh 渲染纹理的帧循环计数器。
         */
        frameLoop: number;
        /**
         * @en Creates a new instance of the `WebXRRenderTexture` class.
         * @zh 创建 WebXRRenderTexture 类的新实例
         */
        constructor();
        /**
         * @en The frame buffer for the render texture.
         * @zh 渲染纹理的帧缓冲。。
         */
        set frameBuffer(value: any);
        /**
         * No glframeBuffer create
         * @param width
         * @param height
         */
        protected _create(width: number, height: number): void;
    }
    /**
     * @en Manages an XRSession to work with the LayaAir engine.
     * @zh 管理 XRSession 用以与 LayaAir 引擎协同工作。
     */
    class WebXRSessionManager extends EventDispatcher {
        static EVENT_MANAGER_END: string;
        static EVENT_FRAME_LOOP: string;
        /**
         * @en The underlying XR session being managed.
         * @zh 被管理的底层 XR 会话。
         */
        session: any;
        /**
         * @en The XRReferenceSpace used for setting up the viewer's reference space.
         * @zh 用于设置观察者参考空间的 XRReferenceSpace。
         */
        viewerReferenceSpace: any;
        /**
         * @en The base reference space for the XR session.
         * @zh XR 会话的基参考空间。
         */
        baseReferenceSpace: any;
        /**
         * @en The current XR frame in the session.
         * @zh 会话中的当前 XR 帧。
         */
        currentFrame: any;
        /**
         * @en The WebXR timestamp updated every frame.
         * @zh 每帧更新的 WebXR 时间戳。
         */
        currentTimestamp: number;
        /**
         * @en The default height compensation used when initialization fails.
         * @zh 初始化失败后使用的高度补偿默认值。
         */
        defaultHeightCompensation: number;
        /**
         * XRReferenceSpace
         */
        private _referenceSpace;
        /** "inline" | "immersive-vr" | "immersive-ar"*/
        private _sessionMode;
        /** session enable state */
        private _sessionEnded;
        /**WebXR Base Layer */
        private _baseLayer;
        /**web XRSystem */
        private _xrNavigator;
        /**
         * @internal
         * 类用来管理WebXR状态
         */
        constructor();
        /**
         * @en The current reference space used in this session.
         * @zh 当前会话中使用参考空间。
         */
        get referenceSpace(): any;
        set referenceSpace(newReferenceSpace: any);
        /**
         * @en The mode for the managed XR session.
         * @zh 管理 XR 会话的模式。
         */
        get sessionMode(): any;
        /**
         * @en Stops the XR session and restores the render loop.
         * @zh 停止 XR 会话并恢复渲染循环。
         */
        exitXR(): void;
        /**
         * @en Initializes the XR layer for the session.
         * @param xrSession The XR session to initialize.
         * @param gl The WebGL rendering context.
         * @returns A promise that resolves to true if the XR layer is successfully initialized.
         * @zh 为会话初始化 XR 层。
         * @param xrSession 要初始化的 XR 会话。
         * @param gl WebGL 渲染上下文。
         * @returns 一个承诺，该承诺在 XR 层成功初始化时解决为 true。。
         */
        initializeXRGL(xrSession: any, gl: WebGLRenderingContext): Promise<boolean>;
        /**
         * @en Checks if the browser supports WebXR.
         * @returns A promise that resolves if WebXR is supported.
         * @zh 检查浏览器是否支持 WebXR。
         * @returns 如果支持 WebXR 则返回一个解决的承诺。
         */
        initializeAsync(): Promise<void>;
        /**
         * @en Checks if the session mode is supported by the browser.
         * @param sessionMode The session mode to check, "inline", "immersive-vr", or "immersive-ar".
         * @returns A promise that resolves to true if the session mode is supported, and false if not.
         * @zh 检查会话模式是否得到浏览器支持。
         * @param sessionMode 要检查的会话模式，可以是 "inline"、"immersive-vr" 或 "immersive-ar"。
         * @returns 如果会话模式得到支持则返回一个解决为 true 的承诺，如果不支持则为 false。
         */
        isSessionSupportedAsync(sessionMode: string): Promise<boolean>;
        /**
         * @en Initializes the XR session with the specified mode and initialization info.
         * @param xrSessionMode The mode for the XR session.
         * @param xrSessionInit The initialization info for the XR session.
         * @returns A promise that resolves with the XR session if successful.
         * @zh 使用指定的模式和初始化信息初始化 XR 会话。
         * @param xrSessionMode XR 会话的模式。
         * @param xrSessionInit XR 会话的初始化信息。
         * @returns 如果成功，返回一个解决为 XR 会话的承诺。
         */
        initializeSessionAsync(xrSessionMode?: string, xrSessionInit?: {}): Promise<any>;
        /**
         * @en Resets the reference space to the one used at the start of the session.
         * @zh 将参考空间重置为会话开始时使用的空间。
         */
        resetReferenceSpace(): void;
        /**
         * @en Starts the rendering loop for the XR session and binds it to the session's animation frame request.
         * @zh 启动 XR 会话的渲染循环，并将其绑定到会话的动画帧请求。
         */
        runXRRenderLoop(): void;
        /**
         * @en Ends the rendering loop for the XR session.
         * @zh 结束 XR 会话的渲染循环。
         */
        endXRRenderLoop(): void;
        /**
         * Update
         * @param xrFrame
         */
        private _updateByXrFrame;
        /**
         * @en Sets the reference space on the XR session.
         * @param referenceSpaceType The type of space to set, defaults to "local-floor".
         * @returns A promise that resolves once the reference space has been set.
         * @zh 在 XR 会话上设置参考空间。
         * @param referenceSpaceType 要设置的参考空间类型，默认为 "local-floor"。
         * @returns 一个promise，该promise在参考空间已被设置时解决。
         */
        setReferenceSpaceTypeAsync(referenceSpaceType?: string): Promise<any>;
        /**
         * @en Updates the render state of the WebXR session.
         * @param state The new render state to be applied.
         * @returns A promise that resolves once the render state has been updated.
         * @zh 更新 WebXR 会话的渲染状态。
         * @param state 要应用的新渲染状态。
         * @returns 一个promise，该promise在渲染状态已被更新时解决。
         */
        updateRenderStateAsync(state: any): any;
        /**
         * @en The current frame rate reported by the device.
         * @zh 设备报告的当前帧率。
         */
        get currentFrameRate(): number | undefined;
        /**
         * @en A list of supported frame rates, available only while in a session.
         * @zh 支持的帧率列表，此属性仅在会话中可用。
         */
        get supportedFrameRates(): Float32Array | undefined;
        /**
         * @en Sets the frame rate for the WebXR session.
         * @param rate The new frame rate to be set, must be within the supportedFrameRates range.
         * @returns A promise that resolves once the frame rate has been set.
         * @zh 为 WebXR 会话设置帧率。
         * @param rate 要设置的新帧率，必须在支持的帧率范围内。
         * @returns 一个承诺，该承诺在帧率已被设置时解决。
         */
        updateTargetFrameRate(rate: number): Promise<void>;
        /**
         * @en Cleans up and destroys the WebXR session manager.
         * @zh 清理并销毁 WebXR 会话管理器。
         */
        destroy(): void;
    }
    /**
     * @en A class that encapsulates Geolocation-related functionalities can check if the browser supports the Geolocation API by using `Geolocation.supported`.
     * @zh 封装了地理位置相关功能的类，可以通过`Geolocation.supported`查看浏览器是否支持地理位置API。
     * @blueprintable
     */
    class Geolocation {
        /**
         * @en Indicates failure to get geographical information due to denied permission.
         * @zh 表示由于权限被拒绝造成的地理信息获取失败。
         */
        static readonly PERMISSION_DENIED: number;
        /**
         * @en Indicates failure to get geographical information due to an internal error from the location source.
         * @zh 表示由于内部位置源返回了内部错误导致地理信息获取失败。
         */
        static readonly POSITION_UNAVAILABLE: number;
        /**
         * @en Whether the runtime environment supports the Geolocation API.
         * @zh 信息获取所用时长超出`timeout`所设置时长。
         */
        static readonly TIMEOUT: number;
        /**
         * @en If `enableHighAccuracy` set to true, and if the device can provide a more accurate location, it will get the best possible results.
         * Note that this may lead to slower response times or increased power consumption (such as when using GPS).
         * On the other hand, if set to false, it will get faster response and less power consumption.
         * The default value is false.
         * @zh 如果`enableHighAccuracy`设置为 true，并且设备能够提供一个更精确的位置，则会获取最佳可能的结果。
         * 请注意，这可能会导致响应时间变慢或电量消耗增加（例如使用 GPS）。
         * 另一方面，如果设置为 false，将会得到更快的响应和更少的电量消耗。
         * 默认值为 false。
         */
        static enableHighAccuracy: boolean;
        /**
         * @en Represents the maximum duration allowed for the device to obtain the location. The default is Infinity, meaning getCurentPosition() will not return until the location is available.
         * @zh 表示允许设备获取位置的最长时间。默认为 Infinity，意味着 `getCurentPosition()` 直到位置可用时才会返回信息。
         */
        static timeout: number;
        /**
         * @en Represents the maximum age of the cached location information that can be returned.
         * If set to 0, it means the device does not use cached locations and attempts to obtain a real-time location.
         * If set to Infinity, the device must return a cached location regardless of its age.
         * @zh 表示可被返回的缓存位置信息的最大时限。
         * 如果设置为 0，意味着设备不使用缓存位置，并且尝试获取实时位置。
         * 如果设置为 Infinity，设备必须返回缓存位置而无论其时限。
         */
        static maximumAge: number;
        /**
         * @en Gets the device's current position.
         * @param onSuccess Callback handler with a unique `Position` parameter.
         * @param onError Optional. Callback handler with an error message. Error code is one of Geolocation.PERMISSION_DENIED, Geolocation.POSITION_UNAVAILABLE, and Geolocation.TIMEOUT.
         * @zh 获取设备当前位置。
         * @param onSuccess 带有唯一 `Position` 参数的回调处理器。
         * @param onError 可选的。带有错误信息的回调处理器。错误代码为 Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE 和 Geolocation.TIMEOUT 之一。
         */
        static getCurrentPosition(onSuccess: (info: GeolocationInfo) => void, onError?: (err: {
            code: number;
            message: string;
        }) => void): void;
        /** @deprecated */
        static getCurrentPosition(onSuccess: Handler, onError?: Handler): void;
        /**
         * @en Watches the device's current position. The callback handler is executed when the device's position changes.
         * @param onSuccess Callback handler with a unique `Position` parameter.
         * @param onError Optional. Callback handler with an error message. Error code is one of Geolocation.PERMISSION_DENIED, Geolocation.POSITION_UNAVAILABLE, and Geolocation.TIMEOUT.
         * @zh 监视设备当前位置。回调处理器在设备位置改变时被执行。
         * @param onSuccess 带有唯一 `Position` 参数的回调处理器。
         * @param onError 可选的。带有错误信息的回调处理器。错误代码为 Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE 和 Geolocation.TIMEOUT 之一。
         */
        static watchPosition(onSuccess: (info: GeolocationInfo) => void, onError?: (err: {
            code: number;
            message: string;
        }) => void): number;
        /** @deprecated */
        static watchPosition(onSuccess: Handler, onError?: Handler): number;
        /**
         * @en Removes the specified handler installed by `watchPosition`.
         * @param id The ID of the watch position handler to clear.
         * @zh 移除 `watchPosition` 安装的指定处理器。
         * @param id 要清除的监视位置处理器的 ID。
         */
        static clearWatch(id: number): void;
    }
    /**
     * @en Represents geolocation information for a device.
     * @zh 表示设备的地理位置信息。
     * @blueprintable
     */
    interface GeolocationInfo {
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationPosition/timestamp) */
        timestamp: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/time) */
        accuracy?: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/altitude) */
        altitude?: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/altitudeAccuracy) */
        altitudeAccuracy?: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/heading) */
        heading?: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/latitude) */
        latitude: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/longitude) */
        longitude: number;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates/speed) */
        speed?: number;
    }
    /**
     * @en The Media class is used for capturing camera and microphone input. You can capture either one or both simultaneously. Before calling getCamera, you can use supported() to check if the current browser supports it.
     * NOTE:
     * Currently, Media only supports Android on mobile platforms, not iOS. It can only be fully used in FireFox; testing in Chrome does not capture video.
     * @zh Media 类用于捕捉摄像头和麦克风。可以单独捕捉任一设备，或者同时捕捉两者。在使用之前，可以使用 `Media.supported()` 方法检查当前浏览器是否支持。
     * NOTE:
     * 目前 Media 仅在移动平台上支持 Android，不支持 iOS。只能在 FireFox 中完整使用，在 Chrome 中测试时无法捕捉视频。
     */
    class Media {
        /**
         * @en Check browser compatibility
         * @zh 检查浏览器兼容性。
         */
        static supported(): boolean;
        /**
         * @en Access the user's media devices (capture camera and microphone).
         * @param constraints A simple set of options like { audio: true, video: true } to indicate capturing both. For more details, see <i>https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</i>.
         * @param onSuccess The success handler which is called with a single argument: the Blob URL of the media, which can be used with the Video element.
         * @param onError The error handler which is called with a single argument: the Error object.
         * @zh 获取用户的媒体设备（捕捉摄像头和麦克风）。
         * @param constraints 简单的可选项，如 { audio: true, video: true } 表示同时捕捉两者。更详细信息请查看 <i>https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</i>。
         * @param onSuccess 获取成功的处理器，唯一参数返回媒体的 Blob 地址，可以将其传给 Video 。
         * @param onError 获取失败的处理器，唯一参数是 Error 对象。
         */
        static getMedia(constraints: MediaStreamConstraints, onSuccess: Handler | ((stream: MediaStream) => void), onError?: Handler | ((err: Error) => void)): void;
    }
    /**
     * @en Acceleration info, The unit of acceleration x/y/z is m/s ².
     * If the hardware (gyroscope) does not support it, the values for alpha, beta, and gamma will be null.
     * @zh 加速计信息，重力加速度x/y/z的单位均为m/s²。
     * 如果硬件（陀螺仪）不支持，则 alpha、beta 和 gamma 的值将为 null。
     */
    interface AccelerationInfo {
        /**
         * @en The acceleration value along the x-axis.
         * @zh x 轴上的加速度值。
         */
        x: number;
        /**
         * @en The acceleration value along the y-axis.
         * @zh y 轴上的加速度值。
         */
        y: number;
        /**
         * @en The acceleration value along the z-axis.
         * @zh z 轴上的加速度值。
         */
        z: number;
    }
    /**
     * @en Use Accelerator.instance to get the unique Accelerator reference. Do not call the constructor directly.
     * The callback handler of listen() accepts four parameters:
     * - acceleration: The acceleration given to the device without gravity.
     * - accelerationIncludingGravity: The total acceleration (including gravity).
     * - rotationRate: The rate of rotation.
     * - interval: The time interval for the acceleration data获取 (in milliseconds).
     * NOTE
     * For example, while the alpha in the rotationRate is documented as the z-axis rotation angle in both Apple and Mozilla documentation, actual testing shows it to be the x-axis rotation angle. To make the values represented by each property consistent with the documentation, the actual values have been swapped with other properties.
     * The mappings are as follows:
     * - alpha uses the gamma value.
     * - beta uses the alpha value.
     * - gamma uses the beta value.
     * It is currently unclear which is correct, and this serves as a note.
     * @zh 通过 Accelerator.instance 获取唯一的 Accelerator 引用，不要直接调用构造函数。
     * listen() 的回调处理器接受四个参数：
     * - acceleration: 设备的加速度（不包含重力）。
     * - accelerationIncludingGravity: 总加速度（包含重力）。
     * - rotationRate: 自转速率。
     * - interval: 获取加速度数据的时间间隔（毫秒）。
     * 注意：
     * 例如，rotationRate 中的 alpha 在 Apple 和 Mozilla 文档中都是 z 轴旋转角度，但实测是 x 轴旋转角度。为了使各属性表示的值与文档所述相同，实际值与其他属性进行了对调。
     * 具体对应如下：
     * - alpha 使用 gamma 值。
     * - beta 使用 alpha 值。
     * - gamma 使用 beta 值。
     * 目前孰是孰非尚未可知，以此为注。
     */
    class Accelerator extends EventDispatcher {
        /**
         * Accelerator的唯一引用。
         */
        private static _instance;
        /**
         * @en The singleton instance of Accelerator.
         * @zh Accelerator 的单例实例。
         */
        static get instance(): Accelerator;
        constructor();
        protected onStartListeningToType(type: string): this;
        private onDeviceMotionChange;
        private static transformedAcceleration;
        /**
         * @en Converts the acceleration values to visually correct acceleration values.
         * @param acceleration The original acceleration information.
         * @returns The transformed acceleration information.
         * @zh 将加速度值转换为视觉上正确的加速度值。
         * @param acceleration 原始的加速度信息。
         * @returns 转换后的加速度信息。
         */
        static getTransformedAcceleration(acceleration: AccelerationInfo): AccelerationInfo;
    }
    /**
     * @en Use Gyroscope.instance to obtain the unique Gyroscope reference. Do not call the constructor directly.
     * The callback handler of listen() accepts two parameters:
     * - onOrientationChange: A function with the signature <code>function onOrientationChange(absolute: Boolean, info: RotationInfo): void</code>.
     * - absolute: Indicates whether the device can provide absolute orientation data (toward the Earth coordinate system) or an arbitrary coordinate system determined by the device. For more information about coordinate systems, see [Orientation and motion data explained](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained).
     * - info: A RotationInfo type parameter that stores the device's rotation values.
     * For browser compatibility, refer to: (http://caniuse.com/#search=deviceorientation).
     * @zh 通过 Gyroscope.instance 获取唯一的 Gyroscope 引用，不要直接调用构造函数。
     * listen() 的回调处理器接受两个参数：
     * - function onOrientationChange: 一个函数，签名为 function onOrientationChange(absolute: Boolean, info: RotationInfo): void。
     * - absolute: 指明设备是否能够提供绝对方位数据（指向地球坐标系），或者由设备决定的任意坐标系。关于坐标系更多信息，请参阅 [方位和运动数据解释](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained)。
     * - info: RotationInfo 类型的参数，保存设备的旋转值。
     * 浏览器兼容性信息，请参阅：(http://caniuse.com/#search=deviceorientation)。
     */
    class Gyroscope extends EventDispatcher {
        /**
         * Gyroscope的唯一引用。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of Gyroscope.
         * @zh 获取 Gyroscope 的单例实例。
         */
        static get instance(): Gyroscope;
        protected onStartListeningToType(type: string): this;
        private onDeviceOrientation;
    }
    /**
     * @en A class that saves rotation information. Do not modify the properties of this category.
     * @zh 保存旋转信息的类。请勿修改本类的属性。
     * @author Survivor
     */
    interface RotationInfo {
        /**
         * @en Indicates whether the device can provide absolute orientation data (toward the Earth coordinate system) or an arbitrary coordinate system determined by the device.
         * For more information about coordinate systems, see (https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained).
         * Note that on iOS, this value is always false. Even so, you can still obtain the correct value from `alpha`.
         * @zh 指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。
         * 关于坐标系的更多信息，请参阅 (https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained)。
         * 需要注意的是，在 iOS 环境下，该值始终为 false。即使如此，你依旧可以从 `alpha` 中取得正确的值。
         */
        absolute: boolean;
        /**
         * @en The angle of rotation around the Z-axis, ranging from 0 to 360.
         * If `absolute` is true or on iOS, the `alpha` value represents the angle from north to the current direction of the device.
         * @zh Z轴旋转角度，其值范围从0至360。
         * 若 `absolute` 为 true 或在 iOS 中，`alpha` 值是从北方到当前设备方向的角度值。
         */
        alpha: number;
        /**
         * @en The angle of rotation around the X-axis, ranging from -180 to 180. Represents the front-to-back motion of the device.
         * @zh X轴旋转角度，其值范围从-180至180。代表设备从前至后的运动。
         */
        beta: number;
        /**
         * @en The angle of rotation around the Y-axis, ranging from -90 to 90. Represents the left-to-right motion of the device.
         * @zh Y轴旋转角度，其值范围从-90至90。代表设备从左至右的运动。
         */
        gamma: number;
        /**
         * @en The accuracy of the compass data in degrees. Available only on iOS.
         * @zh 罗盘数据的精确度（角度）。仅 iOS 可用。
         */
        compassAccuracy: number;
    }
    /**
     * @en Shake is usually achieved through the built-in accelerometer and gyroscope sensors in a mobile phone, and it only works on devices that support this operation.
     * @zh 摇动通常是通过手机内置的加速度计和陀螺仪传感器来实现，只能在支持此操作的设备环境上有效。
     * @blueprintable
     *
     */
    class Shake extends EventDispatcher {
        private threshold;
        private shakeInterval;
        private lastX;
        private lastY;
        private lastZ;
        private lastMillSecond;
        private static _instance;
        /**
         * @en The singleton instance of Shake.
         * @zh  Shake 的单例实例。
         */
        static get instance(): Shake;
        /**
         * @en Starts responding to device shaking.
         * The response is based on the threshold of instantaneous velocity and the interval between shakes.
         * @param threshold The threshold for the instantaneous velocity for a shake response, which is approximately between 5 to 10 for a mild shake.
         * @param interval The interval time for responding to device shakes.
         * @zh 开始响应设备摇晃。
         * @param threshold 响应瞬时速度的阈值，轻度摇晃的值约在 5 到 10 之间。
         * @param interval 设备摇晃的响应间隔时间。
         */
        start(threshold: number, interval: number): void;
        /**
         * @en Stops responding to device shaking.
         * @zh 停止响应设备摇晃。
         */
        stop(): void;
        private onShake;
        /**
         * @en Determines whether the device is shaken based on the acceleration differences in three directions.
         *       It checks if at least two of the acceleration differences exceed the set threshold.
         * @param deltaX The acceleration difference in the X direction.
         * @param deltaY The acceleration difference in the Y direction.
         * @param deltaZ The acceleration difference in the Z direction.
         * @returns Returns true if at least two of the acceleration differences exceed the threshold; otherwise, returns false.
         * @zh 根据三个方向的加速度差值判断设备是否发生摇晃。
         *       检查三个方向的加速度差值中是否至少有两个超过了设定的阈值。
         * @param deltaX X 方向的加速度差值。
         * @param deltaY Y 方向的加速度差值。
         * @param deltaZ Z 方向的加速度差值。
         * @returns 如果至少有两个方向的加速度差值超过阈值，则返回 true；否则返回 false。
         */
        private isShaked;
        /** @internal @blueprintEvent */
        Shake_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @ignore
     */
    class WebDeviceAdapter extends DeviceAdapter {
        protected _loc: Geolocation;
        protected _getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;
        protected _locInfo: GeolocationInfo;
        protected _accInfo: AccelerationInfo;
        protected _accInfo2: AccelerationInfo;
        protected _rotInfo: RotationInfo;
        protected _rotInfo2: RotationInfo;
        constructor();
        get supportedLocation(): boolean;
        get supportedGetUserMedia(): boolean;
        getCurrentPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): void;
        watchPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): number;
        clearWatchPosition(id: number): void;
        getUserMedia(constraints: MediaStreamConstraints, successCallback: (stream: MediaStream) => void, errorCallback?: (err: Error) => void): void;
        protected startListeningDeviceMotion(): void;
        protected startListeningDeviceOrientation(): void;
        protected onDeviceMotion(e: DeviceMotionEvent): void;
        protected onDeviceOrientation(e: DeviceOrientationEvent): void;
    }
    /**
     * @en The Animation class is used to play frame animation.
     * @zh Animation 是用于播放序列帧动画的类。
     */
    class Animation extends Sprite {
        private _comp;
        private _labels;
        /**
         * @deprecated
         * @en The animation template cache pool, stored as key-value pairs.
         * @zh 动画模版缓存池，以key-value键值对存储
         */
        static readonly framesMap: Record<string, string[]>;
        /**
         * @en Constructor method of Animation.
         * @zh 动画类的构造方法
         */
        constructor();
        /**
         * @en Whether to loop playback. Default is true.
         * @zh 是否循环播放。默认为 true。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en Playback order type.
         * @zh 播放顺序类型.
         */
        get wrapMode(): AnimationWrapMode;
        set wrapMode(value: AnimationWrapMode);
        /**
         * @en The interval between frame changes, in milliseconds.
         * @zh 帧改变之间的间隔时间，单位为毫秒。
         */
        get interval(): number;
        set interval(value: number);
        /**
         * @en The index of the current frame in the animation.
         * @zh 动画当前帧的索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The total number of frames in the current animation.
         * @zh 当前动画中帧的总数。
         */
        get count(): number;
        /**
         * @en Atlas path.
         * @zh 图集路径。
         */
        get source(): string;
        set source(value: string);
        /**
         * @en The image path array of the animation.
         * @zh 动画的图片路径数组。
         */
        get images(): string[];
        set images(value: string[]);
        /**
         * @en Whether the animation is currently playing.
         * @zh 是否正在播放中。
         */
        get isPlaying(): boolean;
        /**
         * @en Whether to auto-play, default is false. If set to true, the animation will automatically play after being created and added to the stage.
         * @zh 是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
         */
        set autoPlay(value: boolean);
        get autoPlay(): boolean;
        /**
        * @en Starts playing the animation. The play(...) method is designed to be called at any time after creating an instance.
        * When the corresponding resources are loaded, the animation frame filling method (set frames) is called, or the instance is displayed on the stage,
        * it will check if it's currently playing, and if so, it will start playing.
        * Combined with the wrapMode property, you can set the animation playback order type.
        * @param start (Optional) Specifies the starting index (int) or frame label (String) for animation playback. Frame labels can be added and removed using addLabel(...) and removeLabel(...).
        * @param loop (Optional) Whether to loop playback.
        * @param name (Optional) Animation name.
        * @zh 开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。
        * 配合wrapMode属性，可设置动画播放顺序类型。
        * @param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
        * @param loop （可选）是否循环播放。
        * @param name （可选）动画名称。
        */
        play(start?: string | number, loop?: boolean, name?: string): void;
        /**
         * @en Stops animation playback and clears object properties. It can then be stored in the object pool for easy object reuse.
         * @returns AnimationBase
         * @zh 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
         * @returns AnimationBase
         */
        clear(): this;
        /**
         * @en Stop the animation playback.
         * @zh 停止动画播放。
         */
        stop(): void;
        /**
         * @en Switch the animation to the specified frame and stop there.
         * @param position Frame index or frame label.
         * @zh 将动画切换到指定帧并停在那里。
         * @param position 帧索引或帧标签。
         */
        gotoAndStop(position: number | string): void;
        /**
         * @en Add a frame label to the specified frame index. When the animation plays to this frame, it will dispatch an Event.LABEL event after updating the current frame.
         * @param label The name of the frame label.
         * @param index The frame index.
         * @zh 增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
         * @param label 帧标签名称。
         * @param index 帧索引。
         */
        addLabel(label: string, index: number): void;
        /**
         * @en Remove the specified frame label.
         * @param label The name of the frame label. Note: If empty, all frame labels will be deleted!
         * @zh 删除指定的帧标签。
         * @param label 帧标签名称。注意：如果为空，则删除所有帧标签！
         */
        removeLabel(label: string): void;
        /**
         * @en Load a series of images.
         * @param urls Image path collection.
         * @returns Returns the Animation object itself.
         * @zh 载入一系列的图片。
         * @param urls 图片路径集合。
         * @returns 返回动画本身。
         */
        loadImages(urls: string[]): this;
        /**
         * @en Load the atlas.
         * @param url Atlas path.
         * @returns Returns the Animation object itself.
         * @zh 载入图集。
         * @param url 图集路径。
         * @return 返回动画本身。
         */
        loadAtlas(url: string): this;
        protected getFrameByLabel(label: string): number;
        /**
         * @deprecated
         * @en Creates animation frames and loads the associated resources.
         * @param urls An array of URLs representing the animation frames.
         * @param key The key used to store the animation frames in the frames map.
         * @zh 创建动画帧并加载相关资源。
         * @param urls 动画帧的 URL 数组。
         * @param key 用于存储动画帧的键值。
         */
        static createFrames(urls: string[], key: string): void;
        /**
         * @deprecated
         * @en Clears the animation data with the specified key value from the animation template cache pool.
         * When calling the function to create an animation template, developers can manually specify this value. For animation sets created by LayaAir IDE, the parsed key format is: "url#": represents the default animation template of the animation set, if this value is used as a parameter, it will clear the entire animation set data; "url#aniName": represents the animation template with the corresponding name.
         * @param key The key of the animation template in the animation template cache pool.
         * @zh 从动画模版缓存池中清除指定key值的动画数据。
         * 开发者在调用创建动画模版函数时，可以手动指定此值。而如果是由LayaAir IDE创建的动画集，解析后的key格式为："url#"：表示动画集的默认动画模版，如果以此值为参数，会清除整个动画集数据；"url#aniName"：表示相应名称的动画模版。
         * @param key 动画模板在动画模版缓存池中的key。
         */
        static clearCache(key: string): void;
        protected _setFramesFromCache(name: string, showWarn?: boolean): boolean;
        /** @internal @blueprintEvent */
        Animation_bpEvent: {
            [Event.COMPLETE]: () => void;
            [Event.LABEL]: (label: string) => void;
        };
    }
    class Area2D extends Sprite {
        private _mainCamera;
        _globalRenderData: I2DGlobalRenderData;
        _globalShaderData: ShaderData;
        constructor();
        get mainCamera(): Camera2D;
        _setMainCamera(camera: Camera2D): void;
        /**
         * @internal
         * @param ctx
         * @param x
         * @param y
         */
        render(): void;
        _setBelongScene(scene: Node): void;
        /**
          * @internal
          * @en Unset the node from its belong scene.
          * @zh 从所属场景中移除节点。
          */
        _setUnBelongScene(): void;
        localToView(x: number, y: number, out?: Point): Point;
        /**
         * @en Convert screen coordinates to Area2D internal UI coordinates.
         * @param x The x axis of screen coordinates.
         * @param y The y axis of screen coordinates.
         * @param out The output point. If not passed, a new point will be created.
         * @returns The output point.
         * @zh 将屏幕坐标转换为Area2D内部UI坐标
         * @param x 屏幕坐标的x轴.
         * @param y 屏幕坐标的y轴.
         * @param out 输出点，如果不传入，则会创建一个新的点。
         * @returns 输出点。
         */
        transformPoint(x: number, y: number, out?: Point): Point;
    }
    /**
     * @en BitmapFont is a bitmap font class used to define bitmap font information.
     * @zh BitmapFont 是位图字体类，用于定义位图字体信息。
     * @blueprintIgnore
     */
    class BitmapFont extends Resource {
        /**
         * @en Bitmap font texture
         * @zh 位图字体纹理
         */
        texture: Texture;
        /**
         * @en Bitmap font key-value mapping
         * @zh 位图字体键值对映射
         */
        dict: Record<string, BMGlyph>;
        /**
         * @en Font padding
         * @zh 字体边距
         */
        padding: any[];
        /**
         * @en Current bitmap font size. When used, if the font size is different from the setting and autoScaleSize=true, it will be scaled according to the set font size ratio.
         * @zh 当前位图字体字号，使用时，如果字号和设置不同，并且autoScaleSize=true，则按照设置字号比率进行缩放显示。
         */
        fontSize: number;
        /**
         * @en Indicates whether to scale the bitmap font size according to the actual font size used.
         * @zh 表示是否根据实际使用的字体大小缩放位图字体大小。
         */
        autoScaleSize: boolean;
        /**
         * @en Whether it is a font
         * @zh 是否是字体
         */
        tint: boolean;
        /**
         * @en Maximum width
         * @zh 最大宽度
         */
        maxWidth: number;
        /**
         * @en Line height
         * @zh 行高
         */
        lineHeight: number;
        /**
         * @en Letter spacing
         * @zh 字符间隔
         */
        letterSpacing: number;
        /**
         * @en Load the bitmap font file by specifying the file path. After loading, it will be automatically parsed.
         * @param path The path of the bitmap font file.
         * @param complete The callback function after loading and parsing are completed.
         * @zh 通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
         * @param path 位图字体文件的路径。
         * @param complete 加载并解析完成的回调。
         */
        static loadFont(path: string, complete: Handler): void;
        /**
         * @en BitmapFont constructor.
         * @zh 位图字体构造方法。
         */
        constructor();
        /**
         * @en Parse the font file.
         * @param xml The XML of the font file.
         * @param texture The texture of the font.
         * @zh 解析字体文件。
         * @param xml 字体文件XML。
         * @param texture 字体的纹理。
         */
        parseFont(xml: XML, texture: Texture): void;
        /**
         * @en Destroys the bitmap font. This is called by default when Text.unregisterBitmapFont is invoked.
         * @zh 销毁位图字体，调用 Text.unregisterBitmapFont 时，默认会销毁。
         */
        protected _disposeResource(): void;
        /**
         * @en Get the width of the specified text content.
         * @param text The text content.
         * @param fontSize The font size.
         * @return The width of the text content.
         * @zh 获取指定文本内容的宽度。
         * @param text 文本内容。
         * @param fontSize 字体大小。
         * @return 文本内容的宽度。
         */
        getTextWidth(text: string, fontSize?: number): number;
        /**
         * @en Get the maximum character width.
         * @param fontSize The font size.
         * @zh 获取最大字符宽度。
         * @param fontSize 字体大小。
         */
        getMaxWidth(fontSize?: number): number;
        /**
         * @en Get the maximum character height.
         * @param fontSize The font size.
         * @zh 获取最大字符高度。
         * @param fontSize 字体大小。
         */
        getMaxHeight(fontSize?: number): number;
    }
    interface BMGlyph {
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        advance?: number;
        texture?: Texture;
    }
    /**
     * @en Alpha command.
     * @zh 透明命令
     * @blueprintIgnore
     */
    class AlphaCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the AlphaCmd
         * @zh 透明命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The opacity level of the command.
         * @zh 透明度值。
         */
        alpha: number;
        /**
         * @en Creates or retrieves an AlphaCmd instance from the object pool and initializes it with the specified alpha value.
         * @param alpha The alpha value to set for the AlphaCmd instance.
         * @returns An AlphaCmd instance initialized with the given alpha value.
         * @zh 从对象池创建或获取一个 AlphaCmd 实例，并使用指定的 alpha 值进行初始化。
         * @param alpha 用于设置 AlphaCmd 实例的 alpha 值。
         * @returns 一个已用给定 alpha 值初始化的 AlphaCmd 实例。
         */
        static create(alpha: number): AlphaCmd;
        /**
         * @en Recovers the `AlphaCmd` instance to the object pool for reuse.
         * @zh 将 `AlphaCmd` 实例回收到对象池以供重用。
         */
        recover(): void;
        /**
         * @en Execute the alpha command in the given context.
         * @param runner The rendering context.
         * @param gx The global x coordinate (unused in this method).
         * @param gy The global y coordinate (unused in this method).
         * @zh 在给定的上下文中执行 alpha 命令。
         * @param runner 渲染上下文。
         * @param gx 全局 x 坐标（本方法中未使用）。
         * @param gy 全局 y 坐标（本方法中未使用）。
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en Get the identifier for the AlphaCmd
         * @zh 获得透明命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Clip command
     * @zh 裁剪命令
     * @blueprintIgnore
     */
    class ClipRectCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the ClipRectCmd
         * @zh 裁剪命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis offset.
         * @zh X 轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y 轴偏移量。
         */
        y: number;
        /**
         * @en Width of the clip rectangle.
         * @zh 裁剪矩形的宽度。
         */
        width: number;
        /**
         * @en Height of the clip rectangle.
         * @zh 裁剪矩形的高度。
         */
        height: number;
        /**
         * @en Creates or retrieves a ClipRectCmd instance from the object pool and initializes it with the specified parameters.
         * @param x The x-coordinate of the top-left corner of the clip rectangle.
         * @param y The y-coordinate of the top-left corner of the clip rectangle.
         * @param width The width of the clip rectangle.
         * @param height The height of the clip rectangle.
         * @returns A ClipRectCmd instance initialized with the given parameters.
         * @zh 从对象池创建或获取一个 ClipRectCmd 实例，并使用指定的参数进行初始化。
         * @param x 裁剪矩形左上角的 x 坐标。
         * @param y 裁剪矩形左上角的 y 坐标。
         * @param width 裁剪矩形的宽度。
         * @param height 裁剪矩形的高度。
         * @returns 一个已用给定参数初始化的 ClipRectCmd 实例。
         */
        static create(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * @en Recycle the instance to the object pool.
         * @zh 将实例回收到对象池。
         */
        recover(): void;
        /**
         * @en Execute the clip rectangle command in the given context.
         * @param runner The rendering context.
         * @param gx The global x coordinate.
         * @param gy The global y coordinate.
         * @zh 在给定的上下文中执行裁剪矩形命令。
         * @param runner 渲染上下文。
         * @param gx 全局 x 坐标。
         * @param gy 全局 y 坐标。
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the ClipRectCmd
         * @zh 裁剪命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw a texture with nine-grid information
     * @zh 绘制带九宫格信息的图片
     */
    class Draw9GridTextureCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the Draw9GridTextureCmd
         * @zh 绘制带九宫格信息的图片命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The texture to be drawn
         * @zh 要绘制的纹理
         */
        texture: Texture;
        /**
         * @en (Optional) X-axis offset
         * @zh （可选）X轴偏移量
         */
        x: number;
        /**
         * @en (Optional) Y-axis offset
         * @zh （可选）Y轴偏移量
         */
        y: number;
        /**
         * @en (Optional) Width of the drawn texture
         * @zh （可选）绘制纹理的宽度
         */
        width: number;
        /**
         * @en (Optional) Height of the drawn texture
         * @zh （可选）绘制纹理的高度
         */
        height: number;
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        sizeGrid: number[];
        /**
         * @en Color tint for the texture (default: 0xffffffff)
         * @zh 纹理的颜色色调（默认值：0xffffffff）
         */
        color: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en Creates or retrieves a Draw9GridTextureCmd instance from the object pool and initializes it with the specified parameters.
         * @param texture The texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the drawn texture
         * @param height Height of the drawn texture
         * @param sizeGrid Nine-grid information
         * @param percent Whether the position and size are percentages (default: false)
         * @param color Color tint for the texture (default: null)
         * @returns A Draw9GridTextureCmd instance initialized with the given parameters
         * @zh 从对象池创建或获取一个 Draw9GridTextureCmd 实例，并使用指定的参数进行初始化。
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 绘制纹理的宽度
         * @param height 绘制纹理的高度
         * @param sizeGrid 九宫格信息
         * @param percent 位置和大小是否是百分比（默认值：false）
         * @param color 纹理的颜色色调（默认值：null）
         * @returns 一个已用给定参数初始化的 Draw9GridTextureCmd 实例
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, sizeGrid: number[], percent?: boolean, color?: string): Draw9GridTextureCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw nine-grid texture command in the given context
         * @param runner The rendering context
         * @param gx The global x coordinate
         * @param gy The global y coordinate
         * @zh 在给定的上下文中执行绘制九宫格纹理命令
         * @param runner 渲染上下文
         * @param gx 全局 x 坐标
         * @param gy 全局 y 坐标
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the Draw9GridTextureCmd
         * @zh 绘制带九宫格信息的图片命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw circle command
     * @zh 绘制圆形命令
     */
    class DrawCircleCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawCircleCmd
         * @zh 绘制圆形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis position of the circle center
         * @zh 圆心X轴位置
         */
        x: number;
        /**
         * @en Y-axis position of the circle center
         * @zh 圆心Y轴位置
         */
        y: number;
        /**
         * @en Radius of the circle
         * @zh 圆的半径
         */
        radius: number;
        /**
         * @en Fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) Border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Border width
         * @zh （可选）边框宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en Create a DrawCircleCmd instance
         * @param x X-axis position of the circle center
         * @param y Y-axis position of the circle center
         * @param radius Radius of the circle
         * @param fillColor Fill color
         * @param lineColor Border color
         * @param lineWidth Border width
         * @returns A DrawCircleCmd instance
         * @zh 创建绘制圆形的DrawCircleCmd实例
         * @param x 圆心X轴位置
         * @param y 圆心Y轴位置
         * @param radius 圆的半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比值
         * @returns DrawCircleCmd实例
         */
        static create(x: number, y: number, radius: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawCircleCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw circle command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制圆形命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawCircleCmd
         * @zh 绘制圆形命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw curves command
     * @zh 绘制曲线命令
     */
    class DrawCurvesCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawCurvesCmd
         * @zh 绘制曲线命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis position to start drawing
         * @zh 开始绘制的 X 轴位置
         */
        x: number;
        /**
         * @en Y-axis position to start drawing
         * @zh 开始绘制的 Y 轴位置
         */
        y: number;
        /**
         * @en Collection of points for the curve segments, format: [controlX, controlY, anchorX, anchorY...]
         * @zh 线段的点集合，格式：[controlX, controlY, anchorX, anchorY...]
         */
        points: number[] | null;
        /**
         * @en Line color
         * @zh 线段颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Line width
         * @zh （可选）线段宽度
         */
        lineWidth: number;
        /**
         * @en Create a DrawCurvesCmd instance
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the curve segments
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawCurvesCmd instance
         * @zh 创建一个DrawCurvesCmd实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param points 线段的点集合
         * @param lineColor 线段颜色
         * @param lineWidth 线段宽度
         * @returns DrawCurvesCmd实例
         */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawCurvesCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw curves command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制曲线命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawCurvesCmd
         * @zh 绘制曲线命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw ellipse command
     * @zh 绘制椭圆命令
     */
    class DrawEllipseCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawEllipseCmd
         * @zh 绘制椭圆命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis position of the ellipse center
         * @zh 椭圆中心点X轴位置
         */
        x: number;
        /**
         * @en Y-axis position of the ellipse center
         * @zh 椭圆中心点Y轴位置
         */
        y: number;
        /**
         * @en Horizontal radius of the ellipse
         * @zh 椭圆的横向半径
         */
        width: number;
        /**
         * @en Vertical radius of the ellipse
         * @zh 椭圆的纵向半径
         */
        height: number;
        /**
         * @en Fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) Border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Border width
         * @zh （可选）边框宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en Create a DrawEllipseCmd instance
         * @param x X-axis position of the ellipse center
         * @param y Y-axis position of the ellipse center
         * @param width Horizontal radius of the ellipse
         * @param height Vertical radius of the ellipse
         * @param fillColor Fill color
         * @param lineColor Border color
         * @param lineWidth Border width
         * @param percent Whether the position and size are percentages
         * @returns A DrawEllipseCmd instance
         * @zh 创建一个绘制椭圆命令的实例
         * @param x 椭圆中心点X轴位置
         * @param y 椭圆中心点Y轴位置
         * @param width 椭圆的横向半径
         * @param height 椭圆的纵向半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawEllipseCmd实例
         */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw ellipse command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制椭圆命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawEllipseCmd
         * @zh 绘制椭圆命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw image command
     * @zh 绘制图片命令
     */
    class DrawImageCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawImageCmd
         * @zh 绘制图片命令的标识符
         */
        static readonly ID: string;
        /**
         * @en Texture to be drawn
         * @zh 要绘制的纹理
         */
        texture: Texture | null;
        /**
         * @en (Optional) X-axis offset
         * @zh （可选）X轴偏移量
         */
        x: number;
        /**
         * @en (Optional) Y-axis offset
         * @zh （可选）Y轴偏移量
         */
        y: number;
        /**
         * @en (Optional) Width of the drawn image
         * @zh （可选）绘制图片的宽度
         */
        width: number;
        /**
         * @en (Optional) Height of the drawn image
         * @zh （可选）绘制图片的高度
         */
        height: number;
        /**
         * @en (Optional) Drawing color
         * @zh （可选）绘图颜色
         */
        color: number;
        /**
         * @en Create a DrawImageCmd instance
         * @param texture Texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the drawn image
         * @param height Height of the drawn image
         * @param color Drawing color
         * @returns A DrawImageCmd instance
         * @zh 创建一个绘制图片命令实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 绘制图片的宽度
         * @param height 绘制图片的高度
         * @param color 绘图颜色
         * @returns 绘制图片命令实例
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, color: string): DrawImageCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw image command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制图片命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the DrawImageCmd
         * @zh 绘制图片命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw bend line command
     * @zh 绘制单条曲线命令
     */
    class DrawLineCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawLineCmd
         * @zh 绘制单条曲线命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis start position
         * @zh X轴起始位置
         */
        fromX: number;
        /**
         * @en Y-axis start position
         * @zh Y轴起始位置
         */
        fromY: number;
        /**
         * @en X-axis end position
         * @zh X轴结束位置
         */
        toX: number;
        /**
         * @en Y-axis end position
         * @zh Y轴结束位置
         */
        toY: number;
        /**
         * @en Line color
         * @zh 线条颜色
         */
        lineColor: string;
        /**
         * @en (Optional) Line width
         * @zh （可选）线条宽度
         */
        lineWidth: number;
        /**
         * @en Whether the position is a percentage
         * @zh 位置是否是百分比
         */
        percent: boolean;
        /**
         * @en Create a DrawLineCmd instance
         * @param fromX X-axis start position
         * @param fromY Y-axis start position
         * @param toX X-axis end position
         * @param toY Y-axis end position
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawLineCmd instance
         * @zh 创建一个绘制单条曲线命令实例
         * @param fromX X轴起始位置
         * @param fromY Y轴起始位置
         * @param toX X轴结束位置
         * @param toY Y轴结束位置
         * @param lineColor 线条颜色
         * @param lineWidth 线条宽度
         * @returns DrawLineCmd 实例
         */
        static create(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number, percent?: boolean): DrawLineCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw bend line command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制单条曲线命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawLineCmd
         * @zh 绘制单条曲线命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw continuous curves command
     * @zh 绘制连续曲线命令
     */
    class DrawLinesCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawLinesCmd
         * @zh 绘制连续曲线命令的标识符
         */
        static readonly ID: string;
        /**
         * @en X-axis position to start drawing
         * @zh 开始绘制的X轴位置
         */
        x: number;
        /**
         * @en Y-axis position to start drawing
         * @zh 开始绘制的Y轴位置
         */
        y: number;
        /**
         * @en Collection of points for the line segments. Format: [x1,y1,x2,y2,x3,y3...]
         * @zh 线段的点集合。格式：[x1,y1,x2,y2,x3,y3...]
         */
        points: number[] | null;
        /**
         * @en Line color
         * @zh 线段颜色
         */
        lineColor: any;
        /**
         * @en (Optional) Line width
         * @zh （可选）线段宽度
         */
        lineWidth: number;
        /**
         * @en Create a DrawLinesCmd instance
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the line segments
         * @param lineColor Line color
         * @param lineWidth Line width
         * @returns A DrawLinesCmd instance
         * @zh 创建一个绘制连续曲线命令实例
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 线段的点集合
         * @param lineColor 线段颜色
         * @param lineWidth 线段宽度
         * @returns DrawLinesCmd 实例
         */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawLinesCmd;
        /**
         * @en Recycle the instance to the object pool
         * @zh 将实例回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw continuous lines command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制连续曲线命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the DrawLinesCmd
         * @zh 绘制连续曲线命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw vector graphics based on the path
     * @zh 根据路径绘制矢量图形
     */
    class DrawPathCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawPathCmd
         * @zh 根据路径绘制矢量图形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en Path collection. Paths support the following formats: [["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]].
         * @zh 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
         */
        paths: any[] | null;
        /**
         * @en (Optional) Brush definition, supports the following settings: {fillStyle:"#FF0000"}.
         * @zh （可选）刷子定义，支持以下设置：{fillStyle:"#FF0000"}。
         */
        brush: any;
        /**
         * @en (Optional) Pen definition, supports the following settings: {strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}.
         * @zh （可选）画笔定义，支持以下设置：{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
         */
        pen: any;
        /**
         * @en Create a DrawPathCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param paths Path collection
         * @param brush Brush definition
         * @param pen Pen definition
         * @returns DrawPathCmd instance
         * @zh 创建一个根据路径绘制矢量图形命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param paths 路径集合
         * @param brush 刷子定义
         * @param pen 画笔定义
         * @return DrawPathCmd 实例
         */
        static create(x: number, y: number, paths: any[], brush: any, pen: any): DrawPathCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制命令
         * @param runner 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawPathCmd
         * @zh 根据路径绘制矢量图形命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw a pie chart
     * @zh 绘制扇形
     */
    class DrawPieCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawPieCmd
         * @zh 绘制扇形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The radius of the pie chart.
         * @zh 扇形半径。
         */
        radius: number;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        private _startAngle;
        private _endAngle;
        /**
         * @en Create a DrawPieCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param radius The radius of the pie chart
         * @param startAngle The start angle of the pie chart
         * @param endAngle The end angle of the pie chart
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @returns DrawPieCmd instance
         * @zh 创建一个绘制扇形命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param radius 扇形半径
         * @param startAngle 扇形起始角度
         * @param endAngle 扇形终止角度
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @returns 绘制扇形命令实例
         */
        static create(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any, lineWidth: number): DrawPieCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制命令
         * @param runner 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawPieCmd
         * @zh 绘制扇形命令的标识符
         */
        get cmdID(): string;
        /**
         * @en The start angle of the pie chart in degrees.
         * @zh 开始角度（以度为单位）。
         */
        get startAngle(): number;
        set startAngle(value: number);
        /**
         * @en The end angle of the pie chart in degrees.
         * @zh 结束角度（以度为单位）。
         */
        get endAngle(): number;
        set endAngle(value: number);
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw a polygon
     * @zh 绘制多边形
     */
    class DrawPolyCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawPolyCmd
         * @zh 绘制多边形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The collection of points for the polygon.
         * @zh 多边形的点集合。
         */
        points: number[] | null;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Create a DrawPolyCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param points The collection of points for the polygon
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @returns DrawPolyCmd instance
         * @zh 创建绘制多边形命令的实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param points 多边形的点集合
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         */
        static create(x: number, y: number, points: any[], fillColor: any, lineColor: any, lineWidth: number): DrawPolyCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing polygon command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制多边形命令
         * @param runner 渲染上下文
         * @param gx 全局 X 偏移
         * @param gy 全局 Y 偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the DrawPolyCmd
         * @zh 绘制多边形命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw a rectangle
     * @zh 绘制矩形
     */
    class DrawRectCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawRectCmd
         * @zh 绘制矩形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The X-axis position to start drawing.
         * @zh 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position to start drawing.
         * @zh 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * @en The width of the rectangle.
         * @zh 矩形宽度。
         */
        width: number;
        /**
         * @en The height of the rectangle.
         * @zh 矩形高度。
         */
        height: number;
        /**
         * @en The fill color
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages.
         * @zh 位置和大小是否是百分比。
         */
        percent: boolean;
        /**
         * @en Create a DrawRectCmd instance
         * @param x The X-axis position to start drawing
         * @param y The Y-axis position to start drawing
         * @param width The width of the rectangle
         * @param height The height of the rectangle
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @param percent Whether the position and size are percentages
         * @returns DrawRectCmd instance
         * @zh 创建绘制矩形的命令实例
         * @param x 开始绘制的 X 轴位置
         * @param y 开始绘制的 Y 轴位置
         * @param width 矩形宽度
         * @param height 矩形高度
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawRectCmd实例
         */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRectCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing rectangle command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制矩形命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawRectCmd
         * @zh 绘制矩形命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw a rounded rectangle
     * @zh 绘制圆角矩形
     */
    class DrawRoundRectCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawRoundRectCmd
         * @zh 绘制圆角矩形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The X-axis position of the rounded rectangle.
         * @zh 圆角矩形的 X 轴位置。
         */
        x: number;
        /**
         * @en The Y-axis position of the rounded rectangle.
         * @zh 圆角矩形的 Y 轴位置。
         */
        y: number;
        /**
         * @en The width of the rounded rectangle.
         * @zh 圆角矩形的宽度。
         */
        width: number;
        /**
         * @en The height of the rounded rectangle.
         * @zh 圆角矩形的高度。
         */
        height: number;
        /**
         * @en The radius of the top-left corner.
         * @zh 左上圆角的半径。
         */
        lt: number;
        /**
         * @en The radius of the top-right corner.
         * @zh 右上圆角的半径。
         */
        rt: number;
        /**
         * @en The radius of the bottom-left corner.
         * @zh 左下圆角的半径。
         */
        lb: number;
        /**
         * @en The radius of the bottom-right corner.
         * @zh 右下圆角的半径。
         */
        rb: number;
        /**
         * @en The fill color.
         * @zh 填充颜色
         */
        fillColor: any;
        /**
         * @en (Optional) The border color.
         * @zh （可选）边框颜色
         */
        lineColor: any;
        /**
         * @en (Optional) The width of the border.
         * @zh （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * @en Whether the position and size are percentages.
         * @zh 位置和大小是否是百分比。
         */
        percent: boolean;
        /**
         * @en Create a DrawRoundRectCmd instance
         * @param x The X-axis position of the rounded rectangle
         * @param y The Y-axis position of the rounded rectangle
         * @param width The width of the rounded rectangle
         * @param height The height of the rounded rectangle
         * @param lt The radius of the top-left corner
         * @param rt The radius of the top-right corner
         * @param lb The radius of the bottom-left corner
         * @param rb The radius of the bottom-right corner
         * @param fillColor The fill color
         * @param lineColor The border color
         * @param lineWidth The width of the border
         * @param percent Whether the position and size are percentages
         * @returns DrawRoundRectCmd instance
         * @zh 创建绘制圆角矩形命令的实例
         * @param x 圆角矩形的 X 轴位置
         * @param y 圆角矩形的 Y 轴位置
         * @param width 圆角矩形的宽度
         * @param height 圆角矩形的高度
         * @param lt 左上圆角的半径
         * @param rt 右上圆角的半径
         * @param lb 左下圆角的半径
         * @param rb 右下圆角的半径
         * @param fillColor 填充颜色
         * @param lineColor 边框颜色
         * @param lineWidth 边框宽度
         * @param percent 位置和大小是否是百分比
         * @returns DrawRoundRectCmd 实例
         */
        static create(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRoundRectCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing rounded rectangle command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制圆角矩形命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawRoundRectCmd
         * @zh 绘制圆角矩形命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw a single texture
     * @zh 绘制单个贴图
     */
    class DrawTextureCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawTextureCmd
         * @zh 绘制单个贴图命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture | null;
        /**
         * @en (Optional) X-axis offset.
         * @zh （可选）X轴偏移量。
         */
        x: number;
        /**
         * @en (Optional) Y-axis offset.
         * @zh （可选）Y轴偏移量。
         */
        y: number;
        /**
         * @en (Optional) Width of the texture.
         * @zh （可选）纹理的宽度。
         */
        width: number;
        /**
         * @en (Optional) Height of the texture.
         * @zh （可选）纹理的高度。
         */
        height: number;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en (Optional) Matrix information for transformation.
         * @zh （可选）矩阵信息，用于变换。
         */
        matrix: Matrix | null;
        /**
         * @en (Optional) Alpha value.
         * @zh （可选）透明度。
         */
        alpha: number;
        /**
         * @en (Optional) Color filter.
         * @zh （可选）颜色滤镜。
         */
        color: number;
        /**
         * @en (Optional) Blend mode.
         * @zh （可选）混合模式。
         */
        blendMode: string | null;
        /**
         * @en (Optional) UV coordinates.
         * @zh （可选）UV坐标。
         */
        uv: number[] | null;
        /**
         * @en Create a DrawTextureCmd instance
         * @param texture The texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the texture
         * @param height Height of the texture
         * @param matrix Matrix information for transformation
         * @param alpha Alpha value
         * @param color Color filter
         * @param blendMode Blend mode
         * @param uv UV coordinates
         * @returns DrawTextureCmd instance
         * @zh 创建一个绘制单个贴图实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 纹理的宽度
         * @param height 纹理的高度
         * @param matrix 矩阵信息，用于变换
         * @param alpha 透明度
         * @param color 颜色滤镜
         * @param blendMode 混合模式
         * @param uv UV坐标
         * @returns DrawTextureCmd实例
         */
        static create(texture: Texture, x?: number, y?: number, width?: number, height?: number, matrix?: Matrix, alpha?: number, color?: string, blendMode?: string, uv?: number[], percent?: boolean): DrawTextureCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the draw texture command.
         * @param runner The rendering context.
         * @param gx Starting X coordinate.
         * @param gy Starting Y coordinate.
         * @zh 执行绘制纹理命令。
         * @param runner 渲染上下文。
         * @param gx 起始 X 坐标。
         * @param gy 起始 Y 坐标。
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the DrawTextureCmd
         * @zh 绘制单个贴图命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw multiple textures based on coordinate sets
     * @zh 根据坐标集合绘制多个贴图
     */
    class DrawTexturesCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawTexturesCmd
         * @zh 根据坐标集合绘制多个贴图命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture;
        /**
         * @en Drawing times and coordinates.
         * @zh 绘制次数和坐标。
         */
        pos: ArrayLike<number>;
        /**
         * @en Additional vertex colors.
         * @zh 附加顶点色。
         */
        colors: number[];
        /**
         * @en Create a DrawTexturesCmd instance
         * @param texture The texture to be drawn
         * @param pos Drawing times and coordinates
         * @param colors Additional vertex colors
         * @returns DrawTexturesCmd instance
         * @zh 创建一个根据坐标集合绘制多个贴图实例
         * @param texture 要绘制的纹理
         * @param pos 绘制次数和坐标
         * @param colors 附加顶点色
         * @returns DrawTexturesCmd实例
         */
        static create(texture: Texture, pos: number[], colors: number[]): DrawTexturesCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing textures command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制多个纹理命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the DrawTexturesCmd
         * @zh 根据坐标集合绘制多个贴图命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Draw triangles command
     * @zh 绘制三角形命令
     */
    class DrawTrianglesCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the DrawTrianglesCmd
         * @zh 绘制三角形命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The texture to be drawn.
         * @zh 要绘制的纹理。
         */
        texture: Texture | null;
        /**
         * @en X-axis offset.
         * @zh X轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y轴偏移量。
         */
        y: number;
        /**
         * @en Vertex array.
         * @zh 顶点数组。
         */
        vertices: Float32Array;
        /**
         * @en UV data.
         * @zh UV数据。
         */
        uvs: Float32Array;
        /**
         * @en Vertex indices.
         * @zh 顶点索引。
         */
        indices: Uint16Array;
        /**
         * @en Scaling matrix.
         * @zh 缩放矩阵。
         */
        matrix: Matrix | null;
        /**
         * @en Alpha value.
         * @zh 透明度值。
         */
        alpha: number;
        /**
         * @en Blend mode.
         * @zh 混合模式。
         */
        blendMode: string | null;
        /**
         * @en Color transformation.
         * @zh 颜色变换。
         */
        color: number | null;
        /**
         * @en Mesh factory for creating the mesh.
         * @zh 用于创建网格的工厂。
         */
        mesh: IMeshFactory;
        /**
         * @en Create a DrawTrianglesCmd instance
         * @param texture The texture to be drawn
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param vertices Vertex array
         * @param uvs UV data
         * @param indices Vertex indices
         * @param matrix Scaling matrix
         * @param alpha Alpha value
         * @param color Color transformation
         * @param blendMode Blend mode
         * @returns DrawTrianglesCmd instance
         * @zh 创建一个绘制三角形命令实例
         * @param texture 要绘制的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param vertices 顶点数组
         * @param uvs UV数据
         * @param indices 顶点索引
         * @param matrix 缩放矩阵
         * @param alpha 透明度值
         * @param color 颜色变换
         * @param blendMode 混合模式
         * @returns 绘制三角形命令实例
         */
        static create(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix?: Matrix, alpha?: number, color?: string | number, blendMode?: string): DrawTrianglesCmd;
        /**
         * @en Create a DrawTrianglesCmd instance using a mesh factory
         * @param texture The texture to be drawn
         * @param mesh Mesh factory for creating the mesh
         * @param color Color transformation
         * @returns DrawTrianglesCmd instance
         * @zh 使用网格工厂创建一个绘制三角形命令实例
         * @param texture 要绘制的纹理
         * @param mesh 用于创建网格的工厂
         * @param color 颜色变换
         * @returns 绘制三角形命令实例
         */
        static create2(texture: Texture, mesh: IMeshFactory, color?: string | number): DrawTrianglesCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the drawing triangles command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制三角形命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the DrawTrianglesCmd
         * @zh 绘制三角形命令的标识符
         */
        get cmdID(): string;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Draw text command
     * @zh 绘制文字命令
     */
    class FillTextCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the FillTextCmd
         * @zh 绘制文字命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The x position of the start of the text (relative to the canvas).
         * @zh 开始绘制文本的 x 坐标位置（相对于画布）。
         */
        x: number;
        /**
         * @en The y position of the start of the text (relative to the canvas).
         * @zh 开始绘制文本的 y 坐标位置（相对于画布）。
         */
        y: number;
        private _text;
        private _wordText;
        private _font;
        private _color;
        private _strokeColor;
        private _stroke;
        private _align;
        private _fontObj;
        private _loosyBound;
        /**
         * @en Text content
         * @zh 文本内容
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Stroke color
         * @zh 描边颜色
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Stroke width
         * @zh 描边宽度
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Text alignment
         * @zh 对齐方式
         */
        get align(): number;
        set align(value: number);
        /**
         * @en Create a FillTextCmd instance
         * @param text Text content
         * @param x X position
         * @param y Y position
         * @param font Font
         * @param color Text color
         * @param align Alignment
         * @param stroke Stroke width
         * @param strokeColor Stroke color
         * @returns FillTextCmd instance
         * @zh 创建绘制文本的命令的实例
         * @param text 文本内容
         * @param x x位置
         * @param y y位置
         * @param font 字体
         * @param color 文本颜色
         * @param align 对齐方式
         * @param stroke 描边宽度
         * @param strokeColor 描边颜色
         * @returns 绘制文本的命令实例
         */
        static create(text: string | WordText | null, x: number, y: number, font: string, color: string | null, align: string, stroke: number, strokeColor: string | null): FillTextCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @private
         * @en Execute the drawing text command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制文本命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @en The identifier for the FillTextCmd
         * @zh 绘制文字命令的标识符
         */
        get cmdID(): string;
        /**
         * @en Define the font size and font, e.g., "20px Arial".
         * @zh 定义字号和字体，比如"20px Arial"。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Define the text color, e.g., "#ff0000".
         * @zh 定义文本颜色，比如"#ff0000"。
         */
        get color(): string;
        set color(value: string);
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
    }
    /**
     * @en Fill texture command
     * @zh 填充贴图命令
     */
    class FillTextureCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the FillTextureCmd
         * @zh 填充贴图命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The texture to be filled.
         * @zh 要填充的纹理。
         */
        texture: Texture;
        /**
         * @en X-axis offset.
         * @zh X轴偏移量。
         */
        x: number;
        /**
         * @en Y-axis offset.
         * @zh Y轴偏移量。
         */
        y: number;
        /**
         * @en (Optional) Width of the filled area.
         * @zh （可选）填充区域的宽度。
         */
        width: number;
        /**
         * @en (Optional) Height of the filled area.
         * @zh （可选）填充区域的高度。
         */
        height: number;
        /**
         * @en (Optional) Fill type: repeat|repeat-x|repeat-y|no-repeat
         * @zh （可选）填充类型：repeat|repeat-x|repeat-y|no-repeat
         */
        type: string;
        /**
         * @en (Optional) Texture offset
         * @zh （可选）贴图纹理偏移
         */
        offset?: Point;
        /**
         * @en Whether the position and size are percentages
         * @zh 位置和大小是否是百分比
         */
        percent: boolean;
        /**
         * @en (Optional) Drawing color
         * @zh （可选）绘图颜色
         */
        color: number;
        /**
         * @en Create a FillTextureCmd instance
         * @param texture The texture to be filled
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the filled area
         * @param height Height of the filled area
         * @param type Fill type
         * @param offset Texture offset
         * @param color Drawing color
         * @returns FillTextureCmd instance
         * @zh 创建绘制填充贴图的命令实例
         * @param texture 要填充的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 填充区域的宽度
         * @param height 填充区域的高度
         * @param type 填充类型
         * @param offset 贴图纹理偏移
         * @param color 绘图颜色
         * @returns FillTextureCmd实例
         */
        static create(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: string, percent?: boolean): FillTextureCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the fill texture command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行绘制填充贴图命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the FillTextureCmd
         * @zh 填充贴图命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Restore command, used in conjunction with save
     * @zh 恢复命令，与save配套使用
     * @blueprintIgnore
     */
    class RestoreCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the RestoreCmd
         * @zh 恢复命令的标识符
         */
        static readonly ID: string;
        /**
         * @en Create a RestoreCmd instance
         * @returns RestoreCmd instance
         * @zh 创建一个恢复命令实例
         * @returns 恢复命令实例
         */
        static create(): RestoreCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the restore command
         * @param runner The rendering context
         * @zh 执行恢复命令
         * @param runner 渲染上下文
         */
        run(runner: GraphicsRunner): void;
        /**
         * @en The identifier for the RestoreCmd
         * @zh 恢复命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Rotate command
     * @zh 旋转命令
     * @blueprintIgnore
     */
    class RotateCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the RotateCmd
         * @zh 旋转命令的标识符
         */
        static readonly ID: string;
        /**
         * @en Rotation angle in radians.
         * @zh 旋转角度，以弧度计。
         */
        angle: number;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a RotateCmd instance
         * @param angle Rotation angle in radians
         * @param pivotX Horizontal axis point coordinates.
         * @param pivotY Vertical axis point coordinates.
         * @returns RotateCmd instance
         * @zh 创建一个旋转命令实例
         * @param angle 旋转角度，以弧度计。
         * @param pivotX 水平方向轴心点坐标。
         * @param pivotY 垂直方向轴心点坐标。
         * @returns 旋转命令实例
         */
        static create(angle: number, pivotX: number, pivotY: number): RotateCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the rotate command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行旋转命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the RotateCmd
         * @zh 旋转命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Save command, used in conjunction with restore
     * @zh 存储命令，与restore配套使用
     * @blueprintIgnore
     */
    class SaveCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the SaveCmd
         * @zh 存储命令的标识符
         */
        static readonly ID: string;
        /**
         * @en Create a SaveCmd instance
         * @returns SaveCmd instance
         * @zh 创建一个存储命令实例
         * @returns 存储命令实例
         */
        static create(): SaveCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the save command
         * @param runner The rendering context
         * @zh 执行存储命令
         * @param runner 渲染上下文
         */
        run(runner: GraphicsRunner): void;
        /**
         * @en The identifier for the SaveCmd
         * @zh 存储命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Scale command
     * @zh 缩放命令
     * @blueprintIgnore
     */
    class ScaleCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the ScaleCmd
         * @zh 缩放命令的标识符
         */
        static readonly ID: string;
        /**
         * @en Horizontal scaling value.
         * @zh 水平方向缩放值。
         */
        scaleX: number;
        /**
         * @en Vertical scaling value.
         * @zh 垂直方向缩放值。
         */
        scaleY: number;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a ScaleCmd instance
         * @param scaleX Horizontal scaling value
         * @param scaleY Vertical scaling value
         * @param pivotX Horizontal axis point coordinates
         * @param pivotY Vertical axis point coordinates
         * @returns ScaleCmd instance
         * @zh 创建一个缩放命令实例
         * @param scaleX 水平方向缩放值
         * @param scaleY 垂直方向缩放值
         * @param pivotX 水平方向轴心点坐标
         * @param pivotY 垂直方向轴心点坐标
         * @returns 缩放命令实例
         */
        static create(scaleX: number, scaleY: number, pivotX: number, pivotY: number): ScaleCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the scale command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行缩放命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the ScaleCmd
         * @zh 缩放命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Transform command
     * @zh 矩阵变换命令
     * @blueprintIgnore
     */
    class TransformCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the TransformCmd
         * @zh 矩阵变换命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The transformation matrix.
         * @zh 变换矩阵。
         */
        matrix: Matrix;
        /**
         * @en (Optional) Horizontal axis point coordinates.
         * @zh （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * @en (Optional) Vertical axis point coordinates.
         * @zh （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**
         * @en Create a TransformCmd instance
         * @param matrix The transformation matrix
         * @param pivotX Horizontal axis point coordinates
         * @param pivotY Vertical axis point coordinates
         * @returns TransformCmd instance
         * @zh 创建一个矩阵变换命令实例
         * @param matrix 变换矩阵
         * @param pivotX 水平方向轴心点坐标
         * @param pivotY 垂直方向轴心点坐标
         * @returns 矩阵变换命令实例
         */
        static create(matrix: Matrix, pivotX: number, pivotY: number): TransformCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the transform command
         * @param runner The rendering context
         * @param gx Global X offset
         * @param gy Global Y offset
         * @zh 执行矩阵变换命令
         * @param runner 渲染上下文
         * @param gx 全局X偏移
         * @param gy 全局Y偏移
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the TransformCmd
         * @zh 矩阵变换命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Translate command
     * @zh 位移命令
     * @blueprintIgnore
     */
    class TranslateCmd implements IGraphicsCmd {
        /**
         * @en Identifier for the TranslateCmd
         * @zh 位移命令的标识符
         */
        static readonly ID: string;
        /**
         * @en The value to be added to the horizontal coordinate (x).
         * @zh 添加到水平坐标（x）上的值。
         */
        tx: number;
        /**
         * @en The value to be added to the vertical coordinate (y).
         * @zh 添加到垂直坐标（y）上的值。
         */
        ty: number;
        /**
         * @en Create a TranslateCmd instance
         * @param tx The value to be added to the horizontal coordinate
         * @param ty The value to be added to the vertical coordinate
         * @returns TranslateCmd instance
         * @zh 创建一个位移命令实例
         * @param tx 要添加到水平坐标的值
         * @param ty 要添加到垂直坐标的值
         * @returns 位移命令实例
         */
        static create(tx: number, ty: number): TranslateCmd;
        /**
         * @en Recycle to the object pool
         * @zh 回收到对象池
         */
        recover(): void;
        /**
         * @en Execute the translate command
         * @param context The rendering context
         * @zh 执行位移命令
         * @param context 渲染上下文
         */
        run(context: GraphicsRunner): void;
        /**
         * @ignore
         */
        getBounds(assembler: IGraphicsBoundsAssembler): void;
        /**
         * @en The identifier for the TranslateCmd
         * @zh 位移命令的标识符
         */
        get cmdID(): string;
    }
    /**
     * @en Text style class
     * @zh 文本的样式类
     */
    class TextStyle {
        /**
         * @en Font
         * @zh 字体
         */
        font: string;
        /**
         * @en Font size
         * @zh 字号
         */
        fontSize: number;
        /**
         * @en Text color
         * @zh 文字颜色
         */
        color: string;
        /**
         * @en Whether the text is bold
         * @zh 是否为粗体
         */
        bold: boolean;
        /**
         * @en Whether the text is italic
         * @zh 是否为斜体
         */
        italic: boolean;
        /**
         * @en Whether to show underline
         * @zh 是否显示下划线
         */
        underline: boolean;
        /**
         * @en Underline color
         * @zh 下划线颜色
         */
        underlineColor: string;
        /**
         * @en Whether to display the strikethrough.
         * @zh 是否显示删除线。
         */
        strikethrough: boolean;
        /**
         * @en The color of the strikethrough.
         * @zh 删除线颜色。
         */
        strikethroughColor: string;
        /**
         * @en Indicates the horizontal alignment of text paragraphs using this text format
         * @zh 表示使用此文本格式的文本段落的水平对齐方式
         * @default "left"
         */
        align: string;
        /**
         * @en Indicates the vertical alignment of text paragraphs using this text format
         * @zh 表示使用此文本格式的文本段落的垂直对齐方式
         */
        valign: string;
        /**
         * @en Alignment of images and text in mixed content. Possible values are top, middle, bottom
         * @zh 图文混排时图片和文字的对齐方式。可选值是top, middle, bottom
         */
        alignItems: string;
        /**
         * @en Vertical line spacing (in pixels)
         * @zh 垂直行间距（以像素为单位）
         */
        leading: number;
        /**
         * @en Stroke width (in pixels). Default is 0, meaning no stroke
         * @zh 描边宽度（以像素为单位）。默认值0，表示不描边
         */
        stroke: number;
        /**
         * @en Stroke color, represented as a string
         * @zh 描边颜色，以字符串表示
         */
        strokeColor: string;
    }
    class BlurEffect2D extends PostProcess2DEffect {
        private _renderElement;
        private _mat;
        private _centerScale;
        private _destRT;
        private _shaderV1;
        private _blurInfo;
        /**
          * @en The intensity of the blur filter. The higher the value, the more indistinct the image becomes.
          * @zh 模糊滤镜的强度。值越大，图像越不清晰。
          */
        private _strength;
        get shaderV1(): Vector4;
        set shaderV1(value: Vector4);
        constructor(strength?: number);
        /** @ignore */
        effectInit(postprocess: PostProcess2D): void;
        /** @ignore */
        render(context: PostProcessRenderContext2D): void;
        private _checkRenderTarget;
        clearRT(context: PostProcessRenderContext2D): void;
        /**
          * @en The strength of the blur filter.
          * @zh 模糊滤镜的强度。
          */
        get strength(): number;
        set strength(v: number);
        /** @ignore */
        destroy(): void;
    }
    class ColorEffect2D extends PostProcess2DEffect {
        private _colorMat;
        private _mat;
        private _renderElement;
        private _destRT;
        private _centerScale;
        private _alpha;
        private _colorArray;
        private _alphaArray;
        private _matrix;
        constructor(matrix?: number[]);
        get colorMat(): Matrix4x4;
        set colorMat(value: Matrix4x4);
        gray(): ColorEffect2D;
        get alpha(): Vector4;
        set alpha(value: Vector4);
        effectInit(postprocess: PostProcess2D): void;
        /**
         * @en Sets the matrix data.
         * @param matrix An array with 20 elements arranged in a 4x5 matrix.
         * @zh 设置矩阵数据
         * @param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
         */
        setByMatrix(matrix: number[]): ColorEffect2D;
        /**
         * @en Sets the filter to a color transformation filter with the specified red, green, blue, and alpha coefficients.
         * @param red The red coefficient, range: 0 to 1.
         * @param green The green coefficient, range: 0 to 1.
         * @param blue The blue coefficient, range: 0 to 1.
         * @param alpha The alpha coefficient, range: 0 to 1.
         * @zh 将滤镜设置为具有指定红色、绿色、蓝色和 Alpha 系数的颜色转换滤镜。
         * @param red 红色系数,范围:0~1
         * @param green 绿色系数,范围:0~1
         * @param blue 蓝色系数,范围:0~1
         * @param alpha alpha系数,范围:0~1
         */
        color(red?: number, green?: number, blue?: number, alpha?: number): ColorEffect2D;
        /**
         * @en Sets the filter color using a color value.
         * @param color The color value in string format.
         * @zh 使用颜色值设置滤镜颜色。
         * @param  color 颜色值
         */
        setColor(color: string): ColorEffect2D;
        /**
         * @en Adjusts color properties including brightness, contrast, saturation, and hue.
         * @param brightness Brightness value, range: -100 to 100.
         * @param contrast Contrast value, range: -100 to 100.
         * @param saturation Saturation value, range: -100 to 100.
         * @param hue Hue value, range: -180 to 180.
         * @zh 调整颜色属性，包括亮度、对比度、饱和度和色调。
         * @param brightness 亮度,范围:-100~100
         * @param contrast 对比度,范围:-100~100
         * @param saturation 饱和度,范围:-100~100
         * @param hue 色调,范围:-180~180
         */
        adjustColor(brightness: number, contrast: number, saturation: number, hue: number): ColorEffect2D;
        /**
         * @en Adjusts the brightness of the filter.
         * @param brightness Brightness value, range: -100 to 100.
         * @zh 调整滤镜的亮度。
         * @param brightness 亮度,范围:-100~100
         */
        adjustBrightness(brightness: number): ColorEffect2D;
        /**
         * @en Adjusts the contrast of the image.
         * @param contrast The contrast value. The contrast value should be between -100 and 100.
         * @zh 调整图像的对比度。
         * @param contrast 对比度值。对比度值应在 -100 到 100 之间。
         */
        adjustContrast(contrast: number): ColorEffect2D;
        /**
         * @en Adjusts the saturation of the image.
         * @param saturation The saturation value. The saturation value should be between -100 and 100.
         * @zh 调整图像的饱和度。
         * @param saturation 饱和度值。饱和度值应在 -100 到 100 之间。
         */
        adjustSaturation(saturation: number): ColorEffect2D;
        /**
         * @en Adjusts the hue of the image.
         * @param hue The hue value.The hue value should be between -180 and 180.
         * @zh 调整图像的色调。
         * @param hue 色调值。色调值应在 -180 到 180 之间。
         */
        adjustHue(hue: number): ColorEffect2D;
        /**
         * @en Resets the filter to the identity matrix, removing any filter effects.
         * @zh 将滤镜重置为单位矩阵，移除所有滤镜效果。
         */
        reset(): ColorEffect2D;
        /**
         * @en Multiplication.
         * @param matrix The matrix to multiply with the current one.
         * @zh 矩阵乘法
         * @param matrix 要与当前矩阵相乘的矩阵。
         */
        private _multiplyMatrix;
        /**
         * @en Adjusts the matrix to the correct size.
         * @param matrix The matrix to be adjusted.
         * @zh 规范矩阵，确保矩阵大小正确。
         * @param matrix 需要调整的矩阵。
         */
        private _fixMatrix;
        /**
         * @en Clamps the value to a specified range.
         * @param val The current value to be clamped.
         * @param limit The limit range for the value.
         * @zh 规范值的范围。
         * @param val 当前值。
         * @param limit 值的范围限制。
         */
        private _clampValue;
        /** @ignore */
        render(context: PostProcessRenderContext2D): void;
        private _checkRenderTarget;
        clearRT(context: PostProcessRenderContext2D): void;
        /**
         * @en Called after deserialization.
         * @zh 反序列化后调用。
         */
        onAfterDeserialize(): void;
        /** @ignore */
        destroy(): void;
    }
    class GrayscaleEffect2D extends ColorEffect2D {
        constructor();
    }
    class GlowEffect2D extends PostProcess2DEffect {
        private _blitElement;
        private _blitmat;
        private _blitcenterScale;
        private _glowElement;
        private _glowMat;
        private _compositeElement;
        private _compositeMat;
        private _blitExtendRT;
        private _destRT;
        private _sv_blurInfo1;
        private _sv_blurInfo2;
        private _color;
        private _colorVec;
        get sv_blurInfo1(): Vector4;
        set sv_blurInfo1(value: Vector4);
        get sv_blurInfo2(): Vector4;
        set sv_blurInfo2(value: Vector4);
        /**
         * @en color value
         * @zh 颜色值
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Gest fuzzy value
         * @zh 获取模糊值
         */
        get blur(): number;
        /**
         * @en Sets fuzzy value
         * @zh 设置模糊值
         */
        set blur(value: number);
        /**
         * @en Gets Y offset value
         * @zh 获取Y偏移值
         */
        get offsetY(): number;
        /**
         * @en Sets Y offset value
         * @zh 设置Y偏移值
         */
        set offsetY(value: number);
        /**
         * @en Gets X offset value
         * @zh 获取X偏移值
         */
        get offsetX(): number;
        /**
         * @en Sets X offset value
         * @zh 设置X偏移值
         */
        set offsetX(value: number);
        constructor(color?: string, blur?: number, offX?: number, offY?: number);
        /** @ignore */
        effectInit(postprocess: PostProcess2D): void;
        /** @ignore */
        render(context: PostProcessRenderContext2D): void;
        private _checkRenderTarget;
        /** @ignore */
        clearRT(context: PostProcessRenderContext2D): void;
        /** @ignore */
        destroy(): void;
    }
    class Effect2DShaderInit {
        static colorEffect2DShaderInit(): void;
        static blurEffect2DShaderInit(): void;
        static glow2DShaderInit(): void;
    }
    /**
     * @en The Graphics class is used to create drawing display objects. Graphics can draw multiple bitmaps or vector graphics simultaneously, and can also combine instructions such as save, restore, transform, scale, rotate, translate, alpha, etc. to change the drawing effect.
     * Graphics is stored as a command stream and can be accessed through the cmds property. Graphics is a lighter object than Sprite, and proper use can improve application performance (for example, changing a large number of node drawings to a collection of Graphics commands of one node can reduce the consumption of creating a large number of nodes).
     * @zh Graphics 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
     * Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
     */
    class Graphics {
        /**
         * @internal
         * @en Add global Uniform Data Map
         * @param propertyID The ID of the property
         * @param propertyKey The key of the property
         * @param uniformtype The type of the uniform
         * @zh 添加全局Uniform数据映射
         * @param propertyID 属性ID
         * @param propertyKey 属性键
         * @param uniformtype Uniform类型
         */
        static add2DGlobalUniformData(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /** @readonly */
        owner: Sprite | null;
        /** @internal */
        _data: GraphicsRenderData;
        /** @internal 是否优先使用精灵状态 */
        _useSpriteState: boolean;
        /**
         * @internal
         * @en Whether to return graphics bounds as the sprite rect, instead of the bounds calculated from the commands.
         * @zh 是否返回graphics边界为精灵矩形，而不是从命令计算的边界。对于像文本这种情况，可以优化效率。
         */
        _useSpriteRect: boolean;
        private _cmds;
        private _graphicBounds;
        private _material;
        private _renderDataHandle;
        private _modified;
        private _display;
        /**
        * @en Whether to use sprite state.
        * @zh graphics是否优先使用精灵状态。
        * @blueprintIgnore
        */
        get useSpriteState(): boolean;
        set useSpriteState(value: boolean);
        /**@ignore @blueprintIgnore */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        /** @internal */
        onModified(): void;
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
        /**
         * @en Clear drawing commands.
         * @param recoverCmds Whether to recycle the drawing instruction array. If set to true, the instruction array will be recycled to save memory. It is recommended to set it to true for recycling, but if you manually reference the array, recycling is not recommended.
         * @param exclude (Optional) Exclude a specific command from being cleared. Default is null.
         * @zh 清空绘制命令。
         * @param recoverCmds 是否回收绘图指令数组。设置为true，则对指令数组进行回收以节省内存开销。建议设置为true进行回收，但如果手动引用了数组，不建议回收。
         * @param exclude （可选）排除特定命令不被清除。默认为null。
         */
        clear(recoverCmds?: boolean, exclude?: IGraphicsCmd): void;
        /** @deprecated Use repaint */
        _repaint(): void;
        /**
         * @en Redraw this object.
         * @zh 重绘此对象。
         */
        repaint(): void;
        /**
         * @en Command flow. All drawing commands are stored.
         * @zh 命令流。存储了所有绘制命令。
         */
        get cmds(): IGraphicsCmd[];
        set cmds(value: IGraphicsCmd[]);
        /**
         * @en Save to the command stream.
         * @param cmd Add the command to the command stream.
         * @param index (Optional) The index to be inserted.
         * @zh 添加到命令流。
         * @param cmd 要被添加的命令。
         * @param index （可选）插入的索引。
         */
        addCmd<T extends IGraphicsCmd>(cmd: T, index?: number): T;
        /**
         * @en Remove a specific command from the command list.
         * @param cmd The command to be removed.
         * @param recover (Optional) Whether to recycle the command. Default is false.
         * @zh 从命令列表中移除特定的命令。
         * @param cmd 要移除的命令。
         * @param recover （可选）是否回收命令。默认为false。
         */
        removeCmd(cmd: IGraphicsCmd, recover?: boolean): void;
        /**
         * @en Replace the command.
         * @param oldCmd The command to be replaced.
         * @param newCmd The new command.
         * @param recover (Optional) Whether to recycle the old command. Default is false.
         * @zh 替换命令。
         * @param oldCmd 要被替换的命令。
         * @param newCmd 新命令。
         * @param recover （可选）是否回收旧命令。默认为false。
         */
        replaceCmd<T extends IGraphicsCmd>(oldCmd: IGraphicsCmd, newCmd: T, recover?: boolean): T;
        /** @internal */
        _checkDisplay(): void;
        /**
         * @en Get the position and size information matrix (CPU-intensive, frequent use may cause lag, use sparingly).
         * @returns A Rectangle object composed of position and size.
         * @zh 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @returns 位置与宽高组成的一个 Rectangle 对象。
         */
        getBounds(): Readonly<Rectangle>;
        /**
         * @en Get the list of endpoints.
         * @returns An array of endpoint coordinates.
         * @zh 获取端点列表。
         * @returns 端点坐标的数组。
         */
        getBoundPoints(): ReadonlyArray<number>;
        /**
         * @en The material of the graphics object.
         * @zh 图形对象的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en Draw a single image
         * @param texture The texture to draw
         * @param x (Optional) X-axis offset. Default is 0.
         * @param y (Optional) Y-axis offset. Default is 0.
         * @param width (Optional) Width of the image. Default is null.
         * @param height (Optional) Height of the image. Default is null.
         * @param color (Optional) Color of the image. Default is null.
         * @zh 绘制单独图片
         * @param texture 要绘制的纹理
         * @param x （可选）X轴偏移量。默认为0。
         * @param y （可选）Y轴偏移量。默认为0。
         * @param width （可选）图片宽度。默认为null。
         * @param height （可选）图片高度。默认为null。
         * @param color （可选）图片颜色。默认为null。
         */
        drawImage(texture: Texture, x?: number, y?: number, width?: number, height?: number, color?: string): DrawImageCmd | null;
        /**
         * @en Draw a texture. More powerful than drawImage but less performant.
         * @param texture The texture to draw
         * @param x (Optional) X-axis offset. Default is 0.
         * @param y (Optional) Y-axis offset. Default is 0.
         * @param width (Optional) Width of the texture. Default is null.
         * @param height (Optional) Height of the texture. Default is null.
         * @param matrix (Optional) Matrix information. Default is null.
         * @param alpha (Optional) Transparency. Default is 1.
         * @param color (Optional) Color filter. Default is null.
         * @param blendMode (Optional) Blend mode. Default is null.
         * @param uv (Optional) UV coordinates. Default is undefined.
         * @zh 绘制纹理，相比drawImage功能更强大，性能会差一些
         * @param texture 要绘制的纹理
         * @param x （可选）X轴偏移量。默认为0。
         * @param y （可选）Y轴偏移量。默认为0。
         * @param width （可选）纹理宽度。默认为null。
         * @param height （可选）纹理高度。默认为null。
         * @param matrix （可选）矩阵信息。默认为null。
         * @param alpha （可选）透明度。默认为1。
         * @param color （可选）颜色滤镜。默认为null。
         * @param blendMode （可选）混合模式。默认为null。
         * @param uv （可选）UV坐标。默认为undefined。
         */
        drawTexture(texture: Texture | null, x?: number, y?: number, width?: number, height?: number, matrix?: Matrix | null, alpha?: number, color?: string | null, blendMode?: string | null, uv?: number[]): DrawTextureCmd | null;
        /**
         * @en Batch draw the same texture multiple times.
         * @param texture The texture to draw
         * @param pos Array of positions for each draw
         * @param colors (Optional) Array of colors for each draw
         * @zh 批量绘制同样纹理
         * @param texture 要绘制的纹理
         * @param pos 绘制次数和坐标数组
         * @param colors （可选）图片颜色数组
         */
        drawTextures(texture: Texture, pos: any[], colors?: number[]): DrawTexturesCmd | null;
        /**
         * @en Draw a group of triangles
         * @param texture The texture to use
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param vertices Vertex array
         * @param uvs UV data. Note that the UV coordinates are used directly. If the texture is from an atlas, these UVs are also from the atlas and don't need conversion.
         * @param indices Vertex indices
         * @param matrix (Optional) Scale matrix. Default is null.
         * @param alpha (Optional) Alpha value. Default is 1.
         * @param color (Optional) Color transformation. Default is null.
         * @param blendMode (Optional) Blend mode. Default is null.
         * @zh 绘制一组三角形
         * @param texture 要使用的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param vertices 顶点数组
         * @param uvs UV数据。注意这里的uv是直接使用的，如果texture是图集中的资源，这里的uv也是图集中的，即不需要转换直接用。
         * @param indices 顶点索引
         * @param matrix （可选）缩放矩阵。默认为null。
         * @param alpha （可选）alpha值。默认为1。
         * @param color （可选）颜色变换。默认为null。
         * @param blendMode （可选）混合模式。默认为null。
         */
        drawTriangles(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix?: Matrix | null, alpha?: number, color?: string | number, blendMode?: string | null): DrawTrianglesCmd;
        /**
         * @en Fill with texture
         * @param texture The texture to use for filling
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width (Optional) Width. Default is 0.
         * @param height (Optional) Height. Default is 0.
         * @param type (Optional) Fill type: 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'. Default is 'repeat'.
         * @param offset (Optional) Texture offset. Default is null.
         * @param color (Optional) Color. Default is null.
         * @param percent (Optional) Whether to use percentages. Default is false.
         * @zh 用纹理填充
         * @param texture 用于填充的纹理
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width （可选）宽度。默认为0。
         * @param height （可选）高度。默认为0。
         * @param type （可选）填充类型：'repeat'、'repeat-x'、'repeat-y'或'no-repeat'。默认为'repeat'。
         * @param offset （可选）贴图纹理偏移。默认为null。
         * @param color （可选）颜色。默认为null。
         * @param percent （可选）是否使用百分比。默认为false。
         */
        fillTexture(texture: Texture, x: number, y: number, width?: number, height?: number, type?: string, offset?: Point | null, color?: string, percent?: boolean): FillTextureCmd | null;
        /**
         * @en Set the clipping area. Coordinates outside the clipping area will not be displayed.
         * @param x X-axis offset
         * @param y Y-axis offset
         * @param width Width of the clipping area
         * @param height Height of the clipping area
         * @zh 设置剪裁区域，超出剪裁区域的坐标不显示。
         * @param x X轴偏移量
         * @param y Y轴偏移量
         * @param width 剪裁区域的宽度
         * @param height 剪裁区域的高度
         */
        clipRect(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * @en Draw text on the canvas
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font size and family, e.g., "20px Arial"
         * @param color Defines the text color, e.g., "#ff0000"
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @zh 在画布上绘制文本
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字号和字体，例如"20px Arial"
         * @param color 定义文本颜色，例如"#ff0000"
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         */
        fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd;
        /**
         * @en Draw filled and stroked text on the canvas.
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font and size, e.g., "20px Arial"
         * @param fillColor Defines the text color, e.g., "#ff0000"
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @param lineWidth Width of the stroke line
         * @param borderColor Defines the color of the text stroke
         * @zh 在画布上绘制"被填充且镶边的"文本。
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字体和字号，例如"20px Arial"
         * @param fillColor 定义文本颜色，例如"#ff0000"
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         * @param lineWidth 镶边线条宽度
         * @param borderColor 定义镶边文本颜色
         */
        fillBorderText(text: string | WordText, x: number, y: number, font: string, fillColor: string, textAlign: string, lineWidth: number, borderColor: string): FillTextCmd;
        /**
         * @en Draw text on the canvas (without fill). The default color of the text is black.
         * @param text The text to output on the canvas
         * @param x The x-coordinate where to start drawing the text (relative to the canvas)
         * @param y The y-coordinate where to start drawing the text (relative to the canvas)
         * @param font Defines the font and size, e.g., "20px Arial"
         * @param color Defines the text color, e.g., "#ff0000"
         * @param lineWidth Width of the line
         * @param textAlign Text alignment. Possible values: "left", "center", "right"
         * @zh 在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
         * @param text 在画布上输出的文本
         * @param x 开始绘制文本的x坐标位置（相对于画布）
         * @param y 开始绘制文本的y坐标位置（相对于画布）
         * @param font 定义字体和字号，例如"20px Arial"
         * @param color 定义文本颜色，例如"#ff0000"
         * @param lineWidth 线条宽度
         * @param textAlign 文本对齐方式。可选值："left"、"center"、"right"
         */
        strokeText(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): FillTextCmd;
        /**
         * @en Set the transparency.
         * @param alpha The transparency value
         * @zh 设置透明度。
         * @param alpha 透明度值
         */
        alpha(alpha: number): AlphaCmd;
        /**
         * @en Replace the current transformation matrix for drawing.
         * @param matrix The matrix
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 替换绘图的当前转换矩阵。
         * @param matrix 矩阵
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        transform(matrix: Matrix, pivotX?: number, pivotY?: number): TransformCmd;
        /**
         * @en Rotate the current drawing. (It's recommended to use transform for better performance)
         * @param angle The rotation angle in radians
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 旋转当前绘图。(推荐使用transform，性能更高)
         * @param angle 旋转角度，以弧度计
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        rotate(angle: number, pivotX?: number, pivotY?: number): RotateCmd;
        /**
         * @en Scale the current drawing to a larger or smaller size. (It's recommended to use transform for better performance)
         * @param scaleX Horizontal scaling value
         * @param scaleY Vertical scaling value
         * @param pivotX (Optional) X-coordinate of the pivot point. Default is 0.
         * @param pivotY (Optional) Y-coordinate of the pivot point. Default is 0.
         * @zh 缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
         * @param scaleX 水平方向缩放值
         * @param scaleY 垂直方向缩放值
         * @param pivotX （可选）水平方向轴心点坐标。默认为0。
         * @param pivotY （可选）垂直方向轴心点坐标。默认为0。
         */
        scale(scaleX: number, scaleY: number, pivotX?: number, pivotY?: number): ScaleCmd;
        /**
         * @en Remap the (0,0) position on the canvas.
         * @param tx The value to add to the horizontal coordinate (x)
         * @param ty The value to add to the vertical coordinate (y)
         * @zh 重新映射画布上的 (0,0) 位置。
         * @param tx 添加到水平坐标（x）上的值
         * @param ty 添加到垂直坐标（y）上的值
         */
        translate(tx: number, ty: number): TranslateCmd;
        /**
         * @en Save the current state of the environment.
         * @zh 保存当前环境的状态。
         */
        save(): SaveCmd;
        /**
         * @en Return the previously saved path state and properties.
         * @zh 返回之前保存过的路径状态和属性。
         */
        restore(): RestoreCmd;
        /**
         * @en Replace text color.
         * @param color The new color
         * @zh 替换文本颜色。
         * @param color 新的颜色
         */
        replaceTextColor(color: string): void;
        /**
         * @en Load and display an image.
         * @param url The URL of the image
         * @param x (Optional) The x-coordinate where the image will be displayed. Default is 0.
         * @param y (Optional) The y-coordinate where the image will be displayed. Default is 0.
         * @param width (Optional) The width to display the image. Set to 0 to use the default image width. Default is null.
         * @param height (Optional) The height to display the image. Set to 0 to use the default image height. Default is null.
         * @param complete (Optional) The callback function to be called when the image is loaded
         * @zh 加载并显示一个图片。
         * @param url 图片地址
         * @param x （可选）显示图片的x位置。默认为0。
         * @param y （可选）显示图片的y位置。默认为0。
         * @param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。默认为null。
         * @param height （可选）显示图片的高度，设置为0表示使用图片默认高度。默认为null。
         * @param complete （可选）加载完成回调
         * @blueprintIgnore
         */
        loadImage(url: string, x?: number, y?: number, width?: number, height?: number, complete?: Function | null): void;
        /**
         * @internal
         */
        _render(runner: GraphicsRunner, x?: number, y?: number): void;
        private _check;
        private _renderSpriteTexture;
        /**
         * @en Draw a line.
         * @param fromX X-axis starting position
         * @param fromY Y-axis starting position
         * @param toX X-axis ending position
         * @param toY Y-axis ending position
         * @param lineColor Color of the line
         * @param lineWidth (Optional) Width of the line. Default is 1.
         * @zh 绘制一条线。
         * @param fromX X轴开始位置
         * @param fromY Y轴开始位置
         * @param toX X轴结束位置
         * @param toY Y轴结束位置
         * @param lineColor 线条颜色
         * @param lineWidth （可选）线条宽度。默认为1。
         */
        drawLine(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth?: number): DrawLineCmd;
        /**
         * @en Draw a series of line segments.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for line segments. Format: [x1,y1,x2,y2,x3,y3...]
         * @param lineColor Color of the line segments, or gradient object for filling the drawing
         * @param lineWidth (Optional) Width of the line segments. Default is 1.
         * @zh 绘制一系列线段。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 线段的点集合。格式：[x1,y1,x2,y2,x3,y3...]
         * @param lineColor 线段颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）线段宽度。默认为1。
         */
        drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawLinesCmd | null;
        /**
         * @en Draw a series of curves.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for curves. Format: [controlX, controlY, anchorX, anchorY...]
         * @param lineColor Color of the curves, or gradient object for filling the drawing
         * @param lineWidth (Optional) Width of the curves. Default is 1.
         * @zh 绘制一系列曲线。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 曲线的点集合，格式：[controlX, controlY, anchorX, anchorY...]
         * @param lineColor 曲线颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）曲线宽度。默认为1。
         */
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawCurvesCmd;
        /**
         * @en Draw a rectangle.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param width Width of the rectangle
         * @param height Height of the rectangle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @param percent Whether the position and size are percentage values
         * @returns DrawRectCmd object
         * @zh 绘制矩形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param width 矩形宽度
         * @param height 矩形高度
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         * @param percent 位置和大小是否是百分比值
         * @returns DrawRectCmd对象
         */
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): DrawRectCmd;
        /**
         * @en Draw a rounded rectangle.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param width Width of the rounded rectangle
         * @param height Height of the rounded rectangle
         * @param lt Left-top corner radius
         * @param rt Right-top corner radius
         * @param lb Left-bottom corner radius
         * @param rb Right-bottom corner radius
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @param percent (Optional) Whether the position and size are percentage values
         * @zh 绘制圆角矩形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param width 圆角矩形宽度
         * @param height 圆角矩形高度
         * @param lt 左上圆角
         * @param rt 右上圆角
         * @param lb 左下圆角
         * @param rb 右下圆角
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         * @param percent （可选）位置和大小是否是百分比值
         */
        drawRoundRect(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): DrawRoundRectCmd;
        /**
         * @en Draw a circle.
         * @param x X-axis position of the circle center
         * @param y Y-axis position of the circle center
         * @param radius Radius of the circle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制圆形。
         * @param x 圆点X轴位置
         * @param y 圆点Y轴位置
         * @param radius 半径
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         * @param percent （可选）位置和大小是否是百分比值
         */
        drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): DrawCircleCmd;
        /**
         * @en Draw an ellipse.
         * @param x X-axis position of the ellipse center
         * @param y Y-axis position of the ellipse center
         * @param width Horizontal radius
         * @param height Vertical radius
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing
         * @param lineWidth (Optional) Border width
         * @param percent (Optional) Whether the position and size are percentage values
         * @zh 绘制椭圆形。
         * @param x 圆点X轴位置
         * @param y 圆点Y轴位置
         * @param width 横向半径
         * @param height 纵向半径
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象
         * @param lineWidth （可选）边框宽度
         * @param percent （可选）位置和大小是否是百分比值
         */
        drawEllipse(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * @en Draw a pie.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param radius Radius of the pie
         * @param startAngle Start angle
         * @param endAngle End angle
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制扇形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param radius 扇形半径
         * @param startAngle 开始角度
         * @param endAngle 结束角度
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         */
        drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor?: any, lineWidth?: number): DrawPieCmd;
        /**
         * @en Draw a polygon.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param points Collection of points for the polygon
         * @param fillColor Fill color, or gradient object for filling the drawing
         * @param lineColor (Optional) Border color, or gradient object for filling the drawing. Default is null.
         * @param lineWidth (Optional) Border width. Default is 1.
         * @zh 绘制多边形。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param points 多边形的点集合
         * @param fillColor 填充颜色，或者填充绘图的渐变对象
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。默认为null。
         * @param lineWidth （可选）边框宽度。默认为1。
         */
        drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor?: any, lineWidth?: number): DrawPolyCmd;
        /**
         * @en Draw a path.
         * @param x X-axis position to start drawing
         * @param y Y-axis position to start drawing
         * @param paths Collection of paths. Paths support the following format: [["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]
         * @param brush (Optional) Brush definition, supports the following settings: {fillStyle:"#FF0000"}
         * @param pen (Optional) Pen definition, supports the following settings: {strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}
         * @zh 绘制路径。
         * @param x 开始绘制的X轴位置
         * @param y 开始绘制的Y轴位置
         * @param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]
         * @param brush （可选）刷子定义，支持以下设置：{fillStyle:"#FF0000"}
         * @param pen （可选）画笔定义，支持以下设置：{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}
         */
        drawPath(x: number, y: number, paths: any[], brush?: any, pen?: any): DrawPathCmd;
        /**
         * @en Draw an image with nine-grid
         * @param texture The texture to draw
         * @param x (Optional) X-axis position. Default is 0.
         * @param y (Optional) Y-axis position. Default is 0.
         * @param width (Optional) Width of the image. Default is 0.
         * @param height (Optional) Height of the image. Default is 0.
         * @param sizeGrid Nine-grid information
         * @param color (Optional) Color to tint the image
         * @zh 绘制带九宫格的图片
         * @param texture 要绘制的纹理
         * @param x （可选）X轴位置。默认为0。
         * @param y （可选）Y轴位置。默认为0。
         * @param width （可选）图片宽度。默认为0。
         * @param height （可选）图片高度。默认为0。
         * @param sizeGrid 九宫格信息
         * @param color （可选）图片的着色颜色
         */
        draw9Grid(texture: Texture, x: number, y: number, width: number, height: number, sizeGrid: any[], color?: string): void;
    }
    /**
     * @ignore
     * @en Graphic bounds data class
     * @zh 图形边界数据类
     */
    class GraphicsBounds {
        private _bounds;
        private _bound2;
        private _cached;
        /**
         * @en Destroy
         * @zh 销毁
         */
        destroy(): void;
        /**
         * @en Create a new GraphicsBounds instance
         * @zh 创建一个新的GraphicsBounds实例
         */
        static create(): GraphicsBounds;
        /**
         * @en Reset data
         * @zh 重置数据
         */
        reset(): void;
        /**
         * @en Get the position and size information matrix (CPU intensive, frequent use may cause lag, use sparingly).
         * @returns A Rectangle object composed of position and size.
         * @zh 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @returns 位置与宽高组成的一个Rectangle对象。
         */
        getBounds(g: Graphics): Readonly<Rectangle>;
        /**
         * @en Get the list of boundary points.
         * @returns An array of boundary points.
         * @zh 获取边界点列表。
         * @returns 边界点的数组。
         */
        getBoundPoints(g: Graphics): ReadonlyArray<number>;
        private _getCmdPoints;
    }
    /**
     * @en Graphics command interface
     * @zh 图形命令接口
     * @blueprintableSubclasses
     */
    interface IGraphicsCmd {
        /**
         * @en If true, do not automatically recycle.
         * @zh 如果为true，则不自动回收
         */
        lock?: boolean;
        /**
         *
         * @param runner
         * @param gx
         * @param gy
         */
        run(runner: GraphicsRunner, gx: number, gy: number): void;
        /**
         * @zh 如有回收，实现这个函数
         */
        recover(): void;
        /**
         *
         * @param assembler
         */
        getBounds?(assembler: IGraphicsBoundsAssembler): void;
        /**
         *
         */
        get cmdID(): string;
    }
    /**
     * @blueprintIgnore
     */
    interface IGraphicsBoundsAssembler {
        readonly width: number;
        readonly height: number;
        readonly points: number[];
        flushPoints(dx?: number, dy?: number, matrix?: Matrix): void;
        concatMatrix(matrix: Readonly<Matrix>): void;
    }
    /**
     * @en The Input class is used to create display objects to display and input text.
     * The Input class encapsulates the native text input box. Due to differences between browsers, there may be slight deviations between the position of the default text of this object and the position of the text when the user clicks to input.
     * - Event.INPUT: Dispatched when one or more text characters are input by the user.
     * - Event.CHANGE: Dispatched after the text has changed.
     * - Event.ENTER: Dispatched when the user presses the Enter key in the input field.
     * - Event.FOCUS: Dispatched when the display object receives focus.
     * - Event.BLUR: Dispatched when the display object loses focus.
     * @zh Input 类用于创建显示对象以显示和输入文本。
     * Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。
     * - Event.INPUT: 当用户输入一个或多个文本字符时后调度。
     * - Event.CHANGE: 文本发生变化后调度。
     * - Event.ENTER: 用户在输入框内敲回车键后，将会调度 enter 事件。
     * - Event.FOCUS: 显示对象获得焦点后调度。
     * - Event.BLUR: 显示对象失去焦点后调度。
     */
    class Input extends Text {
        /**
         * @en Regular text field.
         * @zh 常规文本域。
         */
        static readonly TYPE_TEXT: string;
        /**
         * @en Password type for password input fields.
         * @zh password 类型用于密码域输入。
         */
        static readonly TYPE_PASSWORD: string;
        /**
         * @en Email type for input fields that should contain an e-mail address.
         * @zh email 类型用于应该包含 e-mail 地址的输入域。
         */
        static readonly TYPE_EMAIL: string;
        /**
         * @en URL type for input fields that should contain a URL address.
         * @zh url 类型用于应该包含 URL 地址的输入域。
         */
        static readonly TYPE_URL: string;
        /**
         * @en Number type for input fields that should contain a numeric value.
         * @zh number 类型用于应该包含数值的输入域。
         */
        static readonly TYPE_NUMBER: string;
        /**
         * @en Range type for input fields that should contain a numeric value within a certain range.
         * The range type is displayed as a slider.
         * You can also set limitations on the accepted numbers.
         * @zh range 类型用于应该包含一定范围内数字值的输入域。
         * range 类型显示为滑动条。
         * 您还能够设定对所接受的数字的限定。
         */
        static readonly TYPE_RANGE: string;
        /**
         * @en Select day, month, and year.
         * @zh 选取日、月、年。
         */
        static readonly TYPE_DATE: string;
        /**
         * @en Select month and year.
         * @zh month - 选取月、年。
         */
        static readonly TYPE_MONTH: string;
        /**
         * @en Select week and year.
         * @zh week - 选取周和年。
         */
        static readonly TYPE_WEEK: string;
        /**
         * @en Select time (hours and minutes).
         * @zh time - 选取时间（小时和分钟）。
         */
        static readonly TYPE_TIME: string;
        /**
         * @en Select time, day, month, year (UTC time).
         * @zh datetime - 选取时间、日、月、年（UTC 时间）。
         */
        static readonly TYPE_DATE_TIME: string;
        /**
         * @en Select time, day, month, year (local time).
         * @zh datetime-local - 选取时间、日、月、年（本地时间）。
         */
        static readonly TYPE_DATE_TIME_LOCAL: string;
        /**
         * @en Search type for search fields, such as site search or Google search.
         * The search field is displayed as a regular text field.
         * @zh search 类型用于搜索域，比如站点搜索或 Google 搜索。
         * search 域显示为常规的文本域。
         */
        static readonly TYPE_SEARCH: string;
        /**
         * @en The type of the confirm button on the keyboard.
         * @zh 键盘上确认按钮的类型。
         */
        confirmType: 'done' | 'next' | 'search' | 'go' | 'send';
        /**
         * @en The maximum number of characters allowed in the input field. Default is 10000.
         * When setting the character limit, values less than or equal to 0 will set the limit to 10000.
         * @zh 输入框允许的最大字符数量，默认为10000。
         * 设置字符数量限制时，小于等于0的值将会限制字符数量为10000。
         */
        maxChars: number;
        /**
         * @en The restriction on input characters.
         * @zh 对输入字符的限制。
         */
        restrict: string;
        protected _multiline: boolean;
        protected _editable: boolean;
        protected _type: string;
        constructor();
        /**
         * @en Whether it's a multi-line input box.
         * @zh 是否是多行输入框。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * @en Whether the focus is on this instance.
         * Note: On mobile platforms, the keyboard may not immediately pop up when calling the focus interface.
         * On mobile platforms, focus is usually triggered by clicking on the canvas.
         * @zh 焦点是否在此实例上。
         * 注意：在移动平台上，调用 focus 接口可能无法立即弹出键盘。
         * 移动平台上通常是点击画布才会触发焦点。
         */
        get focus(): boolean;
        set focus(value: boolean);
        /**
         * @en The text content of the input field.
         * @zh 输入框的文本内容。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Whether the input text is editable.
         * @zh 输入框文本是否可编辑。
         */
        get editable(): boolean;
        set editable(value: boolean);
        /**
         * @en The prompt text for the input field.
         * @zh 输入框的提示文本。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @en Enter the prompt color.
         * @zh 输入提示文本的颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @en The input field type, which should be one of the Input static constants.
         * Available types include:
         * - TYPE_TEXT
         * - TYPE_PASSWORD
         * - TYPE_EMAIL
         * - TYPE_URL
         * - TYPE_NUMBER
         * - TYPE_RANGE
         * - TYPE_DATE
         * - TYPE_MONTH
         * - TYPE_WEEK
         * - TYPE_TIME
         * - TYPE_DATE_TIME
         * - TYPE_DATE_TIME_LOCAL
         * For platform compatibility, please refer to: http://www.w3school.com.cn/html5/html_5_form_input_types.asp
         * @zh 输入框类型，应为 Input 静态常量之一。
         * 常用类型包括：
         * - TYPE_TEXT
         * - TYPE_PASSWORD
         * - TYPE_EMAIL
         * - TYPE_URL
         * - TYPE_NUMBER
         * - TYPE_RANGE
         * - TYPE_DATE
         * - TYPE_MONTH
         * - TYPE_WEEK
         * - TYPE_TIME
         * - TYPE_DATE_TIME
         * - TYPE_DATE_TIME_LOCAL
         * @zh 平台兼容性请参考：http://www.w3school.com.cn/html5/html_5_form_input_types.asp
         */
        get type(): string;
        set type(value: string);
        /**
         * @en Set the cursor position and select characters.
         * @param startIndex The starting position of the cursor.
         * @param endIndex The ending position of the cursor.
         * @zh 设置光标位置和选取字符。
         * @param startIndex 光标起始位置。
         * @param endIndex 光标结束位置。
         */
        setSelection(startIndex: number, endIndex: number): void;
        /**
         * @en Selects all the text in the current instance.
         * @zh 选中当前实例的所有文本。
         */
        select(): void;
        /** @internal @blueprintEvent */
        Input_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.INPUT]: () => void;
            [Event.ENTER]: () => void;
            [Event.FOCUS]: () => void;
            [Event.BLUR]: () => void;
        };
    }
    class CircleMesh implements IMeshFactory {
        onPopulateMesh(vb: VertexStream): void;
    }
    class FlipMesh implements IMeshFactory {
        flipX: boolean;
        flipY: boolean;
        onPopulateMesh(vb: VertexStream): void;
    }
    /** @blueprintInheritable */
    interface IMeshFactory {
        onPopulateMesh(vb: VertexStream): void;
    }
    function genSliceMesh(vb: VertexStream, contentRect: Readonly<Rectangle>, uvRect: Readonly<Rectangle>, gridRect: Readonly<Rectangle>, tileGridIndice: number): void;
    function genTileMesh(vb: VertexStream, drawRect: Readonly<Rectangle>, uvRect: Readonly<Rectangle>, sourceW: number, sourceH: number, repeatX: boolean, repeatY: boolean): void;
    enum FillMethod {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Radial90 = 3,
        Radial180 = 4,
        Radial360 = 5
    }
    enum FillOrigin {
        Top = 0,
        Bottom = 1,
        Left = 2,
        Right = 3,
        TopLeft = 0,
        TopRight = 1,
        BottomLeft = 2,
        BottomRight = 3
    }
    class ProgressMesh implements IMeshFactory {
        origin: number;
        amount: number;
        clockwise: boolean;
        private _method;
        get method(): FillMethod;
        set method(value: FillMethod);
        onPopulateMesh(vb: VertexStream): void;
    }
    class RegularPolygonMesh implements IMeshFactory {
        sides: number;
        distances: number[];
        rotation: number;
        lineWidth: number;
        lineColor: Color;
        centerColor: Color;
        fillColor: Color;
        onPopulateMesh(vb: VertexStream): void;
    }
    class RoundedRectMesh implements IMeshFactory {
        lt: number;
        rt: number;
        lb: number;
        rb: number;
        onPopulateMesh(vb: VertexStream): void;
    }
    class TileMesh implements IMeshFactory {
        repeatX: boolean;
        repeatY: boolean;
        onPopulateMesh(vb: VertexStream): void;
    }
    type ChildType<T> = T extends Sprite3D ? Sprite3D : T extends GWidget ? GWidget : T extends Scene3D ? Sprite3D : T extends Sprite ? Sprite : Node;
    /**
     * @en The `Node` class is the base class for all objects that can be placed in the display list.
     * The display list manages all objects displayed in the runtime of Laya.
     * Use the Node class to arrange the display list. A Node object can have child display objects.
     * @zh `Node` 类是可放在显示列表中的所有对象的基类。
     * 该显示列表管理 LayaAir 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
     * @blueprintable @blueprintableSubclasses
     */
    class Node extends EventDispatcher {
        protected _bits: number;
        /**
         * @zh 在_setBits里如果改变了这里指定的值的话会同时触发onSetBit方法
         * @en If the value specified here is changed in _setBits, the onSetBit method will be triggered at the same time
         */
        protected _reactiveBits: number;
        protected _hideFlags: number;
        /**
         * @internal
         * @en Child object collection, please do not modify this object directly.
         * @zh 子对象集合，请不要直接修改此对象。
         */
        _children: Node[];
        /**
         * @internal
         * @en Parent node object.
         * @zh 父节点对象。
         */
        _parent: Node;
        /**
         * @internal
         * @en Whether it has been destroyed.
         * @zh 是否已经被销毁。
         */
        _destroyed: boolean;
        /**@internal */
        _conchData: any;
        /**@internal */
        _componentDriver: ComponentDriver;
        /**
         * 0-2D节点，1-3D节点，2-New UI节点
         */
        _nodeType: number;
        /**
         * @internal
         * 可以为节点定义一个容器节点，后续addChild等操作会默认添加到这个容器节点中，而不是本节点
         */
        _$container: Node;
        /**
         * @internal
         * 当节点具有_$container节点后，_$container的孩子节点的_$parent属性指向本节点
         */
        _$parent: Node;
        /**
         * @internal
         * 当节点具有_$container节点后，它的_$children属性会指向_$container的_children
         */
        _$children: Node[];
        /**
         * @internal
         * @en the URL of the resource.
         * @zh 资源的URL。
         */
        _url: string;
        /**
         * @ignore
         * @en Extra data of the node.
         * @zh 节点的额外数据。IDE内部使用。
         */
        _extra: INodeExtra;
        /**
         * @en Node name.
         * @zh 节点名称。
         */
        name: string;
        /**
         * @en Node tag.
         * @zh 节点标签。
         */
        tag: string;
        /**
         * @en The URL of the resource.
         * @zh 资源的URL。
         */
        get url(): string;
        set url(path: string);
        /**
         * @en Hide flags.
         * @zh 隐藏标志。
         */
        get hideFlags(): number;
        set hideFlags(value: number);
        /**
         * @en Whether it is a 3D node, i.e., Scene3D, Sprite3D and their derived classes.
         * @zh 是否是3D节点，即Scene3D、Sprite3D及其衍生类。
         */
        get is3D(): boolean;
        /**
         * @en Whether it has been destroyed. The object cannot be used after being destroyed.
         * @zh 是否已经销毁。对象销毁后不能再使用。
         */
        get destroyed(): boolean;
        /** @ignore  @blueprintIgnore */
        constructor();
        /**
        * @internal
        * @en Initialize the node.
        * @zh 初始化节点。
        */
        _initialize(): void;
        /**
         * @en Set a specific bit of the node.
         * @param bit The bit to set.
         * @param value The value to set, true or false.
         * @return Whether the bit was changed.
         * @zh 设置节点的特定位。
         * @param bit 要设置的位。
         * @param value 要设置的值,true或false。
         * @returns 位是否有变化。
         */
        _setBit(bit: number, value: boolean): boolean;
        /**
         * @en Get a specific bit of the node.
         * @param bit The bit to get.
         * @returns The bit value, true or false.
         * @zh 获取节点的特定位。
         * @param bit 要获取的位。
         * @returns 位的值,true或false。
         */
        _getBit(bit: number): boolean;
        /**
         * @zh 当_setBits设置的目标位包含在reactiveBits中时，会触发onSetBit方法
         * @param bit 要设置的位。
         * @param value 要设置的值,true或false。
         * @en When the target bit set by _setBits is included in reactiveBits, the onSetBit method will be triggered
         * @param bit The bit to set.
         * @param value The value to set, true or false.
         */
        protected _onSetBit(bit: number, value: boolean): void;
        /**
         * @internal
         * @en Set a specific bit up the parent chain.
         * @param type The bit type to set.
         * @zh 向上设置父节点链的特定位。
         * @param type 要设置的位类型。
         */
        _setBitUp(type: number): void;
        /**
         * @en Start listening to a specific event type.
         * This method sets the DISPLAY flag if the event type is DISPLAY or UNDISPLAY and the node is not already marked as displayed.
         * @param type The event type to listen to.
         * @zh 开始监听特定事件类型。
         * 如果事件类型是 DISPLAY 或 UNDISPLAY 且节点尚未标记为显示，则此方法设置 DISPLAY 标志。
         * @param type 要监听的事件类型。
         */
        protected onStartListeningToType(type: string): void;
        /**
         * @en Bubble an event up the parent chain.
         * @param type The event type.
         * @param data The event data. An Event object can be passed.
         * @zh 事件冒泡到父节点链。
         * @param type 事件类型。
         * @param data 事件数据。可以传递一个Event对象。
         */
        bubbleEvent(type: string, data?: any): void;
        /**
         * @en Check whether the node has a specific hide flag.
         * @param flag The hide flag to check.
         * @returns Whether the node has the specified hide flag.
         * @zh 检查节点是否具有特定的隐藏标志。
         * @param flag 要检查的隐藏标志。
         * @returns 节点是否具有指定的隐藏标志。
         */
        hasHideFlag(flag: number): boolean;
        /**
         * @en Destroy this node. When a node is destroyed, it will be removed from its parent node and the references will be cleared, waiting for the garbage collector to recycle it.
         * When destroying a node, its own event listeners, timer listeners, child objects will be removed, and it will be removed from its parent node.
         * @param destroyChild Whether to destroy child nodes as well. If true, all child nodes will be destroyed recursively; otherwise, they will only be removed from the parent.
         * @zh 销毁此节点。destroy对象默认会把自己从父节点移除,并且清理自身引用关系,等待js自动垃圾回收机制回收。destroy后不能再使用。
         * destroy时会移除自身的事情监听,自身的timer监听,移除子对象及从父节点移除自己。
         * @param destroyChild 是否同时销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
        * @en The callback function when the node is destroyed. This is a virtual method. You can override it for custom logic when the node is about to be destroyed.
        * @zh 节点被销毁时执行的回调函数。此方法为虚方法，使用时重写覆盖即可。
         * @blueprintDefaultEvent
        */
        onDestroy(): void;
        /**
         * @en Destroy all child nodes, without destroying the node itself.
         * @zh 销毁所有子节点,但不销毁节点本身。
         */
        destroyChildren(): void;
        /**
         * @en Get children array.
         * @zh 获取子节点数组。
         */
        get children(): ReadonlyArray<Node>;
        /**
         * @en Add a child node.
         * @param node The node to be added as a child.
         * @returns The added child node.
         * @zh 添加子节点。
         * @param node 节点对象。
         * @returns 返回添加的节点。
         */
        addChild<T extends Node>(node: T): T;
        /**
         * @en Add multiple child nodes.
         * @param args A variable number of child nodes to be added.
         * @zh 批量增加子节点。
         * @param args 无数子节点。
         */
        addChildren(...args: Node[]): void;
        /**
         * @en Insert a child node at a specific index.
         * @param node The child node to be inserted.
         * @param index The index at which the child node will be inserted.
         * @returns The inserted child node.
         * @zh 在指定的索引位置插入子节点。
         * @param node 节点对象。
         * @param index 索引位置。
         * @returns 返回添加的节点。
         */
        addChildAt<T extends Node>(node: T, index: number): T;
        /**
         * @en Get the index of a child node.
         * @param node The child node to query.
         * @returns The index of the child node.
         * @zh 获取子节点的索引位置。
         * @param node 子节点。
         * @returns 子节点所在的索引位置。
         */
        getChildIndex(node: Node): number;
        /**
        * @en Get a child node by its name.
        * @param name The name of the child node.
        * @param classType Optional child node type, used to specify the type of the returned child node.
        * @returns The child node with the specified name, or null if not found.
        * @zh 根据子节点的名字获取子节点对象。
        * @param name 子节点的名字。
        * @param classType 可选的子节点类型，用于明确返回子节点的类型。
        * @returns 节点对象。
        */
        getChild<T extends Node = ChildType<this>>(name: string, classType?: new (...args: any[]) => T): T;
        /**
         * @en Same as getChild，recommended to use getChild
         * @param name The name of the child node.
         * @param classType Optional child node type, used to specify the type of the returned child node.
         * @returns The child node with the specified name, or null if not found.
         * @zh 同getChild，推荐使用getChild
         * @param name 子节点的名字。
         * @param classType 可选的子节点类型，用于明确返回子节点的类型。
         * @returns 节点对象。
         */
        getChildByName<T extends Node = ChildType<this>>(name: string, classType?: new (...args: any[]) => T): T;
        /**
         * @en Get a child node by its index.
         * @param index The index of the child node.
         * @param classType Optional child node type, used to specify the type of the returned child node.
         * @returns The child node at the specified index, or null if the index is out of range.
         * @zh 根据子节点的索引位置获取子节点对象。
         * @param index 索引位置。
         * @param classType 可选的子节点类型，用于明确返回子节点的类型。
         * @returns 指定索引处的子节点，如果索引超出范围，则为空。
         */
        getChildAt<T extends Node = ChildType<this>>(index: number, classType?: new (...args: any[]) => T): T;
        /**
         * @en Get the first child node with the specified path. e.g. getChildByPath("A.B.C") is similar to getChild("A") followed by getChild("B") followed by getChild("C").
         * @param path The path of the child node.
         * @param classType Optional child node type, used to specify the type of the returned child node.
         * @returns The child node with the specified path.
         * @zh 获取具有指定路径的第一个子节点。例如 getChildByPath("A.B.C") 类似于 getChild("A") 后跟 getChild("B") 后跟 getChild("C")。
         * @param path 子节点的路径。
         * @param classType 可选的子节点类型，用于明确返回子节点的类型。
         * @returns 指定路径的子节点。
         */
        getChildByPath<T extends Node = ChildType<this>>(path: String, classType?: new (...args: any[]) => T): T;
        /**
         * @en Recursively find child nodes, but will not search nodes inside Prefabs.
         * @param name The name of the child node to find.
         * @param classType Optional child node type, used to specify the type of the returned child node.
         * @returns The child node with the specified name.
         * @zh 递归查找子节点，但不会查找Prefab内部的节点。
         * @param name 要查找的子节点的名称。
         * @param classType 可选的子节点类型，用于明确返回子节点的类型。
         * @returns 指定名称的子节点。
         */
        findChild<T extends Node = ChildType<this>>(name: string, classType?: new (...args: any[]) => T): T;
        /**
         * @en Set the index of a child node.
         * @param node The child node to set the index for.
         * @param index The new index of the child node.
         * @returns The child node itself.
         * @zh 设置子节点的索引位置。
         * @param node 子节点。
         * @param index 新的索引。
         * @returns 返回子节点本身。
         */
        setChildIndex<T extends Node>(node: T, index: number): T;
        /**
         * @zh 设置子节点的索引位置为指定的 index 之前的一个位置。
         * @param node
         * @param index
         * @returns
         * @en Set the index of a child node to the index before the specified index.
         * @param node
         * @param index
         * @returns
         */
        setChildIndexBefore(node: Node, index: number): number;
        /**
         * @internal
         */
        _setChildIndex(node: Node, oldIndex: number, index: number): number;
        /**
         * @en Callback when a child node changes.
         * @param child The child node that has changed.
         * @zh 子节点发生变化时的回调。
         * @param child 发生变化的子节点。
         */
        protected _childChanged(child?: Node): void;
        /**
         * @en Remove a child node.
         * @param node The child node to be removed.
         * @param destroy Whether to destroy the child node. If true, the child node will be destroyed; otherwise, it will only be removed from the parent.
         * @returns The removed node.
         * @zh 删除子节点。
         * @param node 子节点。
         * @param destroy 是否销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         * @returns 被删除的节点。
         */
        removeChild<T extends Node>(node: T, destroy?: boolean): T;
        /**
         * @en Remove itself from its parent node. If it hasn't been added to any parent node, nothing happens.
         * @returns The node itself.
         * @zh 从父容器删除自己,如果已经被删除不会抛出异常。
         * @returns 当前节点。
         */
        removeSelf(): Node;
        /**
         * @en Remove a child node by its name.
         * @param name The name of the child node.
         * @param destroy Whether to destroy the child node. If true, the child node will be destroyed; otherwise, it will only be removed from the parent.
         * @returns The removed node.
         * @zh 根据子节点名字删除对应的子节点对象,如果找不到不会抛出异常。
         * @param name 对象名字。
         * @param destroy 是否销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         * @returns 查找到的节点。
         */
        removeChildByName(name: string, destroy?: boolean): Node;
        /**
         * @en Remove a child node by its index.
         * @param index The index of the child node.
         * @param destroy Whether to destroy the child node. If true, the child node will be destroyed; otherwise, it will only be removed from the parent.
         * @returns The removed node.
         * @zh 根据子节点索引位置,删除对应的子节点对象。
         * @param index 节点索引位置。
         * @param destroy 是否销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         * @returns 被删除的节点。
         */
        removeChildAt(index: number, destroy?: boolean): Node;
        /**
         * @en Remove all children from this node.
         * @param beginIndex The begin index.
         * @param endIndex The end index.
         * @param destroy Whether to destroy the child nodes. If true, all child nodes will be destroyed; otherwise, they will only be removed from the parent.
         * @returns The node itself.
         * @zh 删除指定索引区间的所有子对象。
         * @param beginIndex 开始索引。
         * @param endIndex 结束索引。
         * @param destroy 是否销毁子节点,若值为true,则销毁子节点,否则不销毁子节点。
         * @returns 当前节点对象。
         */
        removeChildren(beginIndex?: number, endIndex?: number, destroy?: boolean): void;
        /**
         * @en Replace a child node.
         * @param newNode The new node to replace the old one.
         * @param oldNode The old node to be replaced.
         * @returns The new node.
         * @zh 替换子节点。
         * @param newNode 新节点。
         * @param oldNode 老节点。
         * @returns 返回新节点。
         */
        replaceChild(newNode: Node, oldNode: Node): Node;
        /**
         * @internal
         * 为节点设置一个容器节点，这样后续addChild等操作会默认添加到这个容器节点中，而不是自身
         */
        _setContainer(container: Node): void;
        /**
         * @internal
         * 当节点成为容器节点后，addChild操作会作用到容器节点上，如果需要添加到自身，可以通过这个方法恢复
         */
        _addChild(node: Node, index?: number): Node;
        /**
         * @internal
         * 当节点成为容器节点后，removeChild操作会作用到容器节点上，如果需要移除自身的孩子，可以通过这个方法恢复
        */
        _removeChild(node: Node): Node;
        /**
         * @en The number of child nodes.
         * @zh 子对象数量。
         */
        get numChildren(): number;
        /**
         * @en The parent node.
         * @zh 父节点。
         */
        get parent(): Node;
        /**
         * @en Check if this node is an ancestor of the given node.
         * @returns True if this node is an ancestor of the given node, false otherwise.
         * @param node The node to check.
         * @zh 检查本节点是否是某个节点的上层节点。
         * @param node 要检查的节点。
         * @returns 一个布尔值，表示本节点是否是某个节点的上层节点。
         */
        isAncestorOf(node: Node): boolean;
        /**
         * @en Set the parent node of the current node.
         * @param value The new parent node.
         * @zh 设置当前节点的父节点。
         * @param value 新的父节点。
         */
        protected _setParent(value: Node): void;
        /**
         * @en Indicates whether the node is displayed in the scene.
         * @zh 表示是否在显示列表中显示。
         */
        get displayedInStage(): boolean;
        /**
         * @internal
         * @en Set the display status of the node.
         * @param value The display status.
         * @zh 设置节点的显示状态。
         * @param value 显示状态。
         */
        _setDisplay(value: boolean): void;
        /**
        * @en Set the display state of a node's children.
        * @param node The node whose children's display state needs to change.
        * @param display The display state to set.
        * @zh 设置指定节点对象的子对象是否可见（是否在渲染列表中）。
        * @param node 节点。
        * @param display 是否可见。
        */
        private _displayChild;
        /**
         * @en Checks whether the current node contains the specified node.
         * @returns A Boolean value indicating whether the current node contains the specified node.
         * @param node The specified node.
         * @zh 当前容器是否包含指定的节点对象。
         * @param node 指定的节点对象。
         * @returns 一个布尔值，表示是否包含指定的节点对象。
         */
        contains(node: Node): boolean;
        /**
         * @en Repeatedly execute a callback function at a fixed interval. This is a wrapper of the `loop` method in the timer property of the node.
         * @param delay The interval between executions, in milliseconds.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @param jumpFrame Whether the callback should be executed when the timer jumps frames. The default value is false. If set to true, the callback will be executed multiple times in a single frame if possible, for performance reasons.
         * @zh 定时重复执行某函数。这是对节点 timer 属性的 `loop` 方法的封装。
         * @param delay 执行间隔时间,以毫秒为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         * @param jumpFrame 时钟是否跳帧。基于时间的循环回调,单位时间间隔内,如能执行多次回调,出于性能考虑,引擎默认只执行一次,设置jumpFrame为true后,则回调会连续执行多次。默认为false。
         */
        timerLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * @en Executes a callback function once after a specified delay.
         * @param delay The delay time, in milliseconds.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 在指定延迟时间后执行一次回调函数。功能同Laya.timer.once()。
         * @param delay 延迟时间,以毫秒为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        timerOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Repeatedly executes a callback function at a fixed interval based on frame rate.
         * @param delay The interval between executions, in frames.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 基于帧率,定时重复执行回调函数。功能同Laya.timer.frameLoop()。
         * @param delay 执行间隔时间,以帧为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Executes a callback function once after a specified delay based on frame rate.
         * @param delay The delay time, in frames.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @param coverBefore Whether to override the previous delayed execution. The default value is true.
         * @zh 基于帧率,在指定延迟时间后执行一次回调函数。功能同Laya.timer.frameOnce()。
         * @param delay 延迟时间,以帧为单位。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         * @param coverBefore 是否覆盖之前的延迟执行,默认为 true。
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Clears a timer.
         * @param caller The execution scope of the callback function (this).
         * @param method The callback function.
         * @zh 清除定时器。功能同Laya.timer.clear()。
         * @param caller 回调函数的执行域(this)。
         * @param method 回调函数。
         */
        clearTimer(caller: any, method: Function): void;
        /**
         * @en Delays the execution of a callback function until the next frame after the current execution block is finished.
         * The callback function will only be executed once. It is generally called before the control is displayed on the screen to delay the calculation of data.
         * @param method The callback function.
         * @param args The parameters passed to the callback function.
         * @zh 在当前执行块完成后,延迟执行回调函数到下一帧。
         * 回调函数只会被执行一次。一般在控件被显示在屏幕之前调用，用于延迟计算数据。
         * @param method 回调函数。
         * @param args 传递给回调函数的参数。
         */
        callLater(method: Function, args?: any[]): void;
        /**
         * @en If there are callback functions delayed by `callLater`, they will be executed immediately.
         * @param method The name of the callback function to be executed, such as `functionName`.
         * @zh 如果有通过 `callLater` 延迟执行的回调函数,将立即执行它们。
         * @param method 要执行的回调函数名称,例如 `functionName`。
         */
        runCallLater(method: Function): void;
        /**
         * @en The component list of this node.
         * @zh 节点的组件列表。
         */
        protected _components: Component[];
        private _activeChangeScripts;
        /**
        * @internal
        * @en The scene this node belongs to.
        * @zh 该节点所属的场景。
        */
        _scene: Node;
        /**
         * @en Get the scene this node belongs to.
         * @zh 获取该节点所属的场景。
         */
        get scene(): Node;
        /**
         * @en Reference to the stage.
         * @zh 对舞台的引用。
         */
        get stage(): Stage;
        /**
         * @en Thether this node is active.
         * @zh 该节点自身是否激活。
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en Whether this node is active in the hierarchy.
         * @zh 该节点在层级中是否激活。
         */
        get activeInHierarchy(): boolean;
        /**
         * @en Actions performed when the node becomes active.
         * @zh 节点激活时执行的操作。
         */
        protected _onActive(): void;
        /**
         * @en Actions performed when the node becomes inactive.
         * @zh 节点停用时执行的操作。
         */
        protected _onInActive(): void;
        /**
         * @en Actions performed when the node is added to the scene.
         * @zh 节点被添加到场景时执行的操作。
         */
        protected _onActiveInScene(): void;
        /**
         * @en Actions performed when the node is removed from the scene.
         * @zh 节点从场景中移除时执行的操作。
         */
        protected _onInActiveInScene(): void;
        /**
         * @en The callback function that is executed when the component is activated, at which point all nodes and components have been created.
         * This is a virtual method that needs to be overridden in the subclass.
         * @zh 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次。
         * 此方法为虚方法，使用时重写覆盖即可。
         * @blueprintDefaultEvent
         */
        onAwake(): void;
        /**
        * @en The callback function that is executed when the component is enabled, such as when a node is added to the stage.
        * This is a virtual method that needs to be overridden in the subclass.
        * @zh 组件被启用后执行，比如节点被添加到舞台后。
        * 此方法为虚方法，使用时重写覆盖即可。
         * @blueprintDefaultEvent
        */
        onEnable(): void;
        /**
         * @en The callback function that is executed when the component is disabled, such as when a node is removed from the stage.
         * This is a virtual method that needs to be overridden in the subclass.
         * @zh 组件被禁用时执行，比如从节点从舞台移除后。
         * 此方法为虚方法，使用时重写覆盖即可。
         * @blueprintDefaultEvent
         */
        onDisable(): void;
        /**
         * @internal
         */
        _parse(data: any, spriteMap: any): void;
        /**
        * @internal
        * @en Set the scene to which the node belongs.
        * @param scene The scene the node belongs to.
        * @zh 设置节点归属的场景。
        * @param scene 节点所属的场景。
        */
        _setBelongScene(scene: Node): void;
        /**
         * @internal
         * @en Unset the node from its belong scene.
         * @zh 从所属场景中移除节点。
         */
        _setUnBelongScene(): void;
        /**
        * @internal
        * @en Processes the active state of the node and its children in the hierarchy.
        * @param active The active state to be set.
        * @param fromSetter Whether the state is set from a setter.
        * @zh 处理节点及其子节点在层级中的激活状态。
        * @param active 设置的激活状态。
        * @param fromSetter 是否由 setter 设置。
        */
        _processActive(active: boolean, fromSetter?: boolean): void;
        /**
         * @internal
         * @en Activate the node and its children within the hierarchy. It marks the node and all its children as active, and adds eligible component scripts to the activation change list.
         * @param activeChangeScripts The list of component scripts affected by the activation change.
         * @zh 在层级中递归地激活节点及其子节点。这个方法将节点及其所有子节点标记为激活状态，并将符合条件的组件脚本添加到激活变更列表中。
         * @param activeChangeScripts 存放激活状态变更的组件脚本列表。
         */
        _activeHierarchy(activeChangeScripts: any[], fromSetter?: boolean): void;
        /**
         * @internal
         * @en Deactivates the current node, its components, and children recursively. Only the scripts that are marked as active will have their references pushed to `activeChangeScripts`.
         * @param activeChangeScripts Array to hold the references of active scripts that are being deactivated.
         * @zh 在层级中递归地停用当前节点、其组件和子节点。只有标记为活动的脚本才会将其引用推送到 `activeChangeScripts` 中。
         * @param activeChangeScripts 用于保存正在被停用的活动脚本的引用的数组。
         */
        _inActiveHierarchy(activeChangeScripts: any[], fromSetter?: boolean): void;
        /**
         * @en Handle the addition of the node to its parent.
         * This method is called when the node is added to a parent node, updating the active state and scene reference if applicable.
         * @zh 处理节点被添加到父节点时的操作。
         * 当节点被添加到父节点时调用此方法，如果适用，更新激活状态和场景引用。
         */
        protected _onAdded(): void;
        /**
         * @en Handle the removal of the node from its parent.
         * This method is called when the node is removed from its parent node, updating the active state and scene reference if applicable.
         * @zh 处理节点从父节点移除时的操作。
         * 当节点从父节点移除时调用此方法，如果适用，更新激活状态和场景引用。
         */
        protected _onRemoved(): void;
        /**
         * @en Add a component instance to the node.
         * @param comp The component instance.
         * @zh 添加组件实例到节点。
         * @param comp 组件实例。
         */
        protected _addComponentInstance(comp: Component): void;
        /**
         * @internal
         * @en Destroy a component on the node.
         * @param comp The component to destroy.
         * @zh 销毁节点上的组件。
         * @param comp 要销毁的组件。
         */
        _destroyComponent(comp: Component): void;
        /**
         * @en Destroy all components on the node.
         * @zh 销毁节点上的所有组件。
         */
        private destroyAllComponent;
        /**
         * @en Handle changes to the node's components.
         * This method is called when a component is added, removed, or all components are destroyed.
         * @param comp The component that was changed.
         * @param action The action performed: 0 for added, 1 for removed, 2 for all destroyed.
         * @zh 处理节点组件的变化。
         * 当组件被添加、移除或所有组件被销毁时调用此方法。
         * @param comp 发生变化的组件。
         * @param action 执行的操作：0 表示添加，1 表示移除，2 表示全部销毁。
         */
        protected _componentsChanged?(comp: Component, action: 0 | 1 | 2): void;
        /**
        * @internal
        * @en Clones the components from the current node to the destination object.
        * @param destObject The destination object to clone the components to.
        * @zh 将当前节点的组件克隆到指定的目标对象中。
        * @param destObject 要克隆组件到的目标对象。
        */
        _cloneTo(destObject: Node, srcRoot: Node, dstRoot: Node): void;
        /**
         * @en Add a component instance to the node.
         * @param component The component instance.
         * @returns The added component instance.
         * @zh 添加组件实例到节点。
         * @param component 组件实例。
         * @returns 添加的组件实例。
         */
        addComponentInstance(component: Component): Component;
        /**
         * @en Add a component to the node.
         * @param componentType The type of the component.
         * @returns The added component instance.
         * @zh 添加组件到节点。
         * @param componentType 组件类型。
         * @returns 添加的组件实例。
         */
        addComponent<T extends Component>(componentType: new () => T): T;
        /**
         * @en Get a component instance by type. Returns null if not found.
         * @param componentType The type of the component.
         * @returns The component instance.
         * @zh 根据类型获取组件实例。如果没有找到则返回null。
         * @param componentType 组件类型。
         * @returns 组件实例。
         */
        getComponent<T extends Component>(componentType: new () => T): T;
        /**
         * @en Get all component instances on the node.
         * @returns An array of component instances.
         * @zh 获取节点上的所有组件实例。
         * @returns 组件实例数组。
         */
        get components(): ReadonlyArray<Component>;
        /**
         * @en Get all component instances by type. Returns an empty array if none are found.
         * @param componentType The type of the component.
         * @returns An array of component instances.
         * @zh 根据类型获取所有组件实例。如果没有找到则返回空数组。
         * @param componentType 组件类型。
         * @returns 组件实例数组。
         */
        getComponents(componentType: typeof Component): Component[];
        /**
         * @en Get the timer associated with the node.
         * @returns The timer.
         * @zh 获取与节点关联的计时器。
         * @returns 计时器。
         */
        get timer(): Timer;
        /**
         * @en Called after deserialization.
         * @zh 反序列化后调用。
         * @blueprintIgnore
         */
        onAfterDeserialize(): void;
    }
    interface INodeExtra {
    }
    /**
     * @en OpenDataContext component for displaying OpenData in WeChat mini-games. Instantiate this component directly to optimally display OpenData based on the component's width, height, and position.
     * @zh 微信小游戏开放数据域显示组件，直接实例化本组件，即可根据组件宽高和位置，以最优的方式显示开放数据域数据。
     */
    class OpenDataContextView extends Sprite {
        private _fps;
        private _widget;
        private _canvas;
        /** @ignore */
        constructor();
        /**
         * @en The frame rate.
         * @zh 帧率。
         */
        get fps(): number;
        set fps(value: number);
        /**
         * @ignore
         */
        _onActive(): void;
        /**
         * @ignore
         */
        _onInActive(): void;
        /**
         * @en The vertical distance (in pixels) between the top edge of the component and the top edge of its content area.
         * @zh 从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。
         */
        get top(): number;
        set top(value: number);
        /**
         * @en The vertical distance (in pixels) between the bottom edge of the component and the bottom edge of its content area.
         * @zh 从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The horizontal distance (in pixels) between the left edge of the component and the left edge of its content area.
         * @zh 从组件左边到其内容区域左边之间的水平距离（以像素为单位）。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The horizontal distance (in pixels) between the right edge of the component and the right edge of its content area.
         * @zh 从组件右边到其内容区域右边之间的水平距离（以像素为单位）。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance (in pixels) between the horizontal axis of this object and the horizontal center line of its parent container.
         * @zh 在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance (in pixels) between the vertical axis of this object and the vertical center line of its parent container.
         * @zh 在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
        private _getWidget;
        private _onLoop;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        updateViewPort(): void;
        /**
         * @en Send a message to the OpenData context.
         * @param msg Message to send.
         * @zh 向开放数据域发送消息。
         * @param msg 要发送的消息。
         */
        postMsg(msg: any): void;
    }
    /**
     * @en Post-process effects for 2D rendering.
     * @zh 2D 渲染的后期处理效果。
     */
    class PostProcess2D extends EventDispatcher {
        private _effects;
        private _enabled;
        /**@internal */
        _context: PostProcessRenderContext2D;
        /**@internal */
        _hasCleanRT: boolean;
        /**@internal */
        static init(): void;
        get enabled(): boolean;
        set enabled(value: boolean);
        constructor();
        private _owner;
        /**
         * @en The owner of the post-processing effect.
         * @zh 后期处理效果的拥有者。
         */
        get owner(): Sprite;
        set owner(value: Sprite);
        /** @internal */
        _checkEnabled(): boolean;
        /**
         * @en Refresh render
         * @zh 刷新渲染
         */
        _onChangeRender(): void;
        /**
          * @en Get a post-processing instance based on its type.
          * @param classReg The registered post-processing class type.
          * @returns The post-processing effect instance, or null if not found.
          * @zh 根据类型获取后期处理实例。
          * @param classReg 注册的后期处理类型
          * @returns 后期处理效果实例，如果没有找到则返回null
          */
        getEffect<T extends PostProcess2DEffect>(classReg: new () => T): T;
        setResource(value: RenderTexture2D): void;
        getDestRT(): RenderTexture2D;
        /**
          * @en Set the array of post-process effects.IDE main
          * @zh 设置后期处理效果数组。
          */
        get effects(): PostProcess2DEffect[];
        set effects(value: PostProcess2DEffect[]);
        /**
         * @en Add a post-processing effect.
         * @param effect The post-processing effect to add.
         * @zh 添加一个后期处理效果。
         * @param effect 要添加的后期处理效果。
         */
        addEffect<T extends PostProcess2DEffect>(effect: T): T | null;
        /**
         * @en Remove a post-processing effect.
         * @param effect The post-processing effect to remove.
         * @zh 移除一个后期处理效果。
         * @param effect 要移除的后期处理效果。
         */
        removeEffect(effect: PostProcess2DEffect): void;
        /**
         * @en Render the post-processing effects.
         * @zh 渲染后期处理效果。
         */
        _render(): void;
        /**
         * @en Clear all post-processing effects.
         * @zh 清除所有后期处理效果。
         */
        clear(): void;
        /**
         * @en Clear the post-processing command buffer.
         * @zh 清除后期处理指令流。
         */
        clearCMD(): void;
        /**
         * @en Destroy the post-processing instance.
         * @zh 销毁后期处理实例。
         */
        /**
         * @en Recover all RTs used in post-processing effects.
         * @zh 回收后处理效果中使用的所有RT。
         */
        recoverAllRTS(): void;
        apply(): void;
        destroy(): void;
    }
    /** @ignore @blueprintIgnore */
    class PostProcessRenderContext2D {
        /**
         * @en The original RenderTexture that is rendered to initially. Do not modify this RT.
         * @zh 原始渲染 RenderTexture (RT)，禁止改变此 RT。
         */
        source: RenderTexture2D;
        /**
         * @en forward effect target
         * @zh 上个后期处理的结果
         */
        indirectTarget: RenderTexture2D;
        /**
         * @en The RenderTexture where the processed result should be drawn to.
         * @zh 需要将处理后的结果画入此 RenderTexture。
         */
        destination: RenderTexture2D;
        /**
         * @en The composite shader data.
         * @zh 合成着色器数据。
         */
        compositeShaderData: ShaderData;
        /**
         * @en The post-processing command buffer.
         * @zh 后期处理指令流。
         */
        command: CommandBuffer2D;
        /**
         * @en Temporary texture array. You can put created textures here or select an RT to use from here to save memory.
         * @zh 临时纹理数组。可以将创建的纹理放入此数组，也可以从这里选取要用的 RT 来节省显存。
         */
        deferredReleaseTextures: RenderTexture2D[];
        /**
         * 顶点偏移值，在后处理中扩张rt的时候会累加
         */
        oriOffset: Vector2;
        /**
          * @en Selects an RT from recycled RTs to save memory.
          * @param width The width of the RenderTexture.
          * @param height The height of the RenderTexture.
          * @param colorFormat The color format of the RenderTexture.
          * @param depthFormat The depth format of the RenderTexture.
          * @returns The selected RenderTexture or null if no match is found.
          * @zh 从回收的 RT 中选择一个 RT 用来节省内存。
          * @param width 纹理的宽度。
          * @param height 纹理的高度。
          * @param colorFormat 纹理的颜色格式。
          * @param depthFormat 纹理的深度格式。
          * @returns 选择到的 RenderTexture，如果没有匹配的，则返回 null。
          */
        getRenderTexture(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat): RenderTexture2D;
        /**
         * @internal
         * @en Apply post-processing effects and recycle unused textures.
         * @zh 应用后处理效果并回收纹理。
         */
        _apply(): void;
    }
    abstract class PostProcess2DEffect {
        protected _active: boolean;
        protected _owner: PostProcess2D;
        destroyed: boolean;
        protected _singleton: boolean;
        /**
         * @internal
         * @en Whether only one instance of the effect can be added.
         * @zh 是否只能添加一个效果实例。
         */
        get singleton(): boolean;
        /**
         * @en Whether the effect is enabled.
         * @zh 效果是否开启。
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * @en Called when added to the post-processing stack.
         * @param postprocess The post-processing component.
         * @zh 在添加到后期处理栈时调用。
         * @param postprocess 后期处理组件。
         */
        abstract effectInit(postprocess: PostProcess2D): void;
        /**
         * @en Renders the effect.
         * @param context The post-processing rendering context.
         * @zh 渲染效果。
         * @param context 后期处理渲染上下文。
         */
        abstract render(context: PostProcessRenderContext2D): void;
        /**
         * @en Clears the render texture.
         * @param context The post-processing rendering context.
         * @zh 清理渲染纹理。
         * @param context 后期处理渲染上下文。
         */
        abstract clearRT(context: PostProcessRenderContext2D): void;
        /**
         * @en Destroys the effect.
         * @zh 销毁效果。
         */
        destroy(): void;
    }
    /**
     * @blueprintIgnore
     */
    class Render2DProcessor {
        static rendercontext2D: IRenderContext2D;
        static runner: GraphicsRunner;
        static __init__(): void;
        private _manager;
        private _basePass;
        get basePass(): IRender2DPass;
        constructor();
        /**
         * 添加一个渲染 Pass
         * @param pass IRender2DPass 实例
         */
        addPass(pass: IRender2DPass): void;
        /**
         * 移除一个渲染 Pass
         * @param pass IRender2DPass 实例
         */
        removePass(pass: IRender2DPass): void;
        /**
         * 渲染所有 Pass
         * @param context2D 2D 渲染上下文
         */
        apply(context2D: IRenderContext2D): void;
        /**
         * 清空所有 Pass
         */
        clear(): void;
    }
    /** @blueprintIgnore */
    interface ILight2DManager {
        preRenderUpdate(): void;
        addRender(node: BaseRenderNode2D): void;
        removeRender(node: BaseRenderNode2D): void;
        _getLayerUpdateMark(layer: number): number;
        _updateShaderDataByLayer(layer: number, shaderData: any): void;
    }
    /**
     * @en Scene class, responsible for scene creation, loading, destruction and other functions.
     * After the scene is removed from the node, it will not be automatically recycled by the garbage mechanism. If you want to recycle it, please call the destroy interface.
     * You can view the list of scenes that have not been destroyed through the unDestroyedScenes property.
     * @zh 场景类，负责场景创建、加载、销毁等功能。
     * 场景被从节点移除后，并不会被自动垃圾机制回收。如果想回收，请调用 destroy 接口。
     * 可以通过 unDestroyedScenes 属性查看还未被销毁的场景列表。
     */
    class Scene extends Sprite {
        static scene2DUniformMap: CommandUniformMap;
        /**创建后，还未被销毁的场景列表，方便查看还未被销毁的场景列表，方便内存管理，本属性只读，请不要直接修改*/
        /**
         * @en List of scenes that have been created but not yet destroyed. This property is read-only, please do not modify it directly.
         * @zh 创建后还未被销毁的场景列表。此属性只读，请不要直接修改。用于方便查看未销毁的场景列表，便于内存管理。
         */
        static readonly unDestroyedScenes: Set<Scene>;
        /**
         * @en Get the root node
         * @zh 获取根节点
         * */
        private static _root;
        private static _loadPage;
        /** 场景组件管理表 */
        private static componentManagerMap;
        /**
         * 注册场景内的管理器
         * @param type 管理器类型
         * @param cla 实例
         */
        static regManager(type: string, cla: new (scene: Scene) => IElementComponentManager): void;
        /** @internal */
        static __init__(): void;
        /**
         * @en Whether to automatically destroy (destroy nodes and used resources) after the scene is closed, default is false
         * @zh 场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为 false
         */
        autoDestroyAtClosed: boolean;
        /** @internal */
        _idMap?: any;
        /** @internal */
        _scene3D: Scene3D;
        /** @internal */
        _area2Ds: Set<Area2D>;
        /**
         * @en relative layout component
         * @zh 相对布局组件
         */
        protected _widget: Widget;
        /**
         * @en The scene clock
         * @zh 场景时钟
         */
        private _timer;
        /** @internal */
        _componentElementDatasMap: any;
        /**@internal */
        _specialManager: Scene2DSpecialManager;
        /**@internal */
        _light2DManager: ILight2DManager;
        /**@internal */
        _globalRenderData: I2DGlobalRenderData;
        constructor();
        /** @internal */
        set componentElementDatasMap(value: any);
        /** @internal */
        get componentElementDatasMap(): any;
        _update(): void;
        /**
         * 获得某个组件的管理器
         * @param type 组件管理类
         */
        getComponentElementManager(type: string): IElementComponentManager;
        /**
         * @deprecated
         * @en Get the node instance based on the node ID in the IDE.
         * @param id The node ID.
         * @zh 根据IDE内的节点id，获得节点实例。
         * @param id 节点ID。
         */
        getNodeByID(id: number): any;
        /**
         * @en Open the scene. Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param closeOther Whether to close other scenes, default is true (optional).
         * @zh 打开场景。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。
         */
        open(closeOther?: boolean): void;
        /**
         * @en Open the scene. Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param closeOther Whether to close other scenes, default is true (optional).
         * @param param Parameters for opening the page, will be passed to the onOpened method (optional).
         * @zh 打开场景。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。
         * @param param 打开页面的参数，会传递给onOpened方法（可选）。
         */
        open(closeOther?: boolean, param?: any): void;
        /**
         * @en Called after the scene is opened (if there is a pop-up animation, it will be executed after the animation is completed).
         * @param param Parameters.
         * @zh 场景打开完成后调用此方法（如果有弹出动画，则在动画完成后执行）。
         * @param param 参数。
         * @blueprintEvent
         */
        onOpened(param: any): void;
        /**
         * @en Close the scene. Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param type The reason for closing, which will be passed to the onClosed function.
         * @zh 关闭场景。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param type 关闭的原因，会传递给onClosed函数。
         */
        close(type?: string): void;
        /**
         * @en Called after the scene is closed (if there is a closing animation, it will be executed after the animation is completed).
         * @param type If triggered by clicking the default close button, pass the name of the close button, otherwise null.
         * @zh 关闭完成后调用此方法（如果有关闭动画，则在动画完成后执行）。
         * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
         * @blueprintEvent
         */
        onClosed(type?: string): void;
        /**
         * @en Destroy the scene.
         * @param destroyChild Whether to delete child nodes.
         * @zh 场景销毁。
         * @param destroyChild 是否删除子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Scene clock
         * @zh 场景时钟
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * @en 3D scene instances included in the scene
         * @zh 场景包含的3D场景实例
         */
        get scene3D(): Scene3D;
        /**
         * @en The vertical distance (in pixels) between the top edge of the component and the top edge of its content area.
         * @zh 从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。
         */
        get top(): number;
        set top(value: number);
        /**
         * @en The vertical distance (in pixels) between the bottom edge of the component and the bottom edge of its content area.
         * @zh 从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The horizontal distance (in pixels) between the left edge of the component and the left edge of its content area.
         * @zh 从组件左边到其内容区域左边之间的水平距离（以像素为单位）。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The horizontal distance (in pixels) between the right edge of the component and the right edge of its content area.
         * @zh 从组件右边到其内容区域右边之间的水平距离（以像素为单位）。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance (in pixels) between the horizontal axis of this object and the horizontal center line of its parent container.
         * @zh 在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance (in pixels) between the vertical axis of this object and the vertical center line of its parent container.
         * @zh 在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
        /**
         * @internal
         * @param ctx
         * @param x
         * @param y
         */
        render(x: number, y: number): void;
        setglobalRenderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @internal
         * @param ctx
         * @param x
         * @param y
         */
        _preRenderUpdate(x: number, y: number): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected _sizeChanged(): void;
        protected _onAdded(): void;
        protected _onRemoved(): void;
        /**
         * @deprecated
         * @en Repositioning
         * @zh 重新排版
         */
        freshLayout(): void;
        /**
         * @en Repositioning
         * @zh 重新排版
         */
        refreshLayout(): void;
        /**
         * @en Get the layout style of the object. Please do not directly modify this object
         * @zh 获取对象的布局样式。请不要直接修改此对象
         */
        private _getWidget;
        /**
         * @en Get the root container of the scene.
         * @zh 获取场景根容器
         */
        static get root(): Sprite;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.HIERARCHY)
         * @en Load the scene and resources used by the scene.
         * @param url The scene address.
         * @param complete Callback function when loading is complete, returns the scene instance (optional).
         * @param progress Callback function for loading progress (optional).
         * @zh 加载场景及场景使用到的资源。
         * @param url 场景地址。
         * @param complete 加载完成回调，返回场景实例（可选）。
         * @param progress 加载进度回调（可选）。
         */
        static load(url: string, complete: Handler, progress?: Handler): Promise<Scene>;
        /**
         * @en Load and open the scene.
         * @param url The scene address.
         * @param closeOther Whether to close other scenes, default is true (optional). Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param param Parameters for opening the page, will be passed to the onOpened method (optional).
         * @param complete Callback function when opening is complete, returns the scene instance (optional).
         * @param progress Callback function for loading progress (optional).
         * @zh 加载并打开场景。
         * @param url 场景地址。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param param 打开页面的参数，会传递给onOpened方法（可选）。
         * @param complete 打开完成回调，返回场景实例（可选）。
         * @param progress 加载进度回调（可选）。
         */
        static open(url: string, closeOther?: boolean, param?: any, complete?: Handler, progress?: Handler): Promise<Scene>;
        /**
         * @en Load and open the scene.
         * @param url The scene address.
         * @param closeOther Whether to close other scenes, default is true (optional). Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @param complete Callback function when opening is complete, returns the scene instance (optional).
         * @param progress Callback function for loading progress (optional).
         * @zh 加载并打开场景。
         * @param url 场景地址。
         * @param closeOther 是否关闭其他场景，默认为true（可选）。注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         * @param complete 打开完成回调，返回场景实例（可选）。
         * @param progress 加载进度回调（可选）。
         */
        static open(url: string, closeOther?: boolean, complete?: (scene: Scene) => void, progress?: ProgressCallback): Promise<Scene>;
        private static _load;
        /**
         * @en Close the scene (including dialog) based on the address.
         * @param url The scene address.
         * @param name If name is not empty, it must match to close the scene.
         * @returns Returns whether the closure was successful. If the url is not found, it will not be successful.
         * @zh 根据地址，关闭场景（包括对话框）。
         * @param url 场景地址。
         * @param name 如果name不为空，name必须相同才能关闭。
         * @returns 返回是否关闭成功，如果url找不到，则不成功。
         */
        static close(url: string, name?: string): boolean;
        /**
         * @en Close all scenes, not including dialogs. To close dialogs, please use Dialog.closeAll().
         * Note: If the closed scene has not set autoDestroyAtRemoved=true, resources may not be reclaimed and need to be manually reclaimed.
         * @zh 关闭所有场景，不包括对话框。如果要关闭对话框，请使用Dialog.closeAll()。
         * 注意：被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收。
         */
        static closeAll(): void;
        /**
         * @en Destroy the scene (including dialog) based on the address.
         * @param url The scene address.
         * @param name If name is not empty, it must match to destroy the scene.
         * @returns Returns whether the destruction was successful. If the url is not found, it will not be successful.
         * @zh 根据地址，销毁场景（包括对话框）。
         * @param url 场景地址。
         * @param name 如果name不为空，name必须相同才能销毁。
         * @returns 返回是否销毁成功，如果url找不到，则不成功。
         */
        static destroy(url: string, name?: string): boolean;
        /**
         * @en Destroy currently unused resources. This function will ignore resources with lock=true.
         * @zh 销毁当前没有被使用的资源，该函数会忽略lock=true的资源。
         */
        static gc(): void;
        /**
         * @en Set the loading interface. The engine will delay opening the loading interface after calling the open method, and close the loading interface after the page is added to the stage.
         * @param loadPage The loading page instance.
         * @zh 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面。
         * @param loadPage load界面实例。
         */
        static setLoadingPage(loadPage: Sprite): void;
        /**
         * @en Display the loading interface.
         * @param param Opening parameters. If it's a scene, it will be passed to the onOpened method.
         * @param delay Delay opening time, default is 500 milliseconds.
         * @zh 显示loading界面。
         * @param param 打开参数，如果是scene，则会传递给onOpened方法。
         * @param delay 延迟打开时间，默认500毫秒。
         */
        static showLoadingPage(param?: any, delay?: number): void;
        private static _showLoading;
        private static _hideLoading;
        /**
         * @en Hide the loading interface.
         * @param delay Delay closing time, default is 500 milliseconds.
         * @zh 隐藏loading界面。
         * @param delay 延迟关闭时间，默认500毫秒。
         */
        static hideLoadingPage(delay?: number): void;
    }
    class Camera2D extends Sprite {
        /**@internal */
        static shaderValueInit(): void;
        /**@internal */
        static VIEW2D: number;
        /**@internal */
        static SHADERDEFINE_CAMERA2D: ShaderDefine;
        private _cameraPos;
        private _cameraSmoothPos;
        private _firstUpdate;
        private _cameraMatrix;
        private _cameraInvertMatrix;
        private _ignoreRotation;
        private _limit_Left;
        private _limit_Right;
        private _limit_Bottom;
        private _limit_Top;
        private _dragHorizontalEnable;
        private _dragVerticalEnable;
        private _drag_Left;
        private _drag_Right;
        private _drag_Top;
        private _drag_Bottom;
        private _positionSmooth;
        private _positionSpeed;
        /**@internal TODO*/
        _renderTarget: RenderTexture;
        /**@internal */
        _isMain: boolean;
        /**@internal */
        _cameraRotation: number;
        /**
         * @en Whether to ignore rotation, if the value is true, the rotation value of camera2d will always be 0
         * @returns The x coordinate value.
         * @zh 是否忽略旋转，如果值是true，camera2d的旋转值始终为0
         * @returns 忽略旋转的值
         */
        get ignoreRotation(): boolean;
        set ignoreRotation(value: boolean);
        /**
        * @en Scnene's main camera? Only one main camera can be used in a scene
        * @returns value
        * @zh 场景的主摄像机，一个场景中只能有一个主摄像机
        * @returns 是否为主相机
        */
        get isMain(): boolean;
        set isMain(value: boolean);
        /**
         * @ignore
         */
        _setUnBelongScene(): void;
        protected _findOwnerArea(): void;
        private _zoom;
        get zoom(): Vector2;
        set zoom(value: Vector2);
        /** @internal min_x max_x min_y max_y */
        _rect: Vector4;
        get limit_Left(): number;
        set limit_Left(value: number);
        get limit_Right(): number;
        set limit_Right(value: number);
        get limit_Bottom(): number;
        set limit_Bottom(value: number);
        get limit_Top(): number;
        set limit_Top(value: number);
        get positionSmooth(): boolean;
        set positionSmooth(value: boolean);
        get positionSpeed(): number;
        set positionSpeed(value: number);
        rotationSmooth: boolean;
        rotationSpeed: number;
        get dragHorizontalEnable(): boolean;
        set dragHorizontalEnable(value: boolean);
        get dragVerticalEnable(): boolean;
        set dragVerticalEnable(value: boolean);
        get drag_Left(): number;
        set drag_Left(value: number);
        get drag_Right(): number;
        set drag_Right(value: number);
        get drag_Top(): number;
        set drag_Top(value: number);
        get drag_Bottom(): number;
        set drag_Bottom(value: number);
        /**
         * @en The layer to be rendered
         * @zh 渲染层
         */
        visiableLayer: number;
        get cameraMatrix(): Matrix3x3;
        private _viewRect;
        getCameraPos(): Vector2;
        /**
         * TODO 功能
         * Camera 的cull功能
         * rotationSmooth、rotationSpeed功能
         * zoom功能
         * RenderTarget功能
         * @ignore
         */
        constructor();
        /**
         * 获得viewPort大小
         * @returns
         */
        private _getScreenSize;
        onEnable(): void;
        onDisable(): void;
        private _onTransChanged;
        /**
         * @internal
         * @returns
         */
        _getCameraTransform(): Matrix3x3;
    }
    class Graphic2DDynamicVIBuffer {
        static MAX_VERTEX: number;
        static DEFAULT_BLOCK_SIZE: number;
        private _bufferState;
        private _vertexBuffer;
        private _indexBuffer;
        private _wholeVertex;
        private _wholeIndex;
        private _vertexBlockSize;
        private _vertexBlockLength;
        private _canVBlockCount;
        private _vertexViews;
        private _indexBufferLength;
        private _indexBufferMaxLength;
        private _vertexFreeBlocks;
        private _vertexDeclaration;
        private _vertexElementLength;
        private _vertexStride;
        /** @internal 临时顶点数据 */
        _tempVertexData: Float32Array;
        get vertexBuffer(): IVertexBuffer;
        get indexBuffer(): IIndexBuffer;
        get bufferState(): IBufferState;
        constructor(vertexBlockSize: number, vertexDeclaration: VertexDeclaration);
        resizeVertexBuffer(blockSize: number): void;
        resizeIndexBuffer(size: number): void;
        indexExtendBlock(length: number): void;
        /**
         * 检查顶点缓冲区是否有足够空间
         * @param vertexCount 需要的长度
         * @returns 使用的blocks，如果空间不足则返回null
         */
        checkVertexBuffer(vertexCount: number): any;
        /**
         * 检查索引缓冲区是否有足够空间
         * @param length 需要的长度
         * @returns 包含数据视图和使用的blocks的对象，如果空间不足则返回null
         */
        checkIndexBuffer(length: number): I2DGraphicIndexDataView;
        private _releaseBlocks;
        /**
         * 释放顶点缓冲区块
         * @param blocks 要释放的blocks数组
         */
        releaseVertexBlocks(blocks: number[]): void;
        /**
         * 准备释放索引缓冲区块
         * @param indexView 要回收的索引缓冲区块
         */
        /**
         * 释放索引缓冲区块
         * @param indexView 要释放的索引缓冲区块
         */
        releaseIndexView(indexView: I2DGraphicIndexDataView): void;
        /**
         * 效果存疑
         * 清除池子内的索引缓冲区块
         */
        /**
         * 清理所有数据
         */
        clear(): void;
        /**
         * 销毁资源
         */
        destroy(): void;
    }
    /** @ignore @blueprintIgnore */
    class GraphicsRunner {
        private _alpha;
        _material: Material;
        private _fillStyle;
        private _strokeStyle;
        private static SEGNUM;
        private _tempUV;
        private _drawTriUseAbsMatrix;
        private _other;
        private _path;
        _curSubmit: SubmitBase;
        _submitKey: SubmitKey;
        _graphicsData: GraphicsRenderData;
        private _transedPoints;
        private _temp4Points;
        _clipRect: Rectangle;
        _globalClipMatrix: Matrix;
        _clip_x: number;
        _clip_y: number;
        _clipInfoID: number;
        private _clipID_Gen;
        private _meshPool;
        _matrixChanged: boolean;
        _curMat: Matrix;
        _matBuffer: Float32Array;
        _lastMatScaleX: number;
        _lastMatScaleY: number;
        private _lastMat_a;
        private _lastMat_b;
        private _lastMat_c;
        private _lastMat_d;
        _nBlendType: BlendMode;
        _save: ISaveData[] & {
            _length?: number;
        };
        _saveMark: SaveMark | null;
        /**
         * 所cacheAs精灵
         * 对于cacheas bitmap的情况，如果图片还没准备好，需要有机会重画，所以要保存sprite。例如在图片
         * 加载完成后，调用repaint
         */
        sprite: Sprite | null;
        _textRender: TextRender | null;
        _italicDeg: number;
        _lastTex: Texture | null;
        _defTexture: Texture | null;
        drawTexAlign: boolean;
        constructor();
        /**@private */
        get lineJoin(): string;
        /**@private */
        set lineJoin(value: string);
        /**@private */
        get lineCap(): string;
        /**@private */
        set lineCap(value: string);
        /**@private */
        get miterLimit(): string;
        /**@private */
        set miterLimit(value: string);
        /**
         * 添加需要touch的资源
         * @param res
         */
        touchRes(res: IAutoExpiringResource): void;
        /**
         * 添加需要引用的资源
         * @param res
         */
        referenceRes(res: Resource): void;
        transformByMatrix(matrix: Matrix, tx: number, ty: number): void;
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number): void;
        alpha(value: number): void;
        /**@internal */
        _transform(mat: Matrix, pivotX: number, pivotY: number): void;
        /**@internal */
        _rotate(angle: number, pivotX: number, pivotY: number): void;
        /**@internal */
        _scale(scaleX: number, scaleY: number, pivotX: number, pivotY: number): void;
        /**@internal */
        _drawLine(x: number, y: number, fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number, vid: number): void;
        /**@internal */
        _drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth: number, vid: number): void;
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number): void;
        private _fillAndStroke;
        /**@internal */
        _drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor: any, lineWidth: number, vid: number): void;
        /**@internal */
        _drawEllipse(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number): void;
        /**@internal */
        _drawRoundRect(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor: any, lineWidth: number): void;
        /**@internal */
        _drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any, lineWidth: number, vid: number): void;
        /**@internal */
        _drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor: any, lineWidth: number, isConvexPolygon: boolean, vid: number): void;
        /**@internal */
        _drawPath(x: number, y: number, paths: any[], brush: any, pen: any): void;
        /**
         * 释放所有资源
         */
        destroy(): void;
        clear(): void;
        /**
         * @zh 获取当前的 X 方向缩放
         * @returns 当前的 X 方向缩放
         * @en Get the current X-axis scaling
         * @returns The current X-axis scaling
         */
        getCurrentScaleX(): number;
        /**
         * @zh 获取当前的 Y 方向缩放
         * @returns 当前的 Y 方向缩放
         * @en Get the current Y-axis scaling
         * @returns The current Y-axis scaling
         */
        getCurrentScaleY(): number;
        /**
         * 获得当前矩阵的缩放值
         * 避免每次都计算getScaleX
         * @return
         */
        getMatScaleX(): number;
        getMatScaleY(): number;
        set fillStyle(value: any);
        get fillStyle(): any;
        set globalAlpha(value: number);
        get globalAlpha(): number;
        set textAlign(value: string);
        get textAlign(): string;
        set textBaseline(value: string);
        get textBaseline(): string;
        set globalCompositeOperation(value: BlendMode);
        get globalCompositeOperation(): BlendMode;
        set strokeStyle(value: any);
        get strokeStyle(): any;
        translate(x: number, y: number): void;
        set lineWidth(value: number);
        get lineWidth(): number;
        save(): void;
        restore(): void;
        fillText(txt: string | WordText, x: number, y: number, fontStr: string, color: string, align: string, lineWidth?: number, borderColor?: string): void;
        drawText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): void;
        strokeWord(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): void;
        fillBorderText(txt: string | WordText, x: number, y: number, font: string, color: string, borderColor: string, lineWidth: number, textAlign: string): void;
        /**@internal */
        _fast_filltext(data: string | WordText, x: number, y: number, fontObj: FontInfo, color: string, strokeColor: string | null, lineWidth: number, textAlign: number): void;
        private _fillRect;
        private _appendBlockInfo;
        fillRect(x: number, y: number, width: number, height: number, fillStyle?: any): void;
        fillTexture(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: number): void;
        /**@internal */
        private _fillTexture;
        createSubmit(mesh: GraphicsMesh): SubmitBase;
        drawTexture(tex: Texture, x: number, y: number, width: number, height: number, color?: number): void;
        drawTextures(tex: Texture, pos: ArrayLike<number>, tx: number, ty: number, colors: number[]): void;
        /**@internal */
        _drawTextureM(tex: Texture, x: number, y: number, width: number, height: number, m: Matrix, alpha: number, uv: any[] | null, color: number): boolean;
        /**@internal */
        _setClipInfo(material: GraphicsShaderInfo): void;
        private isSameClipInfo;
        /**
         * @internal
         * @param tex {Texture | RenderTexture }
         * @param  imgid 图片id用来比较合并的
         * @param x
         * @param y
         * @param width
         * @param height
         * @param m
         * @param alpha
         * @param uv
         * @return
         */
        _inner_drawTexture(tex: Texture | BaseTexture, imgid: number, x: number, y: number, width: number, height: number, m: Matrix | null, uv: ArrayLike<number> | null, alpha: number, lastRender: boolean, color: number): boolean;
        /**
         * pt所描述的多边形完全在clip外边，整个被裁掉了
         * @param pt
         * @return
         */
        private clipedOff;
        /**
         * 应用当前矩阵。把转换后的位置放到输出数组中。
         * @param x
         * @param y
         * @param w
         * @param h
         * @param   italicDeg 倾斜角度，单位是度。0度无，目前是下面不动。以后要做成可调的
         */
        private transformQuad;
        /**
         * 强制拒绝submit合并
         * 例如切换rt的时候
         */
        breakNextMerge(): void;
        drawTextureWithTransform(tex: Texture, x: number, y: number, width: number, height: number, transform: Matrix | null, tx: number, ty: number, alpha: number, blendMode: BlendMode | string | null, uv?: number[], color?: number): void;
        drawTriangles(tex: Texture | BaseTexture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix?: Matrix, alpha?: number, blendMode?: BlendMode | string, colorNum?: number, colors?: Float32Array, uvRange?: ArrayLike<number>): void;
        transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
        rotate(angle: number): void;
        scale(scaleX: number, scaleY: number): void;
        clipRect(x: number, y: number, width: number, height: number, escape?: boolean): void;
        beginPath(convex?: boolean): void;
        closePath(): void;
        /**
         * 添加一个path。
         * @param points [x,y,x,y....]	这个会被保存下来，所以调用者需要注意复制。
         * @param close	是否闭合
         * @param   convex 是否是凸多边形。convex的优先级是这个最大。fill的时候的次之。其实fill的时候不应该指定convex，因为可以多个path
         * @param dx  需要添加的平移。这个需要在应用矩阵之前应用。
         * @param dy
         */
        addPath(points: number[], close: boolean, convex: boolean, dx: number, dy: number): void;
        fill(): void;
        private addVGSubmit;
        stroke(): void;
        moveTo(x: number, y: number): void;
        /**
         *
         * @param x
         * @param y
         */
        lineTo(x: number, y: number): void;
        arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
        arc(cx: number, cy: number, rx: number, ry: number, startAngle: number, endAngle: number, counterclockwise?: boolean, b?: boolean, minNum?: number): void;
        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
        /**
         * 把颜色跟当前设置的alpha混合
         * @return
         */
        mixRGBandAlpha(color: number): number;
        /**@internal */
        _mixRGBandAlpha(color: number, alpha: number): number;
        strokeRect(x: number, y: number, width: number, height: number, parameterLineWidth?: number): void;
        /*******************************************end矢量绘制***************************************************/
        drawParticle(x: number, y: number, pt: any): void;
        private _getPath;
        private _getImageSource;
        private _currentMeshIndex;
        /**
        * 获取一个可用的 Mesh
        * @param vertexCount 需要的顶点数
        * @returns 可用的 Mesh
        */
        acquire(vertexCount: number): MeshBlockInfo;
        appendData(vertices: ArrayLike<number>, indices: ArrayLike<number>, result: MeshBlockInfo, submit: SubmitBase, uvs: ArrayLike<number>, rgba: number, matrix: Matrix, uvrect: ArrayLike<number>, useTex: boolean, colors?: ArrayLike<number>, uvRange?: ArrayLike<number>): void;
        /**
         * @en Default geometry
         * @zh 默认的geometry
         */
        def_geometry: IRenderGeometryElement;
        /**
         * @en Inverse geometry
         * @zh 逆向的geometry
         */
        inv_geometry: IRenderGeometryElement;
        initDefalutMesh(): void;
    }
    /** @internal */
    class GraphicsRenderData {
        static readonly _pool: IPool<IPrimitiveRenderElement2D>;
        /** @internal */
        _renderElements: IPrimitiveRenderElement2D[];
        /**@internal */
        _submits: FastSinglelist<SubmitBase>;
        private _bufferBlocks;
        owner: Sprite;
        constructor(owner: Sprite);
        clear(): void;
        destroy(): void;
        /**
         * 提交所有mesh的数据
         * @param graphics 图形
         * @param struct 渲染结构
         * @param handle 渲染句柄
         */
        updateRenderElement(graphics: Graphics, struct: IRenderStruct2D, handle: I2DPrimitiveDataHandle): void;
        private _updateIndexViews;
        private _updateGraphicsKeys;
        setRenderElement(struct: IRenderStruct2D, handle: I2DPrimitiveDataHandle): void;
        createSubmit(runner: GraphicsRunner, mesh: GraphicsMesh, material: Material): SubmitBase;
        texturesMap: Map<number, Texture>;
        touchRes(res: IAutoExpiringResource): void;
        referenceRes(res: Resource): void;
        private _resourceRepaint;
    }
    /** @internal */
    class SubStructRender {
        private _subRenderPass;
        private _subStruct;
        private _sprite;
        private _renderElement;
        /** @internal 模拟sprite shaderdata */
        private _shaderData;
        private _handle;
        private _submit;
        private _internalInfo;
        /** @internal 渲染区域 */
        _rtRect: Rectangle;
        _oriRect: Rectangle;
        private _needUpdateVertexSize;
        private _scaleX;
        private _scaleY;
        constructor();
        bind(sprite: Sprite, subRenderPass: IRender2DPass, subStruct: IRenderStruct2D): void;
        /**
         * @internal 更新渲染区域
         * @param rect
         * @param scaleX
         * @param scaleY
         */
        _updateRenderOffset(rect: Rectangle, oriRect: Rectangle, scaleX: number, scaleY: number): void;
        /**
         * @internal
         * @param oriRT
         * @param destRT
         */
        _updateRenderTexture(oriRT: RenderTexture2D, destRT: RenderTexture2D): void;
        destroy(): void;
    }
    /**
     * 用于在 2D 中显示 Mesh2D 的节点
     */
    class Mesh2DRender extends BaseRenderNode2D {
        /**
         * @en Default mesh2d render material
         * @zh 默认Mesh2D渲染材质
         */
        static mesh2DDefaultMaterial: Material;
        static __init__(): void;
        private _sharedMesh;
        _renderHandle: IMesh2DRenderDataHandle;
        protected _createRenderHandle(): IMesh2DRenderDataHandle;
        protected _initDefaultRenderData(): void;
        protected _isMaterialVaild(value: Material): boolean;
        renderUpdate(context: IRenderContext2D): void;
        /**
         * @en 2D Mesh
         * @zh 2D 渲染网格
         */
        set sharedMesh(value: Mesh2D);
        get sharedMesh(): Mesh2D;
        /**
         * @en render color
         * @zh 渲染颜色
         */
        set color(value: Color);
        get color(): Color;
        /**
         * @en Rendering textures will not take effect if there is no UV in 2dmesh
         * @zh 渲染纹理，如果2DMesh中没有uv，则不会生效
         */
        set texture(value: BaseTexture);
        get texture(): BaseTexture;
        /**
         * @en Rendering textures will not take effect if there is no UV in 2dmesh
         * @zh 渲染纹理，如果2DMesh中没有uv，则不会生效
         */
        set normalTexture(value: BaseTexture);
        get normalTexture(): BaseTexture;
        /**
         * @en normal strengh
         * @zh 法线效果强度
         */
        set normalStrength(value: number);
        get normalStrength(): number;
        /**
         * @en Render material
         * @zh 渲染材质
         */
        set sharedMaterial(value: Material);
        get sharedMaterial(): Material;
        private _changeMesh;
        /**@ignore */
        constructor();
    }
    class Blit2DCMD extends Command2D {
        static QuadGeometry: IRenderGeometryElement;
        static InvertQuadGeometry: IRenderGeometryElement;
        private static _defaultShader;
        private static _blitShaderData;
        private static _defaultOffsetScale;
        private static __initBlitShader__;
        private static __initGeometryElement__;
        private static __initInvertGeometryElement__;
        static __init__(): void;
        private static readonly _pool;
        /**
         * @en creat a blit2D render Command
         * @param source copy source
         * @param dest copy dest rt
         * @param offsetScale offset and scale Value,(Based on percentage)
         * @param shader use shader
         * @param shaderData data for shader
         * @returns render command
         * @zh 创建一个纹理拷贝渲染指令
         * @param source 拷贝原图
         * @param dest 拷贝目标
         * @param offsetScale 偏移缩放（基于百分比）
         * @param shader 拷贝使用Shader
         * @param shaderData 拷贝使用的shader对应的渲染数据
         * @returns 渲染指令
         */
        static create(source: BaseTexture, dest: IRenderTarget, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData): Blit2DCMD;
        private _source;
        private _dest;
        private _offsetScale;
        private _shader;
        private _shaderData;
        private _renderElement;
        /**
         * @internal
         */
        _blitQuadCMDData: Blit2DQuadCMD;
        constructor();
        /**
         * @en The offset and scale for rendering.
         * @zh 渲染的偏移和缩放。
         */
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        /**
        * @en The destination render texture.
        * @zh 目标渲染纹理。
        */
        get source(): BaseTexture;
        set source(value: BaseTexture);
        /**
         * @en The destination render texture.
         * @zh 目标渲染纹理。
         */
        get dest(): IRenderTarget;
        set dest(value: IRenderTarget);
        /**
         * @en The shader data for rendering.
         * @zh 渲染的着色器数据。
         */
        set shaderData(value: ShaderData);
        /**
         * @internal
         */
        getRenderCMD(): Blit2DQuadCMD;
        /**
         * @en change render shader
         * @param shader use shader
         * @param shaderData data for shader
         * @zh 设置着色器
         * @param shader 使用着色器
         * @param shaderData 着色器数据
         */
        setshader(shader: Shader3D, shaderData: ShaderData): void;
        destroy(): void;
        recover(): void;
    }
    class Command2D {
        /**@internal */
        _commandBuffer: CommandBuffer2D;
        /**@internal */
        _context: IRenderContext2D;
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Organizes rendering commands.
         * @zh 组织渲染指令。
         */
        run?(): void;
        /**
         * @en Recycles the rendering command.
         * @zh 回收渲染指令。
         */
        recover(): void;
        /**
         * @internal
         */
        getRenderCMD?(): IRenderCMD;
        destroy(): void;
    }
    /**
     * @en Interface is used to collect 2D rendering instructions
     * @zh 接口用来收集2D渲染指令
     */
    class CommandBuffer2D {
        private _context;
        private _name;
        private _scene;
        private _commands;
        private _renderCMDs;
        /**
         * @internal
         */
        shaderData: ShaderData;
        /** @ignore */
        constructor(name?: string);
        /**
         * @en The name of the command buffer.
         * @zh 命令缓冲区的名称。
         */
        getName(): string;
        private cacheData;
        private _cacheContextState;
        private _recoverContextState;
        /**
         * 渲染所有渲染指令后恢复context状态
         */
        /**
         * @en Executes all rendering commands.
         * @param render Whether to render immediately, the default is true
         * @zh 调用所有渲染指令。
         * @param render  是否立即渲染，默认为true
         */
        apply(render?: boolean, recoverContextStat?: boolean): void;
        /**
         * @en Executes a single command from the command buffer.
         * @zh 从命令缓冲区执行单个命令。
         */
        applyOne(recoverContextStat?: boolean): boolean;
        /**
         * @en Clears the command buffer.
         * @zh 清除命令缓冲区
         * @param recover
         */
        clear(recover?: boolean): void;
        /**
         * @en Gets the number of commands contained in the command buffer
         * @zh 获取命令缓冲区包含的命令数量
         */
        getCommandsSize(): number;
        /**
         * Set rendering instructions for rendering data
         * @param shaderData dest render data
         * @param nameID property id
         * @param dataType proprty type
         * @param value set value
         * @returns
         * @zh 设置渲染数据渲染指令
         * @param shaderData 目标渲染数据
         * @param nameID 属性ID
         * @param dataType 属性类型
         * @param value 设置数据
         * @returns
         */
        setShaderDataValue(shaderData: ShaderData, nameID: number, dataType: ShaderDataType, value: any): void;
        /**
         * @en set global render data
         * @param nameID property id
         * @param dataType proprty type
         * @param value set value
         * @returns
         * @zh 设置全局渲染数据
         * @param nameID 属性ID
         * @param dataType 属性类型
         * @param value 设置数据
         * @returns
         */
        setGlobalShaderDataValue(nameID: number, dataType: ShaderDataType, value: any): void;
        /**
         * @en set Shader Define marco cmd
         * @param shaderData dest render data
         * @param define marco of shader
         * @param value set bool of marco
         * @zh 设置渲染宏的指令
         * @param shaderData 目标渲染数据
         * @param define 着色器宏
         * @param value 是否开启
         */
        setShaderDefine(shaderData: ShaderData, define: ShaderDefine, value: boolean): void;
        /**
         * 拷贝纹理到渲染目标渲染指令
         * @param source copy source
         * @param dest dest of render
         * @param offsetScale offset&scale of copy
         * @param shader copy use shader
         * @param shaderData copy use data for shader
         */
        blitTextureQuad(source: BaseTexture, dest: IRenderTarget, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData): void;
        blitTextureBlur(source: BaseTexture, dest: IRenderTarget, blurParams: any): void;
        /**
         * 设置渲染目标指令
         * @param renderTexture dest render target
         * @param clearColor clear color when change target
         * @param colorValue clear color value
         * @param invertY invert y coordinate
         */
        setRenderTarget(renderTexture: IRenderTarget, clearColor: boolean, colorValue?: Color, invertY?: boolean): void;
        /**
         * 渲染元素位置指令
         * @param renderelement
         * @param mat
         */
        drawRenderElement(renderelement: IRenderElement2D, mat: Matrix): void;
        /**
         * 渲染Mesh2D指令
         * @param mesh
         * @param mat
         * @param meshTexture
         * @param color
         * @param material
         */
        drawMesh(mesh: Mesh2D, mat: Matrix, meshTexture?: BaseTexture, color?: Color, material?: Material): void;
        drawQuad(): void;
        drawLine(): void;
        /**
         * 添加缓存渲染指令
         * @param cmd
         */
        addCacheCommand(cmd: Command2D): void;
    }
    class DrawMesh2DCMD extends Command2D {
        private static readonly _pool;
        /**
         * @param mesh
         * @param mat
         * @param texture
         * @param color
         * @param material
         * @returns
         */
        static create(mesh: Mesh2D, mat: Matrix, texture: BaseTexture, color: Color, material: Material): DrawMesh2DCMD;
        private _drawElementData;
        private _renderElements;
        private _shaderData;
        private _needUpdateElement;
        private _matrix;
        private _mesh;
        private _material;
        private _color;
        private _renderColor;
        private _texture;
        constructor();
        _setMatrix(value: Matrix): void;
        set material(value: Material);
        get material(): Material;
        set mesh(value: Mesh2D);
        get mesh(): Mesh2D;
        set texture(value: BaseTexture);
        get texture(): BaseTexture;
        set color(value: Color);
        get color(): Color;
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): Draw2DElementCMD;
        /**
         * @en Runs the  command.
         * @zh 运行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the render command for reuse.
         * @zh 回收渲染命令以供重用。
         */
        recover(): void;
        /**
         * @en Destroys the render command.
         * @zh 销毁渲染命令。
         */
        destroy(): void;
    }
    class DrawRenderElement2DCMD extends Command2D {
        private static readonly _pool;
        static create(element: IRenderElement2D, mat?: Matrix): DrawRenderElement2DCMD;
        private _matreix;
        private _renderElement;
        /**
         * @en The render element of this command.
         * @zh 此命令的渲染元素。
         */
        get renderElement(): IRenderElement2D;
        set renderElement(value: IRenderElement2D);
        /**@internal */
        _drawElementCMDData: Draw2DElementCMD;
        constructor();
        _setMatrix(value: Matrix): void;
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the command for reuse.
         * @zh 回收命令以供重用。
         */
        recover(): void;
        /**
        * @override
        * @internal
        * @en Gets the render command data.
        * @zh 获取渲染命令数据。
        */
        getRenderCMD(): Draw2DElementCMD;
        /**
         * @en Destroys the command.
         * @zh 销毁命令。
         */
        destroy(): void;
    }
    class Set2DRTCMD extends Command2D {
        private static readonly _pool;
        static create(renderTexture: IRenderTarget, clearColor: boolean, colorValue: Color, renderInvertY?: boolean): Set2DRTCMD;
        private _renderTexture;
        _setRenderTargetCMD: SetRendertarget2DCMD;
        /**
         * @en The render texture.
         * @zh 渲染纹理。
         */
        get renderTexture(): IRenderTarget;
        set renderTexture(value: IRenderTarget);
        constructor();
        run(): void;
        getRenderCMD(): SetRendertarget2DCMD;
        recover(): void;
    }
    class Set2DShaderDataCMD extends Command2D {
        private static readonly _pool;
        static create(shaderData: ShaderData, nameID: number, value: ShaderDataItem, shaderDataType: ShaderDataType): Set2DShaderDataCMD;
        /**@internal */
        _setRenderDataCMD: SetRenderDataCMD;
        _globalMode: boolean;
        constructor();
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): SetRenderDataCMD;
        setDest(value: ShaderData): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    class Set2DDefineCMD extends Command2D {
        private static readonly _pool;
        /**@internal */
        _setRenderDefineCMD: SetShaderDefineCMD;
        /**@internal */
        _globalMode: boolean;
        /**
             * @internal
             */
        static create(shaderData: ShaderData, define: ShaderDefine, addDefine: boolean): Set2DDefineCMD;
        constructor();
        setDest(value: ShaderData): void;
        /**
         * @override
         * @internal
         * @returns
         */
        getRenderCMD(): SetShaderDefineCMD;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    class Scene2DSpecialManager {
        static SPRITE2DGLOBAL: ShaderDefine;
        /**@internal */
        _shaderData: ShaderData;
        /** @internal */
        componentElementMap: Map<string, IElementComponentManager>;
        constructor();
    }
    /**
     * @en Sprite is a basic display list node for displaying graphical content. By default, Sprite does not accept mouse events. Through the graphics API, images or vector graphics can be drawn, supporting operations like rotation, scaling, translation, and more. Sprite also functions as a container class, allowing the addition of multiple child nodes.
     * @zh Sprite是基本的显示图形的显示列表节点。Sprite默认不接受鼠标事件。通过graphics可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。Sprite同时也是容器类，可用来添加多个子节点。
     * @blueprintInheritable
     */
    class Sprite extends Node {
        /**
         * @internal
         */
        _x: number;
        /**
         * @internal
         */
        _y: number;
        /**
         * @internal
         */
        _width: number;
        /**
         * @internal
         */
        _height: number;
        /**
         * @internal
         * @en Horizontal scaling
         * @zh 水平缩放
         */
        _scaleX: number;
        /**
         * @internal
         * @en Vertical scaling
         * @zh 垂直缩放
         */
        _scaleY: number;
        /**
         * @internal
         * @en Horizontal skew angle
         * @zh 水平倾斜角度
         */
        _skewX: number;
        /**
         * @internal
         * @en Vertical skew angle
         * @zh 垂直倾斜角度
         */
        _skewY: number;
        /**
         * @internal
         * @en X-axis pivot point
         * @zh X轴心点
         */
        _pivotX: number;
        /**
         * @internal
         * @en Y-axis pivot point
         * @zh Y轴心点
         */
        _pivotY: number;
        /**
         * @internal
         * @en X anchor point, value ranges from 0 to 1. Setting anchorX ultimately changes the node's pivot point through the pivotX value.
         * @zh X锚点，值为0-1，设置anchorX值最终通过pivotX值来改变节点轴心点。
         */
        _anchorX: number;
        /**
         * @internal
         * @en Y anchor point, value ranges from 0 to 1. Setting anchorY ultimately changes the node's pivot point through the pivotY value.
         * @zh Y锚点，值为0-1，设置anchorY值最终通过pivotY值来改变节点轴心点。
         */
        _anchorY: number;
        /**
         * @internal
         * @en Rotation angle
         * @zh 旋转角度
         */
        _rotation: number;
        /**
         * @internal
         * @en Transparency
         * @zh 透明度
         */
        _alpha: number;
        /**
         * @internal
         * @en Scroll area
         * @zh 滚动区域
         */
        _scrollRect: Rectangle;
        /**
         * @internal
         * @en Hit area
         * @zh 点击区域
         */
        _hitArea: IHitArea;
        /**
         * @internal
         * @en Dragging
         * @zh 滑动
         */
        _dragSupport: DragSupport;
        /**
         * @internal
         * @en Blend mode
         * @zh 混合模式
         */
        _blendMode: BlendMode;
        /**
         * @internal
         */
        _visible: boolean;
        /**
         * @internal
         * @en Mouse state, 0: auto, 1: mouseEnabled=false, 2: mouseEnabled=true.
         * @zh 鼠标状态，0:auto，1:mouseEnabled=false，2:mouseEnabled=true。
         */
        _mouseState: number;
        /**
         * @internal
         * @en Z-order for sorting, higher values are displayed in front.
         * @zh z排序，数值越大越靠前。
         */
        _zOrder: number;
        /**
         * @internal
         */
        _transform: Matrix;
        /**
         * @internal
         */
        _globalTrans: SpriteGlobalTransform;
        /**@internal */
        _renderType: number;
        /**@internal */
        _graphics: Graphics;
        /**@internal */
        _renderNode: BaseRenderNode2D;
        /**@internal */
        _struct: IRenderStruct2D;
        /**@internal */
        _subpassUpdateFlag: number;
        /**
         * @en For non-UI component display object nodes (container objects or display objects without image resources), specifies whether the mouse events penetrate this object's collision detection. `true` means the object is penetrable, `false` means it is not penetrable.
         * When penetrable, the engine will no longer detect this object and will recursively check its child objects until it finds the target object or misses all objects.
         * When not penetrable, the node's width and height define the mouse collision area (a non-penetrable rectangular area). If the rectangular collision area does not meet the requirements, you can use the drawing area of the hit area as the collision area. The hit area takes precedence over width and height of node as the non-penetrable mouse collision area.
         * Note that for UI object nodes with a set skin property, once a skin texture resource is set, this property becomes ineffective, and the rectangular area drawn by the texture will always be non-penetrable unless it does not accept mouse events or a non-clickable area is set.
         * @zh 用于非UI组件显示对象节点（容器对象或没有设置图像资源的显示对象），鼠标事件与此对象在碰撞检测时，是否穿透。ture为可穿透，false为不可穿透。
         * 可穿透时，引擎不再检测本对象，而会递归检测子对象，直到找到命中的目标对象或者未命中任何对象。
         * 不可穿透时，以节点宽高为鼠标碰撞区（矩形的不可穿透区域）。如果矩形碰撞区不能满足需求，可以将点击区域的绘制图形作为碰撞区，绘制区域优先于宽高作为不可穿透的鼠标碰撞区域。
         * 注意，可以设置skin属性的UI对象节点，当设置了skin纹理资源之后，该属性设置失效，纹理绘制的矩形区域内会始终处于不可穿透状态。除非不接受鼠标事件或设置不可点击区域。
         */
        mouseThrough: boolean;
        /**
         * @en Under the premise that this object is non-penetrable (mouseThrough is false), specify whether the mouse event capture detection prioritizes this object.  When set to true, the object itself is prioritized for detection.  When set to false, the child objects are prioritized.
         * When set to prioritize the object itself, the object is detected first.  If the object itself is not hit, the detection is directly interrupted, indicating that no target was hit.  If the object itself is hit, further recursive detection is performed on its child objects until the final mouse hit target is found or all child nodes have been checked.
         * When set to prioritize child objects, the child objects are recursively detected first.  If a child object is hit, the detection is interrupted and the hit target is obtained.  If all child nodes have been checked and no child object is hit, then the detection checks if the object itself is hit.
         * In most cases, prioritizing the detection of child objects is advisable unless the developer does not care about the mouse event detection results of the current node's child nodes.  For example, when child nodes are certainly within the width and height range of the parent node's container, there is no need for recursive detection layer by layer if the mouse click does not occur within the parent node's area.
         * Using this property appropriately can reduce the nodes for mouse event detection and improve performance.
         * @zh 在本对象为不可穿透（mouseThrough为false）的前提下，指定鼠标事件捕获检测是否优先检测本对象。为`true`时优先检测本对象，为`false`时优先检测子对象。
         * 优先检测本对象时，如果本对象没有被检测命中，会中断检测，表示没有命中目标；如果本对象被检测命中，则进一步递归检测其子对象，直到找到鼠标最终的命中目标或所有子节点都检测完毕。
         * 优先检测子对象时，先递归检测其子对象，如果子对象被检测命中，则中断检测，获得命中目标。如果所有子节点都检测完毕，仍未检测命中任何子对象，最后再检测本对象是否被命中；
         * 大多数情况下需要优先检测子对象，除非开发者并不关心当前节点的子节点的鼠标事件检测结果，也就是以当前节点作为其子节点的鼠标事件检测依据。例如，子节点肯定在父节点的容器宽高范围内，当鼠标点击不发生在父节点范围内的区域时，就不必层层递归检测了。
         * 合理使用本属性，能减少鼠标事件检测的节点，提高性能。
         */
        hitTestPrior: boolean;
        /**
         * @en If the node needs to load related skins but placed in different domains, you can set it here.
         * @zh 如果节点需要加载相关的皮肤，但放在不同域，这里可以设置。
         */
        _skinBaseUrl: string;
        private _autosize;
        private _tfChanged;
        private _repaint;
        private _repaintCount;
        private _sizeFlag;
        private _filterArr;
        private _userBounds;
        private _ownGraphics;
        private _mask;
        /** @internal */
        _maskParent: Sprite;
        private _cacheAsBmp;
        private _layer;
        /** @internal */
        _children: Sprite[];
        /** @internal */
        _$children: Sprite[];
        /** @internal */
        _parent: Sprite;
        /** @internal */
        _scene: Scene;
        /** @internal */
        _texture: Texture;
        /** @internal */
        _ownerArea: Sprite;
        /** @internal */
        _subStructRender: SubStructRender;
        /** @internal 渲染真实spritet的pass，在启用后处理，cacheAsBitmap和mask的时候生效 */
        _oriRenderPass: IRender2DPass;
        /** @internal 渲染真实sprite所需的rt大小 */
        _drawOriRT: RenderTexture2D;
        /** @internal 片，代替的结构 ，真正的结构划到了rt上 */
        _subStruct: IRenderStruct2D;
        /** @internal */
        _shaderData: ShaderData;
        /** @ignore */
        constructor();
        /** @internal */
        _initShaderData(): void;
        /**
         * @en Destroy the sprite.
         * @param destroyChild Whether to destroy child nodes. Default is true.
         * @zh 销毁精灵。
         * @param destroyChild 是否删除子节点。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en The parent node.
         * @zh 父节点。
         */
        get parent(): Sprite;
        /**
         * @en Get the scene the sprite belongs to.
         * @returns The scene object.
         * @zh 获取所属的场景。
         * @returns 场景对象。
         */
        get scene(): Scene;
        /**
         * @en The x coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的水平方向坐标值。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的垂直方向坐标值。
         */
        get y(): number;
        set y(value: number);
        /**
         * @en The width of the Node, in pixels
         * @zh 节点的宽度，单位为像素。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en The height of the Node, in pixels.
         * @zh 节点的高度，单位为像素。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en Check if the width is set.
         * @returns True if the width is set, otherwise false.
         * @zh 检查是否设置了宽度。
         * @returns True 表示宽度已设置，否则为 False。
         */
        get _isWidthSet(): boolean;
        /**
         * @en Check if the height is set.
         * @returns True if the height is set, otherwise false.
         * @zh 检查是否设置了高度。
         * @returns True 表示高度已设置，否则为 False。
         */
        get _isHeightSet(): boolean;
        /**
         * @zh 如果节点的宽度未设置，则每次获取节点宽度时都会调用这个方法获得显示宽度。
         * @en If the size of the node is not set, this method will be called to obtain the display width each time the node width is obtained.
         */
        protected measureWidth(): number;
        /**
         * @zh 如果节点的高度未设置，则每次获取节点高度时都会调用这个方法获得显示高度。
         * @en If the height of the node is not set, this method will be called to obtain the display height each time the node height is obtained.
         */
        protected measureHeight(): number;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * @en The display width of the object, in pixels, including X axis scaling.
         * @returns The display width.
         * @zh 对象的显示宽度（以像素为单位），包含X轴缩放。
         * @returns 显示宽度。
         */
        get displayWidth(): number;
        /**
        * @en The display height of the object, in pixels, including Y axis scaling.
        * @returns The display height.
        * @zh 对象的显示高度（以像素为单位），包含Y轴缩放。
        * @returns 显示高度。
        */
        get displayHeight(): number;
        /**
         * @en The scale factor on the X axis, with a default value of 1. Setting a negative value can achieve a horizontal flip effect, e.g., scaleX=-1.
         * @zh X轴缩放值，默认值为1。设置为负数可以实现水平反转效果，例如scaleX=-1。
         */
        get scaleX(): number;
        set scaleX(value: number);
        /**
         * @en The scale factor on the Y axis, with a default value of 1. Setting a negative value can achieve a vertical flip effect, e.g., scaleY=-1.
         * @zh Y轴缩放值，默认值为1。设置为负数可以实现垂直反转效果，例如scaleY=-1。
         */
        get scaleY(): number;
        set scaleY(value: number);
        /**
         * @en The rotation angle, in degrees, with a default value of 0.
         * @zh 旋转角度，默认值为0。以角度为单位。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The horizontal skew angle, in degrees, with a default value of 0.
         * @zh 水平倾斜角度，默认值为0。以角度为单位。
         */
        get skewX(): number;
        set skewX(value: number);
        /**
          * @en The vertical skew angle, in degrees, with a default value of 0.
          * @zh 垂直倾斜角度,默认值为0。以角度为单位。
          */
        get skewY(): number;
        set skewY(value: number);
        /**
         * @en The matrix information of the object. By setting the matrix, node rotation, scaling, and displacement effects can be achieved.
         * @zh 对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。
         */
        get transform(): Matrix;
        set transform(value: Matrix);
        /**
         * @en The global transformation information of the object.
         * @zh 对象的全局变换信息。
         */
        get globalTrans(): SpriteGlobalTransform;
        /**
         * @en The x-axis pivot point position, in pixels, with a default value of 0. The pivot point affects the object's position, scaling center, and rotation center.
         * @zh X 轴轴心点的位置，以像素为单位，默认为 0。轴心点会影响对象的位置、缩放中心和旋转中心。
         */
        get pivotX(): number;
        set pivotX(value: number);
        /**
         * @en The y-axis pivot point position, in pixels, with a default value of 0. The pivot point affects the object's position, scaling center, and rotation center.
         * @zh Y 轴轴心点的位置，以像素为单位，默认为 0。轴心点会影响对象的位置、缩放中心和旋转中心。
         */
        get pivotY(): number;
        set pivotY(value: number);
        /**
         * @en The anchor point's x-coordinate, ranging from 0 to 1. Setting anchorX will ultimately change the node's pivot point through the pivotX value.
         * @zh X 轴锚点,值为 0-1。设置 anchorX 值最终会通过 pivotX 值来改变节点的轴心点。
         */
        get anchorX(): number;
        set anchorX(value: number);
        /**
         * @en The anchor point's y-coordinate, ranging from 0 to 1. Setting anchorY will ultimately change the node's pivot point through the pivotY value.
         * @zh Y 轴锚点，值为 0-1。设置 anchorY 值最终会通过 pivotY 值来改变节点的轴心点。
         */
        get anchorY(): number;
        set anchorY(value: number);
        /**
         * @en The transparency value, ranging from 0 to 1, with a default value of 1 (opaque). Changing the alpha value will affect the drawcall.
         * @zh 透明度,值为 0-1,默认值为 1(不透明)。更改 alpha 值会影响 drawcall。
         */
        get alpha(): number;
        set alpha(value: number);
        /**
         * @en Indicates whether the object is visible. The default value is true. If set to false, the node will not be rendered.
         * @zh 表示对象是否可见,默认为 true。如果设置为 false,节点将不会被渲染。
         */
        get visible(): boolean;
        set visible(value: boolean);
        /**
         * @en Specifies the blending mode to be used.
         * @zh 指定要使用的混合模式.
         */
        get blendMode(): keyof typeof BlendMode | null;
        set blendMode(value: keyof typeof BlendMode | null);
        /**
         * @en Mask layer.
         * @zh 蒙版层。
         */
        get layer(): number;
        set layer(value: number);
        /** @internal */
        _graphicsData: GraphicsRenderData;
        /**
         * @en The drawing object, which encapsulates the interfaces for drawing bitmaps and vector graphics. All drawing operations of Sprite are implemented through Graphics.
         * @zh 绘图对象。封装了绘制位图和矢量图的接口,Sprite 的所有绘图操作都是通过 Graphics 实现的。
         */
        get graphics(): Graphics;
        set graphics(value: Graphics);
        /**
         * @en Set the Graphics object for drawing.
         * @param value The Graphics object to set.
         * @param transferOwnership Whether to set the Graphics object to the belonging node (i.e., transfer the ownership of the Graphics object to the Sprite). If true, the Sprite will be responsible for destroying the Graphics object when it's no longer needed.
         * @zh 设置用于绘制的 Graphics 对象。
         * @param value 要设置的 Graphics 对象。
         * @param transferOwnership 是否将 Graphics 对象设置到所属节点上(即将 Graphics 对象的所有权转移给 Sprite)。如果为 true,则 Sprite 将负责在不再需要 Graphics 对象时销毁它。
         */
        setGraphics(value: Graphics, transferOwnership?: boolean): void;
        /**
         * @deprecated use post2DProcess
         * @en The filter collection. Multiple filters can be combined.
         * @zh 滤镜集合。可以设置多个滤镜组合。
         */
        get filters(): Filter[];
        /** @deprecated */
        set filters(value: Filter[]);
        protected getPostProcess(create?: boolean): PostProcess2D;
        get postProcess(): PostProcess2D;
        set postProcess(value: PostProcess2D);
        /**
        * @en Specifies whether the display object is cached as a static image. When cacheAs is set, changes in child objects will automatically update the cache. You can also manually call the reCache method to update the cache.
        * It is recommended to cache "complex content" that does not change frequently as a static image to greatly improve rendering performance.
        * The default is "none," which does not perform any caching.
        * When set to "bitmap," renderTarget caching is used.
        * Disadvantages of the renderTarget caching mode: it creates additional renderTarget objects, increasing memory overhead, has a maximum cache area limit of 2048, and can increase CPU overhead with constant redrawing. Advantages: it significantly reduces draw calls and provides the highest rendering performance.
        * @zh 指定显示对象是否缓存为静态图像，cacheAs 时，子对象发生变化，会自动重新缓存，同时也可以手动调用 reCache 方法更新缓存。
        * 建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。
        * 默认为 "none"，不做任何缓存。
        * 当值为 "bitmap" 时，使用 renderTarget 缓存。
        * renderTarget 缓存模式缺点：会额外创建 renderTarget 对象，增加内存开销，缓存面积有最大 2048 限制，不断重绘时会增加 CPU 开销。优点：大幅减少 drawcall，渲染性能最高。
        */
        get cacheAs(): string;
        set cacheAs(value: string);
        /**
         * @en Masking allows setting an object (bitmap or vector graphic) as a mask, displaying content based on the object's shape.
         * @zh 遮罩，可以设置一个对象（支持位图和矢量图），根据对象形状进行遮罩显示。
         */
        get mask(): Sprite;
        set mask(value: Sprite);
        /** @ignore @blueprintIgnore */
        clearSubpassFlag(flag: SubPassFlag): void;
        /**
         * @ignore
         * @blueprintIgnore
         * @param flag
         */
        setSubpassFlag(flag: SubPassFlag): void;
        /** @internal */
        _needUpdateSubpass(): boolean;
        /**
         * @en The scroll rectangle range of the display object, with a clipping effect (if you only want to limit the rendering area of child objects, please use viewport).
         * Differences between srollRect and viewport:
         * 1. srollRect has a clipping effect, viewport only affects whether child objects are rendered, and does not have a clipping effect (higher performance).
         * 2. Setting the x and y properties of the rect can achieve scrolling effect, but scrollRect will keep the position of point 0,0 unchanged.
         * @zh 显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)
         * srollRect和viewport的区别：
         * 1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。
         * 2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。
         */
        get scrollRect(): Rectangle;
        set scrollRect(value: Rectangle);
        /**
         * @deprecated
         */
        get viewport(): Rectangle;
        set viewport(value: Rectangle);
        /**
         * @en Automatically optimize DrawCall. When enabled, all rendering elements contained in the children and grandchildren of this node will be merged into as few DrawCalls as possible without affecting the actual display effect, such as images from the same texture atlas or text. They will be adjusted to a continuous rendering order so that they can be merged into the same DrawCall.
         *
         * Note that if the number of elements is large (e.g., greater than 500), it may significantly consume CPU performance. Developers need to balance the number of DrawCalls and CPU performance consumption.
         * @zh 自动优化DrawCall。开启后，本节点的所有孩子节点和孙子节点包含的渲染元素，在不影响实际显示效果的前提下，会通过调整渲染顺序的手段尽可能进行DrawCall合并，例如同图集的图片，又或者文本，调整到连续渲染的渲染顺序后它们可以合并为同一个DrawCall。
         *
         * 注意，如果元素数量巨大（例如大于500)，可能会显著消耗CPU性能。开发者需要均衡考虑DrawCall数量和CPU性能消耗。
         */
        set drawCallOptimize(value: boolean);
        get drawCallOptimize(): boolean;
        /**
         * @en Whether to enable culling.
         * @zh 是否启用裁剪。
         */
        set enableCulling(value: boolean);
        get enableCulling(): boolean;
        /**
         * @en You can set a rectangular area as the clickable region, or set a HitArea instance as the clickable region. The HitArea can have both clickable and non-clickable areas defined. If the hitArea is not set, the mouse collision detection will be based on the area formed by the width and height of the object.
         * @zh 可以设置一个矩形区域作为点击区域，或者设置一个 `HitArea` 实例作为点击区域，HitArea 内可以设置可点击和不可点击区域。如果不设置 hitArea，则根据宽高形成的区域进行鼠标碰撞检测。
         */
        get hitArea(): IHitArea;
        set hitArea(value: IHitArea);
        /**
         * @en Indicates whether the object receives mouse events. The default is false. If you listen to mouse events, this value will be automatically set to true.
         * @zh 是否接受鼠标事件。默认为 false，如果监听鼠标事件，则会自动设置为 true.
         */
        get mouseEnabled(): boolean;
        set mouseEnabled(value: boolean);
        private setMouseEnabledUp;
        /**
         * @en Get the mouse coordinates relative to this object.
         * @returns The screen point information.
         * @zh 获得相对于本对象上的鼠标坐标信息。
         * @returns 屏幕点信息。
         */
        getMousePoint(): Readonly<Point>;
        /**
         * @en The X-axis coordinate of the mouse in this object's coordinate system.
         * @zh 鼠标在此对象坐标系上的 X 轴坐标信息。
         */
        get mouseX(): number;
        /**
         * @en The Y-axis coordinate of the mouse in this object's coordinate system.
         * @zh 鼠标在此对象坐标系上的 Y 轴坐标信息。
         */
        get mouseY(): number;
        /**
         * @en Gets the global X-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global X-axis scale.
         * @zh 获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局X轴缩放值。
         */
        get globalScaleX(): number;
        /**
         * @en Gets the global Y-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global Y-axis scale.
         * @zh 获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局Y轴缩放值。
         */
        get globalScaleY(): number;
        /**
         * @en The z-order. If this value is changed, all objects of the same container will be re-sorted according to the value. The larger the value, the higher it is. The default is 0, which is sorted according to the order of addition.
         * @zh z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。
         */
        get zOrder(): number;
        set zOrder(value: number);
        /**
         * @en z rendering sort, which will modify the rendering order of the current object. The larger the value, the higher it is. The default is 0.
         * @zh z渲染排序，会修改当前对象的渲染顺序。值越大，越靠上。默认值为 0。
         */
        get zIndex(): number;
        set zIndex(value: number);
        /**
         * @en Whether it is a stacking root node. When a node is set as a stacking root node, the rendering order of all child nodes will be sorted within this node without affecting the outside.
         * @zh 是否为堆叠根节点。当一个节点设置为堆叠根节点时，所有子节点的渲染顺序将在此节点内部排序，而不会影响外部。
         */
        get stackingRoot(): boolean;
        set stackingRoot(value: boolean);
        /**
         * @en Re-sort by zOrder.
         * @zh 根据 zOrder 进行重新排序。
         */
        protected updateZOrder(): void;
        /**
         * @en Set a Texture instance and display the image (if there are other drawings before, it will be cleared).
         * Equivalent to graphics.clear();graphics.drawImage(), but with better performance.
         * You can also assign an image address, which will automatically load the image and then display it.
         * @zh 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。
         * 等同于graphics.clear();graphics.drawImage()，但性能更高。
         */
        get texture(): Texture;
        set texture(value: Texture);
        /**
         * @en 2D sprite material
         * @zh 2D精灵材质
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en The rendering component node of the sprite.
         * @zh 精灵的渲染组件节点。
         */
        get renderNode2D(): BaseRenderNode2D;
        set renderNode2D(value: BaseRenderNode2D);
        /**
         * @en Whether to automatically calculate the width and height of the node. The default value is `false`, which does not automatically calculate and offers better performance.
         * If you want to get the width and height based on the drawn content, you can set this property to `true`, or use the getBounds method to obtain them, which has some impact on performance.
         * @zh 是否自动计算节点的宽高数据。默认值为 false，不自动计算，性能更佳。
         * 如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取，对性能有一定影响。
         */
        get autoSize(): boolean;
        set autoSize(value: boolean);
        /**
         * @en Set the position. Equivalent to setting the x and y properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.pos(...).scale(...);
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @returns The object itself.
         * @zh 设置坐标位置。相当于分别设置x和y属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @returns 返回对象本身。
         */
        pos(x: number, y: number): this;
        /**
         * @deprecated speedMode参数已经弃用。
         */
        pos(x: number, y: number, speedMode: boolean): this;
        /**
         * @en Set the pivot point. Equivalent to setting the pivotX and pivotY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.pivot(...).pos(50, 100);
         * @param x X-axis pivot point.
         * @param y Y-axis pivot point.
         * @returns The object itself.
         * @zh 设置轴心点。相当于分别设置pivotX和pivotY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(50, 100);
         * @param x X轴心点。
         * @param y Y轴心点。
         * @returns 返回对象本身。
         */
        pivot(x: number, y: number): this;
        /**
         * @en Set the anchor coordinate
         * @param x The x coordinate of the anchor.
         * @param y The y coordinate of the anchor.
         * @zh 设置锚点坐标
         * @param x 锚点的X坐标
         * @param y 锚点的Y坐标
         */
        anchor(x: number, y: number): this;
        /**
         * @en Set the size. Equivalent to setting the width and height properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.size(...).pos(50, 100);
         * @param width Width value.
         * @param height Height value.
         * @returns The object itself.
         * @zh 设置宽高。相当于分别设置width和height属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(50, 100);
         * @param width 宽度值。
         * @param height 高度值。
         * @returns 返回对象本身。
         */
        size(width: number, height: number): this;
        /**
         * @en Set the scale. Equivalent to setting the scaleX and scaleY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.scale(...).pos(50, 100);
         * @param x X-axis scale ratio.
         * @param y Y-axis scale ratio.
         * @returns The object itself.
         * @zh 设置缩放。相当于分别设置scaleX和scaleY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(50, 100);
         * @param x X轴缩放比例。
         * @param y Y轴缩放比例。
         * @returns 返回对象本身。
         */
        scale(x: number, y: number): this;
        /**
         * @deprecated speedMode参数已经弃用。
         */
        scale(x: number, y: number, speedMode: boolean): this;
        /**
         * @en Set the skew angle. Equivalent to setting the skewX and skewY properties separately.
         * Since the return value is the Sprite object itself, you can use the following syntax: spr.skew(...).pos(50, 100);
         * @param x Horizontal skew angle.
         * @param y Vertical skew angle.
         * @returns The object itself.
         * @zh 设置倾斜角度。相当于分别设置skewX和skewY属性。
         * 因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(50, 100);
         * @param x 水平倾斜角度。
         * @param y 垂直倾斜角度。
         * @returns 返回对象本身。
         */
        skew(x: number, y: number): this;
        /**
         * @zh Transform改变时的通知，包括坐标，尺寸等，详见TransChangeType定义。
         * @param kind 通知类型
         * @en Notify when the transform changes, including coordinates, size, etc., see TransChangeType for details.
         * @param kind Notify type
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en Draws the current Sprite to a Canvas and returns an HtmlCanvas object.
         * The drawing result can be used as an image source to be drawn into other Sprites.
         * It can also obtain the original image data, send it to the server, or save it as an image to achieve a screenshot effect.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @returns The HTMLCanvas object.
         * @zh 绘制当前 Sprite 到 Canvas 上,并返回一个 HtmlCanvas 对象。
         * 绘制的结果可以当作图片源,再次绘制到其他 Sprite 里面。也可以获取原始图片数据,发给服务器或者保存为图片,从而实现截图效果。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @returns HTMLCanvas 对象。
         */
        drawToCanvas(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number): HTMLCanvas;
        /**
         * @ignore
         * @en Draws the specified Sprite to a Canvas and returns an HtmlCanvas object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @returns The HTMLCanvas object.
         * @zh 绘制指定的 Sprite 到 Canvas 上,并返回一个 HtmlCanvas 对象。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @returns HTMLCanvas 对象。
         */
        static drawToCanvas(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number): HTMLCanvas;
        /**
         * @deprecated
         * @en Draws the current object to a Texture object.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns The drawn Texture or RenderTexture2D object.
         * @zh 绘制当前对象到一个 Texture 对象上。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 绘制的 Texture 或 RenderTexture2D 对象。
         */
        drawToTexture(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean): Texture | RenderTexture2D;
        /**
         * @deprecated
         * @ignore
         * @en Draws the specified Sprite to a Texture or RenderTexture2D object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target. If not provided, a new RenderTexture2D will be created.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @returns The drawn Texture or RenderTexture2D object.
         * @zh 将指定的 Sprite 绘制到 Texture 或 RenderTexture2D 对象上。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。如果未提供,将创建一个新的 RenderTexture2D。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @returns 绘制的 Texture 或 RenderTexture2D 对象。
         */
        static drawToTexture(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null, isDrawRenderRect?: boolean): Texture | RenderTexture2D;
        /**
         * @en Draws the current object to a RenderTexture2D object.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @param flipY Optional. If true, the texture will be flipped vertical. Default is false.
         * @param clearColor Optional. If provided, the texture will be cleared to this color before drawing. Default is null.
         * @returns The drawn RenderTexture2D object.
         * @zh 绘制当前对象到一个 Texture 对象上。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @param flipY 可选。如果为 true，则垂直翻转纹理。默认为 false。
         * @param clearColor 可选。如果提供，则在绘制前清除纹理为该颜色。默认为 null。
         * @param renderScaleX 可选。渲染缩放 X。默认为 1。
         * @param renderScaleY 可选。渲染缩放 Y。默认为 1。
         * @returns 绘制的 RenderTexture2D 对象。
         */
        drawToRenderTexture2D(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D, isDrawRenderRect?: boolean, flipY?: boolean, clearColor?: Color, renderScaleX?: number, renderScaleY?: number): RenderTexture2D;
        /**
         * @en Draws the specified Sprite to a RenderTexture2D object.
         * @param sprite The Sprite to draw.
         * @param canvasWidth The width of the canvas.
         * @param canvasHeight The height of the canvas.
         * @param offsetX The X-axis offset for drawing.
         * @param offsetY The Y-axis offset for drawing.
         * @param rt The render target. If not provided, a new RenderTexture2D will be created.
         * @param isDrawRenderRect A boolean indicating whether to draw the render rectangle. When true, it starts drawing from (0,0) of the render texture and subtracts the offset of the cache rectangle. When false, it keeps the sprite's original relative position for drawing.
         * @param flipY Optional. If true, the texture will be flipped vertical. Default is false.
         * @param clearColor Optional. If provided, the texture will be cleared to this color before drawing. Default is null.
         * @param renderScaleX Optional. The scale of the render texture. Default is 1.
         * @param renderScaleY Optional. The scale of the render texture. Default is 1.
         * @returns The drawn RenderTexture2D object.
         * @zh 将指定的 Sprite 绘制到 RenderTexture2D 对象上。
         * @param sprite 要绘制的 Sprite。
         * @param canvasWidth 画布宽度。
         * @param canvasHeight 画布高度。
         * @param offsetX 绘制的 X 轴偏移量。
         * @param offsetY 绘制的 Y 轴偏移量。
         * @param rt 渲染目标。如果未提供,将创建一个新的 RenderTexture2D。
         * @param isDrawRenderRect 表示是否绘制渲染矩形。为 true 时，从渲染纹理的(0,0)点开始绘制，但要减去缓存矩形的偏移；为 false 时，保持精灵的原始相对位置进行绘制。
         * @param flipY 可选。如果为 true，则垂直翻转纹理。默认为 false。
         * @param clearColor 可选。如果为 true，则清除颜色。默认为 null。
         * @param renderScaleX 可选。渲染缩放 X。默认为 1。
         * @param renderScaleY 可选。渲染缩放 Y。默认为 1。
         * @returns 绘制的 RenderTexture2D 对象。
         */
        static drawToRenderTexture2D(sprite: Sprite, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D, isDrawRenderRect?: boolean, flipY?: boolean, clearColor?: Color, renderScaleX?: number, renderScaleY?: number): RenderTexture2D;
        /**
         * @en Checks whether a point is within this object.
         * @param x Global x-coordinate.
         * @param y Global y-coordinate.
         * @returns Indicates whether the point is inside the object.
         * @zh 检测某个点是否在此对象内。
         * @param x 全局x坐标。
         * @param y 全局y坐标。
         * @returns 表示是否在对象内。
         */
        hitTestPoint(x: number, y: number): boolean;
        /**
         * @en Set the bounds of the object. If set, getBounds will not be used to calculate the bounds. Proper use can improve performance.
         * @param bound The bounds rectangle.
         * @zh 设置对象的边界大小，如果设置，则不再通过getBounds计算边界。合理使用能提高性能。
         * @param bound 边界矩形区域
         */
        setSelfBounds(bound: Rectangle): void;
        /**
         * @en Get the rectangle display area of the object in the parent container's coordinate system.
         * Note: This calculation is complex, use sparingly.
         * @return The rectangle area.
         * @zh 获取本对象在父容器坐标系的矩形显示区域。
         * 注意：计算量较大，尽量少用。
         * @returns 矩形区域。
         */
        getBounds(out?: Rectangle): Rectangle;
        /**
         * @en Get the rectangle display area of the object in its own coordinate system.
         * Note: This calculation is complex, use sparingly.
         * @returns The rectangle area.
         * @zh 获取本对象在自己坐标系的矩形显示区域。
         * 注意：计算量较大，尽量少用。
         * @returns 矩形区域。
         */
        getSelfBounds(out?: Rectangle, recursive?: boolean): Rectangle;
        /**
         * @en Get the rectangle display area of the drawn content of the object in its own coordinate system.
         * @param realSize This parameter is reserved for future use.
         * @param out The output rectangle object.
         * @zh 获取本对象在自己坐标系的矩形显示区域，只计算绘制的内容。
         * @param realSize 此参数预留以后使用。
         * @param out 输出的矩形对象。
         * @returns 矩形区域。
         */
        getGraphicBounds(realSize?: boolean, out?: Rectangle): Rectangle;
        /**
         * @en Converts the local coordinates to the global coordinates relative to the stage.
         * @param point The local coordinate point.
         * @param createNewPoint (Optional) Whether to create a new Point object as the return value. The default is false, which uses the input point object as the return value to reduce object creation overhead.
         * @param globalNode The global node, default is Laya.stage.
         * @return The converted global coordinate point.
         * @zh 把本地坐标转换为相对stage的全局坐标。
         * @param point 本地坐标点。
         * @param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode global节点，默认为Laya.stage。
         * @return 转换后的坐标的点。
         */
        localToGlobal(point: Point, createNewPoint?: boolean, globalNode?: Sprite): Point;
        /**
         * @en Converts the global coordinates relative to the stage to the local coordinates.
         * @param point The global coordinate point.
         * @param createNewPoint (Optional) Whether to create a new Point object as the return value. The default is false, which uses the input point object as the return value to reduce object creation overhead.
         * @param globalNode The global node, default is Laya.stage.
         * @return The converted local coordinate point.
         * @zh 把stage的全局坐标转换为本地坐标。
         * @param point 全局坐标点。
         * @param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode global节点，默认为Laya.stage。
         * @return 转换后的坐标的点。
         */
        globalToLocal(point: Point, createNewPoint?: boolean, globalNode?: Sprite): Point;
        /**
         * @en Converts the coordinates in the local coordinate system to the coordinates in the parent container coordinate system.
         * @param point The local coordinate point.
         * @return The converted point in the parent container coordinate system.
         * @zh 将本地坐标系坐标转换到父容器坐标系。
         * @param point 本地坐标点。
         * @return 转换后的点。
         */
        toParentPoint(point: Point): Point;
        /**
         * @en Converts the coordinates in the parent container coordinate system to the coordinates in the local coordinate system.
         * @param point The point in the parent container coordinate system.
         * @return The converted point in the local coordinate system.
         * @zh 将父容器坐标系坐标转换到本地坐标系。
         * @param point 父容器坐标点。
         * @return 转换后的点。
         */
        fromParentPoint(point: Point): Point;
        /**
         * @en Load and display an image. Equivalent to loading the image and then setting the texture property. Note: calling this method multiple times will only display one image.
         * @param url The image URL.
         * @param complete (Optional) The callback function when loading is complete.
         * @returns Returns the Sprite object itself.
         * @zh 加载并显示一个图片。相当于加载图片后，设置texture属性。注意：多次调用，只会显示一个图片。
         * @param url 图片地址。
         * @param complete （可选）加载完成回调。
         * @returns 返回精灵对象本身。
         */
        loadImage(url: string, complete?: Handler): this;
        /**
         * @en Create a new `Sprite` object based on the image URL to load and display the image.
         * @param url The image URL.
         * @returns Returns a new `Sprite` object.
         * @zh 根据图片地址创建一个新的 `Sprite` 对象用于加载并显示此图片。
         * @param url 图片地址。
         * @returns 返回新的 `Sprite`  对象。
         */
        static fromImage(url: string): Sprite;
        /**
         * @en Call this method to refresh the cache when cacheAs is set.
         * @zh 在设置 cacheAs 的情况下，调用此方法会重新刷新缓存。
         */
        reCache(): void;
        /**
         * @en Get the repaint type.
         * @returns The repaint type.
         * @zh 获取重绘类型。
         * @returns 重绘类型。
         */
        getRepaint(): number;
        /**
        * @en Redraw the Sprite and invalidate its own and parent's cache after setting cacheAs.
        * @param flag repaint flag
        * @zh 重新绘制，cacheAs后，设置自己和父对象缓存失效。
        * @param flag 重绘类型。
        */
        repaint(flag?: number): void;
        /**
         * @en Clear the repaint flag.
         * @zh 清除重绘标志。
         */
        clearRepaint(): void;
        /**
         * @internal
         * @en Check if it is re-cached.
         * @returns True if it is re-cached, otherwise false.
         * @zh 检查是否重新缓存。
         * @returns 如果重新缓存值为 true，否则值为 false。
         */
        _needRepaint(): boolean;
        /**
         * @en Repaint the parent node. When `cacheAs` is enabled, set all parent object caches to invalid.
         * @zh 重新绘制父节点。启用 `cacheAs` 时，设置所有父对象缓存失效。
         */
        parentRepaint(): void;
        /**
         * @en Get the drag support object.
         * @return The drag support object (DragSupport).
         * @zh 获取拖拽支持对象。
         * @return 拖拽支持对象 (DragSupport)。
         */
        get dragSupport(): DragSupport;
        /**
         * @en Starts dragging this object.
         * @param area (Optional) The drag area, which is the active area of the object's registration point (excluding the object's width and height).
         * @param hasInertia (Optional) Whether the object has inertia when the mouse is released. The default is false.
         * @param elasticDistance (Optional) The distance value of the elastic effect. A value of 0 means no elastic effect. The default is 0.
         * @param elasticBackTime (Optional) The bounce-back time for the elastic effect in milliseconds. The default is 300 milliseconds.
         * @param data (Optional) The data carried by the drag event.
         * @param ratio (Optional) The inertia damping coefficient, which affects the strength and duration of inertia.
         * @zh 开始拖动此对象。
         * @param area （可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高） 。
         * @param hasInertia （可选）鼠标松开后，是否还惯性滑动，默认为false。
         * @param elasticDistance （可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0。
         * @param elasticBackTime （可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒。
         * @param data （可选）拖动事件携带的数据。
         * @param ratio （可选）惯性阻尼系数，影响惯性力度和时长。
         */
        startDrag(area?: Rectangle, hasInertia?: boolean, elasticDistance?: number, elasticBackTime?: number, data?: any, ratio?: number): void;
        /**
         * @en Stops dragging this object.
         * @zh 停止拖动此对象。
         */
        stopDrag(): void;
        /**
         * @ignore
         */
        onAfterDeserialize(): void;
        protected onStartListeningToType(type: string): void;
        private setDemandTransEventUp;
        /**
         * @internal
         * @en This method should be called when all variable state determining factors change, typically such as the visible property.
         * @return Whether the visible status is actually changed.
         * @zh 这个方法在所有可变状态决定因子改变时都应调用，典型的如visible属性。
         * @return 可见状态是否真正改变了。
         */
        _processVisible(): boolean;
        /**
         * @ignore
         */
        _setUnBelongScene(): void;
        /**
         * @ignore
         * @param scene
         */
        _setBelongScene(scene: Node): void;
        protected _findOwnerArea(): void;
        protected _setStructParent(value: Sprite): void;
        private createSubRenderPass;
        /** @internal */
        updateRenderTexture(): boolean;
        /** @internal */
        updateSubRenderPassState(): void;
        /** @internal */
        _updateStruct(): void;
        /**
         * @en Set the state of the sub-render pass.
         * @param enable Whether to enable the sub-render pass.
         * @zh 设置子渲染通道的状态。
         * @param enable 是否启用子渲染通道。
         */
        setSubRenderPassState(enable: boolean): void;
        /**
         * @ignore
         */
        protected _setParent(value: Node): void;
        private _checkSubRenderPass;
        private _refreshRenderPass;
        /** @ignore */
        _setDisplay(value: boolean): void;
        /**
         * @ignore
         */
        _setChildIndex(node: Sprite, oldIndex: number, index: number): number;
        /**
         * @ignore
         */
        protected _childChanged(child?: Sprite): void;
        /**
         * @ignore
         */
        protected _addComponentInstance(comp: Component): void;
        /** @internal @blueprintEvent */
        Sprite_bpEvent: {
            [Event.MOUSE_DOWN]: (event: Event) => void;
            [Event.MOUSE_UP]: (event: Event) => void;
            [Event.MOUSE_MOVE]: (event: Event) => void;
            [Event.MOUSE_OVER]: (event: Event) => void;
            [Event.MOUSE_OUT]: (evente: Event) => void;
            [Event.MOUSE_DRAG]: (event: Event) => void;
            [Event.MOUSE_DRAG_END]: (event: Event) => void;
            [Event.CLICK]: (event: Event) => void;
            [Event.RIGHT_MOUSE_DOWN]: (event: Event) => void;
            [Event.RIGHT_MOUSE_UP]: (event: Event) => void;
            [Event.RIGHT_CLICK]: (event: Event) => void;
            [Event.DOUBLE_CLICK]: (event: Event) => void;
            [Event.DRAG_START]: (data: any) => void;
            [Event.DRAG_MOVE]: (data: any) => void;
            [Event.DRAG_END]: (data: any) => void;
            [Event.DROP]: (source: Sprite, data: any) => void;
            [SpriteGlobalTransform.CHANGED]: (type: number) => void;
            [Event.TRANSFORM_CHANGED]: () => void;
        };
    }
    /**
     * @ignore
     */
    class SpriteConst {
        static TEXT: number;
        static AREA2D: number;
        static CANVAS: number;
        static POSTPROCESS: number;
        static MASK: number;
        static CLIP: number;
        static GRAPHICS: number;
        static RENDERNODE2D: number;
        static DRAW2RT: number;
        static UPDATETRANS: number;
    }
    enum RepaintFlag {
        Normal = 0,
        Size = 1,
        Graphics = 2,
        ChildChange = 4,
        UpdateRT = 7
    }
    enum TransformKind {
        Pos = 1,
        Width = 2,
        Height = 4,
        Anchor = 8,
        Scale = 16,
        Skew = 32,
        Rotation = 64,
        Matrix = 128,
        Size = 6,
        Layout = 30,
        TRS = 113
    }
    enum BaseRender2DType {
        empty = -1,
        baseRenderNode = 0,
        spine = 1,
        particle = 2,
        spineSimple = 3,
        graphics = 4
    }
    enum SubPassFlag {
        PostProcess = 1,
        CacheAsBitmap = 2,
        Mask = 4,
        RenderTexture = 8,
        /** @internal */
        UPDATE_POSTPROCESS = 9
    }
    class SpriteGlobalTransform {
        private _sp;
        private _flags;
        private _x;
        private _y;
        private _rot;
        private _scaleX;
        private _scaleY;
        private _matrix;
        private _cache;
        /** @internal */
        _modifiedFrame: number;
        /**
         * @zh An event constant for when the global transformation information changes.
         * @zh 全局变换信息发生改变时的事件常量。
         */
        static readonly CHANGED = "globalTransChanged";
        constructor(sp: Sprite);
        /**
         * @en Whether the global transformation information is cached.
         * @zh 是否缓存了全局变换信息。
         */
        get cache(): boolean;
        set cache(value: boolean);
        /**
         * @en Get the global matrix of the sprite.
         * @returns The global transformation matrix of the sprite.
         * @zh 获取精灵的全局矩阵。
         * @returns 精灵的全局变换矩阵。
         */
        getMatrix(): Matrix;
        /**
         * @en return the invert Matrix of the sprite.
         * @zh 返回逆矩阵
         */
        getMatrixInv(out: Matrix): Matrix;
        /**
         * @en The X-axis position in global coordinates.
         * @zh 全局坐标中的 X 轴位置。
         */
        get x(): number;
        /**
         * @en The Y-axis position in global coordinates.
         * @zh 全局坐标中的 Y 轴位置。
         */
        get y(): number;
        /**
         * 获取基于Scene的变换矩阵
         * @param out
         */
        getSceneMatrix(out: Matrix): Matrix;
        /**
         * @en get the scene position of the node.
         * @zh 获取节点对象在相应scene坐标系中的位置。
         * @param out
         */
        getScenePos(out: Point): Point;
        /**
         * @en get the scene scale of the node.
         * @zh 获取节点对象在相应scene坐标系中的放缩值。
         * @param out
         */
        getSceneScale(out: Point): Point;
        /**
         * @en get the scene rotation of the node.
         * @zh 获取节点对象在相应scene坐标系中的旋转值。
         */
        getSceneRotation(): number;
        /**
         * @en get the global position of the node.
         * @zh 获取节点对象在全局坐标系中的位置。
         * @param out
         */
        getPos(out: Point): Point;
        /**
         * @en Sets the global position of the node.
         * @param x The global X position.
         * @param y The global Y position.
         * @zh 设置节点对象在全局坐标系中的位置。
         * @param x 全局X位置。
         * @param y 全局Y位置。
         */
        setPos(x: number, y: number): void;
        /**
         * @en global rotation value relative to the stage (this value includes the rotation of parent nodes).
         * @zh 相对于stage的全局旋转值（会叠加父亲节点的旋转值）。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en Gets the global X-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global X-axis scale.
         * @zh 获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局X轴缩放值。
         */
        get scaleX(): number;
        /**
         * @en Gets the global Y-axis scale relative to the stage (this value includes the scaling of parent nodes).
         * @returns The global Y-axis scale.
         * @zh 获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
         * @returns 全局Y轴缩放值。
         */
        get scaleY(): number;
        private _cachePos;
        private _cacheScale;
        /**
         * @internal
         * @en Gets a global cache flag for a specific type.
         * @param type The type of cache flag to get.
         * @returns Whether the cache flag is enabled.
         * @zh 获取特定类型的全局缓存标志。
         */
        _getFlag(type: number): boolean;
        /**
         * @internal
         * @en Sets a global cache flag for a specific type.
         * @param type The type of cache flag to set.
         * @param value Whether to enable the cache flag.
         * @param notify Whether to notify.
         * @zh 设置特定类型的全局缓存标志。
         * @param type 要设置的缓存标志类型。
         * @param value 是否启用缓存标志。
         * @param notify 是否通知。
         */
        _setFlag(type: number, value: boolean, notify?: boolean): void;
        /**
         * @internal
         */
        _notifyRenderSpriteTransChange(): void;
        /**
         * @param flag
         * @param value
         */
        private _syncFlag;
        /**
         * @internal
         * @param kind
         */
        _spTransChanged(kind: TransformKind): void;
        /**
         * @en Convert the point to the global coordinate system.
         * @param x The X-axis position of the point.
         * @param y The Y-axis position of the point.
         * @returns The global position of the point.
         * @zh 转换点坐标到全局坐标系。
         * @param x 点的X轴位置。
         * @param y 点的Y轴位置。
         * @returns 全局坐标的点。
         */
        localToGlobal(x: number, y: number): Readonly<Point>;
        /**
         * @en Convert the point to the local coordinate system.
         * @param x The X-axis position of the point.
         * @param y The Y-axis position of the point.
         * @returns The local position of the point.
         * @zh 转换点坐标到本地坐标系。
         * @param x 点的X轴位置。
         * @param y 点的Y轴位置。
         * @returns 本地坐标的点。
         */
        globalToLocal(x: number, y: number): Readonly<Point>;
    }
    /**
     * @en Stage is the root node of the display list. All display objects are shown on the stage. It can be accessed through the Laya.stage singleton.
     * Stage provides several adaptation modes. Different adaptation modes will produce different canvas sizes. The larger the canvas, the greater the rendering pressure, so it's important to choose an appropriate adaptation scheme.
     * Stage provides different frame rate modes. The higher the frame rate, the greater the rendering pressure and power consumption. Reasonable use of frame rates or even dynamic changes in frame rates can help improve mobile phone power consumption.
     * - Event.RESIZE("resize"): Discheduled when the stage size is resized.
     * - Event.FOCUS("focus"): Dispatched when the stage gains focus. For example, when the browser or current tab is switched back from the background.
     * - Event.BLUR("blur"): Dispatched when the stage loses focus. For example, when the browser or current tab is switched to the background.
     * - Event.FOCUS_CHANGE("focuschange"): Dispatched when the stage focus changes. Use Laya.stage.isFocused to get whether the current stage has focus.
     * - Event.VISIBILITY_CHANGE("visibilitychange"): Dispatched when the stage visibility changes (e.g., when the browser or current tab is switched to the background). Use Laya.stage.isVisibility to get the current visibility state.
     * - Event.FULL_SCREEN_CHANGE("fullscreenchange"): Discheduled when the browser fullscreen state changes, such as entering or exiting fullscreen mode.
     * @zh Stage 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。
     * Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。
     * Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。
     * - Event.RESIZE("resize"): 舞台大小经过重新调整时进行调度。
     * - Event.FOCUS("focus"): 舞台获得焦点时调度。比如浏览器或者当前标签处于后台，重新切换回来时进行调度。
     * - Event.BLUR("blur"): 舞台失去焦点时调度。比如浏览器或者当前标签被切换到后台后调度。
     * - Event.FOCUS_CHANGE("focuschange"): 舞台焦点变化时调度，使用Laya.stage.isFocused可以获取当前舞台是否获得焦点。
     * - Event.VISIBILITY_CHANGE("visibilitychange"): 舞台可见性发生变化时调度（比如浏览器或者当前标签被切换到后台后调度），使用Laya.stage.isVisibility可以获取当前是否处于显示状态。
     * - Event.FULL_SCREEN_CHANGE("fullscreenchange"): 浏览器全屏更改时调度，比如进入全屏或者退出全屏。
     */
    class Stage extends Sprite {
        /**
         * @en No scaling is applied, and the stage is displayed at its design size. The actual width and height of the canvas are set to the design width and height. This mode is suitable for applications that want to maintain the original design ratio, but it may result in blank areas or content overflow on different devices.
         * @zh 不进行缩放，舞台按照设计尺寸显示，画布的实际宽度和高度设置为设计宽度和高度。这种模式适合希望保持原始设计比例的应用，但在不同设备上可能会出现空白区域或内容超出屏幕的情况。
         */
        static readonly SCALE_NOSCALE: string;
        /**
         * @en The canvas and stage are proportionally scaled to fit the screen as much as possible while preserving the original design aspect ratio. The scaling factor is determined by the smaller ratio between the screen size and the design resolution (width and height), ensuring that all design content remains fully visible without cropping. This approach may result in blank margins at the top/bottom or sides of the screen, which are typically handled using appropriate canvas alignment settings.
         * @zh 保持设计宽高比例的情况下，将画布和舞台等比缩放至屏幕最大尺寸，缩放系数取设计宽度与屏幕宽度、设计高度与屏幕高度之间的最小缩放因子，以确保整个设计宽高的内容可见，避免裁切，但可能会出现上下或左右的空白边缘，通常需要配合画布的对齐方式使用。
         */
        static readonly SCALE_SHOWALL: string;
        /**
         * @en The stage is scaled to fill the screen, with the actual width and height of the canvas calculated based on the design width and height multiplied by the maximum scale factor. This mode ensures that content fully covers the display area, but it may result in some content being cut off.
         * @zh 将舞台缩放以填满屏幕，画布的实际宽度和高度根据设计宽度和高度乘以最大缩放因子计算。这种模式保证内容完全覆盖屏幕，但可能会导致部分设计内容被裁切。
         */
        static readonly SCALE_NOBORDER: string;
        /**
         * @en Set the stage and canvas directly to the screen's width and height. Other aspects are the same as the SCALE_NOSCALE mode, with no scaling applied to the design content itself. This mode is suitable for scenarios where you want to fully utilize the screen space and handle dynamic layout on the screen yourself.
         * @zh 将舞台与画布直接设置为屏幕宽度和高度，其它方面与SCALE_NOSCALE模式一样，不对设计内容本身进行缩放。这种模式适用于希望完全利用屏幕空间，自行对屏幕动态排版的需求。
         */
        static readonly SCALE_FULL: string;
        /**
         * @en The stage width is kept fixed, and scaling is done based on the screen height. The canvas height is calculated based on the screen height and scale factor, and the stage height is set accordingly. This mode ensures consistent width but may alter the height ratio on different devices.
         * @zh 保持舞台的宽度固定，根据屏幕高度进行缩放。画布的高度根据屏幕高度和缩放因子计算，并设置舞台的高度。这种模式确保宽度一致，但在不同设备上可能会改变高度比例。
         */
        static readonly SCALE_FIXED_WIDTH: string;
        /**
         * @en The stage height is kept fixed, and scaling is done based on the screen width. The canvas width is calculated based on the screen width and scale factor, and the stage width is set accordingly. This mode ensures consistent height but may alter the width ratio on different devices.
         * @zh 保持舞台的高度固定，根据屏幕宽度进行缩放。画布的宽度根据屏幕宽度和缩放因子计算，并设置舞台的宽度。这种模式确保高度一致，但在不同设备上可能会改变宽度比例。
         */
        static readonly SCALE_FIXED_HEIGHT: string;
        /**
         * @en The scaling method is automatically chosen based on the comparison between the screen aspect ratio and the design aspect ratio. If the screen aspect ratio is less than the design aspect ratio, the width is kept fixed with equal scale factors and the canvas height is calculated; otherwise, the height is kept fixed with equal scale factors and the canvas width is calculated. This mode flexibly adapts to different devices but may result in content being cut off or blank borders appearing.
         * @zh 根据屏幕宽高比与设计宽高比的比较，自动选择缩放方式；如果屏幕宽高比小于设计宽高比，则保持宽度固定，缩放因子相等并计算画布高度；否则，保持高度固定，缩放因子相等并计算画布宽度。这种模式可以灵活适应不同的设备，但可能会导致内容被裁切或出现空白边缘。
         */
        static readonly SCALE_FIXED_AUTO: string;
        /**
         * @en Canvas is horizontally aligned to the left.
         * @zh 画布水平居左对齐。
         */
        static readonly ALIGN_LEFT: string;
        /**
         * @en Canvas is horizontally aligned to the right.
         * @zh 画布水平居右对齐。
         */
        static readonly ALIGN_RIGHT: string;
        /**
         * @en Canvas is horizontally centered.
         * @zh 画布水平居中对齐。
         */
        static readonly ALIGN_CENTER: string;
        /**
         * @en Canvas is vertically aligned to the top.
         * @zh 画布垂直居上对齐。
         */
        static readonly ALIGN_TOP: string;
        /**
         * @en Canvas is vertically centered.
         * @zh 画布垂直居中对齐。
         */
        static readonly ALIGN_MIDDLE: string;
        /**
         * @en Canvas is vertically aligned to the bottom.
         * @zh 画布垂直居下对齐。
         */
        static readonly ALIGN_BOTTOM: string;
        /**
         * @en Do not change the screen orientation.
         * @zh 不更改屏幕。
         */
        static readonly SCREEN_NONE: string;
        /**
         * @en Automatically switch to landscape mode.
         * @zh 自动横屏。
         */
        static readonly SCREEN_HORIZONTAL: string;
        /**
         * @en Automatically switch to portrait mode.
         * @zh 自动竖屏。
         */
        static readonly SCREEN_VERTICAL: string;
        /**
         * @en Fast mode, running at the configured maximum frame rate (not exceeding the device's maximum frame rate).
         * @zh 快速模式，以配置的最高帧率运行（不得超过设备最高帧率）。
         */
        static readonly FRAME_FAST: string;
        /**
         * @en Slow mode has a frame rate that is half of the fast mode. The principle is to skip rendering every other frame. For example, if the maximum frame rate in fast mode is 60, the maximum frame rate in slow mode would be 30.
         * @zh 慢速模式的帧率是快速模式的一半，其原理是每隔一帧就会跳过渲染。例如快速模式的满帧为60时，慢速模式的满帧则为30。
         */
        static readonly FRAME_SLOW: string;
        /**
         * @en Mouse mode, In this mode, it checks if the last mouse movement occurred within the last two seconds. If it did, `frameMode` will be set to `FRAME_FAST`; otherwise, it will be set to `FRAME_SLOW`.
         * @zh 鼠标模式，该模式下，会检查上一次鼠标移动的时间，如果是在最近的两秒内，帧率的模式会采用快速模式，否则采用慢速模式。
         */
        static readonly FRAME_MOUSE: string;
        /**
         * @en Sleep mode, running at 1 frame per second.
         * @zh 休眠模式，以每秒1帧的速度运行。
         */
        static readonly FRAME_SLEEP: string;
        /**
         * @en The current focus object, which will affect the dispatch of current keyboard events.
         * @zh 当前焦点对象，此对象会影响当前键盘事件的派发主体。
         */
        readonly focus: Node;
        /**
         * @en Offset relative to the browser's top-left corner.
         * @zh 相对浏览器左上角的偏移。
         */
        offset: Point;
        /**
         * @en Design width (the width set during initialization Laya.init(width,height))
         * @zh 设计宽度（初始化时设置的宽度Laya.init(width,height)）
         */
        designWidth: number;
        /**
         * @en Design height (the height set during initialization Laya.init(width,height))
         * @zh 设计高度（初始化时设置的高度Laya.init(width,height)）
         */
        designHeight: number;
        /**
         * @en Whether the canvas has been flipped.
         * @zh 画布是否发生翻转。
         */
        canvasRotation: boolean;
        /**
         * @en The rotation angle of the canvas.
         * @zh 画布的旋转角度。
         */
        canvasDegree: number;
        /**
         * @en Set whether to render. When set to false, rendering can be stopped, the screen will stay on the last render, reducing CPU consumption. This setting does not affect the clock.
         * For example, in an inactive state, you can set renderingEnabled=false to save consumption.
         * @zh 设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。
         * 比如非激活状态，可以设置renderingEnabled=false以节省消耗。
         */
        renderingEnabled: boolean;
        /**
         * @en Whether to enable screen adaptation. After adaptation, screen adaptation can be turned off at some point to prevent unexpected screen changes caused by certain operations.
         * @zh 是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕意外改变。
         */
        screenAdaptationEnabled: boolean;
        /**
         * @en The transformation matrix of the canvas.
         * @zh 画布的变换矩阵。
         */
        readonly _canvasTransform: Matrix;
        /**
         * @en The pass manager for 2D rendering. It manages the rendering passes and processes the rendering of 2D objects.
         * @zh 2D渲染的Pass管理器，管理渲染Pass并处理2D对象的渲染。
         */
        readonly passManager: Render2DProcessor;
        /** @internal */
        readonly _scene3Ds: Scene3D[];
        /** @internal */
        readonly _scene2Ds: Scene[];
        private _frameRate;
        private _screenMode;
        private _scaleMode;
        private _alignV;
        private _alignH;
        private _bgColor;
        private _renderCount;
        private _frameStartTime;
        private _isFocused;
        private _wgColor;
        private _needUpdateCanvasSize;
        /**
         * @ignore @blueprintIgnore
         * @en Stage class, there is only one stage instance in the engine. This instance can be accessed through Laya.stage.
         * @zh 场景类，引擎中只有一个stage实例，此实例可以通过Laya.stage访问。
         * */
        constructor();
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @ignore
         */
        protected measureWidth(): number;
        /**
         * @ignore
         */
        protected measureHeight(): number;
        /**
         * @en Whether the stage has focus.
         * @zh 舞台是否获得焦点。
         */
        get isFocused(): boolean;
        /**
         * @en Indicates whether the stage is in a visible state (whether it has entered the background).
         * @zh 舞台是否处于可见状态(是否进入后台)。
         */
        get isVisibility(): boolean;
        /**
         * @en Update the canvas size
         * @param delay If true, the change will be executed with a delay
         * @zh 更新canvas大小
         * @param delay 是否延迟执行改动，如果为true，将延迟执行
         */
        updateCanvasSize(delay?: boolean): void;
        /**
         * @en Synchronize the final canvas size
         * @zh 同步最终canvas大小
         */
        needUpdateCanvasSize(): void;
        /**
         * @en Set the screen size. The scene will adapt to the screen size. This method can be called dynamically to change the game display size.
         * @param screenWidth The width of the screen.
         * @param screenHeight The height of the screen.
         * @zh 设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
         * @param screenWidth 屏幕宽度。
         * @param screenHeight 屏幕高度。
         */
        setScreenSize(screenWidth: number, screenHeight: number): void;
        /**
         * @en The scale mode. Default value is "noscale".
         * Available values:
         * - "noscale": No scaling.
         * - "showall": The canvas matches the design width and height, and the stage is scaled proportionally to the maximum size while ensuring the design content remains fully visible.
         * - "full": No scaling, the stage width and height equal to the screen width and height.
         * - "fixedwidth": Fixed width, height scales according to the screen ratio.
         * - "fixedheight": Fixed height, width scales according to the screen ratio.
         * - "fixedauto": Automatically choose between fixedwidth or fixedheight based on the aspect ratio.
         * @zh 缩放模式。默认值为 "noscale"。
         * 取值范围：
         * - "noscale"：不缩放，舞台与画布采用设计宽高。
         * - "showall"：画布等于设计宽高，在保障设计内容可见的前提下，按设计宽高对舞台等比缩放至最大。
         * - "full"：不缩放，舞台与画布的宽高等于屏幕宽高。
         * - "fixedwidth"：宽度不变，高度根据屏幕比缩放。
         * - "fixedheight"：高度不变，宽度根据屏幕比缩放。
         * - "fixedauto"：根据宽高比，自动选择使用fixedwidth或fixedheight。
         */
        get scaleMode(): string;
        set scaleMode(value: string);
        /**
         * @en Horizontal alignment of canvas. Default value is "left".
         * Available values:
         * - "left": Align to the left.
         * - "center": Align to the center.
         * - "right": Align to the right.
         * @zh 画布水平对齐方式。默认值为"left"。
         * 取值范围：
         * - "left"：居左对齐。
         * - "center"：居中对齐。
         * - "right"：居右对齐。
         */
        get alignH(): string;
        set alignH(value: string);
        /**
         * @en Vertical alignment of canvas. Default value is "top".
         * Available values:
         * - "top": Align to the top.
         * - "middle": Align to the middle.
         * - "bottom": Align to the bottom.
         * @zh 画布垂直对齐方式。默认值为"top"。
         * 取值范围：
         * - "top"：居顶部对齐。
         * - "middle"：居中对齐。
         * - "bottom"：居底部对齐。
         */
        get alignV(): string;
        set alignV(value: string);
        /**
         * @en The background color of the stage. Default is black, null for transparent.
         * @zh 舞台的背景颜色，默认为黑色，null为透明。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en The X coordinate of the mouse on the Stage.
         * @zh 鼠标在 舞台 上的 X 轴坐标。
         */
        get mouseX(): number;
        /**
         * @en The Y coordinate of the mouse on the Stage.
         * @zh 鼠标在 舞台 上的 Y 轴坐标。
         */
        get mouseY(): number;
        /**
         * @en Get the mouse coordinate information on the screen
         * @returns Screen point information
         * @zh 获得屏幕上的鼠标坐标信息
         * @returns 屏幕点信息
         */
        getMousePoint(): Point;
        /**
         * @en The X-axis scaling factor caused by the current viewport scaling mode.
         * @zh 当前视窗由缩放模式导致的 X 轴缩放系数。
         */
        get clientScaleX(): number;
        /**
         * @en The Y-axis scaling factor caused by the current viewport scaling mode.
         * @zh 当前视窗由缩放模式导致的 Y 轴缩放系数。
         */
        get clientScaleY(): number;
        /**
         * @en The scene layout type.
         * Available values:
         * - "none": Do not change the screen
         * - "horizontal": Automatic landscape mode
         * - "vertical": Automatic portrait mode
         * @zh 场景布局类型。
         * 取值范围：
         * - "none"：不更改屏幕
         * - "horizontal"：自动横屏
         * - "vertical"：自动竖屏
         */
        get screenMode(): string;
        set screenMode(value: string);
        /**
         * @en Get the time elapsed since the current frame started, in milliseconds.
         * This can be used to judge the time consumption within functions, reasonably control the processing time of each frame function, avoid doing too much in one frame, and process complex calculations across frames, which can effectively reduce frame rate fluctuations.
         * @zh 获得距当前帧开始后，过了多少时间，单位为毫秒。
         * 可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。
         */
        getTimeFromFrameStart(): number;
        /**
         * @en Indicates whether it is visible, default is true. If set to invisible, the node will not be rendered.
         * @zh 表示是否可见，默认为true。如果设置不可见，节点将不被渲染。
         */
        get visible(): boolean;
        set visible(value: boolean);
        /**
         * @en Render all display objects on the stage
         * @param timestamp Current time stamp
         * @zh 渲染舞台上的所有显示对象
         * @param timestamp 当前时间戳
         */
        render(timestamp: number): void;
        /** @ignore */
        _graphicUpdateList: Set<Sprite>;
        /** @ignore */
        _subpassUpdateList: Set<Sprite>;
        /** @ignore */
        _tranMatrixUpdateList: Set<Sprite>;
        /**
         * @perfTag PerformanceDefine.T_UIRender
        */
        private _render2d;
        private _updateMatrixList;
        private _runComponents;
        private _updateTimers;
        /**
         * @en Whether to enable fullscreen mode. Users can enter fullscreen mode by clicking.
         *
         * Compatibility note: Some browsers, such as iPhone, do not allow entering fullscreen mode by clicking.
         * @zh 是否开启全屏，用户点击后进入全屏。
         *
         * 兼容性提示：部分浏览器不允许点击进入全屏，比如iPhone等。
         */
        set fullScreenEnabled(value: boolean);
        private fullScreenChanged;
        /**
         * @zh Exit full screen mode
         * @en 退出全屏模式
         */
        exitFullscreen(): void;
        /**
         * @en Frame rate types:fast (default, full frame rate),slow (half of the full frame rate),mouse (full frame rate after mouse activity, switches to half frame rate if the mouse is idle for 2 seconds),sleep (1 frame per second)
         * @zh 当前帧率类型：fast(默认，满帧)，slow（满帧减半），mouse（鼠标活动后满帧，鼠标不动2秒后满帧减半），sleep（每秒1帧）。
         */
        get frameRate(): string;
        set frameRate(value: string);
        /** @internal @blueprintEvent */
        Stage_bpEvent: {
            [Event.KEY_DOWN]: (event: Event) => void;
            [Event.KEY_UP]: (event: Event) => void;
            [Event.KEY_PRESS]: (event: Event) => void;
            [Event.RESIZE]: () => void;
            [Event.FOCUS]: () => void;
            [Event.BLUR]: () => void;
            [Event.FOCUS_CHANGE]: () => void;
            [Event.VISIBILITY_CHANGE]: (visible: boolean) => void;
            [Event.FULL_SCREEN_CHANGE]: () => void;
            [Event.WILL_RESIZE]: () => void;
        };
    }
    /**
     * @en The Text class is used to create display objects to show text.
     * Note: If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
     *  - Event.CHANGE event dispatched after the text content changes.
     *  - Event.LINK event dispatched when a link is clicked.
     * @zh Text类用于创建显示对象以显示文本。
     * 注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
     *  - Event.CHANGE 事件表示文本内容发生改变后调度。
     *  - Event.LINK 事件表示点击链接时调度。
     */
    class Text extends Sprite {
        /**
         * @en Visible without any clipping.
         * @zh visible不进行任何裁切。
         */
        static readonly VISIBLE: string;
        /**
         * @en Scroll does not display character pixels outside the text area and supports the scroll interface.
         * @zh scroll 不显示文本域外的字符像素，并且支持 scroll 接口。
         */
        static readonly SCROLL: string;
        /**
         * @en Hidden does not display characters beyond the text area.
         * @zh hidden 不显示超出文本域的字符。
         */
        static readonly HIDDEN: string;
        /**
         * @en Shrink the entire text to fit the text box when it exceeds the text area.
         * @zh shrink 超出文本域时，文本整体缩小以适应文本框。
         */
        static readonly SHRINK: string;
        /**
         * @en Ellipsis truncates the text and displays an ellipsis at the end when it exceeds the text area.
         * @zh ellipsis 超出文本域时，文本被截断，并且文本最后显示省略号。
         */
        static readonly ELLIPSIS: string;
        /**
         * @en Language pack, a collection of key:value pairs, indexed by key, replaced with target value language.
         * @zh 语言包，是一个包含key:value的集合，用key索引，替换为目标value语言。
         * @blueprintIgnore
         */
        static langPacks: Record<string, string>;
        /**
         * @en Whether the display order is from right to left.
         * @zh 是否是从右向左的显示顺序。
         */
        static RightToLeft: boolean;
        /**
         * @en Predicted length text, used to improve calculation efficiency, find the largest character for different languages.
         * @zh 预测长度的文字，用来提升计算效率，不同语言找一个最大的字符即可。
         */
        static _testWord: string;
        static _passwordChar: string;
        /**
         * @en Dictionary of bitmap fonts.
         * @zh 位图字体字典。
         */
        private static _bitmapFonts;
        /**
         * @en Mark whether this text ignores the language pack.
         * @zh 标记此文本是否忽略语言包。
         */
        ignoreLang: boolean;
        /**
         * @en Represents the text content string.
         * @zh 表示文本内容字符串。
         */
        protected _text: string;
        /**
         * @en Represents the text overflow property.
         * @zh 表示文本的溢出属性。
         */
        protected _overflow: string;
        /**
         * @en Split render.
         * @zh 拆分渲染。
         */
        protected _singleCharRender: boolean;
        protected _textStyle: TextStyle;
        protected _prompt: string;
        /**
         * @en The color of the input prompt.
         * @zh 输入提示符颜色。
         */
        protected _promptColor: string;
        /**
         * @en The background color of the text, represented as a string.
         * @zh 文本背景颜色，以字符串表示。
         */
        protected _bgColor: string;
        /**
         * @en The border color of the text background, represented as a string.
         * @zh 文本边框背景颜色，以字符串表示。
         */
        protected _borderColor: string;
        /**
         * @en The default padding information.
         * [top padding, right padding, bottom padding, left padding] (in pixels).
         * @zh 默认边距信息
         * [上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        protected _padding: number[];
        /**
         * @en Indicates whether the text field using this text format automatically wraps.
         * If the value of wordWrap is true, the text field automatically wraps; if the value is false, the text field does not automatically wrap.
         * @zh 表示使用此文本格式的文本字段是否自动换行。
         * 如果 wordWrap 的值为 true，则该文本字段自动换行；如果值为 false，则该文本字段不自动换行。
         */
        protected _wordWrap: boolean;
        /**
         * @internal
         * @en Specifies whether the text field is a password text field.
         * If the value of this property is true, the text field is considered a password text field and uses asterisks to hide the input characters instead of the actual characters. If false, the text field is not considered a password text field.
         * @zh 指定文本字段是否是密码文本字段。
         * 如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。
         */
        protected _asPassword: boolean;
        protected _htmlParseOptions: HtmlParseOptions;
        protected _templateVars: Record<string, string>;
        /**
         * @en Indicates whether the text content has changed.
         * @zh 表示文本内容是否发生改变。
         */
        protected _isChanged: boolean;
        /**
         * @en Indicates the width of the text in pixels.
         * @zh 表示文本的宽度，以像素为单位。
         */
        protected _textWidth: number;
        /**
         * @en Indicates the height of the text in pixels.
         * @zh 表示文本的高度，以像素为单位。
         */
        protected _textHeight: number;
        protected _realFont: string;
        protected _bitmapFont: BitmapFont;
        protected _scrollPos: Point | null;
        protected _bgDrawCmd: DrawRectCmd;
        protected _html: boolean;
        protected _ubb: boolean;
        protected _lines: Array<ITextLine>;
        protected _elements: Array<HtmlElement>;
        protected _objContainer: Sprite;
        protected _maxWidth: number;
        protected _hideText: boolean;
        private _updatingLayout;
        private _fontSizeScale;
        private _fontGlobalScale;
        /**
         * @internal
         * @en Whether to convert` \n `and `\t `in the string to functional characters.
         * @zh 是否将字符串中的`\n`,`\t`转换为实际功能的字符。
         */
        _parseEscapeChars: boolean;
        /**
         * An callback function for wrappers to do something after layout updated.
         */
        _onPostLayout: () => void;
        /**
         * An callback to translate the text.
         */
        _onTranslate: (text: string, options: any) => string;
        /**
         * @en Constructor method of Text.
         * @zh 文本的构造方法
         */
        constructor();
        /**
         * @en Register a bitmap font.
         * @param name The name of the bitmap font.
         * @param bitmapFont The bitmap font file.
         * @zh 注册位图字体。
         * @param name 位图字体的名称。
         * @param bitmapFont 位图字体文件。
         */
        static registerBitmapFont(name: string, bitmapFont: BitmapFont): void;
        /**
         * @en Remove a registered bitmap font file.
         * @param name The name of the bitmap font.
         * @param destroy Whether to destroy the specified font file. Default is true.
         * @zh 移除注册的位图字体文件。
         * @param name 位图字体的名称。
         * @param destroy 是否销毁指定的字体文件。默认为 true。
         */
        static unregisterBitmapFont(name: string, destroy?: boolean): void;
        /**
         * @en Destroy the text.
         * @param destroyChild Whether to destroy child nodes. Default is true.
         * @zh 销毁文本。
         * @param destroyChild 是否销毁子节点。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @ignore
         */
        protected measureWidth(): number;
        /**
         * @ignore
         */
        protected measureHeight(): number;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @ignore
         */
        private _updateScrollRect;
        /**
         * @en The width of the text in pixels.
         * @zh 文本的宽度，以像素为单位。
         */
        get textWidth(): number;
        /**
         * @en The height of the text in pixels.
         * @zh 文本的高度，以像素为单位。
         */
        get textHeight(): number;
        /**
         * @en The current content string of the text.
         * @zh 当前文本的内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @deprecated
         * @param text 文本
         */
        changeText(text: string): void;
        /**
         * @en The font name of the text, represented as a string.
         * The default value is "Arial", which can be set through Config.defaultFont.
         * If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
         * @zh 文本的字体名称，以字符串形式表示。
         * 默认值为："Arial"，可以通过Config.defaultFont设置默认字体。
         * 如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en The actual font name used for rendering.
         * @zh 实际用于渲染的字体名称。
         */
        get realFont(): string;
        /**
         * @en Specifies the font size of the text in pixels.
         * The default is 20 pixels, which can be set through Config.defaultFontSize.
         * @zh 指定文本的字体大小（以像素为单位）。
         * 默认为20像素，可以通过 Config.defaultFontSize 设置默认大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en Represents the color value of the text. The default color can be set through Text.defaultColor.
         * The default value is black.
         * @zh 表示文本的颜色值。可以通过 Text.defaultColor 设置默认颜色。
         * 默认值为黑色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Specifies whether the text is bold.
         * The default value is false, which means bold is not used. If the value is true, the text is bold.
         * @zh 指定文本是否为粗体字。
         * 默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Indicates whether the text using this text format is italic.
         * The default value is false, which means italic is not used. If the value is true, the text is italic.
         * @zh 表示使用此文本格式的文本是否为斜体。
         * 默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Represents the horizontal alignment of the text.
         * Possible values:
         * - "left": Left-aligned.
         * - "center": Center-aligned.
         * - "right": Right-aligned.
         * @zh 表示文本的水平显示方式。
         * 取值：
         * - "left"： 居左对齐显示。
         * - "center"： 居中对齐显示。
         * - "right"： 居右对齐显示。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Represents the vertical alignment of the text.
         * Possible values:
         * - "top": Top-aligned.
         * - "middle": Middle-aligned.
         * - "bottom": Bottom-aligned.
         * @zh 表示文本的垂直显示方式。
         * 取值：
         * - "top"： 居顶部对齐显示。
         * - "middle"： 居中对齐显示。
         * - "bottom"： 居底部对齐显示。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en Alignment of images and text in mixed content. Possible values are top, middle, bottom.
         * @zh 图文混排时图片和文字的对齐方式。可选值是 top, middle, bottom。
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @en Indicates whether the text automatically wraps, default is false.
         * If true, the text will automatically wrap; otherwise, it will not.
         * @zh 表示文本是否自动换行，默认为 false。
         * 若值为 true，则自动换行；否则不自动换行。
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * @en Vertical line spacing in pixels.
         * @zh 垂直行间距（以像素为单位）。
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Margin information.
         * Data format: [top margin, right margin, bottom margin, left margin] (margins in pixels).
         * @zh 边距信息。
         * 数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        get padding(): number[];
        set padding(value: number[] | string);
        /**
         * @en Text background color, represented as a string.
         * @zh 文本背景颜色，以字符串表示。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en Text border background color, represented as a string.
         * @zh 文本边框背景颜色，以字符串表示。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en Stroke width in pixels.
         * The default value is 0, which means no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Stroke color, represented as a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Specifies the behavior when text exceeds the text area.
         * Values: visible, hidden, scroll, shrink, ellipsis.
         * Effects:
         * - visible: All text is visible regardless of text width and height constraints.
         * - hidden: Text exceeding width and height will be clipped, best for performance.
         * - scroll: Parts exceeding width and height are hidden, can be controlled by scrolling.
         * - shrink: Text size automatically adjusts to fit within the width and height.
         * - ellipsis: When text exceeds width and height, last few characters are replaced with ellipsis.
         * @zh 指定文本超出文本域后的行为。
         * 值为：可见visible、隐藏hidden、滚动scroll、自动收缩shrink、显示省略号ellipsis。
         * 作用：
         * - 可见：文本不受文本宽高约束全部可见。
         * - 隐藏：超过文本宽高就会被裁切掉，性能最好。
         * - 滚动：超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域。
         * - 自动收缩：文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内。
         * - 显示省略号：当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容。
         */
        get overflow(): string;
        set overflow(value: string);
        /**
         * @en Whether to display underline.
         * @zh 是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en The color of the underline. If null, it uses the font color.
         * @zh 下划线的颜色。如果为null，则使用字体颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        /**
         * @en Whether to display strikethrough.
         * @zh 是否显示删除线。
         */
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * @en The color of the strikethrough. If null, it uses the font color.
         * @zh 下划线的颜色，为null则使用字体颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Whether single character rendering is enabled. Enable this if the text content changes frequently, such as an increasing number, to prevent inefficient use of cache.
         * @zh 是否启用单个字符渲染。如果Text的内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存
         */
        get singleCharRender(): boolean;
        set singleCharRender(value: boolean);
        /**
         * @en Whether rich text is enabled, supporting HTML syntax.
         * @zh 是否启用富文本，支持HTML语法。
         */
        get html(): boolean;
        set html(value: boolean);
        /**
         * @en Whether UBB syntax parsing is enabled for text.
         * @zh 是否启用UBB语法解析文本。
         */
        get ubb(): boolean;
        set ubb(value: boolean);
        /**
         * @en The maximum width allowed for text. When text reaches this width, it will automatically wrap. Set to 0 to disable this limit.
         * @zh 文本允许的最大宽度。当文本达到这个宽度时，将自动换行。设置为0则此限制不生效。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en Rich text HTML mode options.
         * @zh 富文本HTML模式选项。
         */
        get htmlParseOptions(): HtmlParseOptions;
        set htmlParseOptions(value: HtmlParseOptions);
        /**
         * @en Text Template
         * @zh 文本模板
         */
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        /**
         * @en Set the value of a template variable.
         * @param name The name of the template variable.
         * @param value The value to set.
         * @returns The current Text instance.
         * @zh 设置模板值。
         * @param name 模板名
         * @param value 值
         * @returns 当前 Text 实例。
         */
        setVar(name: string, value: any): this;
        /**
         * @en The horizontal scroll amount.
         * Even if a value outside the scroll range is set, it will be automatically limited to the maximum possible value.
         * @zh 横向滚动量。
         * 即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
         */
        get scrollX(): number;
        set scrollX(value: number);
        /**
         * @en The vertical scroll amount (in pixels).
         * Even if a value outside the scroll range is set, it will be automatically limited to the maximum possible value.
         * @zh 纵向滚动量（以像素为单位）。
         * 即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
         */
        get scrollY(): number;
        set scrollY(value: number);
        /**
         * @en The maximum horizontal scrollable value.
         * @zh 横向可滚动的最大值。
         */
        get maxScrollX(): number;
        /**
         * @en The maximum vertical scrollable value.
         * @zh 纵向可滚动的最大值。
         */
        get maxScrollY(): number;
        /**
         * @en The text line information.
         * @zh 文字行信息。
         */
        get lines(): ReadonlyArray<ITextLine>;
        /**
         * @internal
         */
        protected markChanged(): void;
        /**
         * @en Typeset the text.
         * @zh 排版文本。
         */
        typeset(): void;
        /**
         * @en Refresh the layout with a delay.
         * @zh 延迟刷新排版。
         */
        refreshLayout(): void;
        /**
         * @en The object container.
         * @zh 对象容器。
         */
        get objContainer(): Sprite;
        /**
         * @en Hide the text. This is commonly used for input text field when it is focused.
         * @zh 隐藏文本。常用于输入文本框处于焦点时。
         */
        hideText(value: boolean): void;
        /**
         * 排版文本。
         * 进行宽高计算，渲染、重绘文本。
         */
        protected _typeset(): void;
        /**
         * @en Analyze text wrapping.
         * @zh 分析文本换行。
         */
        protected doLayout(): void;
        /**
         * @en Render the text.
         * @zh 渲染文字。
         */
        protected renderText(): void;
        /**
         * @en Draw background
         * @zh 绘制背景
         */
        protected drawBg(): void;
        /** @ignore */
        protected _setParent(value: Node): void;
        /** @internal @blueprintEvent */
        Text_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.LINK]: (href: string) => void;
        };
    }
    interface ITextCmd {
        x: number;
        y: number;
        width: number;
        height: number;
        style: TextStyle;
        ctxFont: string;
        fontSize: number;
        wt: WordText;
        obj: IHtmlObject;
        linkEnd: boolean;
        next: ITextCmd;
        prev: ITextCmd;
    }
    /**  @blueprintIgnore */
    interface ITextLine {
        x: number;
        y: number;
        height: number;
        width: number;
        cmd: ITextCmd;
    }
    /**
     * @deprecated
     * @internal
     */
    class ButtonEffect {
        private _tar;
        private _curState;
        private _curTween;
        /**
         * effectScale
         * @prop {name:effectScale,type:number, tips:"缩放值",default:"1.5"}
         */
        effectScale: number;
        /**
         * tweenTime
         * @prop {name:tweenTime,type:number, tips:"缓动时长",default:"300"}
         */
        tweenTime: number;
        /**
         * effectEase
         * @prop {name:effectEase,type:ease, tips:"效果缓动类型"}
         */
        effectEase: string;
        /**
         * backEase
         * @prop {name:backEase,type:ease, tips:"恢复缓动类型"}
         */
        backEase: string;
        /**
         * 设置控制对象
         * @param tar
         */
        set target(tar: Sprite);
        private toChangedState;
        private toInitState;
        private tweenComplete;
    }
    /**
     * @en Effect plugin base class, managed based on the object pool.
     * @zh 效果插件基类，基于对象池管理。
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    class EffectBase extends Component {
        /**
         * @en The duration of the animation in milliseconds.
         * @zh 动画持续时间，单位为毫秒。
         */
        duration: number;
        /**
         * @en The delay time of the animation in milliseconds.
         * @zh 动画延迟时间，单位为毫秒。
         */
        delay: number;
        /**
         * @en The repeat count of the animation. Default is to play once.
         * @zh 动画的重复次数。默认为播放一次。
         */
        repeat: number;
        /**
         * @en The type of easing. If empty, it defaults to uniform speed playback.
         * @zh 缓动类型，如果为空，则默认为匀速播放。
         */
        ease: string;
        /**
         * @en The event that triggers the effect. If empty, it triggers upon creation.
         * @zh 触发事件，如果为空，则创建时触发。
         */
        eventName: string;
        /**
         * @en The target object of the effect. If empty, it is the node where the script is located.
         * @zh 效用作用的目标对象，如果为空，则是脚本所在的节点本身。
         */
        target: Sprite;
        /**
         * @en Whether to automatically remove the node when the effect is complete.
         * @zh 效果结束后，是否自动移除节点。
         */
        autoDestroyAtComplete: boolean;
        protected _comlete: Handler;
        protected _tween: Tween;
        readonly owner: Sprite;
        protected _onAwake(): void;
        protected _exeTween(): void;
        protected _doTween(): Tween;
        /**
         * @en Reset the effect properties to their default values.
         * @zh 重置效果属性到默认值。
         */
        onReset(): void;
    }
    /**
     * @en Fade in effect
     * @zh 淡入效果
     */
    class FadeIn extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    /**
     * @en Fade out effect
     * @zh 淡出效果
     */
    class FadeOut extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    interface ITouchInfo {
        touchId: number;
        readonly pos: Point;
    }
    /**
     * @en `Event` is a collection of event types. Generally, when an event occurs, the `Event` object is passed as a parameter to the event listener.
     * @zh `Event` 是事件类型的集合。一般当发生事件时,`Event` 对象将作为参数传递给事件侦听器。
     */
    class Event {
        /**
         * @en An empty Event object. Used for event dispatch transfer.
         * @zh 一个空的 Event 对象。用于事件派发中转使用。
         */
        static readonly EMPTY: Readonly<Event>;
        /**
         * @en Defines the value of the `type` property of a `mousedown` event object, triggered when pressed on a display object.
         * @zh 定义 `mousedown` 事件对象的 `type` 属性值，用于在显示对象上按下后触发。
         */
        static readonly MOUSE_DOWN = "mousedown";
        /**
         * @en Defines the value of the `type` property of a `mouseup` event object, triggered when released on a display object.
         * @zh 定义 `mouseup` 事件对象的 `type` 属性值，用于在显示对象抬起后触发。
         */
        static readonly MOUSE_UP = "mouseup";
        /**
         * @en Defines the value of the `type` property of a `rightmousedown` event object.
         * @zh 定义 `rightmousedown` 事件对象的 `type` 属性值。
         */
        static readonly RIGHT_MOUSE_DOWN = "rightmousedown";
        /**
         * @en Defines the value of the `type` property of a `rightmouseup` event object.
         * @zh 定义 `rightmouseup` 事件对象的 `type` 属性值。
         */
        static readonly RIGHT_MOUSE_UP = "rightmouseup";
        /**
         * @en Defines the value of the `type` property of a `click` event object, triggered when a mouse click completes on a display object.
         * @zh 定义 `click` 事件对象的 `type` 属性值，用于鼠标点击对象后触发。
         */
        static readonly CLICK = "click";
        /**
         * @en Defines the value of the `type` property of a `rightclick` event object.
         * @zh 定义 `rightclick` 事件对象的 `type` 属性值。
         */
        static readonly RIGHT_CLICK = "rightclick";
        /**
         * @en Defines the value of the `type` property of a `mousemove` event object, triggered when mouse moves over a display object.
         * @zh 定义 `mousemove` 事件对象的 `type` 属性值，用于鼠标在对象身上进行移动后触发。
         */
        static readonly MOUSE_MOVE = "mousemove";
        /**
         * @en Defines the value of the `type` property of a `mouseover` event object.
         * @zh 定义 `mouseover` 事件对象的 `type` 属性值。
         */
        static readonly MOUSE_OVER = "mouseover";
        /**
         * @en Defines the value of the `type` property of a `mouseout` event object.
         * @zh 定义 `mouseout` 事件对象的 `type` 属性值。
         */
        static readonly MOUSE_OUT = "mouseout";
        /**
         * @en Defines the value of the `type` property of a `mousewheel` event object.
         * @zh 定义 `mousewheel` 事件对象的 `type` 属性值。
         */
        static readonly MOUSE_WHEEL = "mousewheel";
        /**
         * @en Defines the value of the `type` property of a `mouseover` event object.
         * @zh 定义 `mouseover` 事件对象的 `type` 属性值。
         */
        static readonly ROLL_OVER = "mouseover";
        /**
         * @en Defines the value of the `type` property of a `mouseout` event object, triggered when mouse leaves a display object.
         * @zh 定义 `mouseout` 事件对象的 `type` 属性值，用于鼠标离开对象后触发。
         */
        static readonly ROLL_OUT = "mouseout";
        /**
         * @en Defines the value of the `type` property of a `doubleclick` event object.
         * @zh 定义 `doubleclick` 事件对象的 `type` 属性值。
         */
        static readonly DOUBLE_CLICK = "doubleclick";
        /**
         * @en Defines the value of the `type` property of a `mousedrag` event object.
         * @zh 定义 `mousedrag` 事件对象的 `type` 属性值。
         */
        static readonly MOUSE_DRAG = "mousedrag";
        /**
         * @en Defines the value of the `type` property of a `mousedragend` event object.
         * @zh 定义 `mousedragend` 事件对象的 `type` 属性值。
         */
        static readonly MOUSE_DRAG_END = "mousedragend";
        /**
         * @en Defines the value of the `type` property of a `dragstart` event object, triggered when drag start.
         * @zh 定义 `dragstart` 事件对象的 `type` 属性值，用于开始拖动后触发。
         */
        static readonly DRAG_START = "dragstart";
        /**
         * @en Defines the value of the `type` property of a `dragmove` event object, triggered when dragging.
         * @zh 定义 `dragmove` 事件对象的 `type` 属性值，用于拖动中触发。
         */
        static readonly DRAG_MOVE = "dragmove";
        /**
         * @en Defines the value of the `type` property of a `dragend` event object, triggered when drag end.
         * @zh 定义 `dragend` 事件对象的 `type` 属性值，用于拖动结束后触发。
         */
        static readonly DRAG_END = "dragend";
        /**
         * @en Defines the value of the `type` property of a `drop` event object, triggered when drop occured.
         * @zh 定义 `drop` 事件对象的 `type` 属性值，用于拖动放置后触发。
         */
        static readonly DROP = "drop";
        /**
         * @en Defines the value of the `type` property of a `keydown` event object.
         * @zh 定义 `keydown` 事件对象的 `type` 属性值。
         */
        static readonly KEY_DOWN = "keydown";
        /**
         * @en Defines the value of the `type` property of a `keypress` event object.
         * @zh 定义 `keypress` 事件对象的 `type` 属性值。
         */
        static readonly KEY_PRESS = "keypress";
        /**
         * @en Defines the value of the `type` property of a `keyup` event object.
         * @zh 定义 `keyup` 事件对象的 `type` 属性值。
         */
        static readonly KEY_UP = "keyup";
        /**
         * @en Defines the value of the `type` property of a `change` event object.
         * @zh 定义 `change` 事件对象的 `type` 属性值。
         */
        static readonly CHANGE = "change";
        /**
         * @en Defines the value of the `type` property of a `changed` event object.
         * @zh 定义 `changed` 事件对象的 `type` 属性值。
         */
        static readonly CHANGED = "changed";
        /**
         * @en Defines the value of the `type` property of a `moved` event object.
         * @zh 定义 `moved` 事件对象的 `type` 属性值。
         */
        static readonly MOVED = "moved";
        /**
         * @en Defines the value of the `type` property of a `willResize` event object.
         * @zh 定义 `willResize` 事件对象的 `type` 属性值。
         */
        static readonly WILL_RESIZE = "willResize";
        /**
         * @en Defines the value of the `type` property of a `resize` event object.
         * @zh 定义 `resize` 事件对象的 `type` 属性值。
         */
        static readonly RESIZE = "resize";
        /**
         * @en Defines the value of the `type` property of an `added` event object.
         * @zh 定义 `added` 事件对象的 `type` 属性值。
         */
        static readonly ADDED = "added";
        /**
         * @en Defines the value of the `type` property of a `removed` event object.
         * @zh 定义 `removed` 事件对象的 `type` 属性值。
         */
        static readonly REMOVED = "removed";
        /**
         * @en Defines the value of the `type` property of a `display` event object.
         * @zh 定义 `display` 事件对象的 `type` 属性值。
         */
        static readonly DISPLAY = "display";
        /**
         * @en Defines the value of the `type` property of an `undisplay` event object.
         * @zh 定义 `undisplay` 事件对象的 `type` 属性值。
         */
        static readonly UNDISPLAY = "undisplay";
        /**
         * @en Defines the value of the `type` property of an `error` event object.
         * @zh 定义 `error` 事件对象的 `type` 属性值。
         */
        static readonly ERROR = "error";
        /**
         * @en Defines the value of the `type` property of a `complete` event object.
         * @zh 定义 `complete` 事件对象的 `type` 属性值。
         */
        static readonly COMPLETE = "complete";
        /**
         * @en Defines the value of the `type` property of a `loaded` event object.
         * @zh 定义 `loaded` 事件对象的 `type` 属性值。
         */
        static readonly LOADED = "loaded";
        /**
         * @en Defines the value of the `type` property of a `ready` event object.
         * @zh 定义 `ready` 事件对象的 `type` 属性值。
         */
        static readonly READY = "ready";
        /**
         * @en Defines the value of the `type` property of a `progress` event object.
         * @zh 定义 `progress` 事件对象的 `type` 属性值。
         */
        static readonly PROGRESS = "progress";
        /**
         * @en Defines the value of the `type` property of an `input` event object.
         * @zh 定义 `input` 事件对象的 `type` 属性值。
         */
        static readonly INPUT = "input";
        /**
         * @en Defines the value of the `type` property of a `render` event object.
         * @zh 定义 `render` 事件对象的 `type` 属性值。
         */
        static readonly RENDER = "render";
        /**
         * @en Defines the value of the `type` property of an `open` event object.
         * @zh 定义 `open` 事件对象的 `type` 属性值。
         */
        static readonly OPEN = "open";
        /**
         * @en Defines the value of the `type` property of a `message` event object.
         * @zh 定义 `message` 事件对象的 `type` 属性值。
         */
        static readonly MESSAGE = "message";
        /**
         * @en Defines the value of the `type` property of a `close` event object.
         * @zh 定义 `close` 事件对象的 `type` 属性值。
         */
        static readonly CLOSE = "close";
        /**
         * @en Defines the value of the `type` property of a `enterframe` event object.
         * @zh 定义 `enterframe` 事件对象的 `type` 属性值。
         */
        static readonly FRAME = "enterframe";
        /**
         * @en Defines the value of the `type` property of an `enter` event object.
         * @zh 定义 `enter` 事件对象的 `type` 属性值。
         */
        static readonly ENTER = "enter";
        /**
         * @en Defines the value of the `type` property of a `select` event object.
         * @zh 定义 `select` 事件对象的 `type` 属性值。
         */
        static readonly SELECT = "select";
        /**
         * @en Defines the value of the `type` property of a `blur` event object.
         * @zh 定义 `blur` 事件对象的 `type` 属性值。
         */
        static readonly BLUR = "blur";
        /**
         * @en Defines the value of the `type` property of a `focus` event object.
         * @zh 定义 `focus` 事件对象的 `type` 属性值。
         */
        static readonly FOCUS = "focus";
        /**
         * @en Defines the value of the `type` property of a `visibilitychange` event object.
         * @zh 定义 `visibilitychange` 事件对象的 `type` 属性值。
         */
        static readonly VISIBILITY_CHANGE = "visibilitychange";
        /**
         * @en Defines the value of the `type` property of a `orientationchange` event object.
         * @zh 定义 `orientationchange` 事件对象的 `type` 属性值。
         */
        static readonly ORIENTATION_CHANGE = "orientationchange";
        /**
         * @en Defines the value of the `type` property of a `focuschange` event object.
         * @zh 定义 `focuschange` 事件对象的 `type` 属性值。
         */
        static readonly FOCUS_CHANGE = "focuschange";
        /**
         * @en Defines the value of the `type` property of a `played` event object.
         * @zh 定义 `played` 事件对象的 `type` 属性值。
         */
        static readonly PLAYED = "played";
        /**
         * @en Defines the value of the `type` property of a `paused` event object.
         * @zh 定义 `paused` 事件对象的 `type` 属性值。
         */
        static readonly PAUSED = "paused";
        /**
         * @en Defines the value of the `type` property of a `stopped` event object.
         * @zh 定义 `stopped` 事件对象的 `type` 属性值。
         */
        static readonly STOPPED = "stopped";
        /**
         * @en Defines the value of the `type` property of a `start` event object.
         * @zh 定义 `start` 事件对象的 `type` 属性值。
         */
        static readonly START = "start";
        /**
         * @en Defines the value of the `type` property of an `end` event object.
         * @zh 定义 `end` 事件对象的 `type` 属性值。
         */
        static readonly END = "end";
        /**
         * @en Defines the value of the `type` property of a `link` event object.
         * @zh 定义 `link` 事件对象的 `type` 属性值。
         */
        static readonly LINK = "link";
        /**
         * @en Defines the value of the `type` property of a `label` event object.
         * @zh 定义 `label` 事件对象的 `type` 属性值。
         */
        static readonly LABEL = "label";
        /**
         * @en Triggered when the full screen state changes in the browser.
         * @zh 浏览器全屏更改时触发
         */
        static readonly FULL_SCREEN_CHANGE = "fullscreenchange";
        /**
         * @en Triggered when the GPU device is lost.
         * @zh 显卡设备丢失时触发
         */
        static readonly DEVICE_LOST = "devicelost";
        /**
         * @en Triggered when the world matrix is updated.
         * @zh 世界矩阵更新时触发。
         */
        static readonly TRANSFORM_CHANGED = "transformchanged";
        /**
         * @en Triggered when a 3D layer changes.
         * @zh 3D layer改变时触发。
         */
        static readonly LAYER_CHANGE = "layerChange";
        /**
        * @en Triggered when 3D Static changes.
        * @zh 3D Static改变时触发。
        */
        static readonly STATIC_MASK = "staticMask";
        /**
         * @en For 2D physics collision or 3D physics trigger start.
         * @zh 2D物理碰撞或3D物理触发开始。
         */
        static readonly TRIGGER_ENTER = "triggerenter";
        /**
         * @en For 2D physics collision or 3D physics trigger continues.
         * @zh 2D物理碰撞或3D物理触发持续。
         */
        static readonly TRIGGER_STAY = "triggerstay";
        /**
         * @en For 2D physics collision or 3D physics trigger end.
         * @zh 2D物理碰撞或3D物理触发结束。
         */
        static readonly TRIGGER_EXIT = "triggerexit";
        /**
         * @en 3DPhysical collision start.
         * @zh 3D物理碰撞开始。
         */
        static readonly COLLISION_ENTER = "collisionenter";
        /**
         * @en 3DPhysical collision continues.
         * @zh 3D物理碰撞持续。
         */
        static readonly COLLISION_STAY = "collisionstay";
        /**
         * @en 3DPhysical collision end.
         * @zh 3D物理碰撞结束。
         */
        static readonly COLLISION_EXIT = "collisionexit";
        /**
         * @en Joint destruction.
         * @zh 关节破坏。
         */
        static readonly JOINT_BREAK = "jointbreak";
        /**
         * @zh 激活物理3D事件过滤器。
         * @en Activate the physics 3D event filter.
         */
        static readonly UPDATE_PHY_EVENT_FILTER = "physics3dEventFilter";
        /**
         * @en Checks whether the specified event type is a mouse event.
         * @param type The type of the event.
         * @returns True if the specified event type is a mouse event; otherwise, false.
         * @zh 检测指定事件类型是否是鼠标事件。
         * @param type 事件的类型。
         * @returns 如果是鼠标事件，则值为 true;否则，值为 false。
         */
        static isMouseEvent(type: string): boolean;
        /**
         * @en The event type.
         * @zh 事件类型。
         */
        type: string;
        /**
         * @en The triggering object of the event.
         * @zh 事件目标触发对象。
         */
        target: any;
        /**
         * @en The current propagation object of the event.
         * @zh 事件当前冒泡对象。
         */
        currentTarget: any;
        /**
         * @en Unique identifier assigned to the touch point (as an int).
         * @zh 分配给触摸点的唯一标识号（作为 int）。
         */
        touchId: number;
        /**
         * @en The clicked position.
         * @zh 点击坐标。
         */
        readonly touchPos: Point;
        /**
         * @en Specifies whether this is a double-click.
         * @zh 是否双击。
         */
        isDblClick: boolean;
        /**
         * @en The scroll wheel increments.
         * @zh 滚轮滑动增量。
         */
        delta: number;
        /**
         * @en The mouse button.
         * - 0: Main button, usually the left button
         * - 1: Auxiliary button, usually the middle button (wheel button)
         * - 2: Secondary button, usually the right button
         * - 3: Fourth button, typically the browser Back button
         * - 4: Fifth button, typically the browser Forward button
         * @zh 鼠标按键，
         * - 0：主按键，通常指鼠标左键
         * - 1：辅助按键，通常指鼠标滚轮中键
         * - 2：次按键，通常指鼠标右键
         * - 3：第四个按钮，通常指浏览器后退按钮
         * - 4：第五个按钮，通常指浏览器的前进按钮
         */
        button: number;
        /**
         * @en The original browser event.
         * @zh 原生浏览器事件。
         */
        nativeEvent: MouseEvent | TouchEvent | WheelEvent | KeyboardEvent;
        /** @internal */
        _stopped: boolean;
        /** @internal */
        _defaultPrevented: boolean;
        /** @internal */
        _touches: ReadonlyArray<Readonly<ITouchInfo>>;
        constructor();
        /**
         * @en Sets the event data.
         * @param type The type of the event.
         * @param currentTarget The triggering object of the event.
         * @param target The current propagation object of the event.
         * @returns The current Event object.
         * @zh 设置事件数据。
         * @param type 事件类型。
         * @param currentTarget 事件目标触发对象。
         * @param target 事件当前冒泡对象。
         * @returns 返回当前 Event 对象。
         */
        setTo(type: string, currentTarget: any, target: any): Event;
        /**
         * @en Prevents processing of all event listeners on the current node in the event flow after the current one.
         * This method does not affect any event listeners on the current node (currentTarget).
         * @zh 阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。
         */
        stopPropagation(): void;
        /**
         * @en Cancels the event's default behavior.
         * @zh 禁止事件的默认行为
         */
        preventDefault(): void;
        /**
         * @en The list of touch points.
         * @zh 触摸点列表。
         */
        get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        /**
         * @en Indicates whether the Alt key is active (true) or inactive (false).
         * @zh 表示 Alt 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get altKey(): boolean;
        /**
         * @en Indicates whether the Ctrl key is active (true) or inactive (false).
         * @zh 表示 Ctrl 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get ctrlKey(): boolean;
        /**
         * @en Indicates whether the Shift key is active (true) or inactive (false).
         * @zh 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get shiftKey(): boolean;
        /**
         * @en Indicates whether the Meta key is active (true) or inactive (false). It is Command key on the Mac, and the Windows key on Windows.
         * @zh 表示 Meta 键是处于活动状态 (true) 还是非活动状态 (false)。在 Mac 上是 Command 键，在 Windows 上是 Windows 键。
         */
        get metaKey(): boolean;
        /**
         * @en The event name.
         * @zh 事件名称。
         */
        get key(): string;
        /**
         * @en The event name index.
         * @zh 事件名称索引。
         */
        get keyCode(): number;
        /**
         * @en Contains the character code value of the key pressed or released. The character code value is for English keyboard.
         * @zh 包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
         */
        get charCode(): string;
        /**
         * @en Indicates the location of the key on the keyboard. This is useful for differentiating keys that appear more than once on the keyboard.
         * For example, you can use this property to distinguish between the left and right Shift keys: the value of KeyLocation.LEFT for the left Shift key and the value of KeyLocation.RIGHT for the right Shift key. Another example is distinguishing between a key pressed on the standard keyboard (KeyLocation.STANDARD) and the same key pressed on the numeric keypad (KeyLocation.NUM_PAD).
         * @zh 表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。
         * 例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD) 与数字键盘 (KeyLocation.NUM_PAD) 上按下的数字键。
         */
        get keyLocation(): number;
        /**
         * @en The X axis coordinate of the mouse on the Stage.
         * @zh 鼠标在 Stage 上的 X 轴坐标。
         */
        get stageX(): number;
        /**
         * @en The Y axis coordinate of the mouse on the Stage.
         * @zh 鼠标在 Stage 上的 Y 轴坐标。
         */
        get stageY(): number;
    }
    /**
     * @en The `EventDispatcher` class is the base class for all classes that dispatch events.
     * @zh `EventDispatcher` 类是可调度事件的所有类的基类。
     * @blueprintable
     */
    class EventDispatcher {
        /**@private */
        private _events;
        /**
         * @en Start listening to a specific event type.
         * This method is called when a new event listener is added.
         * @param type The event type to listen to.
         * @zh 开始监听特定事件类型。
         * 添加新的事件侦听器时调用此方法。
         * @param type 要监听的事件类型。
         */
        protected onStartListeningToType(type: string): void;
        /**
         * @en Check if the EventDispatcher object has any listeners registered for a specific type of event.
         * @param type The type of event.
         * @returns True if a listener of the specified type is registered, false otherwise.
         * @zh 检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
         * @param type 事件的类型。
         * @returns 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
         */
        hasListener(type: string): boolean;
        /**
         * @en Dispatch an event.
         * @param type The type of event.
         * @param data (Optional) Data to pass to the callback. If multiple parameters p1, p2, p3, ... need to be passed, use an array structure such as [p1, p2, p3, ...]. If a single parameter p needs to be passed and p is an array, use a structure such as [p]. For other single parameters p, you can directly pass parameter p.
         * If data is Event.EMPTY, it means passing an Event object to the callback function. Note that it is not passing Event.TEMP, but an independent Event object.
         * @returns True if there are listeners for this event type, false otherwise.
         * @zh 派发事件。
         * @param type 事件类型。
         * @param data （可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
         * 特别的，如果data是Event.EMPTY，则表示传递一个Event对象给回调函数，注意，并不是传递Event.TEMP，而是一个独立的Event对象。
         * @returns 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
         */
        event(type: string, data?: any): boolean;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        on(type: string, listener: Function): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The listener function.
         * @param args (Optional) The callback parameters of the event listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         * @param args （可选）事件侦听函数的回调参数。
         * @returns 此 EventDispatcher 对象。
         */
        on(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications. This event listener responds once and is automatically removed after the first call.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        once(type: string, listener: Function): EventDispatcher;
        /**
         * @en Register an event listener object with the EventDispatcher object so that the listener receives event notifications. This event listener responds once and is automatically removed after the first call.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The listener function.
         * @param args (Optional) The callback parameters of the event listener function.
         * @returns This EventDispatcher object.
         * @zh 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         * @param args （可选）事件侦听函数的回调参数。
         * @returns 此 EventDispatcher 对象。
         */
        once(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * @en Remove a listener from the EventDispatcher object.
         * @param type The type of event.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除侦听器。
         * @param type 事件的类型。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        off(type: string, listener: Function): EventDispatcher;
        /**
         * @en Remove a listener from the EventDispatcher object.
         * @param type The type of event.
         * @param caller The execution scope of the event listener function.
         * @param listener The listener function.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除侦听器。
         * @param type 事件的类型。
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         * @returns 此 EventDispatcher 对象。
         */
        off(type: string, caller: any, listener?: Function, args?: any[]): EventDispatcher;
        /**
         * @en Remove all listeners of the specified event type from the EventDispatcher object.
         * @param type (Optional) The type of event. If the value is null, all types of listeners on this object are removed.
         * @returns This EventDispatcher object.
         * @zh 从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
         * @param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
         * @returns 此 EventDispatcher 对象。
         */
        offAll(type?: string): EventDispatcher;
        /**
         * @en Remove all event listeners whose caller is the specified target.
         * @param caller The target caller object.
         * @returns This EventDispatcher object.
         * @zh 移除caller为target的所有事件监听。
         * @param caller caller对象
         * @returns 此 EventDispatcher 对象。
         */
        offAllCaller(caller: any): EventDispatcher;
    }
    /**
     * @en The `InputManager` class is responsible for managing input events such as mouse, touch, and keyboard events.
     * @zh `InputManager` 类负责管理输入事件，例如鼠标、触摸和键盘事件。
     * @blueprintable
     */
    class InputManager {
        /**
         * @en Whether to enable multi-touch support.
         * @zh 是否开启多点触控支持。
         */
        static multiTouchEnabled: boolean;
        /**
         * @en Whether to enable mouse/touch events. Default is true.
         * @zh 是否开启鼠标/触摸事件。默认为 true。
         */
        static mouseEventsEnabled: boolean;
        /**
         * @en Whether to enable keyboard events. Default is true.
         * @zh 是否开启键盘事件。默认为 true。
         */
        static keyEventsEnabled: boolean;
        /**
         * @en The threshold for considering a mouse press and release as a click. If the distance between the press and release positions exceeds this value, it is not considered a click.
         * @zh 鼠标按下和弹起位置之间的距离阀值，用以判断是否视为一次点击。如果超过这个距离，则不视为点击。
         */
        static clickTestThreshold: number;
        /**
         * @en The X coordinate of the mouse on the canvas.
         * @zh canvas 上鼠标的 X 坐标。
         */
        static mouseX: number;
        /**
         * @en The Y coordinate of the mouse on the canvas.
         * @zh canvas 上鼠标的 Y 坐标。
         */
        static mouseY: number;
        /**
         * @en The time of the last mouse event.
         * @zh 上一次鼠标事件的时间。
         */
        static lastMouseTime: number;
        /**
         * @en The ID of the last touch event.
         * @zh 上一次触摸事件的ID。
         */
        static lastTouchId: number;
        /**
         * @en Dispatched before the process of a MOUSE_DOWN event, which can be used to preprocess the MOUSE_DOWN event.
         * @zh 在处理MOUSE_DOWN事件之前调度，可用于提前处理按下事件。
         */
        static readonly onMouseDownCapture: Delegate;
        /**@internal */
        protected _stage: Stage;
        /**@internal */
        protected _mouseTouch: TouchInfo;
        /**@internal */
        protected _touches: TouchInfo[];
        /**@internal */
        protected _touchPool: TouchInfo[];
        /**@internal */
        protected _touchTarget: Node;
        /**
         * @en Used for IDE processing.
         * @zh 用于IDE处理。
         */
        protected _eventType: number;
        protected _nativeEvent: MouseEvent | WheelEvent | TouchEvent;
        protected _pressKeys: Set<string | number>;
        protected _keyEvent: Event;
        private _lastTouchTime;
        /**
         * @ignore @blueprintIgnore
         */
        constructor();
        static get inst(): InputManager;
        /**
         * @en Get the touch position.
         * @param touchId The ID of the touch point. If not provided, the position of the first touch point will be returned.
         * @returns The position of the touch point.
         * @zh 获取触摸位置。
         * @param touchId 触摸点ID。如果不提供，将返回第一个触摸点的位置。
         * @returns 触摸点的位置。
         */
        static getTouchPos(touchId?: number): Readonly<Point>;
        /**
         * @en Get the current touch target node.
         * @zh 获取当前触摸目标节点。
         */
        static get touchTarget(): Node;
        /**
         * @en Get the array of current touch information.
         * @zh 获取当前触摸信息的数组。
         */
        static get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        /**
         * @en Get the number of current touches.
         * @zh 获取当前触摸数量。
         */
        static get touchCount(): number;
        /**
         * @en Cancel the click event for a touch point.
         * @param touchId The ID of the touch event to cancel.
         * @zh 取消指定触摸点的点击事件。
         * @param touchId 要取消的触摸事件ID。
         */
        static cancelClick(touchId?: number): void;
        /**
         * @en Check if a specific key is pressed.
         * @param key The key value. For more information, see: https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
         * @return Whether the key is pressed.
         * @zh 返回指定键是否被按下。
         * @param key 键值。更多信息请参考：https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
         * @return 是否被按下。
         */
        static hasKeyDown(key: string | number): boolean;
        /**
         * @internal
         * @en Initialization.
         * @zh 初始化。
         */
        static __init__(): void;
        /**
         * @en Handling mouse events
         * @param ev Mouse events
         * @param type Event types
         * @zh 处理鼠标事件
         * @param ev 鼠标事件
         * @param type 事件类型
         */
        handleMouse(ev: MouseEvent | WheelEvent, type: number): void;
        /**
         * @en Handling touch screen events.
         * @param ev Touch screen events.
         * @param type Event types.
         * @zh 处理触屏事件
         * @param ev 触屏事件
         * @param type 事件类型
         */
        handleTouch(ev: TouchEvent, type: number): void;
        private getTouch;
        /**
         * @en Handle keys events
         * @param ev Keys events
         * @zh 处理按键事件
         * @param ev 按键事件
         */
        handleKeys(ev: KeyboardEvent): void;
        /**
         * @en Obtain nodes under location points
         * @param x The x-coordinate value.
         * @param y The y-coordinate value.
         * @returns The node under the point or the stage if no node is found.
         * @zh 获取位置点下的节点
         * @param x x坐标值。
         * @param y y坐标值。
         * @returns 该点下的对象节点，如果没有找到节点则返回舞台。
         */
        getNodeUnderPoint(x: number, y: number): Node;
        /**
         * @en Get the sprite under the specified coordinates relative to a Sprite. The x/y values are in the local coordinates of the Sprite.
         * @param sp The Sprite relative to which the coordinates are calculated.
         * @param x The x-coordinate relative to the Sprite.
         * @param y The y-coordinate relative to the Sprite.
         * @returns The sprite under the point or null if not found.
         * @zh 获取在相对Sprite指定坐标下的sprite。x/y值是Sprite的本地坐标。
         * @param sp 相对哪个Sprite计算坐标。
         * @param x 相对于Sprite的X坐标。
         * @param y 相对于Sprite的Y坐标。
         * @returns 该点下的sprite，如果没有找到则返回null。
         */
        getSpriteUnderPoint(sp: Sprite, x: number, y: number): Sprite;
        getSprite3DUnderPoint(x: number, y: number): Node;
        /**
         * @en Hit test
         * @param sp Relative Sprite.
         * @param x The x-coordinate relative to the Sprite.
         * @param y The y-coordinate relative to the Sprite.
         * @param editing Whether the test is performed in editing mode.
         * @returns True if the point is within the Sprite's bounds, false otherwise.
         * @zh 点击测试
         * @param sp 相对Sprite
         * @param x 相对于Sprite的X坐标。
         * @param y 相对于Sprite的Y坐标。
         * @param editing 是否在编辑模式下进行测试。
         * @returns 如果点在Sprite的范围内返回true，否则返回false。
         */
        hitTest(sp: Sprite, x: number, y: number, editing?: boolean): boolean;
        private handleRollOver;
    }
    class TouchInfo implements ITouchInfo {
        /**
         * @en The event object associated with this touch.
         * @zh 与此触摸关联的事件对象。
         */
        readonly event: Event;
        /**
         * @en The current position of the touch.
         * @zh 当前触摸的位置。
         */
        readonly pos: Point;
        /**
         * @en The ID of the touch.
         * @zh 触摸的ID。
         */
        touchId: number;
        /**
         * @en The number of consecutive clicks.
         * @zh 连续点击的次数。
         */
        clickCount: number;
        /**
         * @en Indicates whether the touch has begun.
         * @zh 表示触摸是否已开始。
         */
        began: boolean;
        /**
         * @en The target node of the touch.
         * @zh 触摸的目标节点。
         */
        target: Node;
        /**
         * @en The last node the touch rolled over.
         * @zh 最后一次触摸经过的节点。
         */
        lastRollOver: Node;
        /**
         * @en Indicates whether the click was cancelled.
         * @zh 表示点击是否已取消。
         */
        clickCancelled: boolean;
        /**
         * @en Indicates whether the touch has moved.
         * @zh 表示触摸是否已移动。
         */
        moved: boolean;
        /**
         * @en The button pressed during the touch.
         * @zh 触摸期间按下的按钮。
         */
        downButton: number;
        /**
         * @en The list of nodes that were under the touch when it began.
         * @zh 触摸开始时位于其下方的节点列表。
         */
        readonly downTargets: Node[];
        /**
         * @en The position where the touch began.
         * @zh 触摸开始时的位置。
         */
        private downPos;
        private bubbleChain;
        /**
         * @ignore
         * @en Creates a new instance of the TouchInfo class.
         * @param touches An array of touch information.
         * @zh 创建 TouchInfo 类的新实例。
         * @param touches 触摸信息数组。
         */
        constructor(touches: Array<TouchInfo>);
        /**
         * @en Marks the beginning of the touch.
         * @zh 标记触摸的开始。
         */
        begin(): void;
        /**
         * @en Updates the touch information when the touch moves.
         * @zh 当触摸移动时更新触摸信息。
         */
        move(): void;
        /**
         * @en Marks the end of the touch and updates the click count.
         * @zh 标记触摸的结束并更新点击次数。
         */
        end(): void;
        /**
         * @en Tests whether the touch should trigger a click event and returns the target node if successful.
         * @returns The target node if the click test is successful; otherwise, null.
         * @zh 测试触摸是否应触发点击事件，并在成功时返回目标节点。
         * @returns 如果点击测试成功，则返回目标节点；否则返回null。
         */
        clickTest(): Node;
        /**
         * @en Resets the touch information to its initial state.
         * @zh 将触摸信息重置为初始状态。
         */
        reset(): void;
        bubble(type: string, target?: Node): void;
    }
    /**
     * @en The `Keyboard` class contains constants representing the most commonly used keys for controlling a game.
     * @zh `Keyboard` 类的属性是一些常数，这些常数表示控制游戏时最常用的键。
     */
    class Keyboard {
        /**
         * @en The constant associated with the key code value (48) for the 0 key.
         * @zh 与 0 的键控代码值(48) 关联的常数。
         */
        static NUMBER_0: number;
        /**
         * @en The constant associated with the key code value (49) for the 1 key.
         * @zh 与 1 的键控代码值 (49) 关联的常数。
         */
        static NUMBER_1: number;
        /**
         * @en The constant associated with the key code value (50) for the 2 key.
         * @zh 与 2 的键控代码值 (50) 关联的常数。
         */
        static NUMBER_2: number;
        /**
         * @en The constant associated with the key code value (51) for the 3 key.
         * @zh 与 3 的键控代码值 (51) 关联的常数。
         */
        static NUMBER_3: number;
        /**
         * @en The constant associated with the key code value (52) for the 4 key.
         * @zh 与 4 的键控代码值 (52) 关联的常数。
         */
        static NUMBER_4: number;
        /**
         * @en The constant associated with the key code value (53) for the 5 key.
         * @zh 与 5 的键控代码值 (53) 关联的常数。
         */
        static NUMBER_5: number;
        /**
         * @en The constant associated with the key code value (54) for the 6 key.
         * @zh 与 6 的键控代码值 (54) 关联的常数。
         */
        static NUMBER_6: number;
        /**
         * @en The constant associated with the key code value (55) for the 7 key.
         * @zh 与 7 的键控代码值 (55) 关联的常数。
         */
        static NUMBER_7: number;
        /**
         * @en The constant associated with the key code value (56) for the 8 key.
         * @zh 与 8 的键控代码值 (56) 关联的常数。
         */
        static NUMBER_8: number;
        /**
         * @en The constant associated with the key code value (57) for the 9 key.
         * @zh 与 9 的键控代码值 (57) 关联的常数。
         */
        static NUMBER_9: number;
        /**
         * @en The constant associated with the key code value (65) for the A key.
         * @zh 与 A 键的键控代码值 (65) 关联的常数。
         */
        static A: number;
        /**
         * @en The constant associated with the key code value (66) for the B key.
         * @zh 与 B 键的键控代码值 (66) 关联的常数。
         */
        static B: number;
        /**
         * @en The constant associated with the key code value (67) for the C key.
         * @zh 与 C 键的键控代码值 (67) 关联的常数。
         */
        static C: number;
        /**
         * @en The constant associated with the key code value (68) for the D key.
         * @zh 与 D 键的键控代码值 (68) 关联的常数。
         */
        static D: number;
        /**
         * @en The constant associated with the key code value (69) for the E key.
         * @zh 与 E 键的键控代码值 (69) 关联的常数。
         */
        static E: number;
        /**
         * @en The constant associated with the key code value (70) for the F key.
         * @zh 与 F 键的键控代码值 (70) 关联的常数。
         */
        static F: number;
        /**
         * @en The constant associated with the key code value (71) for the G key.
         * @zh 与 G 键的键控代码值 (71) 关联的常数。
         */
        static G: number;
        /**
         * @en The constant associated with the key code value (72) for the H key.
         * @zh 与 H 键的键控代码值 (72) 关联的常数。
         */
        static H: number;
        /**
         * @en The constant associated with the key code value (73) for the I key.
         * @zh 与 I 键的键控代码值 (73) 关联的常数。
         */
        static I: number;
        /**
         * @en The constant associated with the key code value (74) for the J key.
         * @zh 与 J 键的键控代码值 (74) 关联的常数。
         */
        static J: number;
        /**
         * @en The constant associated with the key code value (75) for the K key.
         * @zh 与 K 键的键控代码值 (75) 关联的常数。
         */
        static K: number;
        /**
         * @en The constant associated with the key code value (76) for the L key.
         * @zh 与 L 键的键控代码值 (76) 关联的常数。
         */
        static L: number;
        /**
         * @en The constant associated with the key code value (77) for the M key.
         * @zh 与 M 键的键控代码值 (77) 关联的常数。
         */
        static M: number;
        /**
         * @en The constant associated with the key code value (78) for the N key.
         * @zh 与 N 键的键控代码值 (78) 关联的常数。
         */
        static N: number;
        /**
         * @en The constant associated with the key code value (79) for the O key.
         * @zh 与 O 键的键控代码值 (79) 关联的常数。
         */
        static O: number;
        /**
         * @en The constant associated with the key code value (80) for the P key.
         * @zh 与 P 键的键控代码值 (80) 关联的常数。
         */
        static P: number;
        /**
         * @en The constant associated with the key code value (81) for the Q key.
         * @zh 与 Q 键的键控代码值 (81) 关联的常数。
         */
        static Q: number;
        /**
         * @en The constant associated with the key code value (82) for the R key.
         * @zh 与 R 键的键控代码值 (82) 关联的常数。
         */
        static R: number;
        /**
         * @en The constant associated with the key code value (83) for the S key.
         * @zh 与 S 键的键控代码值 (83) 关联的常数。
         */
        static S: number;
        /**
         * @en The constant associated with the key code value (84) for the T key.
         * @zh 与 T 键的键控代码值 (84) 关联的常数。
         */
        static T: number;
        /**
         * @en The constant associated with the key code value (85) for the U key.
         * @zh 与 U 键的键控代码值 (85) 关联的常数。
         */
        static U: number;
        /**
         * @en The constant associated with the key code value (86) for the V key.
         * @zh 与 V 键的键控代码值 (86) 关联的常数。
         */
        static V: number;
        /**
         * @en The constant associated with the key code value (87) for the W key.
         * @zh 与 W 键的键控代码值 (87) 关联的常数。
         */
        static W: number;
        /**
         * @en The constant associated with the key code value (88) for the X key.
         * @zh 与 X 键的键控代码值 (88) 关联的常数。
         */
        static X: number;
        /**
         * @en The constant associated with the key code value (89) for the Y key.
         * @zh 与 Y 键的键控代码值 (89) 关联的常数。
         */
        static Y: number;
        /**
         * @en The constant associated with the key code value (90) for the Z key.
         * @zh 与 Z 键的键控代码值 (90) 关联的常数。
         */
        static Z: number;
        /**
         * @en The constant associated with the key code value (112) for the F1 key.
         * @zh 与 F1 的键控代码值 (112) 关联的常数。
         */
        static F1: number;
        /**
         * @en The constant associated with the key code value (113) for the F2 key.
         * @zh 与 F2 的键控代码值 (113) 关联的常数。
         */
        static F2: number;
        /**
         * @en The constant associated with the key code value (114) for the F3 key.
         * @zh 与 F3 的键控代码值 (114) 关联的常数。
         */
        static F3: number;
        /**
         * @en The constant associated with the key code value (115) for the F4 key.
         * @zh 与 F4 的键控代码值 (115) 关联的常数。
         */
        static F4: number;
        /**
         * @en The constant associated with the key code value (116) for the F5 key.
         * @zh 与 F5 的键控代码值 (116) 关联的常数。
         */
        static F5: number;
        /**
         * @en The constant associated with the key code value (117) for the F6 key.
         * @zh 与 F6 的键控代码值 (117) 关联的常数。
         */
        static F6: number;
        /**
         * @en The constant associated with the key code value (118) for the F7 key.
         * @zh 与 F7 的键控代码值 (118) 关联的常数。
         */
        static F7: number;
        /**
         * @en The constant associated with the key code value (119) for the F8 key.
         * @zh 与 F8 的键控代码值 (119) 关联的常数。
         */
        static F8: number;
        /**
         * @en The constant associated with the key code value (120) for the F9 key.
         * @zh 与 F9 的键控代码值 (120) 关联的常数。
         */
        static F9: number;
        /**
         * @en The constant associated with the key code value (121) for the F10 key.
         * @zh 与 F10 的键控代码值 (121) 关联的常数。
         */
        static F10: number;
        /**
         * @en The constant associated with the key code value (122) for the F11 key.
         * @zh 与 F11 的键控代码值 (122) 关联的常数。
         */
        static F11: number;
        /**
         * @en The constant associated with the key code value (123) for the F12 key.
         * @zh 与 F12 的键控代码值 (123) 关联的常数。
         */
        static F12: number;
        /**
         * @en The constant associated with the key code value (124) for the F13 key.
         * @zh 与 F13 的键控代码值 (124) 关联的常数。
         */
        static F13: number;
        /**
         * @en The constant associated with the key code value (125) for the F14 key.
         * @zh 与 F14 的键控代码值 (125) 关联的常数。
         */
        static F14: number;
        /**
         * @en The constant associated with the key code value (126) for the F15 key.
         * @zh 与 F15 的键控代码值 (126) 关联的常数。
         */
        static F15: number;
        /**
         * @en The constant associated with the pseudo key code (21) for the numeric keypad.
         * @zh 与数字键盘的伪键控代码 (21) 关联的常数。
         */
        static NUMPAD: number;
        /**
         * @en The constant associated with the key code value (96) for the number 0 on the numeric keypad.
         * @zh 与数字键盘上的数字 0 的键控代码值 (96) 关联的常数。
         */
        static NUMPAD_0: number;
        /**
         * @en The constant associated with the key code value (97) for the number 1 on the numeric keypad.
         * @zh 与数字键盘上的数字 1 的键控代码值 (97) 关联的常数。
         */
        static NUMPAD_1: number;
        /**
         * @en The constant associated with the key code value (98) for the number 2 on the numeric keypad.
         * @zh 与数字键盘上的数字 2 的键控代码值 (98) 关联的常数。
         */
        static NUMPAD_2: number;
        /**
         * @en The constant associated with the key code value (99) for the number 3 on the numeric keypad.
         * @zh 与数字键盘上的数字 3 的键控代码值 (99) 关联的常数。
         */
        static NUMPAD_3: number;
        /**
         * @en The constant associated with the key code value (100) for the number 4 on the numeric keypad.
         * @zh 与数字键盘上的数字 4 的键控代码值 (100) 关联的常数。
         */
        static NUMPAD_4: number;
        /**
         * @en The constant associated with the key code value (101) for the number 5 on the numeric keypad.
         * @zh 与数字键盘上的数字 5 的键控代码值 (101) 关联的常数。
         */
        static NUMPAD_5: number;
        /**
         * @en The constant associated with the key code value (102) for the number 6 on the numeric keypad.
         * @zh 与数字键盘上的数字 6 的键控代码值 (102) 关联的常数。
         */
        static NUMPAD_6: number;
        /**
         * @en The constant associated with the key code value (103) for the number 7 on the numeric keypad.
         * @zh 与数字键盘上的数字 7 的键控代码值 (103) 关联的常数。
         */
        static NUMPAD_7: number;
        /**
         * @en The constant associated with the key code value (104) for the number 8 on the numeric keypad.
         * @zh 与数字键盘上的数字 8 的键控代码值 (104) 关联的常数。
         */
        static NUMPAD_8: number;
        /**
         * @en The constant associated with the key code value (105) for the number 9 on the numeric keypad.
         * @zh 与数字键盘上的数字 9 的键控代码值 (105) 关联的常数。
         */
        static NUMPAD_9: number;
        /**
         * @en The constant associated with the key code value (107) for the plus sign (+) on the numeric keypad.
         * @zh 与数字键盘上的加号 (+) 的键控代码值 (107) 关联的常数。
         */
        static NUMPAD_ADD: number;
        /**
         * @en The constant associated with the key code value (110) for the decimal point (.) on the numeric keypad.
         * @zh 与数字键盘上的小数点 (.) 的键控代码值 (110) 关联的常数。
         */
        static NUMPAD_DECIMAL: number;
        /**
         * @en The constant associated with the key code value (111) for the division sign (/) on the numeric keypad.
         * @zh 与数字键盘上的除号 (/) 的键控代码值 (111) 关联的常数。
         */
        static NUMPAD_DIVIDE: number;
        /**
         * @en The constant associated with the key code value (108) for the Enter key on the numeric keypad.
         * @zh 与数字键盘上的 Enter 的键控代码值 (108) 关联的常数。
         */
        static NUMPAD_ENTER: number;
        /**
         * @en The constant associated with the key code value (106) for the multiplication sign (*) on the numeric keypad.
         * @zh 与数字键盘上的乘号 (*) 的键控代码值 (106) 关联的常数。
         */
        static NUMPAD_MULTIPLY: number;
        /**
         * @en The constant associated with the key code value (109) for the minus sign (-) on the numeric keypad.
         * @zh 与数字键盘上的减号 (-) 的键控代码值 (109) 关联的常数。
         */
        static NUMPAD_SUBTRACT: number;
        /**
         * @en The constant associated with the key code value (186) for the semicolon (;) key.
         * @zh 与 ; 键的键控代码值 (186) 关联的常数。
         */
        static SEMICOLON: number;
        /**
         * @en The constant associated with the key code value (187) for the equal sign (=) key.
         * @zh 与 = 键的键控代码值 (187) 关联的常数。
         */
        static EQUAL: number;
        /**
         * @en The constant associated with the key code value (188) for the comma (,) key.
         * @zh 与 F15 的键控代码值 (188) 关联的常数。
         */
        static COMMA: number;
        /**
         * @en The constant associated with the key code value (189) for the minus (-) key.
         * @zh 与 - 键的键控代码值 (189) 关联的常数。
         */
        static MINUS: number;
        /**
         * @en The constant associated with the key code value (190) for the period (.) key.
         * @zh 与 . 键的键控代码值 (190) 关联的常数。
         */
        static PERIOD: number;
        /**
         * @en The constant associated with the key code value (191) for the forward slash (/) key.
         * @zh 与 / 键的键控代码值 (191) 关联的常数。
         */
        static SLASH: number;
        /**
         * @en The constant associated with the key code value (192) for the backquote (`) key.
         * @zh 与 ` 键的键控代码值 (192) 关联的常数。
         */
        static BACKQUOTE: number;
        /**
         * @en The constant associated with the key code value (219) for the left bracket ([) key.
         * @zh 与 [ 键的键控代码值 (219) 关联的常数。
         */
        static LEFTBRACKET: number;
        /**
         * @en The constant associated with the key code value (220) for the backslash (\) key.
         * @zh 与 \ 键的键控代码值 (220) 关联的常数。
         */
        static BACKSLASH: number;
        /**
         * @en The constant associated with the key code value (221) for the right bracket (]) key.
         * @zh 与 ] 键的键控代码值 (221) 关联的常数。
         */
        static RIGHTBRACKET: number;
        /**
         * @en The constant associated with the key code value (222) for the single quote (') key.
         * @zh 与 ' 键的键控代码值 (222) 关联的常数。
         */
        static QUOTE: number;
        /**
         * @en The constant associated with the key code value (18) for the Alternate (Option) key.
         * @zh 与 Alternate (Option) 键的键控代码值 (18) 关联的常数。
         */
        static ALTERNATE: number;
        /**
         * @en The constant associated with the key code value (8) for the Backspace key.
         * @zh 与 Backspace 的键控代码值 (8) 关联的常数。
         */
        static BACKSPACE: number;
        /**
         * @en The constant associated with the key code value (20) for the Caps Lock key.
         * @zh 与 Caps Lock 的键控代码值 (20) 关联的常数。
         */
        static CAPS_LOCK: number;
        /**
         * @en The constant associated with the key code value (15) for the Mac Command key.
         * @zh 与 Mac 命令键 (15) 关联的常数。
         */
        static COMMAND: number;
        /**
         * @en The constant associated with the key code value (17) for the Ctrl key.
         * @zh 与 Ctrl 的键控代码值 (17) 关联的常数。
         */
        static CONTROL: number;
        /**
         * @en The constant associated with the key code value (46) for the Delete key.
         * @zh 与 Delete 的键控代码值 (46) 关联的常数。
         */
        static DELETE: number;
        /**
         * @en The constant associated with the key code value (13) for the Enter key.
         * @zh 与 Enter 的键控代码值 (13) 关联的常数。
         */
        static ENTER: number;
        /**
         * @en The constant associated with the key code value (27) for the Esc key.
         * @zh 与 Esc 的键控代码值 (27) 关联的常数。
         */
        static ESCAPE: number;
        /**
         * @en The constant associated with the key code value (33) for the Page Up key.
         * @zh 与 Page Up 的键控代码值 (33) 关联的常数。
         */
        static PAGE_UP: number;
        /**
         * @en The constant associated with the key code value (34) for the Page Down key.
         * @zh 与 Page Down 的键控代码值 (34) 关联的常数。
         */
        static PAGE_DOWN: number;
        /**
         * @en The constant associated with the key code value (35) for the End key.
         * @zh 与 End 的键控代码值 (35) 关联的常数。
         */
        static END: number;
        /**
         * @en The constant associated with the key code value (36) for the Home key.
         * @zh 与 Home 的键控代码值 (36) 关联的常数。
         */
        static HOME: number;
        /**
         * @en The constant associated with the key code value (37) for the Left Arrow key.
         * @zh 与向左箭头键的键控代码值 (37) 关联的常数。
         */
        static LEFT: number;
        /**
         * @en The constant associated with the key code value (38) for the Up Arrow key.
         * @zh 与向上箭头键的键控代码值 (38) 关联的常数。
         */
        static UP: number;
        /**
         * @en The constant associated with the key code value (39) for the Right Arrow key.
         * @zh 与向右箭头键的键控代码值 (39) 关联的常数。
         */
        static RIGHT: number;
        /**
         * @en The constant associated with the key code value (40) for the Down Arrow key.
         * @zh 与向下箭头键的键控代码值 (40) 关联的常数。
         */
        static DOWN: number;
        /**
         * @en The constant associated with the key code value (16) for the Shift key.
         * @zh 与 Shift 的键控代码值 (16) 关联的常数。
         */
        static SHIFT: number;
        /**
         * @en The constant associated with the key code value (32) for the Spacebar.
         * @zh 与空格键的键控代码值 (32) 关联的常数。
         */
        static SPACE: number;
        /**
         * @en The constant associated with the key code value (9) for the Tab key.
         * @zh 与 Tab 的键控代码值 (9) 关联的常数。
         */
        static TAB: number;
        /**
         * @en The constant associated with the key code value (45) for the Insert key.
         * @zh 与 Insert 的键控代码值 (45) 关联的常数。
         */
        static INSERT: number;
    }
    /**
     * @en The `KeyLocation` class contains constants that indicate the location of a key on a keyboard or keyboard-like input device.
     * The `KeyLocation` constants are used within the `keyLocation` property of keyboard event objects.
     * @zh `KeyLocation` 类包含表示键盘或类似键盘的输入设备上按键位置的常量。
     * `KeyLocation` 常数用在键盘事件对象的 `keyLocation` 属性中。
     * @blueprintable
     */
    class KeyLocation {
        /**
         * @en Indicates that the active key does not distinguish between the left or right position,
         * nor does it distinguish whether it is located on the numeric keypad (or activated by a virtual key corresponding to the numeric keypad).
         * @zh 表示激活的键不区分位于左侧还是右侧，也不区分是否位于数字键盘（或者是使用对应于数字键盘的虚拟键激活的）。
         */
        static readonly STANDARD: number;
        /**
         * @en Indicates that the active key is in the left key location (a key may have multiple possible locations).
         * @zh 表示激活的键在左侧键位置（此键可能有多个可能的位置）。
         */
        static readonly LEFT: number;
        /**
         * @en Indicates that the active key is in the right key location (a key may have multiple possible locations).
         * @zh 表示激活的键在右侧键位置（此键可能有多个可能的位置）。
         */
        static readonly RIGHT: number;
        /**
         * @en Indicates that the active key is on the numeric keypad or activated by a virtual key corresponding to the numeric keypad.
         * <Note: This property is only valid in Flash mode.
         * @zh 表示激活的键位于数字键盘或者是使用对应于数字键盘的虚拟键激活的。
         * <注意：此属性只在flash模式下有效。
         */
        static readonly NUM_PAD: number;
    }
    /**
     * @deprecated use post2DProcess
     * @en Blur filter
     * @zh 模糊滤镜
     */
    class BlurFilter extends Filter {
        /**
         * @internal
         */
        _effect2D: BlurEffect2D;
        /**
         * @en Gets the effect2d instance.
         * @zh 获取 effect2d 实例。
         */
        getEffect(): BlurEffect2D;
        /**
         * @en Constructs a new BlurFilter instance with the specified strength.
         * The strength of the blur filter, with a default value of 4. Higher values result in a more indistinct image.
         * @param strength The strength of the blur filter. The default value is 4.
         * @zh 创建一个新的模糊滤镜实例，并设置指定的强度值。
         * 模糊滤镜的强度，默认值为4。值越大，图像越不清晰。
         * @param strength 模糊滤镜的强度。默认值为4。
         */
        constructor(strength?: number);
        /**
         * @en The strength of the blur filter.
         * @zh 模糊滤镜的强度。
         */
        get strength(): number;
        set strength(v: number);
    }
    /**
     * @deprecated use post2DProcess
     * @en The `ColorFilter` class represents a color filter that applies a 4x5 matrix transformation to the RGBA color and Alpha values of each pixel of the input image to produce a result with a new set of RGBA colors and Alpha values. This class allows for saturation adjustments, hue rotation, brightness to Alpha, and various other effects. You can apply the filter to any display object (i.e., an object that inherits from the `Sprite` class).
     * For RGBA values, the most significant byte represents the red channel value, followed by the green, blue, and Alpha channel values respectively.
     * @zh `ColorFilter` 类是一个颜色滤镜，它将 4x5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。此类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即从 `Sprite` 类继承的对象）。
     * 注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。
     */
    class ColorFilter extends Filter {
        /**
         * @internal
         */
        _effect2D: ColorEffect2D;
        /**
         * @en Gets the effect2d instance.
         * @zh 获取 effect2d 实例。
         */
        getEffect(): ColorEffect2D;
        /**
         * @en Creates an instance of the ColorFilter class with an optional 4x5 matrix for color transformation.
         * @param mat An array with 20 elements arranged in a 4x5 matrix for color transformation.
         * @zh 创建 `ColorFilter` 类的实例，可选择传入用于颜色转换的 4x5 矩阵。
         * @param mat 用于颜色转换的由 20 个元素组成的数组（排列成 4x5 矩阵）。
         */
        constructor(mat?: any[]);
        /**
         * @en Sets the filter to a grayscale filter.
         * @zh 将滤镜设置为灰度滤镜。
         */
        gray(): ColorFilter;
        /**
         * @en Sets the filter to a color transformation filter with the specified red, green, blue, and alpha coefficients.
         * @param red The red coefficient, range: 0 to 1.
         * @param green The green coefficient, range: 0 to 1.
         * @param blue The blue coefficient, range: 0 to 1.
         * @param alpha The alpha coefficient, range: 0 to 1.
         * @zh 将滤镜设置为具有指定红色、绿色、蓝色和 Alpha 系数的颜色转换滤镜。
         * @param red 红色系数,范围:0~1
         * @param green 绿色系数,范围:0~1
         * @param blue 蓝色系数,范围:0~1
         * @param alpha alpha系数,范围:0~1
         */
        color(red?: number, green?: number, blue?: number, alpha?: number): ColorFilter;
        /**
         * @en Sets the filter color using a color value.
         * @param color The color value in string format.
         * @zh 使用颜色值设置滤镜颜色。
         * @param  color 颜色值
         */
        setColor(color: string): ColorFilter;
        /**
         * @en Sets the matrix data.
         * @param matrix An array with 20 elements arranged in a 4x5 matrix.
         * @zh 设置矩阵数据
         * @param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
         */
        setByMatrix(matrix: any[]): ColorFilter;
        /**
         * @en Adjusts color properties including brightness, contrast, saturation, and hue.
         * @param brightness Brightness value, range: -100 to 100.
         * @param contrast Contrast value, range: -100 to 100.
         * @param saturation Saturation value, range: -100 to 100.
         * @param hue Hue value, range: -180 to 180.
         * @zh 调整颜色属性，包括亮度、对比度、饱和度和色调。
         * @param brightness 亮度,范围:-100~100
         * @param contrast 对比度,范围:-100~100
         * @param saturation 饱和度,范围:-100~100
         * @param hue 色调,范围:-180~180
         */
        adjustColor(brightness: number, contrast: number, saturation: number, hue: number): ColorFilter;
        /**
         * @en Adjusts the brightness of the filter.
         * @param brightness Brightness value, range: -100 to 100.
         * @zh 调整滤镜的亮度。
         * @param brightness 亮度,范围:-100~100
         */
        adjustBrightness(brightness: number): ColorFilter;
        /**
         * @en Adjusts the contrast of the image.
         * @param contrast The contrast value. The contrast value should be between -100 and 100.
         * @zh 调整图像的对比度。
         * @param contrast 对比度值。对比度值应在 -100 到 100 之间。
         */
        adjustContrast(contrast: number): ColorFilter;
        /**
         * @en Adjusts the saturation of the image.
         * @param saturation The saturation value. The saturation value should be between -100 and 100.
         * @zh 调整图像的饱和度。
         * @param saturation 饱和度值。饱和度值应在 -100 到 100 之间。
         */
        adjustSaturation(saturation: number): ColorFilter;
        /**
         * @en Adjusts the hue of the image.
         * @param hue The hue value.The hue value should be between -180 and 180.
         * @zh 调整图像的色调。
         * @param hue 色调值。色调值应在 -180 到 180 之间。
         */
        adjustHue(hue: number): ColorFilter;
        /**
         * @en Resets the filter to the identity matrix, removing any filter effects.
         * @zh 将滤镜重置为单位矩阵，移除所有滤镜效果。
         */
        reset(): ColorFilter;
        /**
         * @en Called after deserialization.
         * @zh 反序列化后调用。
         */
        onAfterDeserialize(): void;
    }
    /**
     *
     * @en The `Filter` class is the base class for filters. Filters are post-processing operations on nodes, so they inevitably operate on a renderTexture.
     * @zh Filter 是滤镜基类。滤镜是针对节点的后处理过程，所以必然操作一个rendertexture
     */
    abstract class Filter extends EventDispatcher {
        protected onChange(): void;
        abstract getEffect(): PostProcess2DEffect;
    }
    /**
     * @deprecated use post2DProcess
     * @en Luminous filter (can also be used as shadow filter)
     * @zh 发光滤镜(也可以当成阴影滤使用）
     */
    class GlowFilter extends Filter {
        _effect2D: GlowEffect2D;
        /**
         * @en Creates an instance of a glow filter.
         * @param color The color of the glow filter.
         * @param blur The size of blurred edges
         * @param offX The horizontal offset for the glow effect.
         * @param offY The vertical offset for the glow effect.
         * @zh 创建一个发光滤镜实例。
         * @param color 发光滤镜的颜色。
         * @param blur 边缘模糊的大小。
         * @param offX 发光效果的水平偏移。
         * @param offY 发光效果的垂直偏移。
         */
        constructor(color: string, blur?: number, offX?: number, offY?: number);
        getEffect(): PostProcess2DEffect;
        /**
         * @en Gets Y offset value
         * @zh 获取Y偏移值
         */
        get offY(): number;
        /**
         * @en Sets Y offset value
         * @zh 设置Y偏移值
         */
        set offY(value: number);
        /**
         * @en Gets X offset value
         * @zh 获取X偏移值
         */
        get offX(): number;
        /**
         * @en Sets X offset value
         * @zh 设置X偏移值
         */
        set offX(value: number);
        /**
         * @en Gets X color value
         * @zh 获取颜色值
         */
        get color(): string;
        /**
         * @en Sets X color value
         * @zh 设置颜色值
         */
        set color(value: string);
        /**
         * @en Gest fuzzy value
         * @zh 获取模糊值
         */
        get blur(): number;
        /**
         * @en Sets fuzzy value
         * @zh 设置模糊值
         */
        set blur(value: number);
    }
    /**
     * @internal
     */
    interface glTFExtension {
        readonly name: string;
        loadExtensionTextureInfo?(info: glTFTextureInfo): any;
        /**
         * 加载附加纹理
         * @param basePath
         * @param progress
         */
        loadAdditionTextures?(basePath: string, progress?: IBatchProgress): Promise<Texture2D[]>;
        createMaterial?(glTFMaterial: glTFMaterial): Material;
        /**
         *
         * @param glTFMaterial
         * @param material
         * @return need default property apply
         */
        additionMaterialProperties?(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_anisotropy implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /**
     * @internal
     * https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat
     *
     * exclusions: KHR_materials_pbrSpecularGlossiness, KHR_materials_unlit
     */
    class KHR_materials_clearcoat implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_emissive_strength implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_ior implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_iridescence implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_sheen implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_specular implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<Texture2D[]>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_materials_transmission implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /**
     * @internal
     * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md
     */
    class KHR_materials_unlit implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        createMaterial(glTFMaterial: glTFMaterial): Material;
    }
    /** @internal */
    class KHR_materials_volume implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
    }
    /** @internal */
    class KHR_texture_transform implements glTFExtension {
        readonly name: string;
        private _resource;
        constructor(resource: glTFResource);
        createTransform(extension: glTFTextureTransform): Matrix3x3;
        loadExtensionTextureInfo(info: glTFTextureInfo): {
            transform: Matrix3x3;
            texCoord: number;
        };
    }
    /**
     * @internal
     */
    const enum glTFAccessorComponentType {
        /** Byte */
        BYTE = 5120,
        /** Unsigned Byte */
        UNSIGNED_BYTE = 5121,
        /** Short */
        SHORT = 5122,
        /** Unsigned Short */
        UNSIGNED_SHORT = 5123,
        /** Unsigned Int */
        UNSIGNED_INT = 5125,
        /** Float */
        FLOAT = 5126
    }
    /**
     * @internal
     */
    const enum glTFAccessorType {
        /** Scalar */
        SCALAR = "SCALAR",
        /** Vector2 */
        VEC2 = "VEC2",
        /** Vector3 */
        VEC3 = "VEC3",
        /** Vector4 */
        VEC4 = "VEC4",
        /** Matrix2x2 */
        MAT2 = "MAT2",
        /** Matrix3x3 */
        MAT3 = "MAT3",
        /** Matrix4x4 */
        MAT4 = "MAT4"
    }
    /**
     * @internal
     */
    const enum glTFAnimationChannelTargetPath {
        /** Translation */
        TRANSLATION = "translation",
        /** Rotation */
        ROTATION = "rotation",
        /** Scale */
        SCALE = "scale",
        /** Weights */
        WEIGHTS = "weights"
    }
    /**
     * @internal
     */
    const enum glTFAnimationSamplerInterpolation {
        /** The animated values are linearly interpolated between keyframes */
        LINEAR = "LINEAR",
        /** The animated values remain constant to the output of the first keyframe, until the next keyframe */
        STEP = "STEP",
        /** The animation's interpolation is computed using a cubic spline with specified tangents */
        CUBICSPLINE = "CUBICSPLINE"
    }
    /**
     * @internal
     */
    const enum glTFCameraType {
        /** A perspective camera containing properties to create a perspective projection matrix  */
        PERSPECTIVE = "perspective",
        /**  An orthographic camera containing properties to create an orthographic projection matrix */
        ORTHOGRAPHIC = "orthographic"
    }
    /**
     * @internal
     */
    const enum glTFImageMimeType {
        /**  JPEG Mime-type */
        JPEG = "image/jpeg",
        /** PNG Mime-type */
        PNG = "image/png"
    }
    /**
     * @internal
     */
    const enum glTFMaterialAlphaMode {
        /**  The alpha value is ignored and the rendered output is fully opaque */
        OPAQUE = "OPAQUE",
        /** The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value */
        MASK = "MASK",
        /** The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator) */
        BLEND = "BLEND"
    }
    /**
     * @internal
     * The type of the primitives to render
     */
    const enum glTFMeshPrimitiveMode {
        /** Points */
        POINTS = 0,
        /** Lines */
        LINES = 1,
        /** Line Loop */
        LINE_LOOP = 2,
        /** Line Strip */
        LINE_STRIP = 3,
        /** Triangles */
        TRIANGLES = 4,
        /** Triangle Strip */
        TRIANGLE_STRIP = 5,
        /** Triangle Fan */
        TRIANGLE_FAN = 6
    }
    /**
     * @internal
     * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
     */
    const enum glTFTextureMagFilter {
        /** Nearest */
        NEAREST = 9728,
        /**  Linear */
        LINEAR = 9729
    }
    /**
     * @internal
     * Minification filter.  All valid values correspond to WebGL enums
     */
    const enum glTFTextureMinFilter {
        /**  Nearest */
        NEAREST = 9728,
        /** Linear */
        LINEAR = 9729,
        /** Nearest Mip-Map Nearest */
        NEAREST_MIPMAP_NEAREST = 9984,
        /** Linear Mipmap Nearest */
        LINEAR_MIPMAP_NEAREST = 9985,
        /** Nearest Mipmap Linear */
        NEAREST_MIPMAP_LINEAR = 9986,
        /** Linear Mipmap Linear */
        LINEAR_MIPMAP_LINEAR = 9987
    }
    /**
     * @internal
     * S (U) wrapping mode.  All valid values correspond to WebGL enums
     */
    const enum glTFTextureWrapMode {
        /** Clamp to Edge */
        CLAMP_TO_EDGE = 33071,
        /** Mirrored Repeat */
        MIRRORED_REPEAT = 33648,
        /** Repeat */
        REPEAT = 10497
    }
    /**
     * @internal
     * glTF Node Property
     */
    interface glTFNodeProperty {
        /** Dictionary object with extension-specific objects. */
        extensions?: {
            [key: string]: any;
        };
        /** Application-specific data. */
        extras?: any;
    }
    /**
     * @internal
     */
    interface glTFChildNodeProperty {
        /** The user-defined name of this object. */
        name?: string;
    }
    /**
     * @internal
     */
    interface glTFAccessorSparseIndeces extends glTFNodeProperty {
        /** The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target */
        bufferView: number;
        /** The offset relative to the start of the bufferView in bytes. Must be aligned */
        byteOffset?: number;
        /** The indices data type.  Valid values correspond to WebGL enums: 5121 (UNSIGNED_BYTE), 5123 (UNSIGNED_SHORT), 5125 (UNSIGNED_INT)*/
        componentType: glTFAccessorComponentType;
    }
    /**
     * @internal
     */
    interface glTFAccessorSparseValues extends glTFNodeProperty {
        /**  The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target */
        bufferView: number;
        /**  The offset relative to the start of the bufferView in bytes. Must be aligned */
        byteOffset?: number;
    }
    /**
     * @internal
     */
    interface glTFAccessorSparse extends glTFNodeProperty {
        /** Number of entries stored in the sparse array. */
        count: number;
        /** Index array of size count that points to those accessor attributes that deviate from their initialization value. Indices must strictly increase */
        indices: glTFAccessorSparseIndeces;
        /** Array of size count times number of components, storing the displaced accessor attributes pointed by indices. Substituted values must have the same componentType and number of components as the base accessor */
        values: glTFAccessorSparseValues;
    }
    /**
     * @internal
     * Indices of those attributes that deviate from their initialization value
     */
    interface glTFAccessor extends glTFNodeProperty {
        /** The index of the bufferView. */
        bufferView?: number;
        /** The offset relative to the start of the bufferView in bytes. */
        byteOffset?: number;
        /** The datatype of components in the attribute. */
        componentType: glTFAccessorComponentType;
        /** Specifies whether integer data values should be normalized. */
        normalized?: boolean;
        /** The number of attributes referenced by this accessor. */
        count: number;
        /** Specifies if the attribute is a scalar, vector, or matrix. */
        type: glTFAccessorType;
        /** Maximum value of each component in this attribute. */
        max?: number[];
        /** Minimum value of each component in this attribute. */
        min?: number[];
        /** Sparse storage of attributes that deviate from their initialization value. */
        sparse?: glTFAccessorSparse;
    }
    /**
     * @internal
     * The index of the node and TRS property that an animation channel targets
     */
    interface glTFAnimationChannelTarget extends glTFNodeProperty {
        /** The index of the node to target */
        node: number;
        /** The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates */
        path: glTFAnimationChannelTargetPath;
    }
    /**
     * @internal
     * Targets an animation's sampler at a node's property
     */
    interface glTFAnimationChannel extends glTFNodeProperty {
        /** * The index of a sampler in this animation used to compute the value for the target */
        sampler: number;
        /** * The index of the node and TRS property to target */
        target: glTFAnimationChannelTarget;
    }
    /**
     * @internal
     * Combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target)
     */
    interface glTFAnimationSampler extends glTFNodeProperty {
        /** The index of an accessor containing keyframe input values, e.g., time */
        input: number;
        /** Interpolation algorithm */
        interpolation?: glTFAnimationSamplerInterpolation;
        /** The index of an accessor, containing keyframe output values */
        output: number;
    }
    /**
     * @internal
     * A keyframe animation.
     */
    interface glTFAnimation extends glTFNodeProperty, glTFChildNodeProperty {
        /** An array of channels, each of which targets an animation's sampler at a node's property */
        channels: glTFAnimationChannel[];
        /** An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target) */
        samplers: glTFAnimationSampler[];
    }
    /**
     * @internal
     * Metadata about the glTF asset
     */
    interface glTFAsset extends glTFChildNodeProperty {
        /** A copyright message suitable for display to credit the content creator. */
        copyright?: string;
        /** Tool that generated this glTF model. Useful for debugging. */
        generator?: string;
        /** The glTF version that this asset targets. */
        version: string;
        /** The minimum glTF version that this asset targets. */
        minVersion?: string;
    }
    /**
     * @internal
     * A buffer points to binary geometry, animation, or skins
     */
    interface glTFBuffer extends glTFChildNodeProperty, glTFNodeProperty {
        /**  The uri of the buffer.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri */
        uri?: string;
        /**  The length of the buffer in bytes */
        byteLength: number;
    }
    /**
     * @internal
     * A view into a buffer generally representing a subset of the buffer
     */
    interface glTFBufferView extends glTFChildNodeProperty, glTFNodeProperty {
        /** The index of the buffer */
        buffer: number;
        /** The offset into the buffer in bytes */
        byteOffset?: number;
        /** The lenth of the bufferView in bytes */
        byteLength: number;
        /** The stride, in bytes */
        byteStride?: number;
    }
    /**
     * @internal
     * An orthographic camera containing properties to create an orthographic projection matrix
     */
    interface glTFCameraOrthographic extends glTFNodeProperty {
        /** The floating-point horizontal magnification of the view. Must not be zero */
        xmag: number;
        /** The floating-point vertical magnification of the view. Must not be zero */
        ymag: number;
        /** The floating-point distance to the far clipping plane. zfar must be greater than znear */
        zfar: number;
        /** The floating-point distance to the near clipping plane */
        znear: number;
    }
    /**
     * @internal
     * A perspective camera containing properties to create a perspective projection matrix
     */
    interface glTFCameraPerspective extends glTFNodeProperty {
        /** The floating-point aspect ratio of the field of view */
        aspectRatio?: number;
        /** The floating-point vertical field of view in radians */
        yfov: number;
        /** The floating-point distance to the far clipping plane */
        zfar?: number;
        /** The floating-point distance to the near clipping plane */
        znear: number;
    }
    /**
     * @internal
     * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
     */
    interface glTFCamera extends glTFChildNodeProperty, glTFNodeProperty {
        /** An orthographic camera containing properties to create an orthographic projection matrix */
        orthographic?: glTFCameraOrthographic;
        /** A perspective camera containing properties to create a perspective projection matrix */
        perspective?: glTFCameraPerspective;
        /** Specifies if the camera uses a perspective or orthographic projection */
        type: glTFCameraType;
    }
    /**
     * @internal
     * Image data used to create a texture. Image can be referenced by URI or bufferView index. mimeType is required in the latter case
     */
    interface glTFImage extends glTFChildNodeProperty, glTFNodeProperty {
        /**
         * The uri of the image.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri.  The image format must be jpg or png
         */
        uri?: string;
        /**
         * The image's MIME type
         */
        mimeType?: glTFImageMimeType;
        /**
         * The index of the bufferView that contains the image. Use this instead of the image's uri property
         */
        bufferView?: number;
    }
    /**
     * @internal
     * Reference to a texture
     */
    interface glTFTextureInfo extends glTFNodeProperty {
        /**  The index of the texture */
        index: number;
        /** The set index of texture's TEXCOORD attribute used for texture coordinate mapping */
        texCoord?: number;
    }
    /**
     * @internal
     * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology
     */
    interface glTFMaterialPbrMetallicRoughness extends glTFNodeProperty {
        /** The material's base color factor */
        baseColorFactor?: number[];
        /** The base color texture */
        baseColorTexture?: glTFTextureInfo;
        /** The metalness of the material */
        metallicFactor?: number;
        /** The roughness of the material */
        roughnessFactor?: number;
        /** The metallic-roughness texture */
        metallicRoughnessTexture?: glTFTextureInfo;
    }
    /**
     * @internal
     * Material Normal Texture Info
     */
    interface glTFMaterialNormalTextureInfo extends glTFTextureInfo {
        /** The scalar multiplier applied to each normal vector of the normal texture. default: 1*/
        scale?: number;
    }
    /**
     * @internal
     * Material Occlusion Texture Info
     */
    interface glTFMaterialOcclusionTextureInfo extends glTFTextureInfo {
        /**
         * A scalar multiplier controlling the amount of occlusion applied
         */
        strength?: number;
    }
    /**
     * @internal
     * The material appearance of a primitive
     */
    interface glTFMaterial extends glTFChildNodeProperty, glTFNodeProperty {
        /** A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of pbrMetallicRoughness apply */
        pbrMetallicRoughness?: glTFMaterialPbrMetallicRoughness;
        /** The normal map texture */
        normalTexture?: glTFMaterialNormalTextureInfo;
        /** The occlusion map texture */
        occlusionTexture?: glTFMaterialOcclusionTextureInfo;
        /** The emissive map texture */
        emissiveTexture?: glTFTextureInfo;
        /** The RGB components of the emissive color of the material. These values are linear. If an emissiveTexture is specified, this value is multiplied with the texel values */
        emissiveFactor?: number[];
        /** The alpha rendering mode of the material */
        alphaMode?: glTFMaterialAlphaMode;
        /** The alpha cutoff value of the material */
        alphaCutoff?: number;
        /** Specifies whether the material is double sided */
        doubleSided?: boolean;
    }
    /**
     * @internal
     * Geometry to be rendered with the given material
     */
    interface glTFMeshPrimitive extends glTFNodeProperty {
        /**
         * A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data
         */
        attributes: {
            [name: string]: number;
        };
        /**
         * The index of the accessor that contains the indices
         */
        indices?: number;
        /**
         * The index of the material to apply to this primitive when rendering
         */
        material?: number;
        /**
         * The type of primitives to render. All valid values correspond to WebGL enums
         */
        mode?: glTFMeshPrimitiveMode;
        /**
         * An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only POSITION, NORMAL, and TANGENT supported) to their deviations in the Morph Target
         */
        targets?: {
            [name: string]: number;
        }[];
    }
    /**
     * @internal
     * A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the mesh in the scene
     */
    interface glTFMesh extends glTFChildNodeProperty, glTFNodeProperty {
        /**  An array of primitives, each defining geometry to be rendered with a material */
        primitives: glTFMeshPrimitive[];
        /**  Array of weights to be applied to the Morph Targets */
        weights?: number[];
    }
    /**
     * @internal
     * A node in the node hierarchy
     */
    interface glTFNode extends glTFChildNodeProperty, glTFNodeProperty {
        /** The index of the camera referenced by this node */
        camera?: number;
        /** The indices of this node's children */
        children?: number[];
        /** The index of the skin referenced by this node */
        skin?: number;
        /** A floating-point 4x4 transformation matrix stored in column-major order */
        matrix?: number[];
        /** The index of the mesh in this node */
        mesh?: number;
        /** The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar */
        rotation?: number[];
        /** The node's non-uniform scale, given as the scaling factors along the x, y, and z axes */
        scale?: number[];
        /** The node's translation along the x, y, and z axes */
        translation?: number[];
        /** The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh */
        weights?: number[];
    }
    /**
     * @internal
     * Texture sampler properties for filtering and wrapping modes
     */
    interface glTFSampler extends glTFChildNodeProperty, glTFNodeProperty {
        /** Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR) */
        magFilter?: glTFTextureMagFilter;
        /** Minification filter.  All valid values correspond to WebGL enums */
        minFilter?: glTFTextureMinFilter;
        /** S (U) wrapping mode.  All valid values correspond to WebGL enums */
        wrapS?: glTFTextureWrapMode;
        /** T (V) wrapping mode.  All valid values correspond to WebGL enums */
        wrapT?: glTFTextureWrapMode;
    }
    /**
     * @internal
     * The root nodes of a scene
     */
    interface glTFScene extends glTFChildNodeProperty, glTFNodeProperty {
        /**  The indices of each root node */
        nodes: number[];
    }
    /**
     * @internal
     * Joints and matrices defining a skin
     */
    interface glTFSkin extends glTFChildNodeProperty, glTFNodeProperty {
        /** The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied */
        inverseBindMatrices?: number;
        /** The index of the node used as a skeleton root. When undefined, joints transforms resolve to scene root */
        skeleton?: number;
        /** Indices of skeleton nodes, used as joints in this skin.  The array length must be the same as the count property of the inverseBindMatrices accessor (when defined) */
        joints: number[];
    }
    /**
     * @internal
     * A texture and its sampler
     */
    interface glTFTexture extends glTFChildNodeProperty, glTFNodeProperty {
        /** The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used */
        sampler?: number;
        /** The index of the image used by this texture */
        source: number;
    }
    /**
     * @internal
     */
    interface glTF extends glTFNodeProperty {
        /** An array of accessors. An accessor is a typed view into a bufferView */
        accessors?: glTFAccessor[];
        /** An array of keyframe animations */
        animations?: glTFAnimation[];
        /** Metadata about the glTF asset */
        asset: glTFAsset;
        /** An array of buffers.  A buffer points to binary geometry, animation, or skins */
        buffers?: glTFBuffer[];
        /** An array of bufferViews.  A bufferView is a view into a buffer generally representing a subset of the buffer */
        bufferViews?: glTFBufferView[];
        /** An array of cameras */
        cameras?: glTFCamera[];
        /** Names of glTF extensions used somewhere in this asset */
        extensionsUsed?: string[];
        /** Names of glTF extensions required to properly load this asset */
        extensionsRequired?: string[];
        /** An array of images.  An image defines data used to create a texture */
        images?: glTFImage[];
        /** An array of materials.  A material defines the appearance of a primitive */
        materials?: glTFMaterial[];
        /** An array of meshes.  A mesh is a set of primitives to be rendered */
        meshes?: glTFMesh[];
        /** An array of nodes */
        nodes?: glTFNode[];
        /** An array of samplers.  A sampler contains properties for texture filtering and wrapping modes */
        samplers?: glTFSampler[];
        /** The index of the default scene */
        scene?: number;
        /** An array of scenes */
        scenes?: glTFScene[];
        /** An array of skins.  A skin is defined by joints and matrices */
        skins?: glTFSkin[];
        /** An array of textures */
        textures?: glTFTexture[];
    }
    /**
     * @internal
     */
    interface glTFMaterialAnisotropy {
        /** The anisotropy strength. When anisotropyTexture is present, this value is multiplied by the blue channel. default: 0.0 */
        anisotropyStrength: number;
        /** The rotation of the anisotropy in tangent, bitangent space, measured in radians counter-clockwise from the tangent. When anisotropyTexture is present, anisotropyRotation provides additional rotation to the vectors in the texture. default: 0.0 */
        anisotropyRotation: number;
        /** The anisotropy texture. Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation. The blue channel contains strength as [0, 1] to be multiplied by anisotropyStrength. */
        anisotropyTexture: glTFTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialClearCoat {
        /** The clearcoat layer intensity. default: 0.0*/
        clearcoatFactor?: number;
        /** The base color texture */
        clearcoatTexture?: glTFTextureInfo;
        /** The clearcoat layer roughness.  default: 0.0*/
        clearcoatRoughnessFactor?: number;
        /** The clearcoat layer roughness texture.*/
        clearcoatRoughnessTexture?: glTFTextureInfo;
        /** The clearcoat normal map texture. */
        clearcoatNormalTexture?: glTFMaterialNormalTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialEmissionStrength {
        /** The strength adjustment to be multiplied with the material's emissive value. default: 1.0 */
        emissiveStrength: number;
    }
    /**
     * @internal
     */
    interface glTFMaterialIOR {
        /** The index of refraction. default: 1.5 */
        ior: number;
    }
    /**
     * @internal
     */
    interface glTFMaterialIridescence {
        /** The iridescence intensity factor. default: 0.0 */
        iridescenceFactor: number;
        /** The iridescence intensity texture. */
        iridescenceTexture: glTFTextureInfo;
        /** The index of refraction of the dielectric thin-film layer. default: 1.3 */
        iridescenceIor: number;
        /** The minimum thickness of the thin-film layer given in nanometers. default: 100.0 */
        iridescenceThicknessMinimum: number;
        /** The maximum thickness of the thin-film layer given in nanometers. default: 400.0 */
        iridescenceThicknessMaximum: number;
        /** The thickness texture of the thin-film layer. */
        iridescenceThicknessTexture: glTFTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialSheen {
        /** The sheen color in linear space. default: [0, 0, 0] */
        sheenColorFactor: number[];
        /** The sheen color (RGB) in sRGB transfer function. */
        sheenColorTexture: glTFTextureInfo;
        /** The sheen roughness. default: 0.0 */
        sheenRoughnessFactor: number;
        /** The sheen roughness (Alpha) texture. */
        sheenRoughnessTexture: glTFTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialSpecular {
        /** The strength of the specular reflection. default: 1.0 */
        specularFactor: number;
        /** A texture that defines the strength of the specular reflection, stored in the alpha (A) channel. This will be multiplied by specularFactor. */
        specularTexture: glTFTextureInfo;
        /** The F0 color of the specular reflection (linear RGB). default: [1.0, 1.0, 1.0] */
        specularColorFactor: number[];
        /** A texture that defines the F0 color of the specular reflection, stored in the RGB channels and encoded in sRGB. This texture will be multiplied by specularColorFactor. */
        specularColorTexture: glTFTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialTransmission {
        /** The base percentage of light that is transmitted through the surface. default: 0 */
        transmissionFactor: number;
        /** A texture that defines the transmission percentage of the surface, stored in the R channel. */
        transmissionTexture: glTFTextureInfo;
    }
    /**
     * @internal
     */
    interface glTFMaterialVolume {
        /** The thickness of the volume beneath the surface. default: 0.0 */
        thicknessFactor: number;
        /** A texture that defines the thickness, stored in the G channel. */
        thicknessTexture: glTFTextureInfo;
        /** Density of the medium given as the average distance that light travels in the medium before interacting with a particle. default: +Infinity */
        attenuationDistance: number;
        /** The color that white light turns into due to absorption when reaching the attenuation distance. default: [1, 1, 1] */
        attenuationColor: number[];
    }
    /**
     * @internal
     */
    interface glTFTextureTransform {
        /** The offset of the UV coordinate origin as a factor of the texture dimensions. default: [0, 0] */
        offset: number[];
        /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. default: 0.0 */
        rotation: number;
        /** The scale factor applied to the components of the UV coordinates. default: [1, 1] */
        scale: number[];
        /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */
        texCoord: number;
    }
    /**
     * @internal
     */
    class glTFResource extends Prefab {
        private static _Extensions;
        static registerExtension(name: string, factory: (resource: glTFResource) => glTFExtension): void;
        protected _data: glTF;
        get data(): Readonly<glTF.glTF>;
        protected _buffers: Record<string, ArrayBuffer>;
        protected _textures: Texture2D[];
        protected _materials: Material[];
        protected _meshes: Record<string, Mesh>;
        protected _extensions: Map<string, glTFExtension>;
        protected _pendingOps: Array<Promise<any>>;
        private _scenes;
        private _nodes;
        /** @internal */
        private _idCounter;
        constructor();
        /**
         * @internal
         * @param basePath
         * @param progress
         * @returns
         */
        loadBinary(basePath: string, progress?: IBatchProgress): Promise<void> | Promise<any[]>;
        loadTextureFromInfo(info: glTFTextureInfo, sRGB: boolean, basePath: string, progress?: IBatchProgress): Promise<Texture2D>;
        /**
         * @internal
         * @param basePath
         * @param progress
         * @returns
         */
        loadTextures(basePath: string, progress?: IBatchProgress): Promise<any>;
        /**
         * @internal
         * @returns
         */
        importMaterials(): Promise<void>;
        /**
         * @internal
         * @returns
         */
        importMeshes(): Promise<void>;
        /**
         * @param data
         * @param createURL
         * @param progress
         * @returns
         */
        _parse(data: glTF, createURL: string, progress?: IBatchProgress): Promise<void>;
        /**
         *
         * @param data
         * @param createURL
         * @param progress
         */
        _parseglb(data: ArrayBuffer, createURL: string, progress?: IBatchProgress): Promise<void>;
        create(): Sprite3D;
        protected loadTextureFromBuffer(buffer: ArrayBuffer, mimeType: glTFImageMimeType, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D>;
        protected loadTexture(url: string, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D>;
        /**
         * @internal
         * 获取 node name
         */
        protected generateId(context: string): string;
        /**
         * 根据数据类型获取分量
         * @param type
         */
        private getAccessorComponentsNum;
        /**
         * 获取 attribute 分量
         * @param attriStr
         */
        private getAttributeNum;
        /**
         * @internal
         * 获取 buffer constructor
         * @param componentType
         */
        private _getTypedArrayConstructor;
        /**
         * @internal
         * 获取 accessor data Type byte stride
         * @param componentType
         */
        _getAccessorDateByteStride(componentType: glTFAccessorComponentType): 1 | 2 | 4;
        private getBufferFormBufferView;
        /**
         * 获取 accessor buffer 数据
         * @param accessorIndex
         */
        private getBufferwithAccessorIndex;
        /**
         * 判断 Texture 是否需要 mipmap
         * @param glTFImage
         * @param glTFSampler
         */
        private getTextureMipmap;
        /**
         * 获取 Texture format
         * @param glTFImage
         */
        private getTextureFormat;
        /**
         * 获取 Texture filter mode
         * @param glTFSampler
         */
        private getTextureFilterMode;
        /**
         * 获取 Texture warp mode
         * @param mode
         */
        private getTextureWrapMode;
        /**
        * 获取 Texture 初始化参数
        * @param glTFImage
        * @param glTFSampler
        */
        private getTextureConstructParams;
        /**
         * 获取 Texture 属性参数
         * @param glTFImage
         * @param glTFSampler
         */
        private getTexturePropertyParams;
        /**
         * 根据 glTFTextureInfo 获取 Texture2D
         * @param glTFTextureInfo
         */
        getTextureWithInfo(glTFTextureInfo: glTFTextureInfo): Texture2D;
        getExtensionTextureInfo(info: glTFTextureInfo, extensionName: string): any;
        /**
         *
         * @param glTFMaterial
         * @param material
         */
        applyMaterialRenderState(glTFMaterial: glTFMaterial, material: Material): void;
        setMaterialTextureProperty(material: Material, texInfo: glTFTextureInfo, name: string, define: ShaderDefine, transformName: string, transformDefine: ShaderDefine): void;
        /**
         * @param glTFMaterial
         * @param material
         */
        applyDefaultMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void;
        /**
         * 根据 glTFMaterial 节点数据创建 default Material
         * @param glTFMaterial
         */
        createDefaultMaterial(glTFMaterial: glTFMaterial): Material;
        protected createMaterial(glTFMaterial: glTFMaterial): Material;
        /**
         * 获取 gltf mesh 中 material
         * @param glTFMesh
         */
        private pickMeshMaterials;
        /**
         * @internal
         * 加载场景节点
         * @param glTFScene
         */
        private loadScenes;
        /**
         * @internal
         * 加载场景节点
         * @param glTFScene
         */
        private _loadScene;
        /**
         * 创建 glTFScene 节点
         * @param glTFScene
         */
        private _createSceneNode;
        /**
         * 应用 Transform 信息
         * @param glTFNode
         * @param sprite
         */
        private applyTransform;
        /**
         * @internal
         * 构建 当前 glTF 对象 节点树
         * @param glTFNodes
         */
        private buildHierarchy;
        /**
         * @internal
         * 加载 glTF 节点
         * @param glTFNodes
         */
        private loadNodes;
        /**
         * @internal
         * 加载 glTF 节点
         * @param glTFNode
         */
        private loadNode;
        /**
         * 创建 节点对象
         * @param glTFNode
         */
        private createSprite3D;
        /**
         * 创建 MeshSprite3D 对象
         * @param glTFNode
         */
        private createMeshSprite3D;
        /**
         * 创建 MeshSprite3D 对象
         * @param glTFNode
         */
        private createSkinnedMeshSprite3D;
        /**
         * @internal
         * 获取 attribute buffer 数据
         * @param attributeAccessorIndex
         * @param layaDeclarStr
         * @param attributes
         * @param vertexDeclarArr
         * @param func
         */
        private getArrributeBuffer;
        /**
         * @internal
         * 获取 glTFMeshPrimitive index buffer
         * @param attributeAccessorIndex
         * @param vertexCount
         */
        private getIndexBuffer;
        private calculateFlatNormal;
        /**
         * @internal
         * 解析 subData 记录数据
         * @param subDatas
         * @param layaMesh
         */
        private parseMeshwithSubMeshData;
        /**
         * @internal
         * 填充 mesh buffer 数据
         * @param subDatas
         * @param vertexArray
         * @param indexArray
         * @param vertexFloatStride
         */
        private fillMeshBuffers;
        /**
         * @internal
         * 根据 单次提交最大骨骼数量 划分 submesh 提交队列
         * @param attributeMap
         * @param indexArray
         * @param boneIndicesList
         * @param subIndexStartArray
         * @param subIndexCountArray
         */
        private splitSubMeshByBonesCount;
        /**
         * @internal
         * 生成 mesh
         * @param vertexArray
         * @param indexArray
         * @param vertexDeclaration
         * @param ibFormat
         * @param subDatas
         * @param layaMesh
         */
        private generateMesh;
        /**
         * @internal
         * mesh 应用蒙皮数据
         * @param mesh
         * @param glTFSkin
         */
        private applyglTFSkinData;
        private applyMorphTarget;
        /**
         * 创建 Mesh
         * @param mesh
         */
        protected createMesh(glTFMesh: glTFMesh, glTFSkin?: glTFSkin): Mesh;
        /**
         * 计算 SkinnedMeshSprite3D local bounds
         * @param skinned
         */
        private calSkinnedSpriteLocalBounds;
        /**
         * @internal
         * 补全 skinnedMeshSprite 所需数据
         * @param glTFNode
         * @param skinned
         */
        private fixSkinnedSprite;
        /**
         * @internal
         * 获取 Animator 根节点
         */
        private getAnimationRoot;
        /**
         * @internal
         * 获取 动画路径信息
         * @param root
         * @param curSprite
         */
        private getAnimationPath;
        /**
         * @internal
         * 加载 Animation
         * @param animations
         */
        private loadAnimations;
        /**
         * @internal
         * 加载 Animation
         * @param animation
         */
        private loadAnimation;
        /**
         * @internal
         * 创建 Animator 组件
         * @param animation
         */
        private createAnimator;
        /**
         * @internal
         * 创建 AnimationClip
         * @param animation
         * @param animatorRoot
         * @returns
         */
        protected createAnimatorClip(animation: glTFAnimation, animatorRoot: Sprite3D): AnimationClip;
    }
    /**
     * @internal
     */
    class glTFShader {
        static ShaderName: string;
        static Define_BaseColorMap: ShaderDefine;
        static Define_BaseColorMapTransform: ShaderDefine;
        static Define_MetallicRoughnessMap: ShaderDefine;
        static Define_MetallicRoughnessMapTransform: ShaderDefine;
        static Define_NormalMap: ShaderDefine;
        static Define_NormalMapTransform: ShaderDefine;
        static Define_OcclusionMap: ShaderDefine;
        static Define_OcclusionMapTransform: ShaderDefine;
        static Define_EmissionMap: ShaderDefine;
        static Define_EmissionMapTransform: ShaderDefine;
        static Define_ClearCoatMap: ShaderDefine;
        static Define_ClearCoatMapTransform: ShaderDefine;
        static Define_ClearCoatRoughnessMap: ShaderDefine;
        static Define_ClearCoatRoughnessMapTransform: ShaderDefine;
        static Define_ClearCoatNormalMapTransform: ShaderDefine;
        static Define_AnisotropyMap: ShaderDefine;
        static Define_AnisotropyMapTransform: ShaderDefine;
        static Define_IridescenceMap: ShaderDefine;
        static Define_IridescenceMapTransform: ShaderDefine;
        static Define_IridescenceThicknessMap: ShaderDefine;
        static Define_IridescenceThicknessMapTransform: ShaderDefine;
        static Define_SheenColorMap: ShaderDefine;
        static Define_SheenColorMapTransform: ShaderDefine;
        static Define_SheenRoughnessMap: ShaderDefine;
        static Define_SheenRoughnessMapTransform: ShaderDefine;
        static Define_TransmissionMap: ShaderDefine;
        static Define_TransmissionMapTransform: ShaderDefine;
        static Define_VolumeThicknessMap: ShaderDefine;
        static Define_VolumeThicknessMapTransform: ShaderDefine;
        static Define_SpecularFactorMap: ShaderDefine;
        static Define_SpecularFactorMapTransform: ShaderDefine;
        static Define_SpecularColorMap: ShaderDefine;
        static Define_SpecularColorMapTransform: ShaderDefine;
        static init(): void;
    }
    /**
     * @en Enum representing the types of HTML elements.
     * @zh 枚举，表示 HTML 元素的类型。
     */
    enum HtmlElementType {
        /**
         * @en Text element, typically used for raw text content.
         * @zh 文本元素，通常用于纯文本内容。
         */
        Text = 0,
        /**
         * @en Link element, used for creating hyperlinks.
         * @zh 链接元素，用于创建超链接。
         */
        Link = 1,
        /**
         * @en Image element, used for embedding images.
         * @zh 图像元素，用于嵌入图像。
         */
        Image = 2,
        /**
         * @en Input element, used for creating input fields.
         * @zh 输入元素，用于创建输入字段。
         */
        Input = 3,
        /**
         * @en Select element, used for creating dropdown selects.
         * @zh 选择元素，用于创建下拉选择框。
         */
        Select = 4,
        /**
         * @en Object element, used for embedding objects like images, videos, or other media.
         * @zh 对象元素，用于嵌入对象，如图像、视频或其他媒体。
         */
        Object = 5,
        /**
         * @internal
         * @en Indicates the end of link elements.
         * @zh 表示链接元素的结束。
         */
        LinkEnd = 6
    }
    /**
     * @en The `HtmlElement` class represents HTML element.
     * @zh `HtmlElement` 类表示 HTML 元素。
     * @blueprintIgnore
     */
    class HtmlElement {
        /**
         * @en The type of the HTML element.
         * @zh HTML 元素的类型。
         */
        type: HtmlElementType;
        /**
         * @en The name of the HTML element.
         * @zh HTML 元素的名称。
         */
        name: string;
        /**
         * @en The text content of the HTML element.
         * @zh HTML 元素的文本内容。
         */
        text: string;
        /**
         * @en The style of the HTML element.
         * @zh HTML 元素的样式。
         */
        style: TextStyle;
        /**
         * @en The object associated with the HTML element.
         * @zh 与 HTML 元素关联的对象。
         */
        obj: IHtmlObject;
        /**
         * @en The space associated with the element, used for layout purposes.
         * @zh 与元素关联的空间，用于布局目的。
         */
        space: number;
        _attrs: Record<string, any>;
        /**
         * @en Creates a new instance of the `HtmlElement` class.
         * @zh 创建 `HtmlElement` 类的新实例。
         */
        constructor();
        /**
         * @en Gets the value of an attribute from the element.
         * @param attrName The name of the attribute to retrieve.
         * @returns The value of the attribute.
         * @zh 从元素中获取属性的值。
         * @param attrName 属性名称。
         * @returns 属性值。
         */
        getAttr(attrName: string): any;
        /**
         * @en Sets an attribute on the element with the given value.
         * @param attrName The name of the attribute to set.
         * @param attrValue The value to set for the attribute.
         * @zh 使用给定的值在元素上设置属性。
         * @param attrName 属性名称。
         * @param attrValue 属性值。
         */
        setAttr(attrName: string, attrValue: any): void;
        /**
         * @en Gets a string attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a string.
         * @returns The string value of the attribute or the default value.
         * @zh 获取字符串属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是字符串。
         * @returns 属性值或默认值。
         */
        getAttrString(attrName: string, defValue?: string): string;
        /**
         * @en Gets an integer attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not an integer.
         * @returns The integer value of the attribute or the default value.
         * @zh 获取整数属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是整数。
         * @returns 属性值或默认值。
         */
        getAttrInt(attrName: string, defValue?: number): number;
        /**
         * @en Gets a float attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a float.
         * @returns The float value of the attribute or the default value.
         * @zh 获取浮点属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是浮点数。
         * @returns 属性值或默认值。
         */
        getAttrFloat(attrName: string, defValue?: number): number;
        /**
         * @en Gets a boolean attribute value, with an optional default.
         * @param attrName The name of the attribute.
         * @param defValue The default value to use if the attribute is not found or is not a boolean.
         * @returns The boolean value of the attribute or the default value.
         * @zh 获取布尔属性值，可设置默认值。
         * @param attrName 属性名称。
         * @param defValue 默认值，如果属性不存在或不是布尔值。
         * @returns 属性值或默认值。
         */
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        /**
         * @en Fetches attributes from an external source and assigns them to the element.
         * @zh 从外部源获取属性，并将它们分配给元素。
         */
        fetchAttributes(): void;
        /**
         * @en Resets the properties of the element to their default state, preparing it for reuse from the pool.
         * @zh 将元素的属性重置为默认状态，准备从池中重用。
         */
        reset(): void;
        /**
         * @en A static pool of HtmlElement objects for reuse.
         * @zh HtmlElement 对象的静态池。
         */
        static pool: Array<HtmlElement>;
        /**
         * @en Retrieves an HtmlElement from the pool with a specified type, initializing it if necessary.
         * @zh 从池中检索具有指定类型的 HtmlElement，如有必要则进行初始化。
         */
        static getFromPool(type: HtmlElementType): HtmlElement;
        /**
         * @en Returns an HtmlElement or an array of HtmlElements back to the pool for reuse.
         * @zh 将 HtmlElement 或 HtmlElement 数组返回到池中以供重用。
         */
        static returnToPool(ele: HtmlElement | Array<HtmlElement>): void;
    }
    /**
     * @en The `HtmlImage` class represents an image object within an HTML element.
     * @zh `HtmlImage` 类表示 HTML 元素中的图像对象。
     */
    class HtmlImage implements IHtmlObject {
        /**
         * @en The sprite object representing the image.
         * @zh 表示图像的精灵对象。
         */
        readonly obj: Sprite;
        private _owner;
        private _element;
        private _ani;
        private _v;
        private _w;
        private _h;
        /**
         * @en Creates a new HtmlImage object.
         * @zh 创建一个 HtmlImage 对象。
         */
        constructor();
        /**
         * @en The associated HTML element.
         * @zh 关联的 HTML 元素。
         */
        get element(): HtmlElement;
        /**
         * @en The width of the image.
         * @zh 图像的宽度。
         */
        get width(): number;
        /**
         * @en The height of the image.
         * @zh 图像的高度。
         */
        get height(): number;
        /**
         * @en Creates and loads the image with the specified owner text and HTML element.
         * @param owner The owner text object.
         * @param element The HTML element associated with the image.
         * @zh 使用指定的文本所有者和 HTML 元素创建并加载图像。
         * @param owner 文本对象的所有者。
         * @param element 与图像关联的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        protected loadTexture(src: string): void;
        private onLoaded;
        /**
         * @en Positions the image at the specified coordinates.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将图像定位到指定的坐标。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources and removes the image object from its parent container.
         * @zh 释放资源并从父容器中移除图像对象。
         */
        release(): void;
        /**
         * @en Destroys the image object.
         * @zh 销毁图像对象。
         */
        destroy(): void;
    }
    /**
     * @en The `HtmlLink` class represents a clickable link area within an HTML element.
     * @zh `HtmlLink` 类表示 HTML 元素内可点击的链接区域。
     */
    class HtmlLink implements IHtmlObject, IHitArea {
        private _owner;
        private _element;
        private _shape;
        private _rects;
        private _rectCnt;
        /**
         * @en Creates a new instance of the `HtmlLink` class.
         * @zh 创建  HtmlLink 类的新实例
         */
        constructor();
        /**
         * @en The associated HTML element.
         * @zh 关联的 HTML 元素。
         */
        get element(): HtmlElement;
        /**
         * @en The width of the link area.
         * @zh 链接区域的宽度。
         */
        get width(): number;
        /**
         * @en The height of the link area.
         * @zh 链接区域的高度。
         */
        get height(): number;
        /**
         * @en Creates the link with the specified owner text and HTML element.
         * @param owner The owner text object.
         * @param element The HTML element associated with the link.
         * @zh 使用指定的文本所有者和 HTML 元素创建链接。
         * @param owner 所有者文本对象。
         * @param element 与链接关联的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        /**
         * @en Resets the link area.
         * @zh 重置链接区域。
         */
        resetArea(): void;
        /**
         * @en Adds a rectangle to the hit area.
         * @param x The x-coordinate of the rectangle.
         * @param y The y-coordinate of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @zh 向点击区域添加一个矩形。
         * @param x 矩形的 x 坐标。
         * @param y 矩形的 y 坐标。
         * @param width 矩形的宽度。
         * @param height 矩形的高度。
         */
        addRect(x: number, y: number, width: number, height: number): void;
        /**
         * @en Checks if the specified point is within the hit area.
         * @param x The x-coordinate of the point.
         * @param y The y-coordinate of the point.
         * @returns `true` if the point is within the hit area, otherwise `false`.
         * @zh 检查指定的点是否在点击区域内。
         * @param x 点的 x 坐标。
         * @param y 点的 y 坐标。
         * @returns 如果点在点击区域内，则返回 `true`，否则返回 `false`。
         */
        contains(x: number, y: number): boolean;
        /**
         * @en Positions the link area at the specified coordinates. This method does nothing.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将链接区域定位到指定的坐标。此方法不执行任何操作。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources and removes the link area from its parent container.
         * @zh 释放资源并从父容器中移除链接区域。
         */
        release(): void;
        /**
         * @en Destroys the link area and its associated sprite.
         * @zh 销毁链接区域及其关联的精灵。
         */
        destroy(): void;
    }
    /**
     * @en The `HtmlParseOptions` class defines a set of options used for parsing HTML content.
     * @zh `HtmlParseOptions` 类定义了一组用于解析 HTML 内容的选项。
     */
    class HtmlParseOptions {
        /**
         * @en Indicates whether links should be displayed with an underline.
         * @zh 指示链接是否应该显示下划线。
         */
        linkUnderline: boolean;
        /**
         * @en The default color for links.
         * @zh 链接的默认颜色。
         */
        linkColor: string;
        /**
         * @en Indicates whether to ignore white spaces in the HTML content.
         * @zh 指示是否忽略 HTML 内容中的空白。
         */
        ignoreWhiteSpace: boolean;
        /**
         * @en The default value for the `linkUnderline` option.
         * @zh `linkUnderline` 选项的默认值。
         */
        static defaultLinkUnderline: boolean;
        /**
         * @en The default value for the `linkColor` option.
         * @zh `linkColor` 选项的默认值。
         */
        static defaultLinkColor: string;
        /**
         * @ignore
         * @en Creates a new instance of the `HtmlParseOptions` class.
         * @zh 创建 HtmlParseOptions 类的新实例。
         */
        constructor();
    }
    /**
     * @en The `HtmlParser` class is responsible for parsing HTML content and converting it into a series of HTML elements with styles.
     * @zh `HtmlParser` 类负责解析 HTML 内容，将其转换为一系列具有样式的 HTML 元素。
     */
    class HtmlParser {
        /**
         * @en The default instance of the HtmlParser class.
         * @zh HtmlParser 类的默认实例。
         */
        static defaultParser: HtmlParser;
        /**
         * @en A mapping of HTML element types to their corresponding classes.
         * @zh 将 HTML 元素类型映射到它们对应的类。
         */
        static classMap: Record<number, new () => IHtmlObject>;
        protected _styleStack: Array<TextStyle>;
        protected _styleStackTop: number;
        protected _style: TextStyle;
        protected _elements: Array<HtmlElement>;
        protected _options: HtmlParseOptions;
        /** @ignore */
        constructor();
        /**
         * @en Parses the given HTML source and populates the output array with HTML elements.
         * @param aSource The HTML source to parse.
         * @param style The default text style to apply.
         * @param out The array to populate with parsed HTML elements.
         * @param options The options for parsing the HTML.
         * @zh 解析给定的 HTML 源代码，并将输出数组填充为 HTML 元素。
         * @param aSource 要解析的 HTML 源代码。
         * @param style 要应用的默认文本样式。
         * @param out 要填充解析后的 HTML 元素的数组。
         * @param options 解析 HTML 的选项。
         */
        parse(aSource: string, style: TextStyle, out: Array<HtmlElement>, options?: HtmlParseOptions): void;
        protected pushStyle(): void;
        protected popStyle(): void;
        protected isNewLine(): boolean;
        protected appendText(text: string): void;
    }
    /**
     * @en The `IHtmlObject` interface defines the structure and behavior of objects that can be embedded within HTML content.
     * @zh `IHtmlObject` 接口定义了可以嵌入在 HTML 内容中的对象的结构和行为。
     * @blueprintIgnore
     */
    interface IHtmlObject {
        /**
         * @en The width of the HTML object.
         * @zh HTML 对象的宽度。
         */
        width: number;
        /**
         * @en The height of the HTML object.
         * @zh HTML 对象的高度。
         */
        height: number;
        /**
         * @en The HTML element associated with this object.
         * @zh 与此对象关联的 HTML 元素。
         */
        element: HtmlElement;
        /**
         * @en Indicates whether the HTML object is currently loading.
         * @zh 表示 HTML 对象当前是否正在加载。
         */
        loading?: boolean;
        /**
         * @en Creates the HTML object with the given owner and element.
         * @param owner The owner of the HTML object.
         * @param element The HTML element to create the object from.
         * @zh 使用给定的所有者和元素创建 HTML 对象。
         * @param owner HTML 对象的所有者。
         * @param element 用于创建对象的 HTML 元素。
         */
        create(owner: Text, element: HtmlElement): void;
        /**
         * @en Positions the HTML object at the specified coordinates.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @zh 将 HTML 对象定位到指定的坐标。
         * @param x x 坐标。
         * @param y y 坐标。
         */
        pos(x: number, y: number): void;
        /**
         * @en Releases resources associated with the HTML object.
         * @zh 释放与 HTML 对象关联的资源。
         */
        release(): void;
        /**
         * @en Destroys the HTML object and frees up all associated resources.
         * @zh 销毁 HTML 对象并释放所有关联的资源。
         */
        destroy(): void;
    }
    /**
     * @en The `IHtmlPageContext` interface represents the context in which HTML content is parsed and rendered, providing methods to create and manage HTML objects.
     * @zh `IHtmlPageContext` 接口表示解析和渲染 HTML 内容的上下文环境，提供创建和管理 HTML 对象的方法。
     */
    interface IHtmlPageContext {
        /**
         * @en Creates an HTML object based on the provided owner and element, which can be embedded within the HTML content.
         * @param owner The owner of the HTML object, typically a text container.
         * @param element The HTML element from which to create the object.
         * @returns An instance of `IHtmlObject` that represents the created HTML object.
         * @zh 基于提供的拥有者和元素创建一个 HTML 对象，该对象可以嵌入在 HTML 内容中。
         * @param owner HTML 对象的拥有者，通常是一个文本容器。
         * @param element 用于创建对象的 HTML 元素。
         * @returns `IHtmlObject` 的一个实例，代表创建的 HTML 对象。
         */
        createObject(owner: Text, element: HtmlElement): IHtmlObject;
        /**
         * @en Frees an HTML object, releasing any resources associated with it. This method is typically called when an object is no longer needed.
         * @param obj The HTML object to be freed.
         * @zh 释放一个 HTML 对象，释放与其关联的所有资源。通常在不再需要对象时调用此方法。
         * @param obj 要释放的 HTML 对象。
         */
        freeObject(obj: IHtmlObject): void;
    }
    interface ITagHandler {
        (tagName: string, end: boolean, attr: string): string;
    }
    /**
     * @en The `UBBParser` class is responsible for parsing UBB formatted text and converting it to HTML.
     * @zh `UBBParser` 类负责解析 UBB 格式的文本，并将其转换为 HTML。
     */
    class UBBParser {
        /**
         * @en The default instance of the UBBParser class.
         * @zh UBBParser 类的默认实例。
         */
        static defaultParser: UBBParser;
        private _text;
        private _readPos;
        protected _handlers: Record<string, ITagHandler>;
        /**
         * @en The default width for image tags.
         * @zh 图像标签的默认宽度。
         */
        defaultImgWidth: number;
        /**
         * @en The default height for image tags.
         * @zh 图像标签的默认高度。
         */
        defaultImgHeight: number;
        /**
         * @en The last color parsed in the text.
         * @zh 文本中解析的最后颜色。
         */
        lastColor: string;
        /**
         * @en The last size parsed in the text.
         * @zh 文本中解析的最后大小。
         */
        lastSize: string;
        /**
         * @ignore
         * @en Creates an instance of the `UBBParser` class.
         * @zh 创建 `UBBParser` 类的实例。
         */
        constructor();
        protected onTag_URL(tagName: string, end: boolean, attr: string): string;
        protected onTag_IMG(tagName: string, end: boolean, attr: string): string;
        protected onTag_B(tagName: string, end: boolean, attr: string): string;
        protected onTag_I(tagName: string, end: boolean, attr: string): string;
        protected onTag_U(tagName: string, end: boolean, attr: string): string;
        protected onTag_Simple(tagName: string, end: boolean, attr: string): string;
        protected onTag_COLOR(tagName: string, end: boolean, attr: string): string;
        protected onTag_FONT(tagName: string, end: boolean, attr: string): string;
        protected onTag_SIZE(tagName: string, end: boolean, attr: string): string;
        protected getTagText(remove?: boolean): string;
        /**
         * @en Parses the UBB formatted text and returns the corresponding HTML string.
         * @param text The UBB formatted text to parse.
         * @param remove Whether to remove UBB tags or convert them to HTML.
         * @returns The resulting HTML string.
         * @zh 解析 UBB 格式的文本，并返回相应的 HTML 字符串。
         * @param text 要解析的 UBB 格式文本。
         * @param remove 是否移除 UBB 标签或将其转换为 HTML。
         * @returns 生成的 HTML 字符串。
         */
        parse(text: string, remove?: boolean): string;
    }
    /**
     * @en The `XML` class represents an XML node with methods to manipulate and parse XML data.
     * @zh `XML` 类表示一个 XML 节点，具有操作和解析 XML 数据的方法。
     * @blueprintIgnore
     */
    class XML {
        /**
         * @en The name of the XML node.
         * @zh XML 节点的名称。
         */
        name: string;
        /**
         * @en The text content of the XML node.
         * @zh XML 节点的文本内容。
         */
        text: string;
        private _attrs;
        private _children;
        /**
         * @ignore
         * @en Creates a new instance of the `XML` class.
         * @param XmlString Optional. The XML source string to parse.
         * @zh 创建 `XML` 类的新实例。
         * @param XmlString 可选。要解析的 XML 源字符串。
         */
        constructor(XmlString?: string);
        /**
         * @en The attributes of the XML node.
         * @zh XML 节点的属性。
         */
        get attributes(): Record<string, string>;
        /**
         * @en Retrieves the value of an attribute as a string. If the attribute is not found, the default value is returned.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found.
         * @returns The attribute value as a string, or the default value if the attribute is not present.
         * @zh 根据属性名称获取对应的字符串。如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果未找到属性，则返回的默认值。
         * @returns 属性的字符串，如果属性不存在，则为默认值。
         */
        getAttrString(attrName: string, defValue?: string): string;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to an integer, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found or not a number.
         * @returns The integer value of an XML node attribute, or the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为整数，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到或无法转换为整数，则返回的默认整数值。
         * @returns XML 节点属性的整数值，如果属性值不存在，则为默认值。
         */
        getAttrInt(attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to a floating-point number, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found.
         * @returns The floating-point value of an XML node attribute, which is the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为浮点数，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到，则返回的默认浮点数。
         * @returns XML 节点属性的浮点数值，如果属性值不存在，则为默认值。
         */
        getAttrFloat(attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the XML node's attributes based on the attribute name, convert it to a floating-point number, and return the default value if the attribute is not found.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value to return if the attribute is not found or not a number.
         * @returns The floating-point value of an XML node attribute, which is the default value if the attribute value does not exist.
         * @zh 根据属性名称从 XML 节点的属性中检索属性值，将其转换为布尔值，如果未找到属性，则返回默认值。
         * @param attrName 要检索的属性名称。
         * @param defValue 如果属性未找到，则返回的默认布尔值。
         * @returns XML 节点属性的布尔值，如果属性值不存在，则为默认值。
         */
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        /**
         * @en Sets an attribute on the XML node to the specified value.
         * @param attrName The name of the attribute to set.
         * @param attrValue The value of the attribute to set.
         * @zh 设置 XML 节点的属性为指定的值。
         * @param attrName 要设置的属性名称。
         * @param attrValue 要设置的属性值。
         */
        setAttribute(attrName: string, attrValue: string): void;
        /**
         * @en Retrieves the first child node with the specified name.
         * @param selector The name of the child node to find.
         * @returns The first child node with the specified name, or null if not found.
         * @zh 检索具有指定名称的第一个子节点。
         * @param selector 要查找的子节点名称。
         * @returns 如果找到具有指定名称的第一个子节点，则返回该节点；如果没有找到，则返回 null。
         */
        getNode(selector: string): XML;
        /**
         * @en Get child elements of the XML node.
         * @param selector Optional. A string to filter child elements by name.
         * @returns An array of XML objects representing the child elements.
         * @zh 获取XML节点的子元素。
         * @param selector 可选。用于按名称筛选子元素的字符串。
         * @returns 表示子元素的XML对象数组。
         */
        elements(selector?: string): Array<XML>;
        /**
         * @en Parses the given XML source string and populates the node and its children according to the XML structure.
         * @param aSource The XML source string to parse.
         * @zh 解析给定的 XML 源字符串，并根据 XML 结构填充节点及其子节点。
         * @param aSource 要解析的 XML 源字符串。
         */
        parse(aSource: string): void;
        /**
         * @en Resets the attributes and child nodes of the XML node.
         * @zh 重置 XML 节点的属性和子节点。
         */
        reset(): void;
    }
    /**
     * @en The tag type of XML.
     * @zh XML 的标签类型
     */
    enum XMLTagType {
        /**
         * @en Represents the start of an XML element.
         * @zh 表示XML元素的开始。
         */
        Start = 0,
        /**
         * @en Represents the end of an XML element.
         * @zh 表示XML元素的结束。
         */
        End = 1,
        /**
         * @en Represents a void XML element (self-closing tag).
         * @zh 表示空的XML元素（自闭合标签）。
         */
        Void = 2,
        /**
         * @en Represents a CDATA section in XML.
         * @zh 表示XML中的CDATA部分。
         */
        CDATA = 3,
        /**
         * @en Represents an XML comment.
         * @zh 表示XML注释。
         */
        Comment = 4,
        /**
         * @en Represents an XML processing instruction.
         * @zh 表示XML处理指令。
         */
        Instruction = 5
    }
    /**
     * @en XMLIterator class for parsing XML strings.
     * @zh XML迭代器类，用于解析XML字符串。
     */
    class XMLIterator {
        /**
         * @en The name of the current XML tag.
         * @zh 当前XML标签的名称。
         */
        static tagName: string;
        /**
         * @en The type of the current XML tag.
         * @zh 当前XML标签的类型。
         */
        static tagType: XMLTagType;
        /**
         * @en The name of the last processed XML tag.
         * @zh 上一个处理的XML标签的名称。
         */
        static lastTagName: string;
        /**
         * @en The source XML string being parsed.
         * @zh 正在解析的源XML字符串。
         */
        static source: string;
        /**
         * @en The length of the source XML string.
         * @zh 源XML字符串的长度。
         */
        static sourceLen: number;
        /**
         * @en The current parsing position in the source string.
         * @zh 源字符串中的当前解析位置。
         */
        static parsePos: number;
        /**
         * @en The starting position of the current tag in the source string.
         * @zh 当前标签在源字符串中的起始位置。
         */
        static tagPos: number;
        /**
         * @en The length of the current tag.
         * @zh 当前标签的长度。
         */
        static tagLength: number;
        /**
         * @en The ending position of the last processed tag.
         * @zh 上一个处理的标签的结束位置。
         */
        static lastTagEnd: number;
        /**
         * @en Indicates whether attributes have been parsed.
         * @zh 指示是否已解析属性。
         */
        static attrParsed: boolean;
        /**
         * @en Indicates whether tag names should be converted to lowercase.
         * @zh 指示是否应将标签名称转换为小写。
         */
        static lowerCaseName: boolean;
        private static _attrs;
        /**
         * @en Initialize the XMLIterator with a source string.
         * @param source The XML string to parse.
         * @param lowerCaseName Optional. Whether to convert tag names to lowercase.
         * @zh 使用源字符串初始化XMLIterator。
         * @param source 要解析的XML字符串。
         * @param lowerCaseName 可选。是否将标签名称转换为小写。
         */
        static begin(source: string, lowerCaseName?: boolean): void;
        /**
         * @en Parses through the XML source to find the next tag and updates the iterator's state accordingly.
         * @returns Returns true if a new tag is found; otherwise, false if the end of the source is reached.
         * @zh 解析XML源，查找下一个标签并相应地更新迭代器的状态。
         * @returns 如果找到新标签则返回true；如果到达源的末尾则返回false。
         */
        static nextTag(): boolean;
        /**
         * @en Get the source of the current XML tag.
         * @returns The source of the current XML tag.
         * @zh 获取当前XML标签的源代码。
         * @returns 当前XML标签的源代码。
         */
        static getTagSource(): string;
        /**
         * @en Gets the raw text between the last tag end and the current tag position.
         * @param trim Whether to trim the whitespace characters at the beginning and end of the text.
         * @returns The raw text, trimmed if specified.
         * @zh 获取上一个标签结束和当前标签位置之间的原始文本。
         * @param trim 是否去除文本首尾的空白字符。
         * @returns 返回的原始文本，如果指定则去除首尾空白。
         */
        static getRawText(trim?: boolean): string;
        /**
         * @en Get the decoded text between XML tags, optionally trimmed.
         * @param trim Whether to trim the whitespace at the beginning and end of the text. Default is false.
         * @returns The decoded text between XML tags.
         * @zh 获取XML标签之间的解码文本，可选择是否去除首尾空白字符。
         * @param trim 是否去除文本开头和结尾的空白字符。默认为false。
         * @returns XML标签之间的解码文本。
         */
        static getText(trim?: boolean): string;
        /**
         * @en The parsed attributes of the current tag.
         * @zh 当前标签解析后的属性。
         */
        static get attributes(): any;
        /**
         * @en Gets the value of the specified attribute from the current tag.
         * @param attrName The name of the attribute to get.
         * @returns The value of the attribute.
         * @zh 从当前标签获取指定属性的值。
         * @param attrName 要获取的属性名称。
         * @returns 返回属性的值。
         */
        static getAttribute(attrName: string): string;
        /**
         * @en Parses the attributes from the source text.
         * @param attrs The object to store the parsed attributes.
         * @zh 从源文本解析属性。
         * @param attrs 存储解析后属性的对象。
         */
        static parseAttributes(attrs: any): void;
    }
    /**
     * @en Utility class for XML operations.
     * @zh XML操作的工具类。
     */
    class XMLUtils {
        /**
         * @en Decodes a string that contains HTML entities into a displayable form.
         * @param aSource The string to decode.
         * @returns The decoded string.
         * @zh 对包含HTML实体的字符串进行解码，转换为可显示的格式。
         * @param aSource 需要解码的字符串。
         * @returns 返回解码后的字符串。
         */
        static decodeString(aSource: string): string;
        /**
         * @en Encodes special characters in a string to their corresponding HTML entities.
         * @param str The string that contains special characters to be encoded.
         * @returns The encoded string with HTML entities.
         * @zh 将字符串中的特殊字符转换为对应的HTML实体。
         * @param str 包含待编码特殊字符的字符串。
         * @returns 包含HTML实体的编码后的字符串。
         */
        static encodeString(str: string): string;
        /**
         * @en Retrieves an attribute value from an object, and converts it to a string. If the attribute or object does not exist, the default value is used.
         * @param attrs The object that contains the attribute.
         * @param attrName The name of the attribute to retrieve.
         * @param defValue The default value if the attribute is not found or is null.
         * @returns The retrieved attribute value, or the default if the attribute is not present.
         * @zh 从一个对象中检索一个属性值，并将此属性转化为字符串，如果属性不存在或对象不存在，则使用默认值。
         * @param attrs 包含待检索属性的对象。
         * @param attrName 需要检索的属性名称。
         * @param defValue 如果属性不存在或为null时的默认值。
         * @returns 检索到的属性值的字符串，如果属性不存在或对象不存在，则返回默认值。
         */
        static getString(attrs: any, attrName: string, defValue?: string): string;
        /**
         * @en Retrieve the attribute values in the object based on the attribute name and convert them to integers. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid integer, return the parsed integer value; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为整数，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的整数，则返回解析后的整数值，否则返回默认值。
         */
        static getInt(attrs: any, attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute value from the object based on the attribute name and convert it to a floating-point number. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid floating-point number, return the parsed floating-point number; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为浮点数，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的浮点数，则返回解析后的浮点数，否则返回默认值。
         */
        static getFloat(attrs: any, attrName: string, defValue?: number): number;
        /**
         * @en Retrieve the attribute values in the object based on the attribute name and convert them to Boolean values. If the attribute does not exist, use the default value.
         * @param attrs The object containing the attribute.
         * @param attrName The name of the attribute.
         * @param defValue The default value if the attribute is not found.
         * @returns If the attribute is a valid Boolean values, return the parsed Boolean values; otherwise, return the default value.
         * @zh 根据属性名检索对象中的属性值，并将其转换为布尔值，如果属性不存在，则使用默认值。
         * @param attrs 包含属性的对象。
         * @param attrName 属性的名称。
         * @param defValue 如果属性未找到，则使用的默认值。
         * @returns 如果属性是有效的布尔值，则返回解析后的布尔值，否则返回默认值。
         */
        static getBool(attrs: any, attrName: string, defValue?: boolean): boolean;
    }
    class BoneConstraints extends Script {
        static DATACHANGE: string;
        private _constraintDatas;
        set constraints(cs: IK_ConstraintData[]);
        get constraints(): IK_ConstraintData[];
        onConstraintDataChange(idx: number): void;
        onAwake(): void;
        onDestroy(): void;
    }
    class IK_AnimLayer {
        roations: Quaternion[];
        positions: Vector3[];
        constructor(n?: number);
        set length(n: number);
        get length(): number;
        captureBonePose(joints: IK_Joint[]): this;
        captureIKResult(joints: IK_Joint[]): this;
        copy(layer: IK_AnimLayer): void;
        /**
         *
         * @param b
         * @param weight b的权重
         * @param out
         */
        blend(b: IK_AnimLayer, weight: number, joints: IK_Joint[], out?: IK_AnimLayer): void;
        /**
         * 把当前的旋转给关节
         * 需要第一个关节的位置
         * @param joints
         */
        applyToBone(joints: IK_Joint[]): void;
    }
    class IK_LayerMgr {
        private finalLayer;
        private lastSet;
        private fadeSrc;
        private fadeTarget;
        private fadeStart;
        private fadeTm;
        constructor();
        getCurrent(): IK_AnimLayer;
        set(layer: IK_AnimLayer): void;
        /**
         * 从当前的结果过度到指定的结果
         * @param layer
         * @param tm
         */
        fadeTo(layer: IK_AnimLayer, tm: number): void;
        stopFade(): void;
        isFading(): boolean;
        apply(joints: IK_Joint[]): void;
    }
    /**
     * 从IK_pose1可以方便的绑定到某个骨骼上，随着动画动
     */
    class IK_Chain extends IK_ChainBase {
        private _showDbg;
        solver: IK_ISolver;
        poleTarget: IK_Target;
        _endAlign: 'no' | 'y' | 'all';
        private _isEndAlign;
        private _parentInEnd;
        constructor(name: string, mgr: IK_Comp);
        isCollinear(target: Vector3, epsilon?: number): boolean;
        visualize(line: ILinerender): void;
        set showDbg(b: boolean);
        get showDbg(): boolean;
        set endAlign(v: 'no' | 'y' | 'all');
        get endAlign(): 'no' | 'y' | 'all';
        private _firstGetParentInEnd;
        solve(): void;
        /**
         * 根据关节的位置计算关节的朝向。
         * 为了避免扭的效果，按照从根到末端计算，并且都按照相对parent的来计算，而不是按照Z
         */
        updateRotations(): void;
    }
    class IK_ChainBase {
        name: string;
        joints: IK_Joint[];
        protected _target: IK_Target;
        layerMgr: IK_LayerMgr;
        staticLayer: IK_AnimLayer;
        animLayer: IK_AnimLayer;
        ik_result: IK_AnimLayer;
        private _isRunning;
        enable: boolean;
        protected _jointMgr: IK_JointManager;
        protected _end_effector: IK_Joint;
        totalLength: number;
        blendWeight: number;
        constructor(mgr: IK_Comp);
        set isRunning(v: boolean);
        get isRunning(): boolean;
        set target(tar: IK_Target);
        get target(): IK_Target;
        set endFixed(v: boolean);
        get endFixed(): boolean;
        visualize(line: ILinerender): void;
        get end_effector(): IK_Joint;
        addJoint(joint: IK_Joint): void;
        getJoint(name: string): IK_Joint;
        rotateJoint(jointId: number, deltaQuat: Quaternion): void;
        copyCurPoseAsInitPose(): void;
        copyInitPose(): void;
        captureStaticPose(): void;
        resetStaticPose(): void;
        captureAnimPose(): void;
        fadeToAnim(): void;
        isFading(): boolean;
        applyResult(): void;
        solve(): void;
        applyIKResult(): void;
        onLinkEnd(): void;
    }
    class IK_ChainData {
        name: string;
        type: string;
        end: Sprite3D;
        fixedEnd: boolean;
        alignTarget: 'no' | 'y' | 'all';
        target: Sprite3D;
        PoleTarget: Sprite3D;
        jointCount: number;
        lookJointCount: number;
        blendWeight: number;
        enable: boolean;
    }
    class IK_Comp extends Script {
        private _ik_sys;
        private _needRebuild;
        private _constraintsMap;
        private _showDbg;
        private _visualSp;
        private _visualInPlay;
        private _chainDatas;
        set chainDatas(v: IK_ChainData[]);
        get chainDatas(): IK_ChainData[];
        private _solverIteration;
        set solverIteration(v: number);
        get solverIteration(): number;
        private _dirsolverIteration;
        set dirSolverIteration(v: number);
        get dirSolverIteration(): number;
        set dampingFactor(v: number);
        get dampingFactor(): number;
        private _constraintDatas;
        set constraints(cs: IK_ConstraintData[]);
        get constraints(): IK_ConstraintData[];
        onConstraintDataChange(idx: number): void;
        set showGizmos(v: boolean);
        get showGizmos(): boolean;
        set 显示约束(v: boolean);
        get 显示约束(): boolean;
        set 显约束轴(v: boolean);
        get 显约束轴(): boolean;
        private _runInEditor;
        get RunInEditor(): boolean;
        set RunInEditor(b: boolean);
        set useAnimLayer(b: boolean);
        get useAnimLayer(): boolean;
        constructor();
        protected _onAdded(): void;
        onAfterDeserialize(): void;
        onChainDataChange(data: IK_ChainData, key: string, value: any, oldvalue: any): void;
        setTarget(name: string | IK_Chain, target: IK_Target): void;
        get chains(): IK_Chain[];
        getChain(name: string): IK_Chain;
        /**
         * 在动画开始之前，用来记录、恢复静态姿态
         */
        beforeOwnerAnim(): void;
        onAwake(): void;
        onDestroy(): void;
        onUpdate(): void;
        private _createConstraintInstanceFromData;
        private _updateConstraintSpace;
        visualize(v: ILinerender): void;
    }
    /**
     * 从0度开始，0度对应父joint
     * 实际使用的时候，需要放到一个指定的空间，主要是指定转轴
     */
    class IK_Constraint_Euler implements IK_Constraint1 {
        xmin: number;
        xmax: number;
        ymin: number;
        ymax: number;
        zmin: number;
        zmax: number;
        rotation: Quaternion;
        cur: number;
        constructor(xmin?: number, xmax?: number, ymin?: number, ymax?: number, zmin?: number, zmax?: number);
        constraintMat(mat: Matrix4x4): Quaternion;
        constraintQ(q: Quaternion): Quaternion;
        visualize(liner: ILinerender, mat: Matrix4x4): void;
    }
    /**
     * 从0度开始，0度对应父joint
     * 实际使用的时候，需要放到一个指定的空间，主要是指定转轴
     */
    class IK_Constraint_SwingTwist implements IK_Constraint1 {
        xmax: number;
        ymax: number;
        zmin: number;
        zmax: number;
        rotation: Quaternion;
        cur: number;
        visual_height: number;
        visual_zheight: number;
        constructor(xmax?: number, ymax?: number, zmin?: number, zmax?: number);
        constraintMat(mat: Matrix4x4): Quaternion;
        constraintQ(q: Quaternion): Quaternion;
        visualize(liner: ILinerender, mat: Matrix4x4): void;
    }
    interface IK_Constraint1 {
        constraintMat(mat: Matrix4x4): Quaternion;
        constraintQ(q: Quaternion): Quaternion;
        visualize(liner: ILinerender, mat: Matrix4x4): void;
        rotation: Quaternion;
    }
    /**
     * 这个必须是ik链已经连好了再调用，因为需要用到父关节
     */
    class IK_ConstraintInstance {
        constraint: IK_Constraint1;
        constraintBone: boolean;
        inParent: Matrix4x4;
        inChild: Matrix4x4;
        enable: boolean;
        data: IK_ConstraintData | null;
        constructor(constraint: IK_Constraint1, matInParent: Matrix4x4, //父bone空间,
        constraintBone: boolean);
        /**
         *
         * @param joint
         */
        doConsraint(joint: IK_Joint): void;
        visualize(joint: IK_Joint, line: ILinerender): void;
    }
    class IK_ConstraintData {
        private _xmin;
        private _xmax;
        private _ymin;
        private _ymax;
        private _zmin;
        private _zmax;
        enable: boolean;
        bone: Sprite3D;
        type: string;
        space: Sprite3D;
        constraintBone: boolean;
        set xmin(v: number);
        get xmin(): number;
        set xmax(v: number);
        get xmax(): number;
        set ymin(v: number);
        get ymin(): number;
        set ymax(v: number);
        get ymax(): number;
        set zmin(v: number);
        get zmin(): number;
        set zmax(v: number);
        get zmax(): number;
        visualHeight: number;
    }
    interface IK_ISolver {
        solve(chain: IK_Chain, targetPos: Vector3, endOffline: boolean): void;
        maxIterations: number;
        dampingFactor: number;
        poleTarget: IK_Target;
    }
    class IK_Joint {
        transform: Transform3D;
        constraint: IK_ConstraintInstance;
        type: "revolute" | "prismatic";
        length: number;
        private _parent;
        name: string;
        bone: Sprite3D;
        childDirOff: Matrix4x4;
        relPos: Vector3;
        fixed: boolean;
        constructor(bone?: Sprite3D);
        copyTransform(): void;
        applyTransform(weight: number): void;
        set rotationQuat(q: Quaternion);
        get rotationQuat(): Quaternion;
        set position(p: Vector3);
        get position(): Vector3;
        get worldMatrix(): Matrix4x4;
        set parent(p: IK_Joint);
        get parent(): IK_Joint;
        visualize(line: ILinerender): void;
        random(axis: Vector3, baseVec: Vector3, childVec: Vector3): Vector3;
        /**
         * 扰动关节以跳出共线状态
         * @returns 如果成功扰动返回true，如果无法扰动返回false
         */
        perturbJoint(): boolean;
    }
    function getJointMgr(sp: Sprite3D): IK_JointManager;
    class IK_JointManager {
        private _mapBoneJoint;
        getJoint(name: string): IK_Joint;
        addJoint(name: string, joint: IK_Joint): void;
    }
    class IK_Lookat extends IK_ChainBase {
        private _chainLength;
        private _end;
        private _hasOff;
        static dirIt: number;
        alignWithTarget: boolean;
        constructor(joints: IK_Joint[], mgr: IK_Comp);
        visualize(line: ILinerender): void;
        solve(): void;
    }
    class IK_Lookat1 extends IK_ChainBase {
        private _chainLength;
        private _end;
        private _hasOff;
        static dirIt: number;
        alignWithTarget: boolean;
        constructor(joints: IK_Joint[], mgr: IK_Comp);
        visualize(line: ILinerender): void;
        solve(): void;
    }
    class IK_Target {
        targetSprite: Sprite3D;
        _pos: Vector3;
        _dir: Vector3;
        constructor(pos?: Vector3 | Sprite3D | null, dir?: Vector3 | null);
        getPose(mat: Matrix4x4): Matrix4x4;
        get pos(): Vector3;
        set pos(p: Vector3);
        get dir(): Vector3;
        set dir(v: Vector3);
    }
    class SHOW_DBG {
        static CONSTRAINT: number;
        static CONSTRAINT_AXIS: number;
        static BONE: number;
        static BONE_AXIS: number;
        static ALL: number;
        static showdbg: number;
        static none(): typeof SHOW_DBG;
        static all(): typeof SHOW_DBG;
        static add(flag: number): typeof SHOW_DBG;
        static sub(flag: number): typeof SHOW_DBG;
        static has(flag: number): boolean;
    }
    class IK_System {
        static version: string;
        private solver;
        chains: IK_Chain[];
        lookats: IK_Lookat[];
        private rootSprite;
        private _showDbg;
        constraintsMap: Map<Sprite3D, IK_ConstraintInstance>;
        enableSolver: boolean;
        owner: Sprite3D;
        useAnimLayer: boolean;
        constructor(owner: Sprite3D);
        setRoot(r: Sprite3D): void;
        setMaxIterations(v: number): void;
        setDampingFactor(v: number): void;
        getDampingFactor(): number;
        set showDbg(b: boolean);
        get showDbg(): boolean;
        visualize(liner: ILinerender): void;
        /**
         * 可以包含多个chain
         * @param chain
         */
        addChain(chain: IK_Chain): void;
        clear(): void;
        private _getChildByName;
        /**
         * 根据给定的id或者名字找到一条链
         * @param name
         * @param length 链的长度
         * 返回的骨骼的顺序是从末端到根
         */
        getBoneChain(name: string, length: number): Sprite3D[];
        getBoneChainBySprite(end: Sprite3D, length: number): Sprite3D[];
        chreateChainByBoneName(comp: IK_Comp, nameOrSp3d: string | Sprite3D, length: number): IK_Chain;
        chreateLookatByEndSprite(comp: IK_Comp, end: Sprite3D, length: number): IK_Lookat;
        private _findChainByName;
        setTarget(endEffectorName: string | IK_Chain, target: IK_Target): void;
        resetPose(): void;
        onUpdate(): Promise<void>;
    }
    class IK_TwoBoneChain {
        root: IK_Joint;
        kee: IK_Joint;
        end: IK_Joint;
        solve(target: Matrix4x4, poleTarget?: Matrix4x4): void;
    }
    function quaternionFromTo(from: Vector3, to: Vector3, out: Quaternion): boolean;
    function delay(time: number): Promise<unknown>;
    function isCollinear(p1: Vector3, p2: Vector3, p3: Vector3, epsilon?: number): boolean;
    class ClsInst {
        static map: Map<string, any[]>;
        static addInst(obj: any): void;
        static upateType(cls: any): void;
    }
    function solveLambdaForNormEquality(v1: Vector3, v2: Vector3, v3: Vector3): number;
    /**
     *
     * @param target 目标位置
     * @param endPose 末端的位置和朝向。
     * @param deltaQ 输出 旋转四元数，可以把末端的z指向target
     */
    function solveLookat(target: Vector3, endPose: Matrix4x4, deltaQ: Quaternion): boolean;
    function ripMatScale(mat: Matrix4x4): Matrix4x4;
    function getVecAngInPlane(axisPos: Vector3, axis: Vector3, zero: Vector3, vec: Vector3): number;
    class IK_CCDSolver implements IK_ISolver {
        dampingFactor: number;
        maxIterations: number;
        epsilon: number;
        poleTarget: IK_Target;
        constructor(maxIterations?: number, epsilon?: number);
        private _targetPos;
        solve(chain: IK_Chain, target: Vector3, endOffline: boolean): void;
    }
    class IK_FABRIK_Solver implements IK_ISolver {
        maxIterations: number;
        tolerance: number;
        debugProc: boolean;
        poleTarget: IK_Target;
        constructor(maxIterations?: number, tolerance?: number);
        dampingFactor: number;
        solve(chain: IK_Chain, targetPos: Vector3, endOffline: boolean): void;
        private applyConstraints;
        private stretchToTarget;
        /**
         * 这个虽然叫做forward，其实是从末端到根，其实更符合传统骨骼动画的backward的定义。
         * @param currentJoint 当前关节
         * @param nextJoint  下一个关节，更接近末端
         */
        private forwardStep;
        private backwardStep;
    }
    interface ILinerender {
        addLine(start: Vector3, end: Vector3, c1: Color, c2: Color): void;
        destroy(): void;
        clear(): void;
    }
    class Bone3D {
        name: string;
        parent: Sprite3D;
        child: Sprite3D;
        boneLength: number;
        pickDist: number;
        constructor(name: string, parent: Sprite3D, child: Sprite3D);
    }
    function drawAxis(lines: ILinerender, mat: Matrix4x4, length: number, color?: Color[]): void;
    function drawEulerRange1(liner: ILinerender, mat: Matrix4x4, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number): void;
    function drawEulerRange(liner: ILinerender, mat: Matrix4x4, xmin: number, xmax: number, ymin: number, ymax: number, zmin: number, zmax: number): void;
    function drawCircle(liner: ILinerender, pos: Vector3, dir: Vector3, radius: number, color: Color): void;
    function drawEllipse(liner: ILinerender, pos: Vector3, dir: Vector3, radiusA: number, radiusB: number, color: Color, axisHint?: Vector3): void;
    class Skeleton3D {
        private _visualSp;
        showBone: boolean;
        private _bones;
        private _bounds;
        private _editorCamera;
        enablePick: boolean;
        private _curPickedBone;
        private _lastMouseX;
        private _lastMouseY;
        private _useGizmo;
        owner: Sprite3D;
        get pickedParent(): Sprite3D;
        get pickedChild(): Sprite3D;
        get pickdName(): string;
        showAxis: boolean;
        axisLength: number;
        onAwake(owner: Sprite3D): void;
        visualize(liner: ILinerender): void;
        private _addLine;
        traverseChildren(parent: Sprite3D, f: (parent: Sprite3D, child: Sprite3D) => void): void;
    }
    /**
     * 纹理信息接口
     */
    interface TextureInfo {
        /** 原始纹理对象 */
        originalTexture: Texture;
        /** 原始uv */
        /** 原始texture2d */
        /** 纹理ID */
        textureId: number;
        /** 纹理URL */
        url: string;
        /** 在大图集中的UV坐标 */
        uv: Vector4;
        /** 大纹理索引 */
        largeTextureIndex: number;
        /** 是否已添加到图集 */
        isInAtlas: boolean;
    }
    /**
     * 动态图集管理器配置
     */
    interface DynamicAtlasConfig {
        /** 大纹理尺寸 [宽度, 高度] */
        largeTextureSize: [
            number,
            number
        ];
        /** 大纹理最大数量 */
        maxLargeTextures: number;
        /** 小纹理单元尺寸 */
        textureUnitSize: number;
        /** 纹理扩边尺寸 */
        extendSize: number;
        /** 纹理格式 */
        textureFormat: RenderTargetFormat;
        /** 是否立即执行合并 */
        immediately: boolean;
        /** 是否自动扩展大纹理数量 */
        autoExtend: boolean;
        /** 是否查重 */
        checkDuplicate: boolean;
    }
    /**
     * 动态图集管理器 - 封装LargeTexManager，提供便捷的图集管理功能
     * 支持动态添加、移除纹理，自动管理UV坐标，替换原始纹理对象
     */
    class DynamicAtlasManager {
        private _largeTexManager;
        private _textureMap;
        private _config;
        private _isDestroyed;
        private _waitIds;
        private _waitUpdate;
        private _autoReplace;
        constructor(config?: Partial<DynamicAtlasConfig>, autoReplace?: boolean);
        /**
         * @en Add texture to atlas
         * @param texture texture to add
         * @param scale scale to add
         * @param largeTextureIndex largeTextureIndex to add
         * @returns boolean whether add texture to atlas successfully
         * @zh 添加纹理到图集
         * @param texture 要添加的纹理
         * @param scale 缩放系数，默认1.0
         * @param largeTextureIndex 指定大纹理索引，-1表示自动分配
         * @returns 是否添加成功
         */
        addTexture(texture: Texture, scale?: number, largeTextureIndex?: number): boolean;
        private afterUpdate;
        /**
         * @en Add texture to atlas by url
         * @param url url of texture to add
         * @param scale scale to add
         * @param largeTextureIndex largeTextureIndex to add
         * @returns boolean whether add texture to atlas successfully
         * @zh 通过URL添加纹理到图集
         * @param url 纹理URL
         * @param scale 缩放系数，默认1.0
         * @param largeTextureIndex 指定大纹理索引，-1表示自动分配
         * @returns 是否添加成功
         */
        addTextureByUrl(url: string, scale?: number, largeTextureIndex?: number): boolean;
        /**
         * @en Add textures to atlas
         * @param textures textures to add
         * @param scale scale to add
         * @param largeTextureIndex largeTextureIndex to add
         * @returns number of textures added successfully
         * @zh 批量添加纹理到图集
         * @param textures 纹理数组
         * @param scale 缩放系数，默认1.0
         * @param largeTextureIndex 指定大纹理索引，-1表示自动分配
         * @returns 成功添加的纹理数量
         */
        addTextures(textures: Texture[], scale?: number, largeTextureIndex?: number): number;
        /**
         * @en Add textures to atlas by urls
         * @param urls urls to add
         * @param scale scale to add
         * @param largeTextureIndex largeTextureIndex to add
         * @returns number of textures added successfully
         * @zh 批量通过URL添加纹理到图集
         * @param urls URL数组
         * @param scale 缩放系数，默认1.0
         * @param largeTextureIndex 指定大纹理索引，-1表示自动分配
         * @returns 成功添加的纹理数量
         */
        addTexturesByUrl(urls: string[], scale?: number, largeTextureIndex?: number): number;
        /**
         * @en Remove texture from atlas
         * @param textureId textureId to remove
         * @param largeTextureIndex largeTextureIndex to remove
         * @returns boolean whether remove texture from atlas successfully
         * @zh 从图集中移除纹理
         * @param textureId 纹理ID
         * @param largeTextureIndex 大纹理索引，-1表示从所有大纹理中移除
         * @returns 是否移除成功
         */
        removeTexture(textureId: number, largeTextureIndex?: number): boolean;
        /**
         * @en Remove texture from atlas by url
         * @param url url of texture to remove
         * @param largeTextureIndex largeTextureIndex to remove
         * @returns boolean whether remove texture from atlas successfully
         * @zh 通过URL从图集中移除纹理
         * @param url 纹理URL
         * @param largeTextureIndex 大纹理索引，-1表示从所有大纹理中移除
         * @returns 是否移除成功
         */
        removeTextureByUrl(url: string, largeTextureIndex?: number): boolean;
        /**
         * @en Replace original texture object,使其使用图集中的纹理
         * @param textureId textureId to replace
         * @returns boolean whether replace original texture object successfully
         * @zh 替换原始纹理对象，使其使用图集中的纹理
         * @param textureId 纹理ID
         * @returns 是否替换成功
         */
        replaceOriginalTexture(textureId: number): boolean;
        /**
         * @en Replace original texture objects
         * @param textureIds textureIds to replace
         * @returns number of textures replaced successfully
         * @zh 批量替换原始纹理对象
         * @param textureIds 纹理ID数组，如果为空则替换所有纹理
         * @returns 成功替换的纹理数量
         */
        replaceOriginalTextures(textureIds?: number[]): number;
        /**
         * @en Get texture info
         * @param textureId textureId to get
         * @returns texture info, if not exists return null
         * @zh 获取纹理信息
         * @param textureId 纹理ID
         * @returns 纹理信息，如果不存在返回null
         */
        getTextureInfo(textureId: number): TextureInfo | null;
        /**
         * @en Get texture info by url
         * @param url url of texture to get
         * @returns texture info, if not exists return null
         * @zh 通过URL获取纹理信息
         * @param url 纹理URL
         * @returns 纹理信息，如果不存在返回null
         */
        getTextureInfoByUrl(url: string): TextureInfo | null;
        /**
         * @en Get large texture object
         * @param largeTextureIndex largeTextureIndex to get
         * @returns large texture object
         * @zh 获取大纹理对象
         * @param largeTextureIndex 大纹理索引
         * @returns 大纹理对象
         */
        getLargeTexture(largeTextureIndex: number): import("./LargeTex").LargeTex;
        /**
         * @en Get all large texture objects
         * @returns all large texture objects
         * @zh 获取所有大纹理对象
         * @returns 大纹理对象数组
         */
        getAllLargeTextures(): import("./LargeTex").LargeTex[];
        /**
         * @en Get texture count in atlas
         * @returns texture count in atlas
         * @zh 获取图集中的纹理数量
         * @returns 纹理数量
         */
        getTextureCount(): number;
        /**
         * @en Clear atlas
         * @zh 清空图集，会清理rt注意引用关系
         */
        clear(): void;
        /**
         * @en Destroy manager
         * @zh 销毁管理器
         */
        destroy(): void;
        /**
         * @en Get statistics info
         * @returns statistics info object
         * @zh 获取统计信息
         * @returns 统计信息对象
         */
        getStatistics(): {
            textureCount: number;
            usageRate: number;
            gpuMemoryUsage: number;
            largeTextureCount: number;
            config: DynamicAtlasConfig;
        };
    }
    class LargeTex extends RenderTexture {
        cmdBuffer: CommandBuffer;
        private _limitMipmap;
        private _willDestroyTex;
        private _shader;
        /**
         * @en Whether to immediately execute the merge
         * @zh 是否立即执行合并
         */
        immediately: boolean;
        /**
         * @en Commands
         * @zh 命令
         */
        commands: Set<Command>;
        constructor(width: number, height: number, format?: RenderTargetFormat, depthStencilFormat?: RenderTargetFormat, mipmap?: boolean, limitMipmap?: number, sRGB?: boolean);
        /**
         * 分帧调用的Update函数
         */
        onUpdate(force?: boolean): void;
        /**
         * 设置Mipmap最大层次
         * @param count
         */
        private _setMaxMipmapLevel;
        /**
         * 绘制小贴图到大贴图上，带扩边功能
         * @param x 绘制到大贴图的位置x
         * @param y 绘制到大贴图的位置y
         * @param w 绘制到大贴图的宽度
         * @param h 绘制到大贴图的高度
         * @param expand 扩边像素数
         * @param smallTex 小贴图
         */
        addTexture(x: number, y: number, w: number, h: number, expand: number, smallTex: Texture2D, needRemove: boolean): BlitScreenQuadCMD;
        /**
         * 向大贴图指定的位置和尺寸填充颜色
         * @param x 填充的位置x
         * @param y 填充的位置y
         * @param w 填充的宽度
         * @param h 填充的高度
         * @param color 填充的颜色
         * @param format 贴图格式
         */
        addColor(x: number, y: number, w: number, h: number, color: Vector4, format: number): BlitScreenQuadCMD;
        /**
         * 向大贴图填充颜色
         * @param color 填充的颜色
         * @param format 贴图格式
         */
        fillColor(color: Vector4, format: number): void;
        /**
         * 销毁对象，清理内存
         */
        destroy(): void;
        /**
         * 创建小贴图
         * @param w 宽度
         * @param h 高度
         * @param pixelArray 像素数据
         * @returns 贴图对象
         */
        private _createSmallTex;
        /**
         * 删除小贴图
         */
        private _doDestoryTex;
        /**
         * 绘制小贴图到大贴图上，包含扩边功能
         * @param x 绘制到大贴图的位置x
         * @param y 绘制到大贴图的位置y
         * @param w 绘制到大贴图的宽度
         * @param h 绘制到大贴图的高度
         * @param expand 扩边像素数
         * @param smallTex 小贴图
         */
        private _drawTex;
    }
    class TextureItem {
        /**
         * @en Texture unique ID (0 is empty, 1 is color block, >1 is texture block)
         * @zh 纹理唯一编号（0是空位，1是颜色块，>1是纹理块）
         * */
        id: number;
        /**
         * @en Texture URL (optional)
         * @zh 纹理URL（可选）
         * */
        url?: string;
        /**
         * @en Texture offset parameters
         * @zh 纹理偏移参数
         * */
        x: number;
        /**
         * @en Texture offset parameters
         * @zh 纹理偏移参数
         * */
        y: number;
        /**
         * @en Texture scale parameters
         * @zh 纹理缩放参数
         * */
        w: number;
        /**
         * @en Texture scale parameters
         * @zh 纹理缩放参数
         * */
        h: number;
        /**
         * @en Texture position and size in large texture set (block coordinates, not pixel coordinates)
         * @zh 纹理所处大图合集位置和宽高（块坐标，非像素坐标）
         * */
        pos: Vector4;
        /**
         * @en Large texture index
         * @zh 大纹理序号
         * */
        largeTextureIndex: number;
        /**
         * @en Scale factor
         * @zh 放缩系数
         * */
        scale: number;
        /**
         * @en Whether only a placeholder (needs to be replaced with actual texture)
         * @zh 是否仅是占位（需要用实际纹理替换）
         * */
        token: boolean;
        /**
         * @en Companion texture ID
         * @zh 伴随纹理ID
         * */
        partId: number[];
        /**
         * @en Command
         * @zh 命令
         * */
        cmd?: Command;
        cloneTo(ti: TextureItem): void;
        /**
         * @en Whether it is itself
         * @param iu id or url
         * @zh 是否是自身
         * @param iu id或url
         */
        isSelf(iu: number | string): boolean;
    }
    type TextureOut = {
        texItem?: TextureItem;
        texture?: LargeTex;
        texCode?: number;
    };
    class LargeTexBase {
        /**
         * @en The texture expansion size (can reduce black edges)
         * @zh 纹理扩边量（可减少黑边）
         * */
        EXTEND_SIZE: number;
        /**
         * @en The minimum size of small textures that can be merged, beyond which they will not be merged
         * @zh 参与合并的小纹理最小允许尺寸，超过这个尺寸将不参与合并
         * */
        TEX_SIZE_MIN: number;
        /**
         * @en The maximum allowed size of small textures that can be merged, beyond which they will not be merged
         * @zh 参与合并的小纹理最大允许尺寸，超过这个尺寸将不参与合并
         * */
        TEX_SIZE_MAX: number;
        /**
         * @en Whether to enable MipMap
         * @zh 是否启用MipMap
         * */
        mipMap: boolean;
        /**
         * @en Texture repeat mode
         * @zh 纹理重复模式
         * */
        texWrap: WrapMode;
        /**
         * @en Texture sampling mode
         * @zh 纹理采样模式
         * */
        texMode: FilterMode;
        /**
         * @en Anisotropic value
         * @zh 各向异性值
         * */
        texAnisoLevel: number;
        /**
         * @en Large texture pixel format
         * @zh 大纹理像素格式
         * */
        texFormat: RenderTargetFormat;
        /**
         * @en Background color
         * @zh 背景色
         * */
        backColor: Vector4;
        /**
         * @en Large texture width
         * @zh 大纹理宽度
         * */
        LARGE_TEX_W: number;
        /**
         * @en Large texture height
         * @zh 大纹理高度
         * */
        LARGE_TEX_H: number;
        /**
         * @en Large texture maximum number
         * @zh 大纹理最大数量
         * */
        LARGE_TEX_N: number;
        /**
         * @en Delay time 30ms
         * @zh 延迟时间 30ms
         * */
        delay: number;
        /**
         * @en Total capacity
         * @zh 总容量
         * */
        totalCapacity: number;
        /**
         * @en Used capacity
         * @zh 已经使用的容量
         * */
        usedCapacity: number;
        /**
         * @en Whether sRGB space
         * @zh 是否sRGB空间
         * */
        sRGB: boolean;
        /**
         * @en Whether to check duplicates
         * @zh 是否查重
         * */
        checkDup: boolean;
        /**
         * @en Whether to automatically extend the number of large textures
         * @zh 是否自动扩展大图数量
         * */
        autoExtend: boolean;
        /**
         * @en Whether to immediately execute merging
         * @zh 是否立即执行合并
         * */
        immediately: boolean;
        /** 参与合并的纹理对象数组 */
        protected _texItems: TextureItem[][];
        /** 大纹理中位置占用情况的Map，尺寸为 (LARGE_TEX_SIZE / TEX_SIZE_MIN) ^ 2，默认为0，占用的位置放纹理id */
        protected _texMaps: number[][];
        /** 临时空间占用图 */
        protected _tempMaps: number[];
        /**
         * @en Merged large texture objects
         * @zh 合并的大纹理对象
         * */
        largeTexs: LargeTex[];
        /** 命令缓冲区 */
        protected _cmdBuffer: CommandBuffer;
        /**
         * @en Whether destroyed
         * @zh 是否已销毁
         * */
        destroyed: boolean;
        /**
         * @en GPU memory usage
         * @zh 显存使用量
         * */
        gpuMemory: number;
        id: number;
        /**
         * @en Large texture set name
         * @zh 大图合集名称
         * */
        name: string;
        /**
         * @en Update hook
         * @zh 更新钩子
         * */
        updateHook: () => void;
        static __init__(): void;
        protected static _largeTexSize: number[][];
        /**
         * @en
         * @param largeTexsize large texture size(size must be a power of 2)
         * @param ltn large texture number limit
         * @param tsm small texture unit size (small texture minimum size)
         * @param exs small texture extend size
         * @zh
         * @param largeTexsize 大纹理像素尺寸（尺寸要符合2次幂）
         * @param ltn 大纹理数量上限
         * @param tsm 小纹理单元尺寸（小纹理最小尺寸）
         * @param exs 小纹理扩边尺寸
         */
        constructor(largeTexsize: number[], ltn: number, tsm?: number, exs?: number, texFormat?: RenderTargetFormat);
        /**
         * @en Response update
         * @param force force update
         * @zh 响应更新
         * @param force 强制更新
         */
        onUpdate(force?: boolean): boolean;
        /**
         * @en Adjust the maximum number of large textures
         * @param add add amount
         * @zh 调整大纹理数量上限
         * @param add 增加量
         */
        adjustLtn(add?: number): void;
        /**
         * @en Calculate the GPU memory usage
         * @zh 统计显存使用量
         */
        calculateGpuMemory(): number;
        /**
         * @en Get the current usage rate (percentage)
         * @zh 获取当前使用率（百分比）
         * @returns
         */
        getLoadUsageRate(): number;
        /**
         * 大图指定位置用颜色填充
         * @param largeTextureIndex 大纹理序号
         * @param x 位置x
         * @param y 位置y
         * @param w 宽度
         * @param h 高度
         * @param r 红色成分（0~255）
         * @param g 绿色成分（0~255）
         * @param b 蓝色成分（0~255）
         * @param a Alpha（0~255）
         */
        fillWithColor(largeTextureIndex: number, x: number, y: number, w: number, h: number, r: number, g: number, b: number, a?: number): void;
        /**
         * 根据一批小纹理计算大纹理尺寸和高宽
         * @param tex
         * @param scale
         * @param tsm
         * @param exs
         * @param tp 合并情况
         * @returns [宽，高，利用率]
         */
        static calcFitTexSize(tex: Texture2D[], scale: number, tsm: number, exs: number, tp?: any): number[];
        /**
         * 指定的贴图是否都已经在大图合集上
         * @param ui 贴图id或url
         * @param largeTextureIndex 大纹理序号
         * @returns 是否都已经在大图合集上
         */
        areTextureMerged(ui: number | string, largeTextureIndex?: number): boolean;
        /**
         * 指定的贴图是否都已经在大图合集上
         * @param texs 贴图组
         */
        areAllTexturesIncluded(texs: Texture2D[]): boolean;
        /**
         * 大图合集指定纹理空间是否够用
         * @param tex 小纹理数组
         * @param scale 放缩系数
         * @param largeTextureIndex 大纹理序号
         * @return 够用true，不够用false
         */
        hasEnoughSpace(tex: Texture2D[], scale: number, largeTextureIndex: number): boolean;
        /**
         * 获取具有足够空间的大纹理编号
         * @param tex 小纹理数组
         * @param scale 放缩系数
         * @return 成功大纹理编号，失败-1
         */
        findAvailableLargeTextureCode(tex: Texture2D[], scale: number): number;
        /**
         * 将一组小纹理合并到指定的大纹理中
         * @param texs 小纹理数组
         * @param scale 放缩系数
         * @param largeTextureIndex 大纹理编号
         * @param needRemove 小纹理用完后是否需要删除
         * @return 成功true，失败false，如果失败，所有的小纹理都没有合并进大纹理中
         */
        addTexturesToLargeTexture(texs: Texture2D[], scale: number, largeTextureIndex: number, needRemove?: boolean): boolean;
        /**
         * 添加小纹理
         * @param tex 纹理对象
         * @param scale 放缩系数（0.1~10.0）
         * @param largeTextureIndex 指定大图纹理编号（-1：不指定）
         * @param url 纹理URL
         * @param needRemove 小纹理用完后是否需要删除
         * @returns 成功大纹理编号，失败-1
         */
        addTexture(tex: Texture2D, scale?: number, largeTextureIndex?: number, url?: string, needRemove?: boolean): number;
        /**
         * 添加纹理占位符
         * @param url 纹理资源
         * @param w 纹理宽度
         * @param h 纹理高度
         * @param scale 放缩系数（0.1~10.0）
         * @param largeTextureIndex 指定大图纹理编号（-1：不指定）
         * @returns
         */
        addPlaceholder(url: string, w: number, h: number, scale?: number, largeTextureIndex?: number): number;
        /**
         * 更新小纹理
         * @param tex 纹理对象
         * @param scale 放缩系数（0.1~10.0）
         * @param largeTextureIndex 指定大图纹理编号（-1：不指定）
         * @param url 纹理URL
         * @param needRemove 小纹理用完后是否需要删除
         * @returns 成功大纹理编号，失败-1
         */
        updateTexture(tex: Texture2D, scale?: number, largeTextureIndex?: number, url?: string, needRemove?: boolean): number;
        /**
         * 获取纹理和UV
         * @param iu 小纹理id或url
         * @param largeTextureIndex 大纹理编号
         * @returns 纹理对象
         */
        getTexture(iu: number | string, largeTextureIndex?: number): TextureOut;
        /**
         * 获取纹理和UV
         * @param tex 纹理对象
         * @param largeTextureIndex 大纹理编号
         * @returns 纹理对象
         */
        getTextureByRef(tex: Texture2D, largeTextureIndex?: number): TextureOut;
        /**
         * 根据大图纹理序号获取大纹理
         * @param largeTextureIndex 大纹理编号
         * @returns 大纹理或null
         */
        getLargeTex(largeTextureIndex: number): LargeTex;
        /**
         * 删除小纹理
         * @param iu 小纹理id或url
         * @param largeTextureIndex 大纹理编号(-1: 不指定)
         */
        removeTexture(iu: number | string, largeTextureIndex?: number): void;
        /**
         * 清空，重用对象
         */
        clear(): void;
        /**
         * 销毁对象，清理内存
         * @param keepRes
         */
        destroy(keepRes?: boolean): void;
        /**
         * 查找小纹理参数/占位
         * @param iu 小纹理id或url
         * @param largeTextureIndex 大纹理编号（-1：不指定）
         * @returns 小纹理信息
         */
        protected _findTexture(iu: number | string, largeTextureIndex?: number): TextureItem;
        /**
         * 清除所有纹理
         */
        removeAllTextures(): void;
        /**
         * 创建大纹理
         * @param largeTextureIndex 大纹理编号
         * @param sRGB 大图是否sRGB格式
         */
        createLargeTex(largeTextureIndex: number, sRGB?: boolean): void;
        /**
         * 计算纹理分块尺寸
         * @param tw 纹理宽度
         * @param th 纹理高度
         * @param scale 放缩系数
         * @param tsm 最小尺寸
         * @param exs 边缘扩展
         * @returns [宽，高，水平块数，垂直块数]
         */
        static calcTexSize(tw: number, th: number, scale: number, tsm: number, exs: number): number[];
        /**
         * 添加小纹理，合成大纹理
         * @param tex 小纹理
         * @param scale 放缩系数
         * @param largeTextureIndex 指定大纹理序号（-1：不指定）
         * @param url 纹理URL
         * @param needRemove 小纹理用完后是否需要删除
         * @returns
         */
        protected _addTexture(tex: Texture2D, scale: number, largeTextureIndex?: number, url?: string, needRemove?: boolean): TextureItem;
        /**
         * 添加纹理占位符
         * @param url 纹理资源
         * @param w 纹理宽度
         * @param h 纹理高度
         * @param scale 放缩系数（0.1~10.0）
         * @param largeTextureIndex 指定大图纹理编号（-1：不指定）
         * @returns 纹理占位对象
         */
        protected _addPlaceholder(url: string, w: number, h: number, scale?: number, largeTextureIndex?: number): TextureItem;
        /**
         * 更新小纹理，合成大纹理
         * @param tex 小纹理
         * @param scale 放缩系数
         * @param largeTextureIndex 指定大纹理序号（-1：不指定）
         * @param url 纹理URL
         * @param needRemove 小纹理用完后是否需要删除
         * @returns
         */
        protected _updateTexture(tex: Texture2D, scale: number, largeTextureIndex?: number, url?: string, needRemove?: boolean): TextureItem;
        /**
         * 查询并占据单张纹理的空间（指定Map）
         * @param x 纹理的尺寸x方向
         * @param y 纹理的尺寸y方向
         * @param texMap 空间占用图
         * @returns 成功true，失败false
         */
        protected _takeRoomInMap(x: number, y: number, texMap: number[]): boolean;
        /**
         * 查询单张纹理的空间（指定Map）
         * @param x 纹理的尺寸x方向
         * @param y 纹理的尺寸y方向
         * @param texMap 空间占用图
         * @returns 空间位置[垂值位置，水平位置]
         */
        protected _peekRoomInMap(x: number, y: number, texMap: number[]): number[];
        /**
         * 查询纹理的空间
         * @param x 纹理的尺寸x方向
         * @param y 纹理的尺寸y方向
         * @param largeTextureIndex 指定大图编号（-1：不指定）
         * @returns [大图编号，垂直位置，水平位置]
         */
        protected _findRoom(x: number, y: number, largeTextureIndex?: number): number[];
        /**
         * 将纹理加入（可排序，面积大的排前面）
         * @param ti 纹理参数
         * @param sort 是否排序
         */
        protected _addToTextureItem(ti: TextureItem, sort?: boolean): void;
    }
    /**
     * @en Large texture manager class (general)
     * @zh 大图合集类（通用）
     * */
    class LargeTexManager extends LargeTexBase {
        COLOR_ITEM_SIZE: number;
        static __LargeTexManagerAll: LargeTexManager[];
        private _curColor;
        private _curColorUV;
        private _curColorMap;
        private _largeTexCode;
        private _reserve;
        active: boolean;
        /**
         * 分帧更新大图
         * @param force 强制更新
         */
        static __updateAll(force?: boolean): void;
        /**
         * 构造函数
         * @param lts 大纹理像素尺寸
         * @param ltn 大纹理数量上限
         * @param tsm 小纹理单元尺寸
         * @param exs 小纹理扩边尺寸
         * @param qds 大纹理观察尺寸
         */
        constructor(lts: number[], ltn: number, tsm?: number, exs?: number, texFormat?: RenderTargetFormat);
        /**
         * 添加空白边框纹理
         * @param largeTextureIndex 大纹理序号
         */
        addDummySideTexture(largeTextureIndex?: number): void;
        /**
         * 添加颜色
         * @param color 颜色
         * @param largeTextureIndex 大图纹理编号（-1:不指定）
         * @returns 成功大纹理编号，失败-1
         */
        addColor(color: Vector4, largeTextureIndex?: number): number;
        /**
         * 获取颜色所在的大纹理
         * @param color 颜色
         * @param uv 纹理坐标（不输入表示不获取）
         * @param largeTextureIndex 大纹理编号（-1:不指定）
         * @returns 大纹理或null
         */
        getColor(color: Vector4, uv?: Vector4, largeTextureIndex?: number): LargeTex;
        /**
         * 获得大图合集是否有保留空间
         * @returns
         */
        getReserve(): boolean;
        /**
         * 设置大图合集是否要保留空间
         * @param rv 是否保留
         */
        setReserve(rv: boolean): void;
        /**
         * 销毁对象，清理内存
         * @param keepRes
         */
        destroy(keepRes?: boolean): void;
        /**
         * 查找颜色
         * @param r 颜色值
         * @param g
         * @param b
         * @param a
         * @param largeTextureIndex 大纹理编号
         * @returns
         */
        private _findColor;
        /**
         * 清除所有纹理
         */
        removeAllTextures(): void;
        /**
         * 将颜色加入，颜色写入大纹理中
         * @param r 颜色值
         * @param g
         * @param b
         * @param a
         * @param largeTextureIndex 大纹理编号
         * @returns
         */
        private _addColor;
        /**
         * 查询纹理的空间（指定Map）
         * @param x 纹理的尺寸x方向
         * @param y 纹理的尺寸y方向
         * @param texMap 空间占用图
         * @returns 空间位置[垂值位置，水平位置]
         */
        protected _peekRoomInMap(x: number, y: number, texMap: number[]): number[];
        /**
         * 获取大图的Base64编码
         * @returns
         */
        getBase64(): Promise<string[]>;
    }
    class TextureMergeShaderInit {
        /** @internal */
        static _sdNotChange: ShaderData;
        /** @internal */
        static _sdGammaToLinear: ShaderData;
        /** @internal */
        static _sdLinearToGamma: ShaderData;
        private static LINEAR_TO_GAMMA;
        private static GAMMA_TO_LINEAR;
        static inited: boolean;
        static init(): void;
    }
    /**
     * @private
     * @en CommandEncoder Shader variable collection
     * @zh CommandEncoder Shader变量集合
     */
    class CommandEncoder {
        /**
         * @internal
         * @en Shader variable list
         * @zh Shader变量列表
         */
        _idata: ShaderVariable[];
        /**
         * @en Constructor method, initialize CommandEncoder object
         * @zh 构造方法，初始化CommandEncoder对象
         */
        constructor();
        /**
         * @internal
         * @en Get the Shader variable list
         * @zh 获取ShaderVariable数组
         */
        getArrayData(): ShaderVariable[];
        /**
         * @internal
         * @en Get the count of ShaderVariables in the array
         * @zh 获取ShaderVariable数组的数量
         */
        getCount(): number;
        /**
         * @internal
         * @en Add one ShaderVariable
         * @param variable The ShaderVariable to be added
         * @zh 添加一个ShaderVariable
         * @param variable 要添加的ShaderVariable
         */
        addShaderUniform(variable: ShaderVariable): void;
    }
    /**
     * @en Package GL commands
     * @zh 封装GL命令
     */
    class LayaGL {
        static textureContext: ITextureContext;
        static renderEngine: IRenderEngine;
        static render2DRenderPassFactory: I2DRenderPassFactory;
        static renderDeviceFactory: IRenderDeviceFactory;
        static unitRenderModuleDataFactory: IUnitRenderModuleDataFactory;
        static statAgent: IStaticsContext;
    }
    enum StatElement {
        /**
         * fps
         */
        CT_FPS = 0,
        /**
         * frame time
         */
        T_Frame_Time = 1,
        /**
         * render 3D time
         */
        T_AllRender3D = 2,
        /**
         * render 3D Depth Normal/Depth time
         */
        T_DepthPass = 3,
        /**
         * render shadow pass time
         */
        T_ShadowPass = 4,
        /**
         * main render pass time
         */
        T_3DMainPass = 5,
        /**
         * 3D context PreRender
         */
        T_3DContextPre = 6,
        /**
         * 3D Context render
         */
        T_3DContextRender = 7,
        /**
         * main render opaque time
         */
        T_3DMainPass_Opaque = 8,
        /**
         * main render trans time
         */
        T_3DMainPass_Trans = 9,
        /**
         * Batch 3D module Time
         */
        T_3DBatchTime = 10,
        /**
         * 3D main cull time
         */
        T_CullMain = 11,
        /**
         * 3D shadow cull time
         */
        T_CullShadow = 12,
        /**
         * render postprocess time
         */
        T_Render_PostProcess = 13,
        /**
         * render 2D time
         */
        T_AllRender2D = 14,
        /**
         * render 2D Pass Time
         */
        T_2DPass = 15,
        /**
         * 2D context PreRender
         */
        T_2DContextPre = 16,
        /**
         * 2D Context render
         */
        T_2DContextRender = 17,
        /**
         * component update time
         */
        T_ScriptUpdateTime = 18,
        /**
         * component Late update time
         */
        T_ScriptLateUpdateTime = 19,
        /**
         * 非透明物体DrawCall
         */
        CT_OpaqueDrawCall = 20,
        /**
         * 透明物体的DrawCall
         */
        CT_TransDrawCall = 21,
        /**
         * 深度图/法线深度图的DrawCall
         */
        CT_DepthCastDrawCall = 22,
        /**
         * 阴影DrawCall
         */
        CT_ShadowDrawCall = 23,
        /**
         * 2DDrawCall
         */
        CT_2DDrawCall = 24,
        /**
         * 3DDrawCall
         */
        CT_3DDrawCall = 25,
        /**
         * drawCall
         */
        CT_DrawCall = 26,
        CT_IndirectDrawCall = 27,
        /**
         * instance Draw Call
         */
        CT_Instancing_DrawCall = 28,
        M_GPUBuffer = 29,
        C_GPUBuffer = 30,
        M_VertexBuffer = 31,
        C_VertexBuffer = 32,
        M_IndexBuffer = 33,
        C_IndexBuffer = 34,
        M_UBOBuffer = 35,
        C_UBOBuffer = 36,
        M_DeviceBuffer = 37,
        C_DeviceBuffer = 38,
        M_AllTexture = 39,
        C_AllTexture = 40,
        M_Texture2D = 41,
        C_Texture2D = 42,
        M_TextureCube = 43,
        C_TextureCube = 44,
        M_Texture3D = 45,
        C_Texture3D = 46,
        M_Texture2DArray = 47,
        C_Texture2DArray = 48,
        M_RenderTexture = 49,
        C_RenderTexture = 50,
        M_GPUMemory = 51,
        CT_ShaderChange = 52,
        CT_Triangle = 53,
        CT_BufferUploadCount = 54,
        CT_GeometryBufferUploadCount = 55,
        CT_UBOBufferUploadCount = 56,
        CT_UBOBufferUploadMemory = 57,
        C_Sprite2DCount = 58,
        C_Sprite3DCount = 59,
        C_BaseRenderCount = 60,
        C_MeshRenderCount = 61,
        C_SkinnedMeshRenderCount = 62,
        C_ShurikenParticleRenderCount = 63,
        T_AnimatorUpdate = 64,
        T_SkinBoneUpdate = 65,
        T_ShurikenUpdate = 66,
        T_Physics_Simulation = 67,
        T_Physics_UpdateNode = 68,
        T_PhysicsEvent = 69,
        C_PhysicsEventCount = 70,
        T_PhysicsCollider = 71,
        T_PhysicsTrigger = 72,
        T_PhysicsColliderEnter = 73,
        T_PhysicsColliderExit = 74,
        T_PhysicsColliderStay = 75,
        T_PhysicsTriggerEnter = 76,
        T_PhysicsTriggerExit = 77,
        T_PhysicsTriggerStay = 78,
        C_PhysicaDynamicRigidBody = 79,
        C_PhysicaStaticRigidBody = 80,
        C_PhysicaKinematicRigidBody = 81,
        C_PhysicaCharacterController = 82,
        C_PhysicsJoint = 83,
        /**
         * 资源下载 + 解析时间。
         */
        T_LoadResourceTime = 84,
        /**
         * 加载次数
         */
        C_LoadResourceCount = 85,
        /**
         * 请求次数
         */
        C_LoadRequestCount = 86,
        /**
         *  网络下载时间
         */
        T_LoadRequestTime = 87,
        StatEnd = 88
    }
    interface IStaticsContext {
        /**
         * 记录数据统计数据
         * @param element
         * @param data
         */
        recordCountData(element: StatElement, data: number): void;
        /**
         * 帧数据 会累计输出平均值（比如drawCall）
         * @param element
         * @param data
         */
        recordCTData(element: StatElement, data: number): void;
        /**
         * 记录时间统计数据
         * @param element
         * @param data
         */
        recordTimeData(element: StatElement, data: number): void;
        /**
         * 记录内存统计数据
         */
        recordMemoryData(element: StatElement, data: number): void;
        /**
         * 获取统计数据
         * @param element
         * @returns
         */
        getElementData(element: StatElement): number;
        /**
         * 开始帧逻辑
         * @param timestamp
         */
        startFrameLogic(timestamp: number): void;
        /**
         * 结束帧逻辑
         * @param timestamp
         */
        endFrameLogic(timestamp: number): void;
        /**
         * 中途切换统计信息 将当前统计信息复制到另一个统计信息中
         * @param context
         */
        cloneTo(context: IStaticsContext): void;
    }
    class DefaultStaticsContext implements IStaticsContext {
        protected _tQueue: Set<StatElement>;
        protected _ctQueue: Set<StatElement>;
        protected _statArray: Float32Array;
        protected _timeArray: Float32Array;
        protected _cacheCount: number;
        protected _cacheTime: number;
        constructor();
        protected _createStatBuffer(): void;
        cloneTo(context: IStaticsContext): void;
        recordCountData(element: StatElement, data: number): void;
        recordTimeData(element: StatElement, data: number): void;
        recordCTData(element: StatElement, data: number): void;
        recordMemoryData(element: StatElement, data: number): void;
        getElementData(element: StatElement): number;
        startFrameLogic(): void;
        endFrameLogic(timestamp: number): void;
    }
    /**
     * @internal
     * @en `HierarchyParserV2` is a class used for parsing hierarchy data in a 3D scene.
     * @zh `HierarchyParserV2` 类用于解析3D场景中的层级数据。
     */
    class HierarchyParserV2 {
        /**
         * @internal
         * @param nodeData 创建数据
         * @param spriteMap 精灵集合
         * @param outBatchSprites 渲染精灵集合
         */
        private static _createSprite3DInstance;
        /**
         * @internal
         * @param nodeData
         * @param spriteMap
         * @param interactMap
         */
        private static _createComponentInstance;
        /**
         * @internal
         */
        static _createNodeByJson02(nodeData: any, outBatchSprites: RenderableSprite3D[]): Node;
        /**
         * @internal
         */
        static _createInteractInstance(interatMap: any, spriteMap: any): void;
        /**
         * @internal
         * @en Parses the provided data into a 3D scene hierarchy.
         * @param data The data object containing the hierarchy information and version.
         * @returns A `Sprite3D` or `Scene3D` object representing the parsed hierarchy.
         * @zh 将提供的数据解析为3D场景层级。
         * @param data 包含层级信息和版本的数据对象。
         * @returns 解析后的层级的Sprite3D或Scene3D对象
         */
        static parse(data: any): Scene3D | Sprite3D;
        /**
         * @internal
         */
        static _createNodeByJson(nodeData: any, outBatchSprites: RenderableSprite3D[]): Node;
        /**
         * @en Collects all the resource links required for loading from the given data object.
         * @param data The data object containing hierarchy and resource information.
         * @param basePath The base path to resolve relative URLs.
         * @returns An array of resource URLs or `ILoadURL` objects.
         * @zh 从给定的数据对象中收集所有需要加载的资源链接。
         * @param data 包含层级和资源信息的数据对象。
         * @param basePath 用于解析相对URL的基路径。
         * @returns 资源URL或 `ILoadURL` 对象的数组。
         */
        static collectResourceLinks(data: any, basePath: string): (string | ILoadURL)[];
    }
    /**
     * @private 场景辅助类
     */
    class LegacyUIParser {
        /**@private */
        private static _funMap;
        /**@private */
        private static _parseWatchData;
        /**@private */
        private static _parseKeyWord;
        /**@internal */
        static _sheet: any;
        static parse(data: any, options: any): Sprite;
        /**
         * @private 根据字符串，返回函数表达式
         */
        static getBindFun(value: string): Function;
        /**
         * @private
         * 通过视图数据创建视图。
         * @param uiView 视图数据信息。
         */
        static createByData(root: Sprite, uiView: any): Sprite;
        static createInitTool(): InitTool;
        /**
         * 根据UI数据实例化组件。
         * @param uiView UI数据。
         * @param comp 组件本体，如果为空，会新创建一个。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         * @return 一个 Component 对象。
         */
        static createComp(uiView: any, comp?: Sprite, view?: Sprite, dataMap?: any[], initTool?: InitTool): any;
        /**
         * @private
         * 设置组件的属性值。
         * @param comp 组件实例。
         * @param prop 属性名称。
         * @param value 属性值。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         */
        private static setCompValue;
        /**
         * @private
         * 通过组建UI数据，获取组件实例。
         * @param json UI数据。
         * @return Component 对象。
         */
        static getCompInstance(json: any): any;
        static collectResourceLinks(uiView: any): string[];
        /**
         * 根据指定的 json 数据创建节点对象。
         * 比如:
         * {
         * 	"type":"Sprite",
         * 	"props":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"customProps":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"child":[
         * 		{
         * 			"type":"Text",
         * 			"props":{
         * 				"text":"this is a test",
         * 				"var":"label",
         * 				"rumtime":""
         * 			}
         * 		}
         * 	]
         * }
         * @param json json字符串或者Object对象。
         * @param node node节点，如果为空，则新创建一个。
         * @param root 根节点，用来设置var定义。
         * @return	生成的节点。
         */
        static createByJson(json: any, node?: any, root?: Node, customHandler?: Handler, instanceHandler?: Handler): any;
        /**
         * @internal
         * 将graphic对象添加到Sprite上
         * @param graphicO graphic对象描述
         */
        static _addGraphicsToSprite(graphicO: any, sprite: Sprite): void;
        /**
         * @internal
         * 将graphic绘图指令添加到sprite上
         * @param graphicO 绘图指令描述
         */
        static _addGraphicToSprite(graphicO: any, sprite: Sprite, isChild?: boolean): void;
        /**
         * @private
         */
        private static _getGraphicsFromSprite;
        /**
         * @private
         */
        private static _getTransformData;
        /**
         * @private
         */
        private static _addGraphicToGraphics;
        /**
         * @private
         */
        private static _adptLineData;
        /**
         * @private
         */
        private static _adptTextureData;
        /**
         * @private
         */
        private static _adptLinesData;
        /**
         * @internal
         */
        static _isDrawType(type: string): boolean;
        /**
         * @private
         */
        private static _getParams;
        /**@private */
        private static DrawTypeDic;
        /**@private */
        private static _temParam;
        /**@private */
        private static _tM;
        /**@private */
        private static _alpha;
        /**
         * @internal
         */
        static _getPointListByStr(str: string): any[];
        /**
         * @private
         */
        private static _getObjVar;
    }
    class InitTool {
        /**@private */
        private _nodeRefList;
        /**@private */
        private _initList;
        /**@internal */
        _idMap: {
            [key: string]: Sprite;
        };
        reset(): void;
        recover(): void;
        static create(): InitTool;
        /**@private */
        addNodeRef(node: any, prop: string, referStr: string): void;
        /**@private */
        setNodeRef(): void;
        /**@private */
        getReferData(referStr: string): any;
        /**@private */
        addInitItem(item: any): void;
        /**@private */
        doInits(): void;
        /**@private */
        finish(): void;
    }
    /**
     * @deprecated
     * @en Each layer of the map is rendered in chunks. This class represents the chunk data of the map.
     * @zh 地图的每层都会分块渲染处理，本类就是地图的块数据。
     */
    class GridSprite extends Sprite {
        /**
         * @en The coordinate relative to the X-axis of the map.
         * @zh 相对于地图X轴的坐标。
         */
        relativeX: number;
        /**
         * @en The coordinate relative to the Y-axis of the map.
         * @zh 相对于地图Y轴的坐标。
         */
        relativeY: number;
        /**
         * @en Indicates whether the object is an independent entity within the object layer.
         * @zh 是否用于对象层的独立物件。
         */
        isAloneObject: boolean;
        /**
         * @en Indicates whether there is an animation in the current GRID.
         * @zh 当前GRID中是否有动画。
         */
        isHaveAnimation: boolean;
        /**
         * @en The array containing animations within the current GRID.
         * @zh 当前GRID包含的动画数组。
         */
        aniSpriteArray: any[];
        /**
         * @en The number of TILEs (including animations) included in the current GRID.
         * @zh 当前GRID包含多少个TILE(包含动画)。
         */
        drawImageNum: number;
        /**
         * @en Reference to the current map object.
         * @zh 当前地图对象的引用。
         */
        private _map;
        /**
         * @en Initialize the data with necessary parameters for clipping and confirming the type of this object.
         * @param map The reference to the map, used for some clipping calculations.
         * @param objectKey If true, indicates that the current GridSprite is an active object that can be controlled; if false, it is a block of the map layer.
         * @zh 传入必要的参数，用于裁剪，跟确认此对象类型。
         * @param map 把地图的引用传进来，参与一些裁剪计算。
         * @param objectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块。
         */
        initData(map: TiledMap, objectKey?: boolean): void;
        /**
         * @en Bind an animation object to the current GridSprite.
         * @param sprite The display object of the animation.
         * @zh 把一个动画对象绑定到当前GridSprite。
         * @param sprite 动画的显示对象。
         */
        addAniSprite(sprite: TileAniSprite): void;
        /**
         * @en Display the current GridSprite and show all animations on it.
         * @zh 显示当前GridSprite，并把上面的动画全部显示。
         */
        show(): void;
        /**
         * @en Hide the current GridSprite and remove all animations bound to it.
         * @zh 隐藏当前GridSprite，并把上面绑定的动画全部移除。
         */
        hide(): void;
        /**
         * @en Refresh the position coordinates. Call this function manually to refresh when you control the movement of a GridSprite.
         * @zh 当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新坐标。
         */
        updatePos(): void;
        /**
         * @en Reset all properties of the current object.
         * @zh 重置当前对象的所有属性。
         */
        clearAll(): void;
    }
    /**
     * @internal
     */
    class IMap {
        static TiledMap: typeof TiledMap;
    }
    /**
     * @deprecated
     * @en The `MapLayer` class represents layer within a map that supports multi-layer rendering, such as terrain, vegetation, and building layers. This class is a hierarchical class
     * @zh `MapLayer` 类代表地图中的层级，支持多层渲染，例如地表层、植被层、建筑层等。本类就是层级类。
     */
    class MapLayer extends Sprite {
        private _map;
        /**
         * @internal
         * @en Internal data associated with the map layer.
         * @zh 与地图层相关联的内部数据。
         */
        _mapData: any[];
        private _tileWidthHalf;
        private _tileHeightHalf;
        private _mapWidthHalf;
        private _mapHeightHalf;
        /**
         * @internal
         * @en Array of grid sprites that make up the layer.
         * @zh 构成层的网格精灵数组。
         */
        _gridSpriteArray: any[];
        private _objDic;
        private _dataDic;
        private _tempMapPos;
        private _properties;
        /**
         * @en The target layer that this layer is merged with.
         * @zh 被合并到的目标层。
         */
        tarLayer: MapLayer;
        /**
         * @en The name of the current layer.
         * @zh 当前层的名称。
         */
        layerName: string;
        /**
         * @en Parse the LAYER data and initialize some data.
         * @param layerData Reference to the layer data within the map data.
         * @param map Reference to the map.
         * @zh 解析LAYER数据，以及初始化一些数据。
         * @param layerData 地图数据中，layer数据的引用。
         * @param map 地图的引用。
         */
        init(layerData: any, map: TiledMap): void;
        /******************************************对外接口*********************************************/
        /**
         * @en Retrieve a control object by name; returns null if not found.
         * @param objName The name of the object to retrieve.
         * @zh 通过名字获取控制对象，如果找不到返回null。
         * @param objName 所要获取对象的名字。。
         */
        getObjectByName(objName: string): GridSprite;
        /**
         * @en Retrieve data by name; returns null if not found.
         * @param objName The name of the object whose data is to be retrieved.
         * @zh 通过名字获取数据，如果找不到返回null。
         * @param objName 所要获取数据的对象名。
         */
        getObjectDataByName(objName: string): any;
        /**
         * @en Get the custom properties of the map layer.
         * @param name The property name.
         * @zh 获取地图层的自定义属性。
         * @param name 属性名。
         */
        getLayerProperties(name: string): any;
        /**
         * @en Get the data of the specified tile.
         * @param tileX The X coordinate of the tile.
         * @param tileY The Y coordinate of the tile.
         * @returns The data of the tile or 0 if out of bounds.
         * @zh 获取指定格子的数据。
         * @param tileX 格子坐标X
         * @param tileY 格子坐标Y
         * @returns 格子数据，如果越界，返回0
         */
        getTileData(tileX: number, tileY: number): number;
        /**
         * @en Convert map coordinates to screen coordinates.
         * @param tileX The X coordinate on the map grid.
         * @param tileY The Y coordinate on the map grid.
         * @param screenPos The Point object to store the calculated screen coordinates.
         * @zh 通过地图坐标得到屏幕坐标。
         * @param tileX 格子坐标X
         * @param tileY 格子坐标Y
         * @param screenPos 把计算好的屏幕坐标数据，放到此对象中
         */
        getScreenPositionByTilePos(tileX: number, tileY: number, screenPos?: Point): void;
        /**
         * @en Retrieve the data of the tile selected by screen coordinates.
         * @param screenX The x-coordinate on the screen.
         * @param screenY The y-coordinate on the screen.
         * @zh 通过屏幕坐标来获取选中格子的数据。
         * @param screenX 屏幕坐标x
         * @param screenY 屏幕坐标y
         */
        getTileDataByScreenPos(screenX: number, screenY: number): number;
        /**
         * @en Get the index of the tile selected by screen coordinates.
         * @param screenX The x-coordinate on the screen.
         * @param screenY The y-coordinate on the screen.
         * @param result The Point object to store the calculated tile coordinates.
         * @zh 通过屏幕坐标来获取选中格子的索引。
         * @param screenX 屏幕坐标x
         * @param screenY 屏幕坐标y
         * @param result 计算好的格子坐标，放到此对象中
         */
        getTilePositionByScreenPos(screenX: number, screenY: number, result?: Point): boolean;
        /***********************************************************************************************/
        /**
         * @en Retrieve a GridSprite based on grid indices.
         * @param gridX The X-axis index of the current Grid.
         * @param gridY The Y-axis index of the current Grid.
         * @returns A GridSprite object.
         * @zh 根据网格的X轴和Y轴索引获取一个GridSprite对象。
         * @param gridX 当前网格的X轴索引
         * @param gridY 当前网格的Y轴索引
         * @returns  一个GridSprite对象
         */
        getDrawSprite(gridX: number, gridY: number): GridSprite;
        /**
         * @en Update the coordinates of the blocks in this layer. The purpose of manual refresh is to keep the width and height of the hierarchy to a minimum and accelerate rendering.
         * @zh 更新此层中块的坐标。手动刷新的目的是，保持层级的宽和高保持最小，加快渲染。
         */
        updateGridPos(): void;
        /**
         * @private
         * @en Draw a tile onto a specified display object.
         * @param gridSprite The target display object to draw on.
         * @param tileX The X-coordinate of the tile.
         * @param tileY The Y-coordinate of the tile.
         * @returns A boolean indicating whether the tile was successfully drawn.
         * @zh 把tile画到指定的显示对象上。
         * @param gridSprite 要绘制的目标显示对象
         * @param tileX 格子的X轴坐标
         * @param tileY 格子的Y轴坐标
         * @returns 一个布尔值，表示是否成功绘制了tile
         */
        drawTileTexture(gridSprite: GridSprite, tileX: number, tileY: number): boolean;
        /**
         * @private
         * @en Clear all properties and references of the current object to free up resources.
         * @zh 清理当前对象，释放资源。
         */
        clearAll(): void;
    }
    /**
     * @deprecated
     * @en The `TileAniSprite` class represents an animation display object within a `TiledMap`. An animation set (represented by `TileTexSet`) can be associated with multiple animation display objects (`TileAniSprite`).
     * @zh `TileAniSprite` 类是 `TiledMap` 的动画显示对象。一个动画集合（由 `TileTexSet` 表示）可以绑定多个动画显示对象（`TileAniSprite`）。
     */
    class TileAniSprite extends Sprite {
        /**
         * @en Reference to the animation set.
         * @zh 动画的引用。
         */
        private _tileTextureSet;
        /**
         * @en The unique name of the current animation display object.
         * @zh 当前动画显示对象的唯一名称。
         */
        private _aniName;
        /**
         * @en Set the name of the current display object and which animation set it belongs to.
         * @param aniName The unique name of the current animation display object.
         * @param tileTextureSet The animation set that the current display object belongs to.
         * @zh 确定当前显示对象的名称以及属于哪个动画。
         * @param aniName	当前动画显示对象的名字，名字唯一
         * @param tileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）
         */
        setTileTextureSet(aniName: string, tileTextureSet: TileTexSet): void;
        /**
         * @en Add the current animation to the corresponding animation refresh list.
         * @zh 把当前动画加入到对应的动画刷新列表中。
         */
        show(): void;
        /**
         * @en Remove the current animation from the corresponding animation refresh list.
         * @zh 把当前动画从对应的动画刷新列表中移除。
         */
        hide(): void;
        /**
         * @en Clear all properties and references of the current object to free up resources.
         * @zh 清理当前对象的所有属性和引用，释放资源。
         */
        clearAll(): void;
    }
    /**
     * @deprecated
     * @en The `TiledMap` class is the core of the entire map system.
     * - The map is divided into layers (e.g., terrain layer, vegetation layer, building layer), and each layer is further divided into grid sprites for display object management, showing only the areas within the viewport. Each grid sprite contains an N*N grid of tiles, which can be either animated tiles or image tiles.
     * @zh `TiledMap` 类是整个地图系统的核心。
     * - 地图以层级划分（例如：地表层、植被层、建筑层），
     * - 每层进一步划分为网格精灵来管理显示对象，只显示视口区域内的部分。
     * - 每个网格精灵包含 N*N 个格子，格子类型分为动画格子和图片格子两种。
     */
    class TiledMap {
        /**
         * @en Orthogonal map.
         * @zh 四边形地图。
         */
        static ORIENTATION_ORTHOGONAL: string;
        /**
         * @en Diamond map.
         * @zh 菱形地图。
         */
        static ORIENTATION_ISOMETRIC: string;
        /**
         * @en 45 degree interleaved map.
         * @zh 45度交错地图。
         */
        static ORIENTATION_STAGGERED: string;
        /**
         * @en Hexagonal map.
         * @zh 六边形地图。
         */
        static ORIENTATION_HEXAGONAL: string;
        /**
         * @en The map grid is rendered starting from the top left corner.
         * @zh 地图格子从左上角开始渲染。
         */
        static RENDERORDER_RIGHTDOWN: string;
        /**
         * @en The map grid is rendered starting from the bottom left corner.
         * @zh 地图格子从左下角开始渲染。
         */
        static RENDERORDER_RIGHTUP: string;
        /**
         * @en The map grid is rendered starting from the top right corner.
         * @zh 地图格子从右上角开始渲染。
         */
        static RENDERORDER_LEFTDOWN: string;
        /**
         * @en The map grid is rendered starting from the bottom right corner.
         * @zh 地图格子从右下角开始渲染。
         */
        static RENDERORDER_LEFTUP: string;
        /**
         * @en The internal JSON data used by the map.
         * @zh 地图使用的内部JSON数据。
         */
        private _jsonData;
        /**
         * @en An array to store all the sub-texture data used in the map.
         * @zh 存放地图中用到的所有子纹理数据的数组。
         */
        private _tileTexSetArr;
        /**
         * @en The main texture data, primarily used when releasing texture resources.
         * @zh 主纹理数据，主要在释放纹理资源时使用。
         */
        private _texArray;
        private _x;
        private _y;
        private _width;
        private _height;
        private _mapW;
        private _mapH;
        private _mapTileW;
        private _mapTileH;
        private _rect;
        private _paddingRect;
        private _mapSprite;
        private _layerArray;
        private _renderLayerArray;
        private _gridArray;
        private _showGridKey;
        private _totalGridNum;
        private _gridW;
        private _gridH;
        private _gridWidth;
        private _gridHeight;
        private _tileSetArray;
        private _currTileSet;
        private _completeHandler;
        private _mapRect;
        private _mapLastRect;
        private _index;
        private _animationDic;
        private _properties;
        private _tileProperties;
        private _tileProperties2;
        private _orientation;
        private _renderOrder;
        private _colorArray;
        private _scale;
        private _pivotScaleX;
        private _pivotScaleY;
        private _centerX;
        private _centerY;
        /**@internal */
        _viewPortX: number;
        /**@internal */
        _viewPortY: number;
        private _viewPortWidth;
        private _viewPortHeight;
        private _enableLinear;
        private _resPath;
        private _pathArray;
        private _limitRange;
        /**
         * @en Whether to automatically cache tiles that do not have animations.
         * @zh 是否自动缓存没有动画的地块。
         */
        autoCache: boolean;
        /**
         * @en The type of automatic caching. For larger maps, "normal" is recommended.
         * @zh 自动缓存类型，地图较大时建议使用 "normal"。
         */
        autoCacheType: string;
        /**
         * @en Whether to enable layer merging. When layer merging is enabled, you can add a "layer" property in the layer attributes. At runtime, layers with the same "layer" attribute will be merged to improve performance.
         * @zh 是否合并图层。开启合并图层时，图层属性内可添加 "layer" 属性，运行时将会将相邻的 "layer" 属性相同的图层进行合并以提高性能。
         */
        enableMergeLayer: boolean;
        /**
         * @en Whether to remove covered tiles. Tiles can have a "type" property; a "type" other than 0 indicates opacity. Tiles that are covered by opaque tiles will be culled to improve performance.
         * @zh 是否移除被覆盖的格子。地块可添加 "type" 属性，"type" 不为 0 时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能。
         */
        removeCoveredTile: boolean;
        /**
         * @en Whether to display the number of textures shown in large grids.
         * @zh 是否在大格子里显示显示的贴图数量。
         */
        showGridTextureCount: boolean;
        /**
         * @en Whether to adjust tile edges to eliminate gaps caused by scaling.
         * @zh 是否调整地块边缘消除缩放导致的缝隙。
         */
        antiCrack: boolean;
        /**
         * @en Whether to cache all large grids after initialization is complete.
         * @zh 是否在加载完成之后 cache 所有大格子。
         */
        cacheAllAfterInit: boolean;
        /** @ignore */
        constructor();
        /**
         * @en Create a map with the specified parameters.
         * @param mapName The name of the JSON file.
         * @param viewRect The viewport area.
         * @param completeHandler The callback function when the map is created.
         * @param viewRectPadding The expanded viewport area to prevent exposure when the viewport moves.
         * @param gridSize The size of the grid.
         * @param enableLinear Whether to enable linear sampling to improve texture quality.
         * @param limitRange Whether to restrict the map to the display area.
         * @zh 使用指定参数创建地图。
         * @param mapName 		JSON文件名字
         * @param viewRect 		视口区域
         * @param completeHandler 地图创建完成的回调函数
         * @param viewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮
         * @param gridSize 		grid大小
         * @param enableLinear 	是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）
         * @param limitRange		把地图限制在显示区域
         */
        createMap(mapName: string, viewRect: Rectangle, completeHandler: Handler, viewRectPadding?: Rectangle, gridSize?: Point, enableLinear?: boolean, limitRange?: boolean): void;
        /**
         * @en Parse the texture data inside the JSON file after successful reading, and start loading.
         * @param tJsonData The JSON data.
         * @zh JSON文件读取成功后，解析里面的纹理数据，进行加载。
         * @param tJsonData JSON数据
         */
        private onJsonComplete;
        /**
         * @en Merge resource paths.
         * @param resPath The base resource path.
         * @param relativePath The relative path to merge with the base path.
         * @returns The resolved path.
         * @zh 合并路径。
         * @param resPath 基础资源路径
         * @param relativePath 相对路径
         * @return 解析后的路径
         */
        private mergePath;
        private _texutreStartDic;
        /**
         * @en Handle the completion of texture loading. If all textures are loaded, begin initializing the map.
         * @param tTexture The loaded texture.
         * @zh 纹理加载完成的处理。如果所有纹理都加载完成，开始初始化地图。
         * @param tTexture 纹理数据
         */
        private onTextureComplete;
        private adptTexture;
        /**
         * @en Initialize map
         * @zh 初始化地图
         */
        private initMap;
        private addTileProperties;
        /**
         * @en Retrieve user data associated with a specific tile by its ID and a sign, with an option for a default value.
         * @param id The unique ID of the tile.
         * @param sign The key for the user data within the tile's data.
         * @param defaultV The default value to return if the specified user data does not exist.
         * @returns The retrieved user data or the default value if not found.
         * @zh 根据地块的ID和标识符检索与之关联的用户数据，并可选择提供默认值。
         * @param id 地块的唯一ID
         * @param sign 用户数据在地块数据中的标识符
         * @param defaultV 默认值，如果指定的用户数据不存在则返回
         * @return 得到的用户数据或默认值
         */
        getTileUserData(id: number, sign: string, defaultV?: any): any;
        private adptTiledMapData;
        private removeCoverd;
        private collectCovers;
        /**
         * @en Retrieve a map texture by its index.
         * @param index The index of the texture. Default to starting from 1.
         * @returns The TileTexSet object at the specified index, or null if not found.
         * @zh 通过索引值获取一块指定的地图纹理，默认索引从1开始。
         * @param index 纹理的索引值。
         * @return 索引处的TileTexSet对象，如果没有找到则返回null
         */
        getTexture(index: number): TileTexSet;
        /**
         * @en Get the custom properties of the map.
         * @param name The name of the property to retrieve.
         * @returns The value of the specified property, or null if not found.
         * @zh 获取地图的自定义属性。
         * @param name	属性名称
         * @return 得到的属性值，如果没有找到则返回null
         */
        getMapProperties(name: string): any;
        /**
         * @en Get custom properties of a tile.
         * @param index The index of the tile data.
         * @param id The specific TileSetID of the tile.
         * @param name The name of the property to retrieve.
         * @returns The value of the specified property for the given tile, or null if not found.
         * @zh 获取tile的自定义属性。
         * @param index	地图块索引
         * @param id		具体的TileSetID
         * @param name	属性名称
         * @returns 给定tile的指定属性值，如果没有找到则返回null
         */
        getTileProperties(index: number, id: number, name: string): any;
        /**
         * @en Generate a controllable sprite using the texture index.
         * @param index The index of the texture. Starting from 1 by default.
         * @param width The width of the sprite.
         * @param height The height of the sprite.
         * @returns The created GridSprite object, or null if not created.
         * @zh 通过纹理索引生成一个可控制物件。
         * @param index	纹理索引，默认从1开始
         * @param width		精灵的宽
         * @param height		精灵的高
         * @returns 生成的GridSprite对象，如果没有生成则返回null
         */
        getSprite(index: number, width: number, height: number): GridSprite;
        /**
         * @en Set the viewport pivot point based on scale, useful for centering the scaling origin.
         * @param scaleX The horizontal scale value for the pivot point.
         * @param scaleY The vertical scale value for the pivot point.
         * @zh 根据缩放值设置视口的缩放中心点，例如：scaleX= scaleY= 0.5 表示以视口中心缩放。
         * @param scaleX	水平缩放值
         * @param scaleY	垂直缩放值
         */
        setViewPortPivotByScale(scaleX: number, scaleY: number): void;
        /**
         * @en Set the map's scale, which affects the size of the map within the viewport.
         * @param scale The new scale value. Scale less than or equal to zero will be ignored.
         * @zh 设置地图缩放，影响地图在视口中的大小。
         * @param scale	新的缩放值，小于等于0的缩放值将被忽略
         */
        set scale(scale: number);
        /**
         * @en Get the current scale of the map.
         * @zh 获取当前地图的缩放比例。
         */
        get scale(): number;
        /**
         * @en Move the viewport to a new position.
         * @param moveX The new x-coordinate for the viewport.
         * @param moveY The new y-coordinate for the viewport.
         * @zh 移动视口到新的位置。
         * @param moveX	视口的新x坐标
         * @param moveY	视口的新y坐标
         */
        moveViewPort(moveX: number, moveY: number): void;
        /**
         * @en Change the size and/or position of the viewport.
         * @zh 改变视口的大小和/或位置。
         * @param moveX The new x-coordinate for the viewport.
         * @param moveY The new y-coordinate for the viewport.
         * @param width The new width of the viewport.
         * @param height The new height of the viewport.
         * @zh 改变视口的大小和/或位置。
         * @param moveX	视口的坐标x
         * @param moveY	视口的坐标y
         * @param width	视口的宽
         * @param height	视口的高
         */
        changeViewPort(moveX: number, moveY: number, width: number, height: number): void;
        /**
         * @en Change the viewport based on width and height, calculated from the anchor point.
         * @param width The new width for the viewport.
         * @param height The new height for the viewport.
         * @param rect The Rectangle object to store the result (optional).
         * @returns The resulting Rectangle with the new viewport dimensions and position.
         * @zh 基于锚点计算，通过宽和高来重新计算视口。
         * @param width		新视口宽
         * @param height		新视口高
         * @param rect		返回的结果
         * @returns	返回的Rectangle对象，包含新的视口的宽高和位置
         */
        changeViewPortBySize(width: number, height: number, rect?: Rectangle): Rectangle;
        /**
         * @en Refresh Viewport
         * @zh 刷新视口
         */
        private updateViewPort;
        /**
         * @en GRID cropping
         * @zh GRID裁剪
         */
        private clipViewPort;
        /**
         * @en Display the specified grid on the map.
         * @param gridX The X-coordinate of the grid.
         * @param gridY The Y-coordinate of the grid.
         * @zh 显示地图中指定的网格。
         * @param gridX	网格的X坐标
         * @param gridY	网格的Y坐标
         */
        private showGrid;
        /**
         * @en Cache all grids in the map to improve rendering performance.
         * @zh 缓存地图中的所有网格以提高渲染性能。
         */
        private cacheAllGrid;
        private static _tempCanvas;
        /**
         * @en Cache an array of grids by rendering them to an off-screen canvas.
         * @param arr An array of GridSprite objects to cache.
         * @zh 通过将网格渲染到离屏画布上来缓存网格数组。
         * @param arr	要缓存的GridSprite数组。
         */
        private cacheGridsArray;
        /**
         * @en Retrieve or initialize the array of grid sprites for a specific grid position on the map.
         * @param gridX The X-coordinate of the grid position.
         * @param gridY The Y-coordinate of the grid position.
         * @returns An array of grid sprites for the specified grid position.
         * @zh 检索或初始化地图中特定网格位置的网格精灵数组。
         * @param gridX	网格位置的X坐标
         * @param gridY	网格位置的Y坐标
         * @return	指定网格位置的网格精灵数组
         */
        private getGridArray;
        /**
         * @en Hide the specified grid on the map.
         * @param gridX The X-coordinate of the grid to hide.
         * @param gridY The Y-coordinate of the grid to hide.
         * @zh 隐藏地图中指定的网格。
         * @param gridX	要隐藏的网格的X坐标
         * @param gridY	要隐藏的网格的Y坐标
         */
        private hideGrid;
        /**
         * @en Retrieve an object from a specific layer by its name.
         * @param layerName The name of the layer where the object resides.
         * @param objectName The name of the object to find.
         * @returns The GridSprite object if found, or null if not found.
         * @zh 根据名称从特定层中获取一个对象。
         * @param layerName	物体所在层的名称
         * @param objectName	要查找的物体的名称
         * @return	找到的GridSprite对象，如果没找到则返回null
         */
        getLayerObject(layerName: string, objectName: string): GridSprite;
        /**
         * @en Destroy and cleanup the map, releasing all resources.
         * @zh 销毁地图并清理资源。
         */
        destroy(): void;
        /****************************地图的基本数据***************************/
        /**
         * @en Gets the width of a tile.
         * @zh 获取格子的宽度。
         */
        get tileWidth(): number;
        /**
         * @en Gets the height of a tile.
         * @zh 获取格子的高度。
         */
        get tileHeight(): number;
        /**
         * @en Gets the width of the map.
         * @zh 获取地图的宽度。
         */
        get width(): number;
        /**
         * @en Gets the height of the map.
         * @zh 获取地图的高度。
         */
        get height(): number;
        /**
         * @en Gets the number of horizontal tiles in the map.
         * @zh 获取地图横向的格子数。
         */
        get numColumnsTile(): number;
        /**
         * @en Gets the number of vertical tiles in the map.
         * @zh 获取地图竖向的格子数。
         */
        get numRowsTile(): number;
        /**
         * @private
         * @en Gets the viewport's x-coordinate.
         * @zh 获取视口的x坐标。
         */
        get viewPortX(): number;
        /**
         * @private
         * @en Gets the viewport's y-coordinate.
         * @zh 获取视口的y坐标。
         */
        get viewPortY(): number;
        /**
         * @private
         * @en Gets the width of the viewport.
         * @zh 获取视口的宽度。
         */
        get viewPortWidth(): number;
        /**
         * @private
         * @en Gets the height of the viewport.
         * @zh 获取视口的高度。
         */
        get viewPortHeight(): number;
        /**
         * @en Gets the x-coordinate of the map.
         * @zh 获取地图的x坐标。
         */
        get x(): number;
        /**
         * @en Gets the y-coordinate of the map.
         * @zh 获取地图的y坐标。
         */
        get y(): number;
        /**
         * @en Gets the width of a grid block.
         * @zh 获取块的宽度。
         */
        get gridWidth(): number;
        /**
         * @en Gets the height of a grid block.
         * @zh 获取块的高度。
         */
        get gridHeight(): number;
        /**
         * @en Gets the number of horizontal grid blocks in the map.
         * @zh 获取地图的横向块数。
         */
        get numColumnsGrid(): number;
        /**
         * @en Gets the number of vertical grid blocks in the map.
         * @zh 获取地图的坚向块数。
         */
        get numRowsGrid(): number;
        /**
         * @en Gets the current map orientation type.
         * @zh 获取当前地图类型。
         */
        get orientation(): string;
        /**
         * @en Gets the tile rendering order.
         * @zh 获取tile渲染顺序。
         */
        get renderOrder(): string;
        /*****************************************对外接口**********************************************/
        /**
         * @en Gets the display container for the entire map.
         * @zh 获取整个地图的显示容器。
         */
        mapSprite(): Sprite;
        /**
         * @en Retrieves a `MapLayer` by its name.
         * @param layerName The name of the layer to find.
         * @returns The found `MapLayer` or null if not found.
         * @zh 通过名称获取指定的`MapLayer`。
         * @param layerName 要查找的层的名称。
         * @returns 找到的`MapLayer`对象，如果没找到则返回null。
         */
        getLayerByName(layerName: string): MapLayer;
        /**
         * @en Retrieves a `MapLayer` by its index.
         * @param index The index of the layer to retrieve.
         * @zh 通过索引获取`MapLayer`。
         * @param index 要检索的层的索引。
         */
        getLayerByIndex(index: number): MapLayer;
    }
    /**
     * @deprecated
     * @en The `TileTexSet` class is a sub-texture class that also manages animations of the same type.
     * TiledMap divides textures into numerous sub-textures and can replace a specific sub-texture with an animation sequence.
     * The implementation of this class sets the `animationKey` to true if a sub-texture is replaced with an animation sequence.
     * That is, if `animationKey` is true, use `TileAniSprite` for display, and draw the animation sequence onto `TileAniSprite` according to time.
     * @zh `TileTexSet` 类是一个子纹理类，同时管理同类型动画。
     * TiledMap 将纹理分割成许多子纹理，并且可以将其中的某个子纹理替换为动画序列。
     * 如果发现子纹理被替换为动画序列，本类的实现会将 `animationKey` 设置为 true。
     * 即如果 `animationKey` 为 true，则使用 `TileAniSprite` 来显示，并将动画序列根据时间绘制到 `TileAniSprite` 上。
     */
    class TileTexSet {
        /**
         * @en The unique identifier for the tile texture set.
         * @zh 子纹理集的唯一标识。
         */
        gid: number;
        /**
         * @en The reference to the sub-texture.
         * @zh 子纹理的引用。
         */
        texture: Texture;
        /**
         * @en The X coordinate offset when displaying the texture.
         * @zh 纹理显示时的X坐标偏移。
         */
        offX: number;
        /**
         * @en The Y coordinate offset when displaying the texture.
         * @zh 纹理显示时的Y坐标偏移。
         */
        offY: number;
        /**
         * @en The array of textures to be displayed for the current animation.
         * @zh 当前要播放的动画纹理序列。
         */
        textureArray: any[];
        /**
         * @en The duration of each frame in the current animation.
         * @zh 当前动画每帧的时间间隔。
         */
        durationTimeArray: any[];
        /**
         * @en The total duration of the animation.
         * @zh 动画播放的总时间。
         */
        animationTotalTime: number;
        /**
         * @en Indicates whether the current texture is an animation sequence (true) or a single texture (false).
         * @zh 表示当前纹理是一组动画(true)还是单个纹理(false)。
         */
        isAnimation: boolean;
        /**
         * @en The number of display objects in the current animation.
         * @zh 当前动画的显示对象数量。
         */
        private _spriteNum;
        /**
         * @en A dictionary to save display objects by their unique name.
         * @zh 通过显示对象的唯一名字保存显示对象的字典。
         */
        private _aniDic;
        /**
         * @en The current frame index in the animation sequence.
         * @zh 当前动画播放到的帧索引。
         */
        private _frameIndex;
        /**
         * @en The elapsed time since the last animation refresh.
         * @zh 距离上次动画刷新过了多少时间。
         */
        private _time;
        /**
         * @en The interval time for refreshing each frame.
         * @zh 每帧刷新的时间间隔。
         */
        private _interval;
        /**
         * @en The timestamp of the last frame refresh.
         * @zh 上一帧刷新的时间戳。
         */
        private _preFrameTime;
        /**
         * @en Adds an animation display object to this animation.
         * @param aniName The name of the display object.
         * @param sprite The display object.
         * @zh 将一个动画显示对象加入到此动画中。
         * @param aniName 显示对象的名字。
         * @param sprite 显示对象。
         */
        addAniSprite(aniName: string, sprite: TileAniSprite): void;
        /**
         * @en Draws the animation to all registered sprites.
         * @zh 把动画画到所有注册的显示对象上。
         */
        private animate;
        /**
         * @en Draws the texture to the specified sprite.
         * @param sprite The sprite to draw the texture on.
         * @param tileTextSet The tile texture set to draw.
         * @zh 将纹理绘制到指定的显示对象上。
         * @param sprite 要绘制纹理的显示对象。
         * @param tileTextSet 要绘制的子纹理集。
         */
        private drawTexture;
        /**
         * @en Removes the sprite that no longer needs to be updated.
         * @param _name The name of the sprite to remove.
         * @zh 移除不再需要更新的显示对象。
         * @param _name 要移除的显示对象的名字。
         */
        removeAniSprite(_name: string): void;
        /**
         * @en Displays the current usage of the animation.
         * @returns A string containing the debug information.
         * @zh 显示当前动画的使用情况。
         * @returns 包含调试信息的字符串。
         */
        showDebugInfo(): string;
        /**
         * @en Clears all properties of the tile texture set.
         * @zh 清理子纹理集的所有属性。
         */
        clearAll(): void;
    }
    /**
     * 灯光类型
     */
    enum Light2DType {
        Base = 0,
        Spot = 1,
        Sprite = 2,
        Freeform = 3,
        Direction = 4
    }
    /**
     * 灯光混合模式
     */
    enum Light2DMode {
        Add = 0,
        Sub = 1,
        Mul = 2,
        Mix = 3
    }
    /**
     * 阴影边缘类型
     */
    enum ShadowFilterType {
        None = 0,
        PCF5 = 1,
        PCF9 = 2,
        PCF13 = 3
    }
    /**
     * 2D灯光基类
     */
    class BaseLight2D extends Component {
        /**
         * 光影图
         * @readonly
         */
        static LIGHTANDSHADOW: number;
        /** @readonly */
        static LIGHTANDSHADOW_ADDMODE: number;
        /** @readonly */
        static LIGHTANDSHADOW_SUBMODE: number;
        /**
         * 灯光高度值
         * @readonly
         */
        static LIGHTANDSHADOW_LIGHT_DIRECTION: number;
        /**
         * 光影图尺寸和偏移
         * @readonly
         */
        static LIGHTANDSHADOW_PARAM: number;
        /**
         * 环境光
         * @readonly
         */
        static LIGHTANDSHADOW_AMBIENT: number;
        /**
         * @internal
         */
        static idCounter: number;
        readonly owner: Sprite;
        /**
         * @internal
         */
        static __init__(): void;
        protected _type: Light2DType;
        private _lightMode;
        private _sceneMode;
        private _order;
        private _color;
        private _intensity;
        private _antiAlias;
        private _lightRotation;
        private _lightScale;
        private _layerMask;
        private _layers;
        private _shadowEnable;
        private _shadowColor;
        private _shadowStrength;
        private _shadowFilterSmooth;
        private _shadowLayerMask;
        private _shadowFilterType;
        protected _localRange: Rectangle;
        protected _worldRange: Rectangle;
        protected _lightRange: Rectangle;
        private _recoverFC;
        protected _needToRecover: any[];
        private _inScreen;
        protected _screenCache: Rectangle;
        private _texSize;
        /**
         * @internal
         * 灯光贴图（实时渲染)
         */
        _texLight: BaseTexture;
        /**
         * @en Is show light texture
         * @zh 是否显示灯光贴图
         */
        showLightTexture: boolean;
        /**
         * @internal
         */
        _lightId: number;
        /**
         * @internal
         */
        _needUpdateLight: boolean;
        /**
         * @internal
         */
        _needUpdateLightAndShadow: boolean;
        /**
         * @internal
         */
        _needUpdateLightLocalRange: boolean;
        /**
         * @internal
         */
        _needUpdateLightWorldRange: boolean;
        /**
         * @en The light render order
         * @zh 灯光渲染顺序
         */
        get order(): number;
        set order(value: number);
        /**
         * @en The light blend mode
         * @zh 灯光之间混合模式
         */
        get lightMode(): Light2DMode;
        set lightMode(value: Light2DMode);
        /**
         * @en The scene blend mode
         * @zh 灯光场景混合模式
         */
        get sceneMode(): Light2DMode;
        set sceneMode(value: Light2DMode);
        /**
         * @en The light color
         * @zh 灯光颜色
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en The light intensity
         * @zh 灯光强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * @en Is antiAlias
         * @zh 是否抗锯齿
         */
        get antiAlias(): boolean;
        set antiAlias(value: boolean);
        /**
         * @en The light rotation angle
         * @zh 灯光旋转角度
         */
        get lightRotation(): number;
        set lightRotation(value: number);
        /**
         * @en The light scale
         * @zh 灯光的缩放值
         */
        get lightScale(): Vector2;
        set lightScale(value: Vector2);
        /**
         * @en Is shadow enable, true means enable shadow, false means disable shadow.
         * @zh 阴影是否启用，true 表示启用阴影，false 表示禁用阴影。
         */
        get shadowEnable(): boolean;
        set shadowEnable(value: boolean);
        /**
         * @en The shadow color
         * @zh 阴影颜色
         */
        get shadowColor(): Color;
        set shadowColor(value: Color);
        /**
         * @en The shadow strength
         * @zh 阴影强度
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * @en Shadow filter type
         * - 0: None: not filter, the edge is completely sharp. The calculation efficiency is the highest, but the visual effect is the worst, suitable for performance-sensitive scenarios.
         * - 1: PCF5: Use 5 sampling points for blurring. The edge has a certain smooth effect, but the blur degree is limited, suitable for medium blur requirements.
         * - 2: PCF9: Use 9 sampling points for blurring. The edge has a stronger smooth effect, suitable for high-quality shadow scenes. Calculation cost is medium, visual effect is significantly improved.
         * - 3: PCF13: Use 13 sampling points for blurring, one of the highest quality blur algorithms. The edge is very soft, suitable for scenes that require extremely
         * @zh 阴影滤波类型
         * - 0: None: 没有滤波处理，阴影边缘是完全锐利的。计算效率最高，但视觉效果最差，适合性能敏感的场景。
         * - 1: PCF5: 使用 5 个采样点 进行模糊处理。阴影边缘有一定的平滑效果，但模糊程度有限，适合中等模糊需求的场景。计算开销较低，平衡性能和质量。
         * - 2: PCF9: 使用 9 个采样点进行模糊处理。阴影边缘有更强的平滑效果，适合高质量光影的场景。计算开销适中，视觉效果明显提升。
         * - 3: PCF13: 使用 13 个采样点进行模糊处理，是最高质量的模糊算法之一。阴影边缘非常柔和，适合对视觉质量要求极高的场景。计算开销较高，但效果非常细腻。
         */
        get shadowFilterType(): ShadowFilterType;
        set shadowFilterType(value: ShadowFilterType);
        /**
         * @en The shadow filter smooth
         * @zh 阴影滤波平滑系数
         */
        get shadowFilterSmooth(): number;
        set shadowFilterSmooth(value: number);
        /**
         * @en the layer mask
         * @zh 灯光层遮罩（灯光影响哪些层）
         */
        get layerMask(): number;
        set layerMask(value: number);
        /**
         * @en Get light layers
         * @zh 获取灯光层数组（灯光影响哪些层）
         */
        get layers(): number[];
        /**
         * @en The shadow layer mask
         * @zh 阴影层遮罩（阴影影响哪些层）
         */
        get shadowLayerMask(): number;
        set shadowLayerMask(value: number);
        /**
         * @ignore
         */
        constructor();
        /**
         * @en notify this light layer mask change
         * @zh 通知此灯光层遮罩的改变
         */
        private _notifyLightLayerMaskChange;
        /**
         * @en notify this light shadow layer mask change
         * @zh 通知此灯阴影层遮罩的改变
         */
        private _notifyShadowCastLayerMaskChange;
        /**
         * @en notify this light shadow PCF change
         * @zh 通知此灯阴影PCF参数的改变
         */
        private _notifyShadowPCFChange;
        /**
         * @en notify this light shadow enable change
         * @zh 通知此灯阴影启用改变
         */
        private _notifyShadowEnableChange;
        /**
         * @en notify this light render order change
         * @zh 通知此灯的渲染顺序发生改变
         */
        private _notifyLightOrderChange;
        /**
         * @en notify this light antiAlias change
         * @zh 通知此灯的抗锯齿设置发生改变
         */
        protected _notifyAntiAliasChange(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**
         * @internal
         * @en Response matrix change
         * @zh 响应矩阵改变
         */
        _transformChange(): void;
        /**
         * @en Clear screen size cache
         * @zh 清除屏幕尺寸缓存
         */
        protected _clearScreenCache(): void;
        /**
         * @internal
         * @en Calculate PCF coefficient
         * @zh 计算PCF系数
         */
        _pcfIntensity(): number;
        /**
         * @internal
         * @en Get light range (local coordinates)
         * @zh 获取灯光范围（局部坐标）
         */
        _getLocalRange(): Rectangle;
        /**
         * @internal
         * @en Get light range (world coordinates)
         * @zh 获取灯光范围（世界坐标）
         */
        _getWorldRange(screen?: Rectangle): Rectangle;
        /**
         * @internal
         * @en Get light range (light map)
         * @zh 获取灯光范围（光影图）
         */
        _getLightRange(screen?: Rectangle): Rectangle;
        /**
         * @internal
         * 获取贴图尺寸
         */
        _getTextureSize(): Vector2;
        /**
         * @internal
         * 是否需要建立阴影网格
         */
        _isNeedShadowMesh(): boolean;
        /**
         * 矩形1是否包含矩形2
         * @param rect1
         * @param rect2
         */
        private _rectContain;
        /**
         * @en Get light type
         * @zh 获取灯光类型
         */
        getLightType(): Light2DType;
        /**
         * @en Get light global position x
         * @zh 获取灯光世界位置的X坐标值
         */
        getGlobalPosX(): number;
        /**
         * @en Get light global position y
         * @zh 获取灯光世界位置的Y坐标值
         */
        getGlobalPosY(): number;
        /**
         * @en Get light global position
         * @zh 获取灯光位置的X坐标值（基于全局坐标系）
         * @param out
         */
        getGlobalPos(out: Point): Point;
        /**
         * @en Set layer mask by list
         * @param layerList Layer list
         * @zh 用列表设置灯光层掩码
         * @param layerList 层列表
         */
        setLayerMaskByList(layerList: number[]): void;
        /**
         * @en Is the light turned on for the specified layer
         * @param layer Specified layer
         * @zh 灯光对指定层是否开启
         * @param layer 指定层
         */
        isLayerEnable(layer: number): number;
        /**
         * @en Set shadow layer mask by list
         * @param layerList Layer list
         * @zh 用列表设置阴影层掩码
         * @param layerList 层列表
         */
        setShadowLayerMaskByList(layerList: number[]): void;
        /**
         * @en Is the shadow turned on for the specified layer
         * @param layer Specified layer
         * @zh 阴影对指定层是否开启
         * @param layer 指定层
         */
        isShadowLayerEnable(layer: number): number;
        /**
         * @internal
         * 将渲染出的贴图以Base64的方式打印到终端上
         */
        _printTextureToConsoleAsBase64(): void;
        /**
         * @internal
         * 计算灯光范围（局部坐标）
         */
        protected _calcLocalRange(): void;
        /**
         * @internal
         * 获取灯光范围
         */
        protected _calcWorldRange(screen?: Rectangle): void;
        /**
         * @internal
         * 设置灯光放缩和旋转
         */
        protected _lightScaleAndRotation(): void;
        /**
         * @en Render light texture
         * @zh 渲染灯光贴图
         */
        renderLightTexture(): void;
        /**
         * @internal
         * 灯光是否在指定范围内
         */
        _isInRange(range: Rectangle): boolean;
        /**
         * @internal
         * 灯光是否在屏幕内
         * @param screen 屏幕位置和尺寸
         */
        _isInScreen(screen: Rectangle): boolean;
        /**
         * @en Generates or updates a mesh object.
         * @param points Vertex data representing the coordinates of the mesh vertices.
         * @param inds Index data representing how the mesh vertices are connected.
         * @param mesh Optional reusable mesh object. If provided, this mesh object will be updated if possible.
         * @param recover Optional recovery queue. If the mesh object is not reused, it will be added to this queue.
         * @returns The generated or updated mesh object.
         * @zh 创建或更新网格对象
         * @param points 顶点数据，表示网格的顶点坐标。
         * @param inds 索引数据，表示网格顶点的连接方式。
         * @param mesh 可选的复用网格对象，如果传入则尝试更新此网格对象。不传则会创建一个新的网格对象。
         * @param recover 可选的回收队列，如果网格对象未被复用，则将其放入回收队列。
         * @returns 生成或更新后的网格对象。
         */
        protected _makeOrUpdateMesh(points: Vector3[], inds: number[], mesh?: Mesh2D, recover?: any[]): Mesh2D;
    }
    /**
     * 线性灯光
     */
    class DirectionLight2D extends BaseLight2D {
        private _directionAngle;
        private _directionVector;
        private _shadowDistance;
        private _shadowRange;
        /**@ignore */
        constructor(directionAngle?: number);
        /**
         * @en Get direction light angle
         * @zh 获取灯光角度
         */
        get directionAngle(): number;
        /**
         * @en Set direction light angle
         * @param value Angle value
         * @zh 设置灯光角度
         * @param value 角度值
         */
        set directionAngle(value: number);
        /**
         * @en Get direction light vector
         * @zh 获取灯光角度矢量
         */
        get directionVector(): Vector2;
        /**
         * @en Set direction light vector
         * @param value Direction value
         * @zh 设置灯光角度矢量
         * @param value 方向矢量
         */
        set directionVector(value: Vector2);
        /**
         * @en Direction light max shadow distance
         * @zh 阴影最远距离
         */
        get shadowDistance(): number;
        /**
         * @en Direction light max shadow distance
         * @param value Distance value
         * @zh 阴影最远距离
         * @param value 距离值
         */
        set shadowDistance(value: number);
        /**
         * @internal
         * @param screen 屏幕位置和尺寸
         */
        _getWorldRange(screen?: Rectangle): Rectangle;
        /**
         * 计算灯光范围（局部坐标）
         */
        protected _calcLocalRange(): void;
        /**
         * 计算灯光范围（世界坐标）
         * @param screen 屏幕位置和尺寸
         */
        protected _calcWorldRange(screen?: Rectangle): void;
        /**
         * @internal
         * 获取阴影范围（世界坐标）
         * @param screen 屏幕位置和尺寸
         */
        _getShadowRange(screen?: Rectangle): Rectangle;
        /**
         * @internal
         * 灯光是否在指定范围内
         */
        _isInRange(range: Rectangle): boolean;
        /**
         * @internal
         * 灯光是否在屏幕内
         * @param screen 屏幕位置和尺寸
         */
        _isInScreen(screen: Rectangle): boolean;
    }
    /**
     * 自定义形状灯光
     */
    class FreeformLight2D extends BaseLight2D {
        /** @readonly */
        static FALLOF_WIDTH: number;
        private _falloffRange;
        private _lightPolygon;
        private _globalPolygon;
        private _localCenter;
        private _cmdBuffer;
        private _cmdRT;
        private _cmdMesh;
        private _material;
        readonly owner: Sprite;
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Get the range of light attenuation
         * @zh 获取灯光衰减范围
         */
        get falloffRange(): number;
        /**
         * @en Set the range of light attenuation
         * @param value Light attenuation value
         * @zh 设置灯光衰减范围
         * @param value 灯光衰减范围值
         */
        set falloffRange(value: number);
        /**
         * @internal
         * 设置默认多边形数据
         */
        private _defaultPoly;
        /**
         * @en Set polygon endpoint data
         * @param poly Poly data
         * @zh 设置多边形端点数据
         * @param poly 多边形数据
         */
        set polygonPoint(poly: PolygonPoint2D);
        /**
         * @en Get polygon endpoint data
         * @zh 获取多边形端点数据
         */
        get polygonPoint(): PolygonPoint2D;
        /**
         * @en Get light global position x
         * @zh 获取灯光世界位置的X坐标值
         */
        getGlobalPosX(): number;
        /**
         * @en Get light global position y
         * @zh 获取灯光世界位置的Y坐标值
         */
        getGlobalPosY(): number;
        /**
         * @internal
         * @en Response matrix change
         * @zh 响应矩阵改变
         */
        _transformChange(): void;
        /**
         * 计算灯光范围（局部坐标）
         */
        protected _calcLocalRange(): void;
        /**
         * 计算灯光范围（世界坐标）
         * @param screen 屏幕位置和尺寸
         */
        protected _calcWorldRange(screen?: Rectangle): void;
        /**
         * @en notify this light antiAlias change
         * @zh 通知此灯的抗锯齿设置发生改变
         */
        protected _notifyAntiAliasChange(): void;
        /**
         * 创建渲染灯光的贴图
         * @param width
         * @param height
         */
        private _buildRenderTexture;
        /**
         * @en Render light texture
         * @zh 渲染灯光贴图
         */
        renderLightTexture(): void;
        /**
         * 限制参数范围
         */
        private _limitParam;
        /**
         * 创建灯光多边形网格
         * @param expand
         * @param arcSegments
         * @param mesh
         * @param recover
         */
        private _createMesh;
        /**
         * 耳切法三角化凹多边形
         * @param polygon
         */
        private _earCut;
        /**
         * 是否耳尖
         * @param vertices
         * @param indices
         * @param vertexCount
         * @param a
         * @param b
         * @param c
         */
        private _isEarTip;
        /**
         * 是否包含其他顶点
         * @param vertices
         * @param indices
         * @param vertexCount
         * @param a
         * @param b
         * @param c
         * @param exclude
         */
        private _containsAnyPoint;
        /**
         * 销毁
         */
        protected _onDestroy(): void;
    }
    /**
     * 2D灯光全局配置参数
     */
    class Light2DConfig {
        /**
         * @en Light direction vector (affects normal effect)
         * @zh 灯光方向矢量（影响法线效果）
         */
        lightDirection: Vector3;
        /**
         * @en ambient light color
         * @zh 环境光颜色
         */
        ambientColor: Color;
        /**
         * @en Layers affected by ambient light (affects all layers by default)
         * @zh 环境光影响的层（默认影响所有层）
         */
        ambientLayerMask: number;
        /**
         * @en Light and shadow map multisampling number (1 or 4, affects jagged shadow edges)
         * @zh 光影图多重采样数（1或4，影响阴影边缘锯齿）
         */
        multiSamples: number;
    }
    /**
     * 生成2D光影图的渲染流程
     * @blueprintIgnore
     */
    class Light2DManager implements IElementComponentManager, ILight2DManager {
        /**
         * @internal
         */
        static _managerName: string;
        static MAX_LAYER: number;
        static SCREEN_SCHMITT_SIZE: number;
        static DIRECTION_LIGHT_SIZE: number;
        static REUSE_CMD: boolean;
        static REUSE_MESH: boolean;
        static DEBUG: boolean;
        static SUPPORT_LIGHT_BLEND_MODE: boolean;
        static SUPPORT_LIGHT_SCENE_MODE: boolean;
        lsTarget: RenderTexture[];
        lsTargetAdd: RenderTexture[];
        lsTargetSub: RenderTexture[];
        occluderAgent: Occluder2DAgent;
        static _config: Light2DConfig;
        get config(): Light2DConfig;
        set config(value: Light2DConfig);
        private _PCF;
        private _scene;
        private _screen;
        private _screenPrev;
        private _screenSchmitt;
        private _screenSchmittChange;
        private _segments;
        private _points;
        private _param;
        private _lights;
        private _occluders;
        private _works;
        private _updateMark;
        private _updateLayerLight;
        private _spriteLayer;
        private _spriteNumInLayer;
        private _lightLayer;
        private _lightLayerAll;
        private _lightSceneModeNum;
        private _lightsInLayer;
        private _lightsInLayerAll;
        private _occluderLayer;
        private _occludersInLayer;
        private _occludersInLight;
        private _lightRenderRes;
        private _sceneInv0;
        private _sceneInv1;
        private _stageMat0;
        private _stageMat1;
        private _lightScenePos;
        private _recoverFC;
        private _needToRecover;
        private _needUpdateLightRes;
        private _needCollectLightInLayer;
        private _needCollectOccluderInLight;
        private _lightsNeedCheckRange;
        static __init__(): void;
        constructor(scene: Scene);
        destroy(): void;
        /**
         * 响应屏幕尺寸改变
         */
        private _onScreenResize;
        /**
         * 场景矩阵发生变化
         */
        private _sceneTransformChange;
        /**
         * @en Add render sprite
         * @param node Render node
         * @zh 添加渲染精灵
         * @param node 渲染节点
         */
        addRender(node: BaseRenderNode2D): void;
        /**
         * @en Remove render sprite
         * @param node Render node
         * @zh 删除渲染精灵
         * @param node 渲染节点
         */
        removeRender(node: BaseRenderNode2D): void;
        name: string;
        Init(data: any): void;
        update(dt: number): void;
        /**
         * @internal
         * 将渲染出的贴图以Base64的方式打印到终端上
         */
        _printTextureToConsoleAsBase64(tex: RenderTexture): void;
        /**
         * @internal
         * 灯光的变换矩阵发生变化
         * @param light 灯光对象
         */
        _lightTransformChange(light: BaseLight2D): void;
        /**
         * 检查灯光范围，如果需要更新则更新
         * @param light 灯光对象
         */
        private _checkLightRange;
        /**
         * @en Need check the light range
         * @param light light object
         * @zh 需要检查灯光范围
         * @param light 灯光对象
         */
        needCheckLightRange(light: BaseLight2D): void;
        /**
         * @en Need collect light in layers
         * @param layerMask mask layer
         * @zh 是否需要收集各层中的灯光
         * @param layerMask 遮罩层
         */
        needCollectLightInLayer(layerMask: number): void;
        /**
         * @en Need collect occluder in layers who effect lights
         * @param layerMask mask layer
         * @zh 是否需要收集各层中影响各灯光的遮光器
         * @param layerMask 遮罩层
         */
        needCollectOccluderInLight(layerMask: number): void;
        /**
         * @en light layer mask change
         * @param light Light object
         * @param oldLayerMask old mask layer
         * @param newLayerMask new mask layer
         * @zh 灯光的影响层发生变化
         * @param light 灯光对象
         * @param oldLayerMask 新遮罩层
         * @param newLayerMask 旧遮罩层
         */
        lightLayerMaskChange(light: BaseLight2D, oldLayerMask: number, newLayerMask: number): void;
        /**
         * @en light shadow layer mark change
         * @param light Light object
         * @param oldLayerMask old shadow mask layer
         * @param newLayerMask new shadow mask layer
         * @zh 灯光的阴影遮罩层发生变化
         * @param light 灯光对象
         * @param oldLayerMask 旧阴影遮罩层
         * @param newLayerMask 新阴影遮罩层
         */
        lightShadowLayerMaskChange(light: BaseLight2D, oldLayerMask: number, newLayerMask: number): void;
        /**
         * @en light shadow pcf change
         * @param light Light object
         * @zh 灯光的阴影PCF参数发生变化
         * @param light 灯光对象
         */
        lightShadowPCFChange(light: BaseLight2D): void;
        /**
         * @en light shadow enable change
         * @param light
         * @zh 灯光的阴影使能变化
         * @param light
         */
        lightShadowEnableChange(light: BaseLight2D): void;
        /**
         * @en light render order change
         * @param light
         * @zh 灯光的渲染顺序变化
         * @param light
         */
        lightRenderOrderChange(light: BaseLight2D): void;
        /**
         * @en Clear all lights
         * @zh 清除所有灯光
         */
        clearLight(): void;
        /**
         * @en Add light
         * @param light Light object
         * @zh 添加灯光
         * @param light 灯光对象
         */
        addLight(light: BaseLight2D): void;
        /**
         * @en Remove light
         * @param light Light object
         * @zh 移除灯光
         * @param light 灯光对象
         */
        removeLight(light: BaseLight2D): void;
        /**
         * @en Clear all occluders
         * @zh 清除所有遮光器
         */
        clearOccluder(): void;
        /**
         * @en Add occluder
         * @param occluder Occluder object
         * @zh 添加遮光器
         * @param occluder 遮光器对象
         */
        addOccluder(occluder: LightOccluder2DCore): void;
        /**
         * @en Remove occluder
         * @param occluder Occluder object
         * @zh 移除遮光器
         * @param occluder 遮光器对象
         */
        removeOccluder(occluder: LightOccluder2DCore): void;
        /**
         * @en Occluder layer change
         * @param occluder
         * @param oldLayerMask
         * @param newLayerMask
         * @zh 遮光器的影响层发生变化
         * @param occluder
         * @param oldLayerMask
         * @param newLayerMask
         */
        occluderLayerMaskChange(occluder: LightOccluder2DCore, oldLayerMask: number, newLayerMask: number): void;
        /**
         * 创建渲染目标（光影图）
         * @param width
         * @param height
         */
        private _buildRenderTexture;
        /**
         * 收集屏幕内指定层中的灯光和遮光器
         * @param layer 层序号
         */
        private _collectLightInScreenByLayer;
        /**
         * 更新指定层的渲染资源
         * @param layer 层序号
         */
        private _updateLayerRenderRes;
        /**
         * 更新指定灯光的PCF参数
         * @param light 灯光对象
         */
        private _updateLightPCF;
        /**
         * 提取指定层中灯光遮挡器线段
         * @param layer
         * @param sn
         * @param lightX
         * @param lightY
         * @param range
         * @param shadow
         */
        private _getOccluderSegment;
        /**
         * 收集影响指定灯光的遮光器
         * @param layer
         * @param light
         * @param sn 灯光序号
         */
        private _collectOccludersInLight;
        /**
         * 回收资源
         */
        private _recoverResource;
        /**
         * @en Render light and shader texture
         * @zh 渲染光影图
         */
        preRenderUpdate(): void;
        /**
         * @internal
         * 获取层更新码
         * @param layer 层序号
         */
        _getLayerUpdateMark(layer: number): number;
        /**
         * @internal
         * 更新指定层的着色器数据
         * @param layer 层序号
         * @param shaderData 着色器数据
         */
        _updateShaderDataByLayer(layer: number, shaderData: ShaderData): void;
        /**
         * 更新屏幕尺寸和偏移参数
         */
        private _updateScreen;
        /**
         * 更新光影信息
         * @param layer
         * @param layerOffetX
         * @param layerOffetY
         * @param light
         * @param mesh
         * @param pcf
         * @param sn
         */
        private _update;
        /**
         * 更新光影信息（阴影）
         * @param layer
         * @param layerOffsetX
         * @param layerOffsetY
         * @param light
         * @param mesh
         * @param sn
         */
        private _updateShadow;
        /**
         * @en Generates or updates a mesh object.
         * @param vertices Vertex data representing the coordinates of the mesh vertices.
         * @param indices Index data representing how the mesh vertices are connected.
         * @param mesh Optional reusable mesh object. If provided, this mesh object will be updated if possible.
         * @returns The generated or updated mesh object.
         * @zh 创建或更新网格对象
         * @param vertices 顶点数据，表示网格的顶点坐标。
         * @param indices 索引数据，表示网格顶点的连接方式。
         * @param mesh 可选的复用网格对象，如果传入则尝试更新此网格对象。不传则会创建一个新的网格对象。
         * @returns 生成或更新后的网格对象。
        */
        private _makeOrUpdateMesh;
        /**
         * 生成灯光网格
         * @param lightX 光源位置
         * @param lightY
         * @param lightWidth 光源尺寸
         * @param lightHeight
         * @param lightOffsetX 灯光贴图的偏移值
         * @param lightOffsetY
         * @param layerOffsetX 光影图的偏移值
         * @param layerOffsetY
         * @param inputPoints 顶点
         * @param mesh
         */
        private _genLightMesh;
        /**
         * 生成阴影多边形，阴影多边形是圆减去内部多边形的部分，圆要能完全包围住多边形
         * @param lightX 光源位置
         * @param lightY
         * @param lightWidth 光源尺寸
         * @param lightHeight
         * @param lightOffsetX 灯光贴图的偏移值
         * @param lightOffsetY
         * @param layerOffsetX 光影图的偏移值
         * @param layerOffsetY
         * @param inputPoints 顶点
         * @param radius 圆半径
         * @param mesh
         */
        private _genShadowMesh;
        /**
         * 计算射线和线段的交点
         * @param ray
         * @param segment
         * @param result
         */
        private _getIntersection;
        /**
         * 根据灯光位置，遮光器线段，获取光照多边形顶点序列（按顺时针排列）
         * @param lightX
         * @param lightY
         * @param segments
         */
        private _getLightPolygon;
    }
    /**
     * 每一层用于渲染光影图的资源
     */
    class Light2DRenderRes {
        lights: BaseLight2D[];
        textures: BaseTexture[];
        material: Material[];
        materialShadow: Material[];
        lightMeshs: Mesh2D[][];
        shadowMeshs: Mesh2D[];
        needShadowMesh: boolean[];
        sceneModeNum: number[];
        sceneModeList: Light2DMode[];
        private _layer;
        private _invertY;
        private _cmdRT;
        private _cmdRTAdd;
        private _cmdRTSub;
        private _cmdLightMeshs;
        private _cmdShadowMeshs;
        private _cmdBuffer;
        constructor(scene: Scene, layer: number, invertY: boolean);
        /**
         * 初始化材质
         * @param material 待初始化的材质
         * @param shadow 是否用于渲染阴影
         */
        private _initMaterial;
        /**
         * 设置材质参数
         * @param light
         * @param material
         * @param shadow
         */
        setMaterialData(light: BaseLight2D, material: Material, shadow: boolean): void;
        /**
         * @en add lights group
         * @param lights the lights object array
         * @param recover the queue for recovery
         * @zh 添加灯光组
         * @param lights 灯光对象数组
         * @param recover 回收队列
         */
        addLights(lights: BaseLight2D[], recover?: any[]): void;
        /**
         * @en update lights group PCF
         * @param light the lights object
         * @zh 更新灯光组PCF
         * @param light 灯光对象
         */
        updateLightPCF(light: BaseLight2D): void;
        /**
         * @en put mesh into recover queue
         * @param recover recover queue
         * @param length the length to be reserved, the previous will be recycled
         * @zh 将mesh放入回收队列
         * @param recover 回收队列
         * @param length 保留的长度，之前的会被回收
         */
        private _needRecoverMesh;
        /**
         * @en set render target command
         * @param rt render target
         * @param rtAdd
         * @param rtSub
         * @zh 设置渲染目标命令
         * @param rt 渲染目标
         * @param rtAdd
         * @param rtSub
         */
        setRenderTargetCMD(rt: RenderTexture, rtAdd?: RenderTexture, rtSub?: RenderTexture): void;
        /**
         * @en build render mesh command cache
         * @zh 建立渲染网格命令缓存
         */
        buildRenderMeshCMD(): void;
        /**
         * @en update command cache's render material
         * @zh 更新命令缓存中的渲染材质
         */
        updateMaterial(): void;
        /**
         * @en update command cache's mesh
         * @param mesh mesh object
         * @param i array index
         * @param j array index
         * @zh 更新命令缓存中的网格
         * @param mesh 网格对象
         * @param i 数组索引
         * @param j 数组索引
         */
        updateLightMesh(mesh: Mesh2D, i: number, j: number): void;
        /**
         * @en update command cache's mesh
         * @param mesh  mesh object
         * @param i array index
         * @zh 更新命令缓存中的网格
         * @param mesh 网格对象
         * @param i 数组索引
         */
        updateShadowMesh(mesh: Mesh2D, i: number): void;
        /**
         * @en enable shadow
         * @param light light object
         * @param recover revert array
         * @zh 启用阴影
         * @param light 光源对象
         * @param recover 回收队列
         */
        enableShadow(light: BaseLight2D, recover: any[]): void;
        /**
         * @en Render light and shadow
         * @param rt Render target (mulitply mode)
         * @param rtAdd
         * @param rtSub
         * @zh 渲染光影图
         * @param rt 渲染目标（相乘模式）
         * @param rtAdd
         * @param rtSub
         */
        render(rt?: RenderTexture, rtAdd?: RenderTexture, rtSub?: RenderTexture): void;
    }
    /**
     * 2D线段
     * （可用于对象池）
     */
    class LightLine2D {
        a: Vector2;
        b: Vector2;
        n: Vector2;
        useNormal: boolean;
        /**
         * @en Create 2D line
         * @param ax Point A x coordinate
         * @param ay Point A y coordinate
         * @param bx Point B x coordinate
         * @param by Point B y coordinate
         * @param useNormal Is create and use normal
         * @zh 创建2D线段
         * @param ax 端点A的x坐标
         * @param ay 端点A的y坐标
         * @param bx 端点B的x坐标
         * @param by 端点B的y坐标
         * @param useNormal 是否创建和使用法线
         */
        create(ax: number, ay: number, bx: number, by: number, useNormal?: boolean): this;
    }
    /**
     * 2D灯光遮挡器（遮光器）
     */
    class LightOccluder2D extends Component {
        private _core;
        readonly owner: Sprite;
        /**
         * @en the layer mask
         * @zh 遮光器层遮罩（遮光器影响哪些层）
         */
        get layerMask(): number;
        set layerMask(value: number);
        /**
         * @en Can in light boolean value
         * @zh 灯光在内部时是否挡光
         */
        get canInLight(): boolean;
        set canInLight(value: boolean);
        /**
         * @en Only outside shadow the light
         * @zh 是否只是外圈遮挡光线
         */
        get outside(): boolean;
        set outside(value: boolean);
        /**
         * @en Get polygon endpoint data
         * @zh 获取多边形端点数据
         */
        get polygonPoint(): PolygonPoint2D;
        set polygonPoint(poly: PolygonPoint2D);
        /**
         * @ignore
         */
        constructor();
        protected _onEnable(): void;
        protected _onDisable(): void;
    }
    /**
     * 2D灯光遮挡器（遮光器）
     */
    class LightOccluder2DCore {
        /**
         * @internal
         */
        static _idCounter: number;
        private _layerMask;
        private _layers;
        private _owner;
        set owner(value: Sprite);
        private _manager;
        set manager(value: Light2DManager);
        private _x;
        private _y;
        private _scaleX;
        private _scaleY;
        private _skewX;
        private _skewY;
        private _rotation;
        private _transform;
        private _tfChanged;
        private _sceneMatrix;
        /**
         * @en the layer mask
         * @zh 遮光器层遮罩（遮光器影响哪些层）
         */
        get layerMask(): number;
        set layerMask(value: number);
        /**
         * @en The occluder layers
         * @zh 遮光器层数组
         */
        get layers(): number[];
        private _canInLight;
        /**
         * @en Can in light boolean value
         * @zh 灯光在内部时是否挡光
         */
        get canInLight(): boolean;
        set canInLight(value: boolean);
        private _outside;
        /**
         * @en Only outside shadow the light
         * @zh 是否只是外圈遮挡光线
         */
        get outside(): boolean;
        set outside(value: boolean);
        /**
         * @internal
         */
        _occluderId: number;
        /**
         * 遮光器范围（局部坐标）
         */
        private _localRange;
        /**
         * 遮光器范围（世界坐标）
         */
        private _worldRange;
        /**
         * @internal
         */
        private _needUpdate;
        get needUpdate(): boolean;
        set needUpdate(value: boolean);
        private _needTransformPoly;
        private _needUpdateLightLocalRange;
        private _needUpdateLightWorldRange;
        private _select;
        private _occluderPolygon;
        private _globalPolygon;
        private _cutPolygon;
        private _outsideSegment;
        private _segments;
        private _segLight;
        private _tempVec2;
        /**
         * @ignore
         */
        constructor(manager?: Light2DManager);
        /**
         * @internal
         */
        _onEnable(): void;
        /**
         * @internal
         */
        _onDisable(): void;
        /**
         * @en Set the position. Equivalent to setting the x and y properties separately.
         * Since the return value is the object itself, you can use the following syntax: spr.pos(...).scale(...);
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @returns The object itself.
         * @zh 设置坐标位置。相当于分别设置x和y属性。
         * 因为返回值为对象本身，所以可以使用如下语法：spr.pos(...).scale(...);
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @returns 返回对象本身。
         */
        pos(x: number, y: number): this;
        /**
         * @en Set the scale. Equivalent to setting the scaleX and scaleY properties separately.
         * Since the return value is the object itself, you can use the following syntax: spr.scale(...).pos(50, 100);
         * @param x X-axis scale ratio.
         * @param y Y-axis scale ratio.
         * @returns The object itself.
         * @zh 设置缩放。相当于分别设置scaleX和scaleY属性。
         * @param x X轴缩放比例。
         * @param y Y轴缩放比例。
         * @returns 返回对象本身。
         */
        scale(x: number, y: number): this;
        /**
         * @en Set the skew angle. Equivalent to setting the skewX and skewY properties separately.
         * Since the return value is the object itself, you can use the following syntax: spr.skew(...).pos(50, 100);
         * @param x Horizontal skew angle.
         * @param y Vertical skew angle.
         * @returns The object itself.
         * @zh 设置倾斜角度。相当于分别设置skewX和skewY属性。
         * 因为返回值为对象本身，所以可以使用如下语法：spr.skew(...).pos(50, 100);
         * @param x 水平倾斜角度。
         * @param y 垂直倾斜角度。
         * @returns 返回对象本身。
         */
        skew(x: number, y: number): this;
        /**
         * @en The x coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的水平方向坐标值。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y coordinate value relative to the parent container.
         * @zh 显示对象相对于父容器的垂直方向坐标值。
         */
        get y(): number;
        set y(value: number);
        /**
         * @en The scale factor on the X axis, with a default value of 1. Setting a negative value can achieve a horizontal flip effect, e.g., scaleX=-1.
         * @zh X轴缩放值，默认值为1。
        */
        get scaleX(): number;
        set scaleX(value: number);
        /**
         * @en The scale factor on the Y axis, with a default value of 1. Setting a negative value can achieve a vertical flip effect, e.g., scaleY=-1.
         * @zh Y轴缩放值，默认值为1。
         */
        get scaleY(): number;
        set scaleY(value: number);
        /**
         * @en The horizontal skew angle, in degrees, with a default value of 0.
         * @zh 水平倾斜角度，默认值为0。以角度为单位。
         */
        get skewX(): number;
        set skewX(value: number);
        /**
          * @en The vertical skew angle, in degrees, with a default value of 0.
          * @zh 垂直倾斜角度,默认值为0。以角度为单位。
          */
        get skewY(): number;
        set skewY(value: number);
        /**
         * @en The rotation angle, in degrees, with a default value of 0.
         * @zh 旋转角度，默认值为0。以角度为单位。
         */
        get rotation(): number;
        set rotation(value: number);
        get transform(): Matrix;
        set transform(value: Matrix);
        /**
         * @internal
         * 通知此遮光器层的改变
         * @param oldLayerMask 旧层掩码
         * @param newLayerMask 新层掩码
         */
        _layerMaskChange(oldLayerMask: number, newLayerMask: number): void;
        /**
         * @internal
         * 响应矩阵改变
         */
        _transformChange(): void;
        /**
         * @en Set polygon endpoint data
         * @param poly Polygon data
         * @zh 设置多边形端点数据
         * @param poly 多边形数据
         */
        set polygonPoint(poly: PolygonPoint2D);
        /**
         * @en Get polygon endpoint data
         * @zh 获取多边形端点数据
         */
        get polygonPoint(): PolygonPoint2D;
        /**
         * 清理缓存
         */
        private _clearCache;
        /**
         * @en Get occluder's segments
         * @param lightX Light position x
         * @param lightY Light position y
         * @zh 获取遮光器线段
         * @param lightX 灯光位置x值
         * @param lightY 灯光位置y值
         */
        getSegment(lightX: number, lightY: number): LightLine2D[];
        /**
         * 计算范围（局部坐标）
         */
        private _calcLocalRange;
        /**
         * 计算范围（世界坐标）
         */
        private _calcWorldRange;
        /**
         * @internal
         * 获取范围（世界坐标）
         */
        _getRange(): Rectangle;
        /**
         * @en Is inside the light range
         * @param range Specified range
         * @zh 是否在指定灯光范围内
         * @param range 指定范围
         */
        isInLightRange(range: Rectangle): boolean;
        /**
         * @en According to whether the light position is selected, if the light is located inside the polygon, it is not selected
         * @param x Light position x
         * @param y Light position y
         * @zh 按照灯光位置是否被选用，如果灯光位于多边形内部，则不选用
         * @param x 灯光位置x值
         * @param y 灯光位置y值
         */
        selectByLight(x: number, y: number): boolean;
        /**
         * 变换多边形顶点（基于Scene）
         */
        private _transformPoly;
        /**
         * 选择出口边（包括部分出口边）
         * @param polygon
         * @param outsidePointX
         * @param outsidePointY
         * @param outPoly
         */
        private _selectOutside;
        /**
         * 查找距离p1最近的交点
         * @param p1x
         * @param p1y
         * @param p2x
         * @param p2y
         * @param outsidePointX
         * @param outsidePointY
         * @param points
         */
        private _findNearestIntersection;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 创建遮光器的参数结构体
     */
    type Occluder2DParam = {
        poly: PolygonPoint2D | number[];
        layerMask?: number;
        px?: number;
        py?: number;
        sx?: number;
        sy?: number;
        rot?: number;
    };
    /**
     * 遮光器代理
     */
    class Occluder2DAgent {
        private _manager;
        private _occluderMap;
        constructor(manager: Light2DManager);
        /**
         * @en Create a occluder
         * @param index Unique index
         * @param param Shader parameter object
         * @returns Occluder Object
         * @zh 创建遮光器
         * @param index 唯一索引
         * @param param 遮光器参数对象
         * @returns 遮光器对象
         */
        addOccluder(index: number, param: Occluder2DParam): LightOccluder2DCore;
        /**
         * @zh Get the occluder object
         * @param index Unique index
         * @returns Occluder object (successful), undefined (failed)
         * @zh 获取遮光器
         * @param index 唯一索引
         * @returns 遮光器对象（成功），undefined（失败）
         */
        getOccluder(index: number): LightOccluder2DCore;
        /**
         * @en Set the occluder position
         * @param index Unique index
         * @param x X Coordinate value
         * @param y Y Coordinate value
         * @returns Occluder object (successful), undefined (failed)
         * @zh 设置遮光器位置
         * @param index 唯一索引
         * @param x X坐标值
         * @param y Y坐标值
         * @returns 遮光器对象（成功），undefined（失败）
         */
        setPos(index: number, x: number, y: number): LightOccluder2DCore;
        /**
         * @en Set the occluder rotation
         * @param index Unique index
         * @param rot Rotation angle
         * @returns Occluder object (successful), undefined (failed)
         * @zh 设置遮光器旋转
         * @param index 唯一索引
         * @param rot 旋转角度
         * @returns 遮光器对象（成功），undefined（失败）
         */
        setRot(index: number, rot: number): LightOccluder2DCore;
        /**
         * @en Set the occluder scale
         * @param index Unique index
         * @param x X scale value
         * @param y Y scale value
         * @returns Occluder object (successful), undefined (failed)
         * @zh 设置遮光器放缩
         * @param index 唯一索引
         * @param x X放缩值
         * @param y Y放缩值
         * @returns 遮光器对象（成功），undefined（失败）
         */
        setScale(index: number, x: number, y: number): LightOccluder2DCore;
        /**
         * @en Remove the occluder
         * @param index Unique index
         * @returns true (successful), false(failed)
         * @zh 删除指定遮光器
         * @param index 唯一索引
         * @returns true（成功），false（失败）
         */
        removeOccluder(index: number): boolean;
        /**
         * @en Clear all occluders
         * @zh 清除所有遮光器
         */
        clearOccluder(): void;
    }
    /**
     * 二维点集（可用于表示多边形）
     */
    class PolygonPoint2D {
        private _points;
        constructor(points?: number[]);
        /**
         * @en The points
         * @zh 点集
         */
        get points(): number[];
        set points(value: number[]);
        /**
         * @en Add point
         * @param x
         * @param y
         * @param index Insert position，-1 is to last
         * @zh 添加顶点
         * @param x
         * @param y
         * @param index 插入位置，-1代表插入最后
         */
        addPoint(x: number, y: number, index?: number): void;
        /**
         * @en Update point
         * @param x
         * @param y
         * @param index Update position
         * @zh 更新顶点
         * @param x
         * @param y
         * @param index 更新位置
         */
        updatePoint(x: number, y: number, index: number): void;
        /**
         * @en Remove point
         * @param index Remove position
         * @zh 删除顶点
         * @param index 删除位置
         */
        removePoint(index: number): void;
        /**
         * @en Clear points
         * @zh 清空顶点
         */
        clear(): void;
        /**
         * @en Clone object
         * @zh 克隆对象
         */
        clone(): PolygonPoint2D;
        /**
         * @en Clone object
         * @param other
         * @zh 克隆对象
         * @param other
         */
        cloneTo(other: PolygonPoint2D): PolygonPoint2D;
    }
    class LightAndShadow {
        static __init__(): void;
    }
    /**
     * 用于生成光影图
     */
    class LightAndShadowGenShader2D {
        static renderShader: Shader3D;
        static readonly RenderUniform: UniformMapType;
        static readonly RenderAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        static __init__(): void;
    }
    /**
     * 用于生成灯光图（SpotLight，FreeformLight）
     */
    class LightGenShader2D {
        static renderShader: Shader3D;
        static readonly RenderAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        static __init__(): void;
    }
    /**
     * 用于在光影图上叠加阴影亮度和颜色（如果阴影没有亮度和颜色，可以不用执行该生成步骤）
     */
    class ShadowGenShader2D {
        static renderShader: Shader3D;
        static readonly RenderUniform: UniformMapType;
        static readonly RenderAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        static __init__(): void;
    }
    /**
     * 用于显示渲染目标
     */
    class ShowRenderTarget {
        private _sprite;
        private _render;
        constructor(scene: Scene, tex: BaseTexture, x: number, y: number, width: number, height: number);
        /**
         * @en Set render target
         * @zh 设置待显示的渲染目标
         * @param rt
         */
        setRenderTarget(rt: BaseTexture): void;
        /**
         * @en Generate the mesh
         * @zh 生成网格
         */
        private _genMesh;
    }
    /**
     * 聚灯光
     */
    class SpotLight2D extends BaseLight2D {
        private _innerRadius;
        private _outerRadius;
        private _innerAngle;
        private _outerAngle;
        private _falloffIntensity;
        private _cmdBuffer;
        private _cmdRT;
        private _cmdMesh;
        private _material;
        readonly owner: Sprite;
        constructor(innerRadius?: number, outerRadius?: number, innerAngle?: number, outerAngle?: number, falloff?: number);
        /**
         * @en Get inner circle radius
         * @zh 获取内圆半径
         */
        get innerRadius(): number;
        /**
         * @en Set inner circle radius
         * @param value Radius value
         * @zh 设置内圆半径
         * @param value 半径值
         */
        set innerRadius(value: number);
        /**
         * @en Get outer circle radius
         * @zh 获取外圆半径
         */
        get outerRadius(): number;
        /**
         * @en Set outer circle radius
         * @param value Radius value
         * @zh 设置外圆半径
         * @param value 半径值
         */
        set outerRadius(value: number);
        /**
         * @en Get inner fan angle
         * @zh 获取内扇形张角
         */
        get innerAngle(): number;
        /**
         * @en Set inner fan angle
         * @param value Angle value
         * @zh 设置内扇形张角
         * @param value 角度值
         */
        set innerAngle(value: number);
        /**
         * @en Get outer fan angle
         * @zh 获取外扇形张角
         */
        get outerAngle(): number;
        /**
         * @en Set outer fan angle
         * @param value Angle value
         * @zh 设置外扇形张角
         * @param value 角度值
         */
        set outerAngle(value: number);
        /**
         * @en Get the edge attenuation coefficient
         * @zh 获取边缘衰减系数
         */
        get falloffIntensity(): number;
        /**
         * @en Set the edge attenuation coefficient
         * @param value Attenuation value
         * @zh 设置边缘衰减系数
         * @param value 衰减系数值
         */
        set falloffIntensity(value: number);
        /**
         * 计算灯光范围（局部坐标）
         */
        protected _calcLocalRange(): void;
        /**
         * 计算灯光范围（世界坐标）
         * @param screen
         */
        protected _calcWorldRange(screen?: Rectangle): void;
        /**
         * @en notify this light antiAlias change
         * @zh 通知此灯的抗锯齿设置发生改变
         */
        protected _notifyAntiAliasChange(): void;
        /**
         * 创建渲染灯光的贴图
         * @param width
         * @param height
         */
        private _buildRenderTexture;
        /**
         * @en Render light texture
         * @zh 渲染灯光贴图
         */
        renderLightTexture(): void;
        /**
         * 限制参数范围
         */
        private _limitParam;
        /**
         * 创建灯光多边形
         * @param mesh
         * @param recover
         */
        private _createMesh;
        /**
         * 销毁
         */
        protected _onDestroy(): void;
    }
    /**
     * 精灵灯光
     */
    class SpriteLight2D extends BaseLight2D {
        readonly owner: Sprite;
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Set the sprite texture
         * @param value Texture object
         * @zh 设置精灵贴图
         * @param value 贴图对象
         */
        set spriteTexture(value: Texture2D);
        /**
         * @en Get the sprite texture
         * @zh 获取精灵贴图
         */
        get spriteTexture(): Texture2D;
        /**
         * @internal
         * 计算灯光范围（局部坐标）
         */
        protected _calcLocalRange(): void;
        /**
         * 计算灯光范围（世界坐标）
         * @param screen 屏幕位置和尺寸
         */
        protected _calcWorldRange(screen?: Rectangle): void;
        /**
         * @en Render light texture
         * @zh 渲染灯光贴图
         */
        renderLightTexture(): void;
        /**
         * 销毁
         */
        protected _onDestroy(): void;
    }
    class Draw2DLineCMD extends Command2D {
        private static readonly _pool;
        static create(pointArray: number[], mat: Matrix, color?: Color, lineWidth?: number): Draw2DLineCMD;
        private _drawElementData;
        _line2DRender: Line2DRender;
        private _needUpdateElement;
        private _matrix;
        private _shaderData;
        private _struct;
        constructor();
        _setMatrix(value: Matrix): void;
        /**
       * @override
       * @internal
       * @returns
       */
        getRenderCMD(): Draw2DElementCMD;
        /**
         * @en Runs the  command.
         * @zh 运行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the render command for reuse.
         * @zh 回收渲染命令以供重用。
         */
        recover(): void;
    }
    class Line2DRender extends BaseRenderNode2D {
        private static defaultLine2DMaterial;
        /**
         * @internal
         */
        static _createDefaultLineMaterial(): void;
        private _color;
        private _baseRender2DTexture;
        private _positions;
        private _isdashed;
        private _tillOffset;
        private _dashedValue;
        private _needUpdate;
        private _maxLineNumer;
        private _enLarge;
        private _lineWidth;
        private _renderGeometry;
        private _positionInstansBufferData;
        private _positionVertexBuffer;
        private _lineLengthBufferData;
        private _lineLengthVertexBuffer;
        /**
         * @en Set the line segment data in the format [beginX, beginY, endX, endY, beginX, beginY, endX, endY, beginX, beginY, endX, endY...].Data must be in multiples of 4
         * @zh 设置线段数据,格式为[beginX,beginY,endX,endY,beginX,beginY,endX,endY,beginX,beginY,endX,endY...],数据必须是4的倍数
         */
        get positions(): number[];
        set positions(value: number[]);
        /**
         * @en The width of the line segment, in pixels.
         * @zh 线段宽度，单位为像素
         */
        get lineWidth(): number;
        set lineWidth(value: number);
        /**
         * @en The color of the line segment.
         * @zh 线段颜色
         */
        set color(value: Color);
        get color(): Color;
        /**
         * @en Whether to enable dashed mode.
         * @zh 是否启用虚线模式
         */
        set enableDashedMode(value: boolean);
        get enableDashedMode(): boolean;
        /**
         * @en The length of the dashed line, in pixels.
         * @zh 虚线长度，单位为像素
         */
        set dashedLength(value: number);
        get dashedLength(): number;
        /**
         * @en The percentage of the dashed line that is a solid line, ranging from 0 to 1.
         * @zh 实段占虚线间隔的百分比，取值范围0-1
         */
        set dashedPercent(value: number);
        get dashedPercent(): number;
        /**
         * @en The offset of the dashed line, in pixels.
         * @zh 虚线偏移量，单位为像素
         */
        set dashedOffset(value: number);
        get dashedOffset(): number;
        /**
        * @en Rendering textures will not take effect if there is no UV in 2dmesh
        * @zh 渲染纹理，如果2DMesh中没有uv，则不会生效
        */
        set texture(value: BaseTexture);
        get texture(): BaseTexture;
        /**
         * @en Set the tiling offset of the texture.
         * @zh 设置纹理tiling偏移量
         */
        set tillOffset(value: Vector4);
        get tillOffset(): Vector4;
        /**
       * @en Render material
       * @zh 渲染材质
       */
        set sharedMaterial(value: Material);
        private _updateDashValue;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * 基于不同BaseRender的uniform集合
         * @internal
         */
        protected _getcommonUniformMap(): Array<string>;
        protected _initDefaultRenderData(): void;
        /**
         * @internal
         */
        private _changeGeometry;
        /**
         * @en Add a line segment.
         * @param startx  starting x position
         * @param starty  starting y position
         * @param endx  ending x position
         * @param endy  ending y position
         * @zh 添加线段
         * @param startx 起点x
         * @param starty 起点y
         * @param endx 终点x
         * @param endy 终点y
         */
        addPoint(startx: number, starty: number, endx: number, endy: number): void;
        /**
         * @en Clear all line segments.
         * @zh 清空线段
         */
        clear(): void;
        onPreRender(): void;
        /** @internal */
        _initRender(): void;
        /**@ignore */
        constructor();
    }
    class LineShader {
        static LINEWIDTH: number;
        static DASHED: number;
        static TILINGOFFSET: number;
        static linePoisitionDesc: VertexDeclaration;
        static lineLengthDesc: VertexDeclaration;
        /**
         * @internal
         */
        static _vbs: IVertexBuffer;
        /**
         * @internal
         */
        static _ibs: IIndexBuffer;
        private static _isInit;
        static __init__(): void;
    }
    class HierarchyLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<Prefab>;
        protected _load(api: IHierarchyParserAPI, task: ILoadTask, data: any, fromDCC: boolean): Promise<Prefab>;
    }
    class HierarchyParser {
        static parse(data: any, options?: Record<string, any>, errors?: Array<any>): Array<Node>;
        static collectResourceLinks(data: any, basePath: string): (string | ILoadURL)[];
    }
    class LoadModel2DV01 {
        /**@internal */
        private static _BLOCK;
        /**@internal */
        private static _DATA;
        /**@internal */
        private static _strings;
        /**@internal */
        private static _readData;
        /**@internal */
        private static _version;
        /**@internal */
        private static _mesh;
        /**@internal */
        private static _subMeshes;
        /**
         * @internal
         */
        static parse(readData: Byte, version: string, mesh: Mesh2D, subMeshes: IRenderGeometryElement[]): void;
        /**
         * @internal
         */
        private static _readString;
        /**
         * @internal
         */
        private static READ_DATA;
        /**
         * @internal
         */
        private static READ_BLOCK;
        /**
         * @internal
         */
        private static READ_STRINGS;
        /**
         * @internal
         */
        private static READ_MESH;
        /**
         * @internal
         */
        private static READ_SUBMESH;
    }
    class MaterialLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
        private load2;
        private move;
    }
    class MaterialParser {
        static parse(data: any): Material;
        static collectLinks(data: any, basePath: string): ILoadURL[];
        /**
         * @deprecated
         * @inheritDoc
         */
        static parseLegacy(data: any): Material;
        /**
            * @deprecated
            * 兼容Blend数据
            */
        private static _getRenderStateParams;
    }
    interface IMeshReaderAPI {
        /**解析 */
        parse(readData: Byte, version: string): Resource;
    }
    class MeshLoader implements IResourceLoader {
        static v3d: IMeshReaderAPI;
        static v2d: IMeshReaderAPI;
        load(task: ILoadTask): Promise<Resource>;
        _parse(task: ILoadTask, data: ArrayBuffer): Resource;
    }
    class Mesh2DReader {
        static parse(readData: Byte, version: string): Mesh2D;
    }
    class NullLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
    }
    class ObjDecoder {
        errors: Array<any>;
        getNodeByRef: (id: string | string[]) => Node;
        getNodeData: (node: Node) => any;
        static decodeObj(data: any, obj?: any): any;
        decodeObj(data: any, obj?: any, excludeKeys?: Set<string>): any;
        decodeObjBounds(data: any, obj: Sprite): void;
        private _decode;
    }
    const TypedArrayClasses: Record<string, any>;
    class SerializeUtil {
        static isDeserializing: boolean;
        static _data: any;
        static hasProp(...keys: string[]): boolean;
        static decodeObj(data: any, obj?: any): any;
        static getLoadTypeByEngineType(type: string): string;
        static bakeOverrideData(overrideData: any): Record<string, any[]>;
        static applyOverrideData(nodeData: any, overrideDataMap: Record<string, Array<any>>): any;
    }
    class ShaderParser {
        static parse(data: string, basePath?: string): Shader3D;
        static compileToTree(sliceFlag: string[], data: string, sliceIndex: number): string[];
        static getMapKey(value: string): string;
        /**
         * get Shader Data
         */
        static getShaderBlock(source: string): IShaderObjStructor;
        /**
         * get CG data for map
         * @param source
         * @returns
         */
        static getCGBlock(source: string): {
            [key: string]: string;
        };
        static bindCG(shaderObj: IShaderObjStructor, cgmap: {
            [key: string]: string;
        }): void;
        /**
         * trans string to ShaderDataType
         * @param value
         * @returns
         */
        static getShaderDataType(value: string): ShaderDataType;
        /**
         * set ShaderData Value
         * @param type
         * @param data
         * @returns
         */
        static getDefaultData(type: ShaderDataType, data: any): any;
    }
    class Texture2DLoader implements IResourceLoader {
        constructor();
        load(task: ILoadTask): Promise<BaseTexture>;
        protected load2(task: ILoadTask, meta: any): Promise<BaseTexture>;
        protected move(obsoluteInst: BaseTexture, tex: BaseTexture): BaseTexture;
    }
    class RenderTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<RenderTexture>;
    }
    class VideoTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<VideoTexture>;
    }
    class TextureLoader implements IResourceLoader {
        wrapTex2D(task: ILoadTask, tex2D: Texture2D): Texture;
        load(task: ILoadTask): Promise<Texture>;
    }
    /**
     * @en Utility class for calculating Bezier curves.
     * @zh 计算贝塞尔曲线的工具类。
     */
    class Bezier {
        /**
         * @en Get points on the Bezier curve.
         * @param pList Control points [x0,y0,x1,y1...]
         * @param inSertCount The number of interpolation points for each curve segment
         * @param count The order of the Bezier curve (2 for quadratic, 3 for cubic)
         * @returns An array of points on the Bezier curve
         * @zh 获取贝塞尔曲线上的点。
         * @param pList 控制点[x0,y0,x1,y1...]
         * @param inSertCount 每次曲线的插值数量
         * @param count 贝塞尔曲线的阶数（2表示二次曲线，3表示三次曲线）
         * @returns 贝塞尔曲线上的点组成的数组
         */
        static getPoints(pList: number[], inSertCount?: number, count?: number, out?: number[]): number[];
        /**
         * @en Get the interpolated y-value on a special cubic Bezier curve at a given progress t.
         * This curve is defined with fixed start point P0(0,0) and end point P3(1,1), commonly used for easing functions in animations.
         * @param t The progress parameter, between 0 and 1, where 0 represents the start of the curve and 1 represents the end.
         * @param px0 X-coordinate of the first control point P1.
         * @param py0 Y-coordinate of the first control point P1.
         * @param px1 X-coordinate of the second control point P2.
         * @param py1 Y-coordinate of the second control point P2.
         * @returns The interpolated y-value at the given progress t. This value represents the state of an animated property at that point in the animation.
         * If t is greater than the x-coordinate of all sampled points, it returns 1.
         * @zh 获取特殊三次贝塞尔曲线在给定进度 t 的插值 y 值。
         * 这条曲线的起点 P0 固定为 (0,0)，终点 P3 固定为 (1,1)，通常用于定义动画的缓动函数。
         * @param t 进度参数，在 0 到 1 之间，其中 0 表示曲线的起点，1 表示曲线的终点。
         * @param px0 第一个控制点 P1 的 X 坐标。
         * @param py0 第一个控制点 P1 的 Y 坐标。
         * @param px1 第二个控制点 P2 的 X 坐标。
         * @param py1 第二个控制点 P2 的 Y 坐标。
         * @returns 在给定进度 t 的插值 y 值。这个值表示动画属性在动画过程中的某个状态。
         * 如果 t 大于所有采样点的 x 坐标，则返回 1。
         */
        static getRate(t: number, px0: number, py0: number, px1: number, py1: number): number;
    }
    class BooleanKeyframe extends Keyframe {
        /**
         * @en The value of the keyframe.
         * @zh 关键帧的值。
         */
        value: boolean;
        /**
         * @inheritDoc
         * @override
         * @en Clones the data to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆数据到目标对象。
         * @param destObject 拷贝数据结构
         */
        cloneTo(destObject: BooleanKeyframe): void;
        /**
         * @en Clones.
         * @zh 克隆
         */
        clone(): BooleanKeyframe;
    }
    /**
     * @en The Color class is used to create color instances.
     * @zh Color类用于创建颜色实例。
     */
    class Color implements IClone {
        /**
         * @en Red color
         * @zh 红色
         */
        static readonly RED: Readonly<Color>;
        /**
         * @en Green color
         * @zh 绿色
         */
        static readonly GREEN: Readonly<Color>;
        /**
         * @en Blue color
         * @zh 蓝色
         */
        static readonly BLUE: Readonly<Color>;
        /**
         * @en Cyan color
         * @zh 蓝绿色
         */
        static readonly CYAN: Readonly<Color>;
        /**
         * @en Yellow color
         * @zh 黄色
         */
        static readonly YELLOW: Readonly<Color>;
        /**
         * @en Magenta color
         * @zh 品红色
         */
        static readonly MAGENTA: Readonly<Color>;
        /**
         * @en Gray color
         * @zh 灰色
         */
        static readonly GRAY: Readonly<Color>;
        /**
         * @en White color
         * @zh 白色
         */
        static readonly WHITE: Readonly<Color>;
        /**
         * @en Black color
         * @zh 黑色
         */
        static readonly BLACK: Readonly<Color>;
        /**
         * @en Fully transparent
         * @zh 全透明
         */
        static readonly CLEAR: Readonly<Color>;
        /**
        * @en Converts an unsigned integer color value to a string representation.
        * @param color The color value.
        * @returns A string representation of the color value.
        * @zh 将 uint 类型的颜色值转换为字符串型颜色值。
        * @param color 颜色值。
        * @return 字符串型颜色值。
        */
        static hexToString(color: number): string;
        /**
         * @en Converts a string color value to a number color.
         * @param value The string color value.
         * @returns The color value as a number, in the format 0xrrggbb.
         * @zh 将字符串型颜色值转换为数字型颜色值。
         * @param value 字符串颜色值
         * @returns 作为数字的颜色值，格式0xrrggbb。
         */
        static stringToHex(value: string): number;
        /**
         * @en Convert gamma space value to linear space.
         * @param value The value in gamma space.
         * @returns The value in linear space.
         * @zh 将 Gamma 空间值转换为线性空间值。
         * @param value Gamma 空间值。
         * @returns 线性空间值。
         */
        static gammaToLinearSpace(value: number): number;
        /**
         * @en Convert linear space value to gamma space.
         * @param value The value in linear space.
         * @returns The value in gamma space.
         * @zh 将线性空间值转换为 Gamma 空间值。
         * @param value 线性空间值。
         * @returns Gamma 空间值。
         */
        static linearToGammaSpace(value: number): number;
        /**
         * @en Red component
         * @zh 红色分量
         */
        r: number;
        /**
         * @en Green component
         * @zh 绿色分量
         */
        g: number;
        /**
         * @en Blue component
         * @zh 蓝色分量
         */
        b: number;
        /**
         * @en Alpha component
         * @zh 透明度分量
         */
        a: number;
        /**
         * @en Constructor method Color.
         * @param r Red component (0-1).
         * @param g Green component (0-1).
         * @param b Blue component (0-1).
         * @param a Alpha component (0-1).
         * @zh 构造函数,初始化颜色实例。
         * @param r 红色分量（0-1）。
         * @param g 绿色分量（0-1）。
         * @param b 蓝色分量（0-1）。
         * @param a 透明度分量（0-1）。
         */
        constructor(r?: number, g?: number, b?: number, a?: number);
        /**
         * @en Check if two colors are equal.
         * @param c The color to compare with.
         * @returns True if the colors are equal, false otherwise.
         * @zh 判断两个颜色是否相等。
         * @param c 要比较的颜色。
         * @returns 如果颜色相等则返回 true，否则返回 false。
         */
        equal(c: Color): boolean;
        /**
         * @en parse a color string or a hex color value.
         * @param value The color string or the hex color value.
         * String formats can be "#RRGGBB", "#RRGGBBAA", "rgb(r,g,b)", "rgba(r,g,b,a)".
         * Number format is a hex color value, i.e., #RRGGBB.
         * @zh 解析颜色值，可以传入一个颜色字符串或十六进制颜色值。
         * 字符串格式可以是：0xRRGGBB、"#RRGGBB"、"#RGB"、"#RRGGBBAA"、"rgb(r,g,b)"、"rgba(r,g,b,a)"。
         * 数字格式是十六进制颜色值，即#RRGGBB。
         * @param value 颜色字符串或十六进制颜色值。
         */
        parse(value: string | number | null): this;
        /**
         * @en Convert from gamma space to linear space.
         * @param out The output color in linear space.
         * @zh 从 Gamma 空间转换到线性空间。
         * @param out 输出的线性空间颜色。
         */
        toLinear(out: Color): void;
        /**
         * @en Convert from linear space to gamma space.
         * @param out The output color in gamma space.
         * @zh 从线性空间转换到 Gamma 空间。
         * @param out 输出的 Gamma 空间颜色。
         */
        toGamma(out: Color): void;
        /**
         * @en Clone the color to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆颜色到目标对象。
         * @param destObject 目标克隆对象。
         */
        cloneTo(destObject: Color): void;
        /**
         * @en Scale the color.
         * @param value The scale value.
         * @returns The scaled color.
         * @zh 缩放颜色。
         * @param value 缩放值。
         * @returns 缩放后的颜色。
         */
        scale(value: number): Color;
        /**
         * @en Set the color components (0-1).
         * @param r Red component.
         * @param g Green component.
         * @param b Blue component.
         * @param a Alpha component.
         * @zh 设置颜色分量（0-1）。
         * @param r 红色分量。
         * @param g 绿色分量。
         * @param b 蓝色分量。
         * @param a 透明度分量。
         */
        setValue(r: number, g: number, b: number, a: number): Color;
        /**
         * @en Convert from Array to color.
         * @param array The source array.
         * @param offset The offset of the array.
         * @zh 从Array数组拷贝值。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * @en Convert to Array.
         * @returns An array representing the color [r, g, b, a].
         * @zh 转换为Array数组
         * @returns 表示颜色的数组 [r, g, b, a]。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the color rgb values to a array.
         * @param arr The target array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将颜色rgb数值写入数组。
         * @zh arr 目标数组。
         * @zh offset 数组偏移。默认值为 0。
         */
        writeTo(arr: {
            [n: number]: number;
        }, offset?: number): void;
        /**
         * @en Clone the color.
         * @returns The cloned color.
         * @zh 克隆颜色。
         * @returns 克隆副本。
         */
        clone(): Color;
        /**
         * @en Get the hex value of the color.
         * @returns The hex value of the color in 0xRRGGBB format.
         * @zh 获取颜色的十六进制值。
         * @returns 颜色的十六进制值，以 0xRRGGBB 格式表示。
         */
        getRGB(): number;
        setRGB(value: number): void;
        /**
         * @en Get the hex value of the color.
         * @returns The hex value of the color in 0xAARRGGBB format.
         * @zh 获取颜色的十六进制值。
         * @returns 颜色的十六进制值，以 0xAARRGGBB 格式表示。
         */
        getARGB(): number;
        /**
         * @en Get the hex value of the color.
         * @returns The hex value of the color in 0xAABBGGRR format.
         * @zh 获取颜色的十六进制值。
         * @returns 颜色的十六进制值，以 0xAABBGGRR 格式表示。
         */
        getABGR(): number;
        /**
         * @en Set the color from a hex value in 0xAABBGGRR format.
         * @param value The hex value of the color in 0xAABBGGRR format.
         * @zh 设置颜色值，格式为0xAABBGGRR。
         * @param value 颜色值，格式为0xAABBGGRR。
         */
        setABGR(value: number): void;
        /**
         * @en Get the string representation of the color, format "#RRGGBB".
         * @returns The string representation of the color.
         * @zh 返回颜色字符串表示, 以"#RRGGBB"格式。
         * @returns 颜色字符串。
         */
        toString(): string;
        /**
         * @en Get the string representation of the color, if alpha is 1, format "#RRGGBB", else format "rgba(r,g,b,a)".
         * @returns The string representation of the color.
         * @zh 返回颜色字符串表示，如果透明度为1，格式为"#RRGGBB"，否则格式为"rgba(r,g,b,a)"。
         * @returns 颜色字符串。
         */
        getStyleString(): string;
    }
    /**
     * @en The `FloatKeyframe` class is used to create floating-point keyframe instances.
     * @zh `FloatKeyframe` 类用于创建浮点关键帧实例。
     */
    class FloatKeyframe extends Keyframe {
        /**
         * @en The in-tangent of the keyframe.
         * @zh 关键帧的内切线。
         */
        inTangent: number;
        /**
         * @en The out-tangent of the keyframe.
         * @zh 关键帧的外切线。
         */
        outTangent: number;
        /**
         * @en The value of the keyframe.
         * @zh 关键帧的值。
         */
        value: number;
        /**
         * @en The in-weight of the keyframe. Default is Keyframe.defaultWeight.
         * @zh 关键帧的内权重。默认值为 Keyframe.defaultWeight。
         */
        inWeight: number;
        /**
         * @en The out-weight of the keyframe. Default is Keyframe.defaultWeight.
         * @zh 关键帧的外权重。默认值为 Keyframe.defaultWeight。
         */
        outWeight: number;
        /**
         * @en The weighted mode of the keyframe. Default is WeightedMode.None.
         * @zh 关键帧的权重模式。默认值为 WeightedMode.None。
         */
        weightedMode: number;
        /**
         * @ignore
         * @en Creates an instance of `FloatKeyframe`.
         * @zh 创建一个 `FloatKeyframe` 的实例。
         */
        constructor();
        /**
         * @inheritDoc
         * @override
         * @en Clones the data to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆数据到目标对象。
         * @param destObject 拷贝数据结构
         */
        cloneTo(destObject: FloatKeyframe): void;
        /**
         * @en Clones.
         * @zh 克隆
         */
        clone(): FloatKeyframe;
    }
    /**
     * @en The `Gradient` class is used to create color gradients.
     * @zh `Gradient` 类用于创建颜色渐变。
     */
    class Gradient implements IClone {
        private _mode;
        private _maxColorRGBKeysCount;
        get maxColorRGBKeysCount(): number;
        private _colorRGBKeysCount;
        /**
         * @en Get the count of color RGB keys.
         * @returns The count of color RGB keys.
         * @zh 获取颜色 RGB 数量。
         * @returns 颜色 RGB 数量。
         */
        get colorRGBKeysCount(): number;
        /**@internal */
        _rgbElementDatas: Float32Array;
        /**
         * @internal
         * rgb 数据 保存设置值
         */
        get _rgbElements(): Float32Array;
        /**
         * @internal
         * rgb 数据 保存设置值
         */
        set _rgbElements(value: Float32Array);
        private _maxColorAlphaKeysCount;
        get maxColorAlphaKeysCount(): number;
        private _colorAlphaKeysCount;
        /**
         * 获取颜色Alpha数量。
         * @return 颜色Alpha数量。
         */
        get colorAlphaKeysCount(): number;
        /**@internal */
        _alphaElementDatas: Float32Array;
        /**
         * @internal
         * alpha 保存设置值
         */
        get _alphaElements(): Float32Array;
        /**
         * @internal
         * alpha 保存设置值
         */
        set _alphaElements(value: Float32Array);
        get maxColorKeysCount(): number;
        /**
         * @internal
         * @en element key range
         * x: colorkey min
         * y: colorkey max
         * z: alphakey min
         * w: alphakey max
         * @zh 元素键值范围
         * x: 颜色最小值
         * y: 颜色最大值
         * z: 透明度最小值
         * w: 透明度最大值
         */
        _keyRanges: Vector4;
        /**
         * @en Get the gradient mode.
         * @returns The gradient mode.
         * @zh 获取梯度模式。
         * @returns 梯度模式。
         */
        get mode(): number;
        /**
         * @en Set the gradient mode.
         * @param value The gradient mode.
         * @zh 设置梯度模式。
         * @param value 梯度模式。
         */
        set mode(value: number);
        /**
         * @ignore
         */
        constructor();
        /**
         * @en Add a color RGB key.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The RGB value.
         * @zh 增加颜色 RGB 帧。
         * @param key 生命周期，范围为 0 到 1。
         * @param value RGB 值。
         */
        addColorRGB(key: number, value: Color): void;
        /**
         * @en Add a color Alpha key.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The Alpha value.
         * @zh 增加颜色 Alpha 帧。
         * @param key 生命周期，范围为 0 到 1。
         * @param value Alpha 值。
         */
        addColorAlpha(key: number, value: number): void;
        /**
         * @en Update a color RGB key.
         * @param index The index.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The RGB value.
         * @zh 更新颜色 RGB 帧。
         * @param index 索引。
         * @param key 生命周期，范围为 0 到 1。
         * @param value RGB 值。
         */
        updateColorRGB(index: number, key: number, value: Color): void;
        /**
         * @en Update a color Alpha key.
         * @param index The index.
         * @param key The lifetime, ranging from 0 to 1.
         * @param value The Alpha value.
         * @zh 更新颜色 Alpha 帧。
         * @param index 索引。
         * @param key 生命周期，范围为 0 到 1。
         * @param value Alpha 值。
         */
        updateColorAlpha(index: number, key: number, value: number): void;
        /**
         * @en Get RGB color through interpolation.
         * @param lerpFactor Interpolation factor, clamped between 0 and 1.
         * @param out The resulting color.
         * @param startSearchIndex The starting search index. Default is 0.
         * @param reverseSearch Whether to perform reverse interpolation. Default is false.
         * @returns The current index after interpolation.
         * @zh 通过插值获取RGB颜色。
         * @param lerpFactor 插值因子，取值范围在0到1之间。
         * @param out 颜色结果。
         * @param startSearchIndex 开始查找索引。默认为0。
         * @param reverseSearch 是否进行反向插值。默认为false。
         * @returns 插值后的当前索引。
         */
        evaluateColorRGB(lerpFactor: number, out: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * @en Get the alpha value through interpolation.
         * @param lerpFactor The interpolation factor.
         * @param outColor The resulting color.
         * @param startSearchIndex The starting search index. Default is 0.
         * @param reverseSearch Whether to perform reverse interpolation. Default is false.
         * @returns The resulting index.
         * @zh 通过插值获取透明值。
         * @param lerpFactor 插值因子。
         * @param outColor 颜色结果。
         * @param startSearchIndex 开始查找索引。默认为0。
         * @param reverseSearch 是否反向插值。默认为false。
         * @returns 结果索引。
         */
        evaluateColorAlpha(lerpFactor: number, outColor: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * 更新 GPU data array
         * @param data GPU data array
         * @param elements 原始数据
         * @param dateLength GPU data length
         */
        private _updateGpuData;
        private _fixGPUAlphaData;
        private _fixGPURGBData;
        private _gpuRGBData4;
        /**
         * @internal
         * 获取 GPU rgb data
         * 并更新数据
         * @returns
         */
        _getGPURGBData4(): Float32Array;
        private _gpuRGBData8;
        /**
         * @internal
         * 获取 GPU rgb data
         * 并更新数据
         * @returns
         */
        _getGPURGBData8(): Float32Array;
        private _gpuAlphaData4;
        /**
         * @internal
         * 获取 GPU alpha data
         * 并更新数据
         * @returns
         */
        _getGPUAlphaData4(): Float32Array;
        private _gpuAlphaData8;
        /**
         * @internal
         * 获取 GPU alpha data
         * 并更新数据
         * @returns
         */
        _getGPUAlphaData8(): Float32Array;
        /**
         * @en Clone.
         * @param destObject The destination object to clone to.
         * @zh 克隆。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Gradient): void;
        /**
         * @en Clone the gradient.
         * @returns A clone of the gradient.
         * @zh 克隆渐变。
         * @returns 克隆的副本。
         */
        clone(): Gradient;
    }
    /**
     * @en The gradient mode.
     * @zh  渐变模式
     */
    class GradientMode {
        /**
         * @en Finds the two keys adjacent to the requested evaluation time and linearly interpolates between them to obtain a blended color.
         * @zh 找到与请求的评估时间相邻的两个键,并线性插值在他们之间,以获得一种混合的颜色。
         */
        static Blend: number;
        /**
         * @en Returns a fixed color by finding the first key with a time value greater than the requested evaluation time.
         * @zh 返回一个固定的颜色，通过查找第一个键的时间值大于所请求的评估时间。
         */
        static Fixed: number;
    }
    /**
     * @en Graham Scan algorithm for convex hull calculation.
     * @zh 凸包算法。
     */
    class GrahamScan {
        /**
         * @en Find the minimum polygon vertex set that includes all points.
         * @param pList The [x,y...] list.
         * @param out The output array to store the result. If not provided, a new array will be created.
         * @returns The minimum polygon vertex set.
         * @zh 寻找包括所有点的最小多边形顶点集合。
         * @param pList 形如[x0,y0,x1,y1...]的点列表。
         * @param out 输出数组，用于存储结果。如果未提供，将创建一个新数组。
         * @returns 最小多边形顶点集合。
         */
        static scanPList(pList: ReadonlyArray<number>, out?: number[]): number[];
        /**
         * @en Find the minimum polygon vertex set that includes all points.
         * @param points The Point list.
         * @returns The minimum polygon vertex set.
         * @zh 寻找包括所有点的最小多边形顶点集合。
         * @param points Point列表。
         * @return 最小多边形顶点集合。
         */
        static scan(points: ReadonlyArray<Point>, out?: Point[]): Point[];
    }
    /**
     * @en Animation weight mode
     * @zh 动画权重模式
     */
    enum WeightedMode {
        None = 0,
        In = 1,
        Out = 2,
        Both = 3
    }
    /**
     * @en The `Keyframe` class is used to create keyframe instances.
     * @zh `Keyframe` 类用于创建关键帧实例。
     */
    class Keyframe implements IClone {
        /**
         * @en The default weight value for keyframes.
         * @zh 关键帧的默认权重值。
         */
        static defaultWeight: number;
        /**
         * @en The time of the keyframe.
         * @zh 关键帧的时间。
         */
        time: number;
        /** @ignore */
        constructor();
        /**
         * @en Source of the keyframe.
         * @param destObject The target object to clone to.
         * @zh 克隆到另一个对象。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: Keyframe): void;
        /**
         * @en Creates a clone of the current keyframe.
         * @returns A clone of the current keyframe.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): Keyframe;
    }
    /**
     * @en The MathUtil class is a utility class for data processing.
     * @zh MathUtil 是一个数据处理工具类。
     * @blueprintable @blueprintPure
     */
    class MathUtil {
        /**
         * @en Performs linear interpolation between two values.
         * @param left The start value.
         * @param right The end value.
         * @param amount The interpolation amount (0-1).
         * @returns The interpolated value.
         * @zh 在两个值之间进行线性插值。
         * @param left 起始值。
         * @param right 终止值。
         * @param amount 插值比率（0-1）。
         * @returns 插值结果。
         */
        static lerp(left: number, right: number, amount: number): number;
        /**
         * @en Repeats a value `t` within the range of `0` to `length`.
         *
         * This function calculates the remainder of `t` divided by `length`,
         * effectively wrapping `t` around within the interval `[0, length)`.
         *
         * @param t - The value to be repeated.
         * @param length - The length of the interval within which to repeat the value.
         * @returns The repeated value within the interval `[0, length)`.
         * @zh 重复一个值 `t`，使其范围限定在 `0` 到 `length` 之间。
         * @param t - 要重复的值。
         * @param length - 要重复的范围长度。
         * @returns 重复的值，其范围在 `[0, length)` 之间。
         */
        static repeat(t: number, length: number): number;
        /**
         * @en Calculates the distance between two points (x1, y1) and (x2, y2) in a 2D space.
         * @param x1 - The x-coordinate of the first point.
         * @param y1 - The y-coordinate of the first point.
         * @param x2 - The x-coordinate of the second point.
         * @param y2 - The y-coordinate of the second point.
         * @returns The distance between the two points.
         * @zh 计算二维空间中两点 (x1, y1) 和 (x2, y2) 之间的距离。
         * @param x1 第一个点的 X 坐标。
         * @param y1 第一个点的 Y 坐标。
         * @param x2 第二个点的 X 坐标。
         * @param y2 第二个点的 Y 坐标。
         * @returns 两点之间的距离。
         */
        static distance(x1: number, y1: number, x2: number, y2: number): number;
        /**
         * @en Clamps a value between a minimum float and maximum float value.
         * @param value The value to clamp.
         * @param min The minimum value. If `value` is less than `min`, `min` is returned.
         * @param max The maximum value. If `value` is greater than `max`, `max` is returned.
         * @returns The clamped value.
         * @zh 将值限制在指定范围内。
         * @param value 要限制的值。
         * @param min 最小值，如果 `value` 小于 `min`，返回 `min`。
         * @param max 最大值，如果 `value` 大于 `max`，返回 `max`。
         * @returns 限制后的值。
         */
        static clamp(value: number, min: number, max: number): number;
        /**
         * @en Clamps a value between 0 and 1.
         * @param value The value to clamp.
         * @returns The clamped value.
         * @zh 将值限制在 0 和 1 之间。
         * @param value 要限制的值。
         * @returns 限制后的值。
         */
        static clamp01(value: number): number;
        /**
         * @en Performs spherical linear interpolation (slerp) between two quaternions.
         * @param a The start quaternion array.
         * @param Offset1 The offset in the start quaternion array.
         * @param b The end quaternion array.
         * @param Offset2 The offset in the end quaternion array.
         * @param t The interpolation amount (0-1).
         * @param out The output quaternion array to store the result.
         * @param Offset3 The offset in the output quaternion array.
         * @returns The output quaternion array.
         * @zh 在两个四元数之间进行球面线性插值（slerp）。
         * @param a 起始四元数数组。
         * @param Offset1 起始四元数数组的偏移量。
         * @param b 终止四元数数组。
         * @param Offset2 终止四元数数组的偏移量。
         * @param t 插值比率（0-1）。
         * @param out 用于存储结果的输出四元数数组。
         * @param Offset3 输出四元数数组的偏移量。
         * @returns 输出四元数数组。
         */
        static slerpQuaternionArray(a: Float32Array, Offset1: number, b: Float32Array, Offset2: number, t: number, out: Float32Array, Offset3: number): Float32Array;
        /**
         * @en Gets the angle value of the line segment formed by two specified points.
         * @param x0 The X coordinate of the first point.
         * @param y0 The Y coordinate of the first point.
         * @param x1 The X coordinate of the second point.
         * @param y1 The Y coordinate of the second point.
         * @returns The angle value in degrees.
         * @zh 获取由两个指定点组成的线段的角度值。
         * @param x0 第一个点的 X 坐标。
         * @param y0 第一个点的 Y 坐标。
         * @param x1 第二个点的 X 坐标。
         * @param y1 第二个点的 Y 坐标。
         * @returns 角度值，单位为度。
         */
        static getRotation(x0: number, y0: number, x1: number, y1: number): number;
        /**
         * @en A comparison function to determine the sorting order of array elements.
         * @param a The first number to compare.
         * @param b The second number to compare.
         * @returns 0 if a equals b, 1 if b > a, -1 if b < a.
         * @zh 一个用来确定数组元素排序顺序的比较函数。
         * @param a 待比较数字。
         * @param b 待比较数字。
         * @returns 如果a等于b 则值为0；如果b>a则值为1；如果b<则值为-1。
         */
        static sortBigFirst(a: number, b: number): number;
        /**
         * @en A comparison function to determine the sorting order of array elements.
         * @param a The first number to compare.
         * @param b The second number to compare.
         * @returns 0 if a equals b, -1 if b > a, 1 if b < a.
         * @zh 一个用来确定数组元素排序顺序的比较函数。
         * @param a 待比较数字。
         * @param b 待比较数字。
         * @returns 如果a等于b 则值为0；如果b>a则值为-1；如果b<则值为1。
         */
        static sortSmallFirst(a: number, b: number): number;
        /**
         * @en Compares the specified elements by converting them to numbers.
         * @param a The first element to compare.
         * @param b The second element to compare.
         * @returns The difference between b and a as numbers (b-a).
         * @zh 将指定的元素转为数字进行比较。
         * @param a 待比较元素。
         * @param b 待比较元素。
         * @returns b、a转化成数字的差值 (b-a)。
         */
        static sortNumBigFirst(a: any, b: any): number;
        /**
         * @en Compares the specified elements by converting them to numbers.
         * @param a The first element to compare.
         * @param b The second element to compare.
         * @returns The difference between a and b as numbers (a-b).
         * @zh 将指定的元素转为数字进行比较。
         * @param a 待比较元素。
         * @param b 待比较元素。
         * @returns a、b转化成数字的差值 (a-b)。
         */
        static sortNumSmallFirst(a: any, b: any): number;
        /**
         * @en Returns a comparison function for sorting objects based on a specified property.
         * @param key The name of the object property to sort by.
         * @param bigFirst If true, sort from big to small; otherwise, sort from small to big.
         * @param forceNum If true, convert the sorting elements to numbers for comparison.
         * @returns The sorting function.
         * @zh 返回根据对象指定的属性进行排序的比较函数。
         * @param key 排序要依据的元素属性名。
         * @param bigFirst 如果值为true，则按照由大到小的顺序进行排序，否则按照由小到大的顺序进行排序。
         * @param forceNum 如果值为true，则将排序的元素转为数字进行比较。
         * @return 排序函数。
         * @blueprintIgnore
         */
        static sortByKey(key: string, bigFirst?: boolean, forceNum?: boolean): (a: any, b: any) => number;
    }
    /**
     * @en The MathUtils3D class is used to create mathematical utilities.
     * @zh MathUtils3D 类用于创建数学工具。
     * @blueprintable
     */
    class MathUtils3D {
        /**
         * @en Tolerance for single-precision floating-point (float) zero.
         * @zh 单精度浮点(float)零的容差。
         */
        static readonly zeroTolerance: number;
        /**
         * @en Default maximum value for floating-point numbers.
         * @zh 浮点数默认最大值。
         */
        static readonly MaxValue: number;
        /**
         * @en Default minimum value for floating-point numbers.
         * @zh 浮点数默认最小值。
         */
        static readonly MinValue: number;
        /**
         * @en Coefficient for converting degrees to radians.
         * @zh 角度转弧度系数。
         */
        static readonly Deg2Rad: number;
        /**
         * @en Determines if a value is approximately zero within the tolerance range.
         * @param v The value to be checked.
         * @returns Whether the value is approximately zero.
         * @zh 是否在容差的范围内近似于0。
         * @param v 要判断的值。
         * @returns 是否近似于0。
         */
        static isZero(v: number): boolean;
        /**
         * @en Determines if two values are approximately equal within the tolerance range.
         * @param n1 The first value to compare.
         * @param n2 The second value to compare.
         * @returns Whether the two values are approximately equal.
         * @zh 两个值是否在容差的范围内近似相等
         * @param n1 要比较的第一个值。
         * @param n2 要比较的第二个值。
         * @returns 两个值是否近似相等。
         */
        static nearEqual(n1: number, n2: number): boolean;
        /**
         * @en Calculate the reciprocal of the square root of a non-zero number.
         * @param value The input value.
         * @returns The reciprocal of the square root of the input value.
         * @zh 计算一个非0数的平方根的倒数。
         * @param value 输入值。
         * @returns 输入值的平方根倒数。
         */
        static fastInvSqrt(value: number): number;
    }
    /**
     * @en Represents a transformation matrix that determines how to map points from one coordinate space to another.
     * You can perform various graphical transformations on a display object by setting the properties of a Matrix object, applying it to the matrix property of a Transform object, and then applying that Transform object as the transform property of the display object.
     * These transformation functions include translation (x and y repositioning), rotation, scaling, and skewing.
     * @zh 表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。
     * 您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，
     * 然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。
     */
    class Matrix {
        /**
         * @en Compares two matrices for equality.
         * @param a The first matrix.
         * @param b The second matrix.
         * @returns true if the matrices are equal, false otherwise.
         * @zh 比较两个矩阵是否相等。
         * @param a 第一个矩阵。
         * @param b 第二个矩阵。
         * @returns 如果矩阵相等，返回 true，否则返回 false。
         */
        static equals(a: Matrix, b: Matrix): boolean;
        /**
         * @en Extracts the transformation information from the matrix, including the skew in the X and Y directions.
         * @param matrix The matrix from which to extract the transformation information.
         * @returns An object containing the transformation information.
         * @zh 从 Matrix.abcd txty 提取变换信息，包括X和Y方向的倾斜
         * @param matrix 需要提取的矩阵
         * @returns 返回一个包含变换信息的对象
         */
        static extractTransformInfo(matrix: Matrix): {
            x: number;
            y: number;
            scaleX: number;
            scaleY: number;
            rotation: number;
            skewX: number;
            skewY: number;
        };
        /**
         * @en An initialized Matrix object. The content of this object is not allowed to be modified.
         * @zh 一个初始化的 Matrix 对象，不允许修改此对象内容。
         */
        static readonly EMPTY: Readonly<Matrix>;
        /**
         * @en A Matrix object used for temporary operations.
         * @zh 用于中转使用的 Matrix 对象。
         */
        static readonly TEMP: Matrix;
        /**@internal */
        static _createFun: Function | null;
        /**
         * @en The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @zh 缩放或旋转图像时影响像素沿 x 轴定位的值。
         */
        a: number;
        /**
         * @en The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @zh 旋转或倾斜图像时影响像素沿 y 轴定位的值。
         */
        b: number;
        /**
         * @en The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @zh 旋转或倾斜图像时影响像素沿 x 轴定位的值。
         */
        c: number;
        /**
         * @en The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @zh 缩放或旋转图像时影响像素沿 y 轴定位的值。
         */
        d: number;
        /**
         * @en The distance by which to translate each point along the x axis.
         * @zh 沿 x 轴平移每个点的距离。
         */
        tx: number;
        /**
         * @en The distance by which to translate each point along the y axis.
         * @zh 沿 y 轴平移每个点的距离。
         */
        ty: number;
        /**
         * @internal
         * @en Whether there are rotation or scaling operations.
         * @zh 是否有旋转缩放操作。
         */
        _bTransform: boolean;
        /**
         * @en Constructs method, initialize matrix.
         * @param a (Optional) The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @param b (Optional) The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @param c (Optional) The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @param d (Optional) The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @param tx (Optional) The distance by which to translate each point along the x axis.
         * @param ty (Optional) The distance by which to translate each point along the y axis.
         * @param nums (Optional) Additional parameter.
         * @zh 构造方法，初始化矩阵。
         * @param a		（可选）缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param b		（可选）旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param c		（可选）旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param d		（可选）缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param tx	（可选）沿 x 轴平移每个点的距离。
         * @param ty	（可选）沿 y 轴平移每个点的距离。
         * @param nums   (可选) 附加参数。
         */
        constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number, nums?: number);
        /**
         * @en Sets this matrix to an identity matrix.
         * @returns The current matrix.
         * @zh 将本矩阵设置为单位矩阵。
         * @return 返回当前矩形。
         */
        identity(): Matrix;
        /**@internal */
        _checkTransform(): boolean;
        /**
         * @en Sets the translation along the x and y axes.
         * @param x The distance to translate along the x axis.
         * @param y The distance to translate along the y axis.
         * @returns The current matrix object.
         * @zh 设置沿 x 、y 轴平移每个点的距离。
         * @param x 沿 x 轴平移每个点的距离。
         * @param y 沿 y 轴平移每个点的距离。
         * @return	返回对象本身
         */
        setTranslate(x: number, y: number): Matrix;
        /**
         * @en Translates the matrix along the x and y axes, as specified by the x and y parameters.
         * @param x The amount to move along the x axis (in pixels).
         * @param y The amount to move along the y axis (in pixels).
         * @returns The current matrix object.
         * @zh 沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
         * @param x 沿 x 轴向右移动的量（以像素为单位）。
         * @param y 沿 y 轴向下移动的量（以像素为单位）。
         * @return 返回此矩形对象。
         */
        translate(x: number, y: number): Matrix;
        /**
         * @en Applies a scaling transformation to the matrix.
         * @param x The multiplier used to scale the object along the x axis.
         * @param y The multiplier used to scale the object along the y axis.
         * @returns The current matrix object.
         * @zh 对矩阵应用缩放转换。
         * @param x 用于沿 x 轴缩放对象的乘数。
         * @param y 用于沿 y 轴缩放对象的乘数。
         * @return	返回矩阵对象本身
         */
        scale(x: number, y: number): Matrix;
        /**
         * @en Applies a rotation transformation to the Matrix object.
         * @param angle The rotation angle in radians.
         * @returns The current matrix objec.
         * @zh 对 Matrix 对象应用旋转转换。
         * @param angle 以弧度为单位的旋转角度。
         * @return	返回矩阵对象本身
         */
        rotate(angle: number): Matrix;
        /**
         * @en Applies a skew transformation to the Matrix object.
         * @param x The 2D skew angle along the X axis in radians.
         * @param y The 2D skew angle along the Y axis in radians.
         * @returns The current Matrix object.
         * @zh 对 Matrix 对象应用倾斜转换。
         * @param x 沿着 X 轴的 2D 倾斜弧度。
         * @param y 沿着 Y 轴的 2D 倾斜弧度。
         * @returns 当前 Matrix 对象。
         */
        skew(x: number, y: number): Matrix;
        /**
         * @en Applies the inverse transformation of the current matrix to the specified point and returns this point.
         * @param out The Point object to be transformed.
         * @returns The transformed out Point object.
         * @zh 对指定的点应用当前矩阵的逆转化并返回此点。
         * @param out 待转化的点 Point 对象。
         * @returns	返回out
         */
        invertTransformPoint(out: Point): Point;
        /**
         * @en Applies the geometric transformation represented by the Matrix object to the specified point.
         * @param out The point used to set the output result.
         * @returns The transformed out Point object.
         * @zh 将 Matrix 对象表示的几何转换应用于指定点。
         * @param out 用来设定输出结果的点。
         * @returns	返回out
         */
        transformPoint(out: Point): Point;
        /**
         * @en Applies the geometric transformation represented by the Matrix object to the specified point, ignoring tx and ty.
         * @param out The point used to set the output result.
         * @returns The transformed out Point object.
         * @zh 将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
         * @param out 用来设定输出结果的点。
         * @returns	返回out
         */
        transformPointN(out: Point): Point;
        /**
         * @en Gets the X-axis scaling value.
         * @zh 获取 X 轴缩放值。
         */
        getScaleX(): number;
        /**
         * @en Gets the Y-axis scaling value.
         * @zh 获取 Y 轴缩放值。
         */
        getScaleY(): number;
        /**
         * @en Perform the inverse transformation of the original matrix.
         * @returns The current matrix object.
         * @zh 执行原始矩阵的逆转换。
         * @returns 当前矩阵对象。
         */
        invert(): Matrix;
        /**
         * @en Sets the members of Matrix to the specified values.
         * @param a The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
         * @param b The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
         * @param c The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
         * @param d The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
         * @param tx The distance by which to translate each point along the x axis.
         * @param ty The distance by which to translate each point along the y axis.
         * @returns The current matrix object.
         * @zh 将 Matrix 的成员设置为指定值。
         * @param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param tx 沿 x 轴平移每个点的距离。
         * @param ty 沿 y 轴平移每个点的距离。
         * @return 当前矩阵对象。
         */
        setTo(a: number, b: number, c: number, d: number, tx: number, ty: number): Matrix;
        /**
         * @en Concatenates the specified matrix with the current matrix, effectively combining the geometric effects of the two.
         * @param matrix The matrix to be concatenated to the source matrix.
         * @returns The current matrix.
         * @zh 将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
         * @param matrix 要连接到源矩阵的矩阵。
         * @return	当前矩阵。
         */
        concat(matrix: Matrix): Matrix;
        /**
         * @en Multiplies the specified two matrices and assigns the result to the specified output object.
         * @param m1 The first matrix.
         * @param m2 The second matrix.
         * @param out The output object.
         * @returns The result output object out.
         * @zh 将指定的两个矩阵相乘后的结果赋值给指定的输出对象。
         * @param m1 矩阵一。
         * @param m2 矩阵二。
         * @param out 输出对象。
         * @return	结果输出对象 out。
         */
        static mul(m1: Matrix, m2: Matrix, out: Matrix): Matrix;
        /**
         * @en Multiplies the specified two matrices and assigns the result to the specified output array of length 16.
         * @param m1 The first matrix.
         * @param m2 The second matrix.
         * @param out The output Array object.
         * @returns The result output object out.
         * @zh 将指定的两个矩阵相乘，结果赋值给指定的输出数组，长度为16。
         * @param m1	矩阵一。
         * @param m2	矩阵二。
         * @param out	输出对象Array。
         * @returns 结果输出对象 out。
         */
        static mul16(m1: Matrix, m2: Matrix, out: any[]): any[];
        /**
         * @en Applies a scaling transformation to the matrix. Reverse multiplication.
         * @param x The multiplier used to scale the object along the x axis.
         * @param y The multiplier used to scale the object along the y axis.
         * @zh 对矩阵应用缩放转换。反向相乘
         * @param x 用于沿 x 轴缩放对象的乘数。
         * @param y 用于沿 y 轴缩放对象的乘数。
         */
        scaleEx(x: number, y: number): void;
        /**
         * @en Applies a rotation transformation to the Matrix object. Reverse multiplication.
         * @param angle The rotation angle in radians.
         * @zh 对 Matrix 对象应用旋转转换。反向相乘
         * @param angle 以弧度为单位的旋转角度。
         */
        rotateEx(angle: number): void;
        /**
         * @en Returns a copy of this Matrix object.
         * @returns A new Matrix instance with exactly the same properties as the original instance.
         * @zh 返回此 Matrix 对象的副本。
         * @returns 与原始实例具有完全相同的属性的新 Matrix 实例。
         */
        clone(): Matrix;
        /**
         * @en Returns a copy of this Matrix object.
         * @returns A new Matrix instance with exactly the same properties as the original instance.
         * @zh 返回此 Matrix 对象的副本。
         * @returns 与原始实例具有完全相同的属性的新 Matrix 实例。
         */
        cloneTo(dec: Matrix): Matrix;
        /**
         * @en Copy all matrix data from the current Matrix object to the specified Matrix object.
         * @param dec The Matrix object to copy the current matrix data to.
         * @returns The Matrix object with the copied matrix data.
         * @zh 将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
         * @param dec 要复制当前矩阵数据的 Matrix 对象。
         * @returns 已复制当前矩阵数据的 Matrix 对象。
         */
        copyTo(dec: Matrix): Matrix;
        /**
         * 设置矩阵
         * 输出矩阵 = 平移矩阵*旋转矩阵*斜切矩阵*缩放矩阵*描点矩阵
         * [a,b,tx] = [1,0,x]  *  [cos(r),-sin(r),0]  *  [cos(sy),sin(sx),0]  *  [sx,0,0]  *  [1,0,-pivotx]
         * [c,d,ty]   [0,1,y]     [sin(r), cos(r),0]     [sin(sy),cos(sx),0]     [0,sy,0]     [0,1,-pivoty]
         *
         * @param x x坐标
         * @param y y坐标
         * @param sx x轴缩放
         * @param sy y轴缩放
         * @param rotation 旋转，以角度为单位。
         * @param skewX x轴倾斜，以角度为单位。
         * @param skewY y轴倾斜，以角度为单位。
         * @param pivotx x 描点
         * @param pivoty y 描点
         */
        setMatrix(x: number, y: number, sx: number, sy: number, rotation: number, skewX: number, skewY: number, pivotx: number, pivoty: number): Matrix;
        /**
         * 返回列出该 Matrix 对象属性的文本值。
         * @return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
         */
        toString(): string;
        /**
         * @en Destroy this object.
         * @zh 销毁此对象。
         */
        destroy(): void;
        /**
         * @en Recycle to the object pool for reuse.
         * @zh 回收到对象池，方便复用。
         */
        recover(): void;
        /**
         * @en Create a Matrix object from the object pool.
         * @returns A Matrix object.
         * @zh 从对象池中创建一个 Matrix 对象。
         * @returns 返回一个 Matrix 对象。
         */
        static create(): Matrix;
    }
    /**
     * @en The Matrix3x3 class is used to create a 3x3 matrix.
     * @zh Matrix3x3 类用于创建 3x3 矩阵。
     */
    class Matrix3x3 implements IClone {
        /**
         * @en Default value
         * @zh 默认值
         */
        static readonly DEFAULT: Readonly<Matrix3x3>;
        /**
         * @en Temporary variable
         * @zh 临时变量
         */
        static readonly TEMP: Matrix3x3;
        /**
         * @en Create a rotation matrix from a quaternion.
         * @param rotation The rotation quaternion.
         * @param out The output rotation matrix.
         * @zh 通过四元数创建旋转矩阵。
         * @param rotation 旋转四元数。
         * @param out 输出的旋转矩阵。
         */
        static createRotationQuaternion(rotation: Quaternion, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified translation.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 根据指定平移生成 3x3 矩阵。
         * @param trans 平移向量。
         * @param out 输出矩阵。
         */
        static createFromTranslation(trans: Vector2, out: Matrix3x3): void;
        static createMatrixFromValue(pos: Vector2, rotate: number, scale: Vector2, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified rotation.
         * @param rad The rotation value.
         * @param out The output matrix.
         * @zh 根据指定旋转生成 3x3 矩阵。
         * @param rad 旋转值。
         * @param out 输出矩阵。
         */
        static createFromRotation(rad: number, out: Matrix3x3): void;
        /**
         * @en Generate a 3x3 matrix based on the specified scaling.
         * @param scale The scaling vector.
         * @param out The output matrix.
         * @zh 根据指定缩放生成 3x3 矩阵。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        static createFromScaling(scale: Vector3, out: Matrix3x3): void;
        /**
         * @en Convert a 4x4 matrix to a 3x3 matrix (upper-left principle, ignoring the fourth row and column).
         * @param sou The source 4x4 matrix.
         * @param out The output 3x3 matrix.
         * @zh 从 4x4 矩阵转换为一个 3x3 的矩阵（原则为 upper-left，忽略第四行四列）。
         * @param sou 4x4 源矩阵。
         * @param out 3x3 输出矩阵。
         */
        static createFromMatrix4x4(sou: Matrix4x4, out: Matrix3x3): void;
        /**
         * @en Multiply two 3x3 matrices.
         * @param left The left matrix.
         * @param right The right matrix.
         * @param out The output matrix.
         * @zh 两个 3x3 矩阵的相乘。
         * @param left 左矩阵。
         * @param right 右矩阵。
         * @param out 输出矩阵。
         */
        static multiply(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void;
        /**
         * @en Matrix element array
         * @zh 矩阵元素数组
         */
        elements: Float32Array;
        constructor(createElement?: boolean);
        /**
         * @en Clone the matrix by array.
         * @param destObject The target array to clone to.
         * @zh 通过数组克隆矩阵。
         * @param destObject 克隆目标数组。
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * @en Calculate the determinant of the 3x3 matrix.
         * @returns The determinant of the matrix.
         * @zh 计算 3x3 矩阵的行列式。
         * @returns 返回矩阵的行列式。
         */
        determinant(): number;
        /**
         * @en Transform the 3x3 matrix by a two-dimensional vector.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 通过一个二维向量转换 3x3 矩阵。
         * @param trans 转换向量。
         * @param out 输出矩阵。
         */
        translate(trans: Vector2, out: Matrix3x3): void;
        /**
         * @en Rotate the 3x3 matrix by a specified angle.
         * @param rad The rotation angle in radians.
         * @param out The output matrix.
         * @zh 根据指定角度旋转 3x3 矩阵。
         * @param rad 旋转角度（弧度）。
         * @param out 输出矩阵。
         */
        rotate(rad: number, out: Matrix3x3): void;
        /**
         * @en Scale the 3x3 matrix by a specified value.
         * @param scale The scaling vector.
         * @param out The output matrix.
         * @zh 根据指定缩放值缩放 3x3 矩阵。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        scale(scale: Vector2, out: Matrix3x3): void;
        /**
         * @en Calculate the inverse of the 3x3 matrix.
         * @param out The output inverse matrix.
         * @zh 计算 3x3 矩阵的逆矩阵。
         * @param out 输出的逆矩阵。
         */
        invert(out: Matrix3x3): void;
        /**
         * @en Calculate the transpose of the 3x3 matrix.
         * @param out The output matrix.
         * @zh 计算 3x3 矩阵的转置矩阵。
         * @param  out 输出矩阵。
         */
        transpose(out: Matrix3x3): void;
        /**
         * @en Set the existing matrix to an identity matrix.
         * @zh 设置已有的矩阵为单位矩阵。
         */
        identity(): void;
        /**
         * @en Clone the matrix.
         * @param destObject The clone target.
         * @zh 克隆矩阵。
         * @param destObject 克隆目标。
         */
        cloneTo(destObject: Matrix3x3): void;
        /**
         * @en Clone the matrix.
         * @returns A clone of the matrix.
         * @zh 克隆矩阵。
         * @returns 矩阵的克隆副本。
         */
        clone(): Matrix3x3;
        /**
         * @en Calculate the 3x3 view matrix.
         * @param eye The position of the observer.
         * @param target The position of the target.
         * @param up The up vector.
         * @param out The output 3x3 matrix.
         * @zh 计算观察3x3矩阵。
         * @param eye 观察者位置。
         * @param target 目标位置。
         * @param up 上向量。
         * @param out 输出3x3矩阵。
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
        /**
         * @en Calculate the 3x3 view matrix with forward direction looking at target. Forward is defined as the z-axis here.
         * @param eye The starting point.
         * @param target The target point.
         * @param up The up vector.
         * @param out The output matrix.
         * @zh 计算前向看向目标的3x3观察矩阵。这里规定前向为z轴。
         * @param eye 起始点。
         * @param target 目标点。
         * @param up 向上轴。
         * @param out 输出矩阵。
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
    }
    /**
     * @en The `Matrix4x4` class is used to create 4x4 matrices.
     * @zh `Matrix4x4` 类用于创建4x4矩阵。
     */
    class Matrix4x4 implements IClone {
        /**
         * @en Temporary matrix for internal calculations.
         * @zh 用于内部计算的临时矩阵。
         */
        static readonly TEMP: Matrix4x4;
        /**
         * @en Default matrix. Do not modify.
         * @zh 默认矩阵，禁止修改。
         */
        static readonly DEFAULT: Readonly<Matrix4x4>;
        /**
         * @en Inverse of the default matrix. Do not modify.
         * @zh 默认值的逆矩阵，禁止修改。
         */
        static readonly DEFAULTINVERT: Readonly<Matrix4x4>;
        /**
         * @en Default matrix. Do not modify.
         * @zh 默认矩阵，禁止修改。
         */
        static readonly ZERO: Readonly<Matrix4x4>;
        /**
         * @en Create a rotation matrix around the X axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕X轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationX(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix around the Y axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕Y轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationY(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix around the Z axis.
         * @param rad The rotation angle.
         * @param out The output matrix.
         * @zh 创建绕Z轴旋转的矩阵。
         * @param rad 旋转角度。
         * @param out 输出矩阵。
         */
        static createRotationZ(rad: number, out: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from yaw, pitch, and roll angles.
         * @param yaw The rotation angle around the vertical axis (Y-axis).
         * @param pitch The rotation angle around the transverse axis (X-axis).
         * @param roll The rotation angle around the longitudinal axis (Z-axis).
         * @param result The output result matrix.
         * @zh 通过yaw、pitch、roll角度创建旋转矩阵。
         * @param yaw 绕垂直轴（Y轴）的旋转角度。
         * @param pitch 绕横向轴（X轴）的旋转角度。
         * @param roll 绕纵向轴（Z轴）的旋转角度。
         * @param result 输出结果矩阵。
         */
        static createRotationYawPitchRoll(yaw: number, pitch: number, roll: number, result: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from an axis and an angle.
         * @param axis The rotation axis, assumed to be normalized.
         * @param angle The rotation angle.
         * @param result The output result matrix.
         * @zh 通过旋转轴和旋转角度计算旋转矩阵。
         * @param axis 旋转轴，假定已经归一化。
         * @param angle 旋转角度。
         * @param result 输出结果矩阵。
         */
        static createRotationAxis(axis: Vector3, angle: number, result: Matrix4x4): void;
        /**
         * @en Create a rotation matrix from a quaternion.
         * @param rotation The rotation quaternion.
         * @param result The output rotation matrix.
         * @zh 通过四元数创建旋转矩阵。
         * @param rotation 旋转四元数。
         * @param result 输出旋转矩阵。
         */
        static createRotationQuaternion(rotation: Quaternion, result: Matrix4x4): void;
        /**
         * @en Create a translation matrix.
         * @param trans The translation vector.
         * @param out The output matrix.
         * @zh 根据平移向量创建平移矩阵。
         * @param trans 平移向量。
         * @param out 输出矩阵。
         */
        static createTranslate(trans: Vector3, out: Matrix4x4): void;
        /**
         * @en Create a scaling matrix.
         * @param scale The scaling values.
         * @param out The output matrix.
         * @zh 根据缩放值创建缩放矩阵。
         * @param scale 缩放值。
         * @param out 输出矩阵。
         */
        static createScaling(scale: Vector3, out: Matrix4x4): void;
        /**
         * @en Multiply two matrices.
         * @param left The left matrix.
         * @param right The right matrix.
         * @param out The output matrix.
         * @zh 计算两个矩阵的乘法。
         * @param left 左矩阵。
         * @param right 右矩阵。
         * @param out 输出矩阵。
         */
        static multiply(left: Matrix4x4, right: Matrix4x4, out: Matrix4x4): void;
        /**
         * @en Calculate the rotation matrix from a quaternion.
         * @param rotation The input quaternion.
         * @param out The output matrix.
         * @zh 从四元数计算旋转矩阵。
         * @param rotation 输入的四元数。
         * @param out 输出矩阵。
         */
        static createFromQuaternion(rotation: Quaternion, out: Matrix4x4): void;
        /**
         * @en Calculate the affine transformation matrix.
         * @param trans The translation vector.
         * @param rot The rotation quaternion.
         * @param scale The scale vector.
         * @param out The output matrix.
         * @zh 计算仿射变换矩阵。
         * @param trans 平移向量。
         * @param rot 旋转四元数。
         * @param scale 缩放向量。
         * @param out 输出矩阵。
         */
        static createAffineTransformation(trans: Vector3, rot: Quaternion, scale: Vector3, out: Matrix4x4): void;
        /**
         * @en Calculate the view matrix.
         * @param eye The position of the viewer's eye.
         * @param target The position of the target point.
         * @param up The up vector.
         * @param out The output matrix.
         * @zh 计算观察矩阵。
         * @param eye 视点位置。
         * @param target 视点目标。
         * @param up 向上向量。
         * @param out 输出矩阵。
         */
        static createLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix4x4): void;
        /**
         * @en Create a perspective projection matrix using FOV.
         * @param fov The field of view in radians.
         * @param aspect The aspect ratio (width / height).
         * @param znear The near clipping plane.
         * @param zfar The far clipping plane.
         * @param out The output matrix.
         * @zh 通过FOV创建透视投影矩阵。
         * @param fov 视角（以弧度为单位）。
         * @param aspect 横纵比（宽/高）。
         * @param znear 近裁面。
         * @param zfar 远裁面。
         * @param out 输出矩阵。
         */
        static createPerspective(fov: number, aspect: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Create a perspective projection matrix.
         * @param left The left boundary of the frustum.
         * @param right The right boundary of the frustum.
         * @param bottom The bottom boundary of the frustum.
         * @param top The top boundary of the frustum.
         * @param znear The near boundary of the frustum.
         * @param zfar The far boundary of the frustum.
         * @param out The output matrix.
         * @zh 创建透视投影矩阵。
         * @param left 视椎左边界。
         * @param right 视椎右边界。
         * @param bottom 视椎底边界。
         * @param top 视椎顶边界。
         * @param znear 视椎近边界。
         * @param zfar 视椎远边界。
         * @param out 输出矩阵。
         */
        static createPerspectiveOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Calculate the orthographic projection matrix.
         * @param left The left boundary of the frustum.
         * @param right The right boundary of the frustum.
         * @param bottom The bottom boundary of the frustum.
         * @param top The top boundary of the frustum.
         * @param znear The near boundary of the frustum.
         * @param zfar The far boundary of the frustum.
         * @param out The output matrix.
         * @zh 计算正交投影矩阵。
         * @param left 视椎左边界。
         * @param right 视椎右边界。
         * @param bottom 视椎底边界。
         * @param top 视椎顶边界。
         * @param znear 视椎近边界。
         * @param zfar 视椎远边界。
         * @param out 输出矩阵。
         */
        static createOrthoOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * @en Matrix elements array.
         * @zh 矩阵元素数组。
         */
        elements: Float32Array;
        /**
         * @en Constructor method.
         * @zh 构造方法
         */
        constructor(m11?: number, m12?: number, m13?: number, m14?: number, m21?: number, m22?: number, m23?: number, m24?: number, m31?: number, m32?: number, m33?: number, m34?: number, m41?: number, m42?: number, m43?: number, m44?: number, elements?: Float32Array);
        /**
         * @internal
         * @en Get the element of the matrix by row and column.
         * @param row The row index (0-3).
         * @param column The column index (0-3).
         * @returns The value of the element.
         * @zh 通过行和列获取矩阵元素。
         * @param row 行索引（0-3）。
         * @param column 列索引（0-3）。
         * @returns 元素的值。
         */
        getElementByRowColumn(row: number, column: number): number;
        /**
         * @internal
         * @en Set the element of the matrix by row and column.
         * @param row The row index (0-3).
         * @param column The column index (0-3).
         * @param value The value to set.
         * @zh 通过行和列设置矩阵元素。
         * @param row 行索引（0-3）。
         * @param column 列索引（0-3）。
         * @param value 要设置的值。
         */
        setElementByRowColumn(row: number, column: number, value: number): void;
        /**
         * @en Generate matrix from quaternion.
         * @param rotation The rotation quaternion.
         * @zh 从四元数生成矩阵。
         * @param rotation 旋转四元数。
         */
        setRotation(rotation: Quaternion): void;
        /**
         * @en Set the position of the matrix.
         * @param position The position vector.
         * @zh 设置矩阵的位置。
         * @param position 位置向量。
         */
        setPosition(position: Vector3): void;
        /**
         * @en Determine if two 4x4 matrices have equal values.
         * @param other The other 4x4 matrix to compare.
         * @returns True if the matrices are equal, false otherwise.
         * @zh 判断两个4x4矩阵的值是否相等。
         * @param other 要比较的另一个4x4矩阵。
         * @returns 如果矩阵相等则返回true，否则返回false。
         */
        equalsOtherMatrix(other: Matrix4x4): boolean;
        /**
         * @en Decompose the matrix into translation vector, rotation quaternion, and scale vector.
         * @param translation The translation vector.
         * @param rotation The rotation quaternion.
         * @param scale The scale vector.
         * @returns Whether the decomposition was successful.
         * @zh 分解矩阵为平移向量、旋转四元数、缩放向量。
         * @param translation 平移向量。
         * @param rotation 旋转四元数。
         * @param scale 缩放向量。
         * @returns 是否分解成功。
         */
        decomposeTransRotScale(translation: Vector3, rotation: Quaternion, scale: Vector3): boolean;
        /**
         * @en Decompose the matrix into translation vector, rotation matrix, and scale vector.
         * @param translation The translation vector.
         * @param rotationMatrix The rotation matrix.
         * @param scale The scale vector.
         * @returns Whether the decomposition was successful.
         * @zh 分解矩阵为平移向量、旋转矩阵、缩放向量。
         * @param translation 平移向量。
         * @param rotationMatrix 旋转矩阵。
         * @param scale 缩放向量。
         * @returns 是否分解成功。
         */
        decomposeTransRotMatScale(translation: Vector3, rotationMatrix: Matrix4x4, scale: Vector3): boolean;
        /**
         * @en Decompose the rotation matrix into Yaw-Pitch-Roll Euler angles.
         * @param yawPitchRoll Vector3 to store the resulting Euler angles (in radians).
         * @zh 分解旋转矩阵为Yaw-Pitch-Roll欧拉角。
         * @param yawPitchRoll 用于存储结果欧拉角的Vector3（单位为弧度）。
         */
        decomposeYawPitchRoll(yawPitchRoll: Vector3): void;
        /**
         * @en Normalize the matrix.
         * @zh 归一化矩阵。
         */
        normalize(): void;
        /**
         * @en Calculate the transpose of the matrix.
         * @returns The transposed matrix.
         * @zh 计算矩阵的转置矩阵。
         * @returns 转置后的矩阵。
         */
        transpose(): Matrix4x4;
        /**
         * @en Calculate the inverse of a matrix.
         * @param out The output matrix to store the result.
         * @zh 计算矩阵的逆矩阵。
         * @param out 用于存储结果的输出矩阵。
         */
        invert(out: Matrix4x4): void;
        /**
         * @en Calculate the Billboard matrix
         * @param objectPosition The position of the object
         * @param cameraPosition The position of the camera
         * @param cameraUp The up vector of the camera
         * @param cameraForward The forward vector of the camera
         * @param mat The transformation matrix to store the result
         * @zh 计算Billboard矩阵
         * @param objectPosition 物体位置
         * @param cameraPosition 相机位置
         * @param cameraUp 相机上向量
         * @param cameraForward 相机前向量
         * @param mat 用于存储结果的变换矩阵
         */
        static billboard(objectPosition: Vector3, cameraPosition: Vector3, cameraUp: Vector3, cameraForward: Vector3, mat: Matrix4x4): void;
        /**
         * @en Normalization
         * @zh 归一化
         */
        identity(): void;
        /**
         * @en Check if the matrix is an identity matrix
         * @zh 判断是否是单位矩阵
         */
        isIdentity(): boolean;
        /**
         * @en Clone the matrix to another object
         * @param destObject Clone Source
         * @zh 克隆矩阵到另一个对象
         * @param destObject 克隆源。
         */
        cloneTo(destObject: Matrix4x4): void;
        /**
         * @en Clone the matrix from a Float32Array
         * @param destObject The Float32Array to clone from
         * @zh 从Float32Array克隆矩阵
         * @param destObject 要克隆的Float32Array
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * @en Clone the matrix
         * @returns A new Matrix4x4 object with the same values
         * @zh 克隆矩阵
         * @returns 一个具有相同值的新Matrix4x4对象
         */
        clone(): Matrix4x4;
        /**
         * @en Convert a coordinate matrix
         * @param v3 Coordinate points
         * @param out The output matrix
         * @zh 转换一个坐标位矩阵
         * @param v3 坐标点
         * @param out 输出矩阵
         */
        static translation(v3: Vector3, out: Matrix4x4): void;
        /**
         * @en Get the translation vector from the matrix
         * @param out The output vector to store the translation
         * @zh 获取矩阵中的平移向量
         * @param out 用于存储平移向量的输出向量
         */
        getTranslationVector(out: Vector3): void;
        /**
         * @en Set the translation vector of the matrix
         * @param translate The vector representing the translation
         * @zh 设置矩阵的平移向量
         * @param translate 表示平移的向量
         */
        setTranslationVector(translate: Vector3): void;
        /**
         * @en Get the forward vector from the matrix
         * @param out The output vector to store the forward vector
         * @zh 获取矩阵的前向量
         * @param out 用于存储前向量的输出向量
         */
        getForward(out: Vector3): void;
        /**
         * @en Set the forward vector of the matrix
         * @param forward The vector representing the forward direction
         * @zh 设置矩阵的前向量
         * @param forward 表示前向方向的向量
         */
        setForward(forward: Vector3): void;
        /**
         * @en Determine if this matrix is an inverted matrix
         * @returns True if the matrix is inverted, false otherwise
         * @zh 判断此矩阵是否是反向矩阵
         * @returns 如果矩阵是反向的返回true，否则返回false
         */
        getInvertFront(): boolean;
    }
    class PathPointKeyframe extends Keyframe {
        /**
         * @en The value of the keyframe.
         * @zh 关键帧的值。
         */
        value: CurvePath;
        /**
         * @inheritDoc
         * @override
         * @en Clones the data to another object.
         * @param destObject The target object to clone to.
         * @zh 克隆数据到目标对象。
         * @param destObject 拷贝数据结构
         */
        cloneTo(destObject: PathPointKeyframe): void;
        /**
         * @en Clones.
         * @zh 克隆
         */
        clone(): PathPointKeyframe;
    }
    /**
     * @en The `Point` object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
     * @zh `Point` 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     */
    class Point {
        /**
         * @en Temporary public object for reuse.
         * @zh 临时使用的公用对象。
         */
        static readonly TEMP: Point;
        /**
         * @en Global empty point object (x=0, y=0), the content of this object is not allowed to be modified.
         * @zh 全局空的point对象(x=0，y=0)，不允许修改此对象内容。
         */
        static readonly EMPTY: Readonly<Point>;
        /**
         * @en The horizontal coordinate of this point.
         * @zh 该点的水平坐标。
         */
        x: number;
        /**
         * @en The vertical coordinate of this point.
         * @zh 该点的垂直坐标。
         */
        y: number;
        /**
         * @en Creates a new Point object based on the specified coordinates.
         * @param x The horizontal coordinate. Default is 0.
         * @param y The vertical coordinate. Default is 0.
         * @zh 根据指定坐标，创建一个新的 Point 对象。
         * @param x 水平坐标。默认值为0。
         * @param y 垂直坐标。默认值为0。
         */
        constructor(x?: number, y?: number);
        /**
         * @en Create from object pool
         * @returns A Point object from the pool
         * @zh 从对象池创建
         * @returns 从对象池中获取的Point对象
         */
        static create(): Point;
        /**
         * @en Sets the members of Point to the specified values.
         * @param x The horizontal coordinate.
         * @param y The vertical coordinate.
         * @returns The current Point object.
         * @zh 将 Point 的成员设置为指定值。
         * @param x 水平坐标。
         * @param y 垂直坐标。
         * @returns 当前 Point 对象。
         */
        setTo(x: number, y: number): Point;
        /**
         * @en Reset the point to (0, 0)
         * @returns The current Point object.
         * @zh 重置点为(0, 0)
         * @returns 当前 Point 对象。
         */
        reset(): Point;
        /**
         * @en Recycle to the object pool for reuse
         * @zh 回收到对象池，方便复用
         */
        recover(): void;
        /**
         * @en Calculate the distance between the current point and the target point (x, y).
         * @param x The horizontal coordinate of the target point.
         * @param y The vertical coordinate of the target point.
         * @returns The distance between the current point and the target point.
         * @zh 计算当前点和目标点(x，y)的距离。
         * @param x 目标点的水平坐标。
         * @param y 目标点的垂直坐标。
         * @returns 返回当前点和目标点之间的距离。
         */
        distance(x: number, y: number): number;
        /**
         * @en Returns a string that contains the values of the x and y coordinates.
         * @zh 返回包含 x 和 y 坐标的值的字符串。
         */
        toString(): string;
        /**
         * @en Normalize the vector.
         * @zh 标准化向量。
         */
        normalize(): void;
        /**
         * @en Copy coordinates from another point
         * @param point The point to be copied from
         * @returns The current Point object.
         * @zh 复制另一个点的坐标
         * @param point 需要被复制的点
         * @returns 当前 Point 对象。
         */
        copy(point: Point): Point;
    }
    /**
     * @en The `Quaternion` class is used to create quaternions.
     * @zh `Quaternion` 类用于创建四元数。
     */
    class Quaternion implements IClone {
        /**@internal */
        static readonly TEMP: Quaternion;
        /**
         * @en Default quaternion, read-only.
         * @zh 默认四元数，只读。
         */
        static readonly DEFAULT: Readonly<Quaternion>;
        /**
         * @en Invalid quaternion, read-only.
         * @zh 无效四元数，只读。
         */
        static readonly NAN: Readonly<Quaternion>;
        /**
         * @en Generate a quaternion from Euler angles (order is Yaw, Pitch, Roll)
         * @param yaw The yaw value
         * @param pitch The pitch value
         * @param roll The roll value
         * @param out The output quaternion
         * @zh 从欧拉角生成四元数（顺序为Yaw、Pitch、Roll）
         * @param yaw yaw值
         * @param pitch pitch值
         * @param roll roll值
         * @param out 输出四元数
         */
        static createFromYawPitchRoll(yaw: number, pitch: number, roll: number, out: Quaternion): void;
        /**
         * @en Multiply two quaternions
         * @param left The left quaternion
         * @param right The right quaternion
         * @param out The output quaternion
         * @zh 计算两个四元数相乘
         * @param left left四元数
         * @param right right四元数
         * @param out 输出四元数
         */
        static multiply(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
         * @en Calculate a quaternion that rotates around an arbitrary axis.
         * @param axis The rotation axis
         * @param rad The rotation angle in radians
         * @param out The output quaternion after rotation
         * @zh 计算绕任意轴旋转的四元数。
         * @param axis 旋转轴
         * @param rad 旋转角度（以弧度为单位）
         * @param out 旋转后的输出四元数
         */
        static rotationAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        private static arcTanAngle;
        private static angleTo;
        /**
         * @en Calculate a quaternion from the specified axis and angle.
         * @param axis The axis vector.
         * @param rad The angle in radians.
         * @param out The output quaternion.
         * @zh 从指定的轴和角度计算四元数。
         * @param axis 轴向量。
         * @param rad 角度（以弧度为单位）。
         * @param out 输出的四元数。
         */
        static createFromAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        /**
         * @en Calculate a quaternion from a rotation matrix.
         * @param mat The rotation matrix.
         * @param out The output quaternion.
         * @zh 从旋转矩阵计算四元数。
         * @param mat 旋转矩阵。
         * @param out 输出的四元数。
         */
        static createFromMatrix4x4(mat: Matrix4x4, out: Quaternion): void;
        /**
         * @en Spherical linear interpolation between two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param t The interpolation factor, ranging from 0 to 1.
         * @param out The output quaternion.
         * @returns The output quaternion.
         * @zh 两个四元数之间的球面线性插值。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param t 插值因子，范围从0到1。
         * @param out 输出的四元数。
         * @returns 输出的四元数。
         */
        static slerp(left: Quaternion, right: Quaternion, t: number, out: Quaternion): Quaternion;
        /**
         * @en Calculate the linear interpolation between two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param amount The interpolation factor, ranging from 0 to 1.
         * @param out The output quaternion.
         * @zh 计算两个四元数的线性插值。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param amount 插值因子，范围从0到1。
         * @param out 输出的四元数。
         */
        static lerp(left: Quaternion, right: Quaternion, amount: number, out: Quaternion): void;
        /**
         * @en Calculate the sum of two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @param out The output quaternion.
         * @zh 计算两个四元数的和。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @param out 输出的四元数。
         */
        static add(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
         * @en Calculate the dot product of two quaternions.
         * @param left The left quaternion.
         * @param right The right quaternion.
         * @returns The dot product.
         * @zh 计算两个四元数的点积。
         * @param left 左侧四元数。
         * @param right 右侧四元数。
         * @returns 点积结果。
         */
        static dot(left: Quaternion, right: Quaternion): number;
        /**
         * @en X-axis coordinate.
         * @zh X轴坐标。
         */
        x: number;
        /**
         * @en Y-axis coordinate.
         * @zh Y轴坐标。
         */
        y: number;
        /**
         * @en Z-axis coordinate.
         * @zh Z轴坐标。
         */
        z: number;
        /**
         * @en W-axis coordinate.
         * @zh W轴坐标。
         */
        w: number;
        /**
         * @en Constructor method, initializes the default value.
         * @param x The x value of the quaternion. Default is 0.
         * @param y The y value of the quaternion. Default is 0.
         * @param z The z value of the quaternion. Default is 0.
         * @param w The w value of the quaternion. Default is 1.
         * @zh 构造方法,初始化为默认值。
         * @param x 四元数的x值。默认为0。
         * @param y 四元数的y值。默认为0。
         * @param z 四元数的z值。默认为0。
         * @param w 四元数的w值。默认为1。
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @en Set the values of the quaternion.
         * @param x The X value.
         * @param y The Y value.
         * @param z The Z value.
         * @param w The W value.
         * @zh 设置四元数的值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         */
        setValue(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set the values of the quaternion and return itself.
         * @param x The X value.
         * @param y The Y value.
         * @param z The Z value.
         * @param w The W value.
         * @returns The quaternion itself.
         * @zh 设置四元数的值并返回自身。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         * @returns 四元数自身。
         */
        set(x: number, y: number, z: number, w: number): this;
        /**
         * @en Scale the quaternion by a scalar value.
         * @param scaling The scalar value to scale by.
         * @param out The output quaternion.
         * @zh 根据缩放值缩放四元数。
         * @param scaling 缩放值。
         * @param out 输出的四元数。
         */
        scaling(scaling: number, out: Quaternion): void;
        /**
         * @en Normalize the quaternion.
         * @param out The output normalized quaternion.
         * @zh 归一化四元数。
         * @param out 输出的归一化四元数。
         */
        normalize(out: Quaternion): void;
        /**
         * @en Calculate the length of the quaternion.
         * @returns The length of the quaternion.
         * @zh 计算四元数的长度。
         * @returns 四元数的长度。
         */
        length(): number;
        /**
         * @en Rotate the quaternion around the X axis.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕X轴的角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateX(rad: number, out: Quaternion): void;
        /**
         * @en Rotate the quaternion around the Y axis by a specified angle.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕Y轴的指定角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateY(rad: number, out: Quaternion): void;
        /**
         * @en Rotate the quaternion around the Z axis by a specified angle.
         * @param rad The angle of rotation.
         * @param out The output rotated quaternion.
         * @zh 根据绕Z轴的指定角度旋转四元数。
         * @param rad 旋转角度。
         * @param out 输出的旋转后的四元数。
         */
        rotateZ(rad: number, out: Quaternion): void;
        /**
         * @en Decompose the quaternion into Euler angles (in the order of Yaw, Pitch, Roll).
         * Note: This method may produce sudden flips when rotating around the X axis beyond ±90 degrees.
         * @param out The output Vector3 to store the Euler angles.
         * @zh 将四元数分解为欧拉角（按Yaw、Pitch、Roll的顺序）。
         * 注意：当绕X轴旋转超过±90度时，此方法可能会产生突然的翻转。
         * @param out 用于存储欧拉角的输出Vector3。
         */
        getYawPitchRoll(out: Vector3): void;
        /**
         * @en Calculate the inverse of the quaternion.
         * @param out The output inverted quaternion.
         * @zh 计算四元数的逆。
         * @param out 输出的逆四元数。
         */
        invert(out: Quaternion): void;
        /**
         * @en Set the quaternion to identity quaternion.
         * @zh 将四元数设置为单位四元数。
         */
        identity(): void;
        /**
         * @en Copy values from an array.
         * @param array The source array.
         * @param offset The start offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param array 源数组。
         * @param offset 数组中的起始偏移量。默认为0。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * @en Clone the quaternion to a destination object.
         * @param destObject The destination object.
         * @zh 克隆四元数到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Quaternion): void;
        /**
         * @en Clone the quaternion.
         * @returns A new quaternion with the same values as this one.
         * @zh 克隆四元数。
         * @returns 一个与当前四元数值相同的新四元数。
         */
        clone(): Quaternion;
        /**
         * @en Determines if two quaternions are equal.
         * @param b The quaternion to compare with.
         * @zh 如果四元数相等则返回true，否则返回false。
         * @param b 对比四元数
         */
        equals(b: Quaternion): boolean;
        /**
         * @en Calculates a rotation quaternion to look at a direction.
         * @param forward The forward direction.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算旋转观察四元数。
         * @param forward 方向
         * @param up     上向量
         * @param out    输出四元数
         */
        static rotationLookAt(forward: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates a look-at quaternion (suitable for Camera and Light).
         * @param eye The position of the observer.
         * @param target The target position to look at.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算观察四元数（适用于相机和灯光）。
         * @param eye    观察者位置
         * @param target 目标位置
         * @param up     上向量
         * @param out    输出四元数
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates a look-at quaternion (suitable for GameObject).
         * @param eye The position of the observer.
         * @param target The target position to look at.
         * @param up The up vector.
         * @param out The output quaternion.
         * @zh 计算观察四元数（适用于游戏对象）。
         * @param eye 观察者位置
         * @param target 目标位置
         * @param up 上向量
         * @param out 输出四元数
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * @en Calculates the squared length of the quaternion.
         * @returns The squared length of the quaternion.
         * @zh 计算四元数长度的平方。
         * @returns 四元数长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Calculates the inverse of a quaternion.
         * @param value The input quaternion.
         * @param out The output inverse quaternion.
         * @zh 计算四元数的逆四元数。
         * @param value 四元数。
         * @param out 逆四元数。
         */
        static invert(value: Quaternion, out: Quaternion): void;
        /**
         * @en Creates a quaternion from a 3x3 rotation matrix.
         * @param matrix3x3 The 3x3 rotation matrix.
         * @param out The output quaternion.
         * @zh 通过一个3x3旋转矩阵创建一个四元数。
         * @param matrix3x3  3x3矩阵
         * @param out        四元数
         */
        static rotationMatrix(matrix3x3: Matrix3x3, out: Quaternion): void;
    }
    /**
     * @en The `QuaternionKeyframe` class is used to create quaternion keyframe instances.
     * @zh `QuaternionKeyframe` 类用于创建四元数关键帧实例。
     */
    class QuaternionKeyframe extends Keyframe {
        /**
         * @en In-tangent of the keyframe
         * @zh 内切线
         */
        inTangent: Vector4;
        /**
         * @en Out-tangent of the keyframe
         * @zh 外切线
         */
        outTangent: Vector4;
        /**
         * @en Frame data (quaternion value)
         * @zh 帧数据（四元数值）
         */
        value: Quaternion;
        /**
         * @en In-weight of the keyframe
         * @zh 内权重
         */
        inWeight: Vector4;
        /**
         * @en Out-weight of the keyframe
         * @zh 外权重
         */
        outWeight: Vector4;
        /**
         * @en Weight mode of the keyframe
         * @zh 权重模式
         */
        weightedMode: Vector4;
        /**
         * @en Creates an instance of `QuaternionKeyframe`.
         * @param weightMode Whether to enable weight mode
         * @zh 创建一个 `QuaternionKeyframe` 的实例。
          * @param weightMode 是否启用权重模式
         */
        constructor(weightMode?: boolean);
        /**
         * @override
        * @en Clone the QuaternionKeyframe.
        * @param dest The target object to clone to
        * @zh 克隆。
        * @param dest 克隆源。
        */
        cloneTo(dest: any): void;
    }
    /**
     * @en The `Rectangle` object is an area defined by its position, as indicated by its top-left corner point (x, y), and by its width and height.
     * The x, y, width, and height properties of the Rectangle class are independent of each other; changing the value of one property has no effect on the others.
     * @zh `Rectangle` 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     */
    class Rectangle implements IClone {
        /**
         * @en Global empty rectangle area with x=0, y=0, width=0, height=0. The content of this object is not allowed to be modified.
         * @zh 全局空的矩形区域，x=0, y=0, width=0, height=0。不允许修改此对象内容。
         */
        static readonly EMPTY: Readonly<Rectangle>;
        /**
         * @en Global temporary rectangle area. This object is used for global reuse to reduce object creation.
         * @zh 全局临时的矩形区域，此对象用于全局复用，以减少对象创建。
         */
        static readonly TEMP: Rectangle;
        /**
         * @en The x coordinate of the top-left corner of the rectangle.
         * @zh 矩形左上角的 X 轴坐标。
         */
        x: number;
        /**
         * @en The y coordinate of the top-left corner of the rectangle.
         * @zh 矩形左上角的 Y 轴坐标。
         */
        y: number;
        /**
         * @en The width of the rectangle.
         * @zh 矩形的宽度。
         */
        width: number;
        /**
         * @en The height of the rectangle.
         * @zh 矩形的高度。
         */
        height: number;
        /**
         * @en Constructor method.
         * @param x The x coordinate of the top-left corner of the rectangle.
         * @param y The y coordinate of the top-left corner of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @zh 构造方法
         * @param x 矩形左上角的 X 轴坐标。
         * @param y 矩形左上角的 Y 轴坐标。
         * @param width 矩形的宽度。
         * @param height 矩形的高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * @en The x-coordinate of the right side of this rectangle. It is equal to the sum of the x and width properties.
         * @zh 此矩形右侧的 X 轴坐标。等于 x 和 width 属性的和。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The y-coordinate of the bottom side of this rectangle. It is equal to the sum of the y and height properties.
         * @zh 此矩形底端的 Y 轴坐标。等于 y 和 height 属性的和。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en Sets the properties of the Rectangle to the specified values.
         * @param x The x-coordinate of the top-left corner of the rectangle.
         * @param y The y-coordinate of the top-left corner of the rectangle.
         * @param width The width of the rectangle.
         * @param height The height of the rectangle.
         * @return The rectangle object itself after the property values have been modified.
         * @zh 将 Rectangle 的属性设置为指定值。
         * @param x	x 矩形左上角的 X 轴坐标。
         * @param y	x 矩形左上角的 Y 轴坐标。
         * @param width	矩形的宽度。
         * @param height	矩形的高。
         * @return	返回属性值修改后的矩形对象本身。
         */
        setTo(x: number, y: number, width: number, height: number): this;
        /**
         * @en Resets the rectangle to default values (x=0, y=0, width=0, height=0).
         * @zh 重置矩形为默认值（x=0, y=0, width=0, height=0）。
         */
        reset(): this;
        /**
         * @en Recycles the rectangle object.
         * @zh 回收矩形对象。
         */
        recover(): void;
        /**
         * @en Creates a new Rectangle object from the object pool.
         * @zh 从对象池中创建一个新的 Rectangle 对象。
         */
        static create(): Rectangle;
        /**
         * @en Copies the property values from the source Rectangle object to this rectangle object.
         * @param source The source Rectangle object.
         * @returns The rectangle object itself after the property values have been modified.
         * @zh 复制源 Rectangle 对象的属性值到此矩形对象中。
         * @param source 源 Rectangle 对象。
         * @return 返回属性值修改后的矩形对象本身。
         */
        copyFrom(source: Rectangle): this;
        /**
         * @en Determines whether the specified point is contained within the rectangular region defined by this Rectangle object.
         * @param x The x-coordinate of the point (horizontal position).
         * @param y The y-coordinate of the point (vertical position).
         * @return True if the Rectangle object contains the specified point; false otherwise.
         * @zh 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
         * @param x	点的 X 轴坐标值（水平位置）。
         * @param y	点的 Y 轴坐标值（垂直位置）。
         * @return	如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
         */
        contains(x: number, y: number): boolean;
        /**
         * @en Determines whether the object specified in the rect parameter intersects with this Rectangle object. This method checks the x, y, width, and height properties of the specified Rectangle object to see if it intersects with this Rectangle object.
         * @param rect The Rectangle object to compare.
         * @returns True if the specified rectangle intersects with this one, false otherwise.
         * @zh 确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
         * @param rect Rectangle 对象。
         * @return	如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
         */
        intersects(rect: Readonly<Rectangle>): boolean;
        /**
         * @en If the Rectangle object specified in the rect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the rectangles do not intersect, this method returns null.
         * @param rect The rectangle to compare against.
         * @param out (Optional) The rectangle object for storing the output. If null, a new one will be created. It is allowed to be the same as rect or this.
         * @returns The intersection area as a Rectangle object, or null if there's no intersection.
         * @zh 如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
         * @param rect 待比较的矩形区域。
         * @param out （可选）待输出的矩形区域。如果为空则创建一个新的。允许out与rect或者this相同。
         * @return	返回相交的矩形区域对象。
         */
        intersection(rect: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @en Adds two rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two rectangles.
         * Note: The union() method ignores rectangles with a height or width of 0, such as: var rect2:Rectangle = new Rectangle(300,300,50,0);
         * @param source The Rectangle object to add to this Rectangle object.
         * @param out The Rectangle object to store the output. If null, a new one will be created. It is allowed to be the same as rect or this.
         * @returns A new Rectangle object that is the union of the two rectangles.
         * @zh 矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
         * 注意：union() 方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle = new Rectangle(300,300,50,0);
         * @param source 要添加到此 Rectangle 对象的 Rectangle 对象。
         * @param out	用于存储输出结果的矩形对象。如果为空，则创建一个新的。允许out与rect或者this相同。
         * @return	充当两个矩形的联合的新 Rectangle 对象。
         */
        union(source: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @zh 缩放矩形
         * @param scaleX X缩放值
         * @param scaleY Y缩放值
         * @returns 本对象
         * @en Scales the rectangle.
         * @param scaleX The scaling factor in the x-direction.
         * @param scaleY The scaling factor in the y-direction.
         * @returns This object.
         */
        scale(scaleX: number, scaleY: number): this;
        /**
         * @en Transforms a rectangle with a transformation matrix.
         * @param mat The transform matrix to be applied.
         * @returns This object.
         * @zh 使用变换矩阵转换矩形。
         * @param mat 变换矩阵。
         * @returns 本对象。
         */
        transform(mat: Matrix, out?: Rectangle): Rectangle;
        /**
         * @en Returns a string representation of this Rectangle object, with the x, y, width, and height values joined by commas.
         * @zh 返回当前 Rectangle 对象的字符串表示，其中水平位置 x、垂直位置 y、宽度 width 和高度 height 以逗号连接。
         */
        toString(): string;
        /**
         * @en Checks if the properties of the input Rectangle object are equal to the properties of the current Rectangle object (x, y, width, height).
         * @param rect The Rectangle object to compare.
         * @returns True if all properties are equal, false otherwise.
         * @zh 检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
         * @param rect	待比较的 Rectangle 对象。
         * @return	如果判断的属性都相等，则返回 true 值，否则返回 false。
         */
        equals(rect: Rectangle): boolean;
        /**
         * @en Adds a point to the current rectangle object, expanding it to the smallest rectangle that contains both the current rectangle and the given point.
         * This method modifies the current object.
         * @param x The x-coordinate of the point.
         * @param y The y-coordinate of the point.
         * @return This Rectangle object.
         * @zh 为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。
         * 此方法会修改本对象。
         * @param x	点的 X 坐标。
         * @param y	点的 Y 坐标。
         * @return 返回此 Rectangle 对象。
         */
        addPoint(x: number, y: number): this;
        /**
         * @en Returns vertex data representing the current rectangle.
         * @return Vertex data.
         * @zh 返回代表当前矩形的顶点数据。
         * @return 顶点数据。
         */
        getBoundPoints(out?: Array<number>): Array<number>;
        /**
         * @en Returns the smallest rectangle that contains all the points.
         * @param points List of points.
         * @param out Optional Rectangle object to store the result.
         * @returns The smallest rectangle that contains all the points.
         * @zh 返回包含所有点的最小矩形。
         * @param points 点列表。
         * @param out （可选）用于存储结果的矩形对象。
         * @return 包含所有点的最小矩形矩形对象。
         */
        static _getWrapRec(points: ArrayLike<number>, out?: Rectangle): Rectangle;
        /**
         * Creates a rectangle from two corner points.
         * @param minX The smallest x value.
         * @param minY The smallest y value.
         * @param maxX The largest x value.
         * @param maxY The largest y value.
         * @param out Optional Rectangle object to store the result.
         * @returns The resulting rectangle.
         * @zh 由两个角点创建一个矩形。
         * @param minX 最小的 x 值。
         * @param minY 最小的 y 值。
         * @param maxX 最大的 x 值。
         * @param maxY 最大的 y 值。
         * @param out （可选）用于存储结果的矩形对象。
         * @return 结果矩形。
         */
        static minMaxRect(minX: number, minY: number, maxX: number, maxY: number, out?: Rectangle): Rectangle;
        /**
         * @en Determines whether this Rectangle object is empty.
         * @returns True if the width or height of the Rectangle object is less than or equal to 0, false otherwise.
         * @zh 确定此 Rectangle 对象是否为空。
         * @return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
         */
        isEmpty(): boolean;
        /**
         * @en Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
         * @param out (Optional) The rectangle object used to store the result. If null, a new one is created. Recommendation: Reuse objects as much as possible to reduce object creation overhead. The Rectangle.TEMP object can be used for object reuse.
         * @returns A Rectangle object with the same values for x, y, width, and height properties as the current Rectangle object.
         * @zh 返回一个新的 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         * @param out （可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
         * @return 一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         */
        clone(out?: Rectangle): Rectangle;
        /**
         * @en Copies the properties of this Rectangle to the destination object.
         * @param destObject The destination object to copy to.
         * @zh 将此 Rectangle 的属性复制到目标对象。
         * @param destObject 目标对象。
         */
        cloneTo(destObject: Rectangle): void;
    }
    interface IV2 {
        x: number;
        y: number;
    }
    /**
     * @en The `Vector2` class is used to create two-dimensional vectors.
     * @zh `Vector2` 类用于创建二维向量。
     */
    class Vector2 implements IClone {
        /**
         * @en Zero vector, read-only.
         * @zh 零向量，只读。
         */
        static readonly ZERO: Readonly<Vector2>;
        /**
         * @en One vector, read-only.
         * @zh 单位向量，只读。
         */
        static readonly ONE: Readonly<Vector2>;
        /**
         * @en Temporary Vector2 for calculations.
         * @zh 用于计算的临时 Vector2。
         */
        static readonly TEMP: Vector2;
        /**
         * @en X-axis coordinate.
         * @zh X 轴坐标。
         */
        x: number;
        /**
         * @en Y-axis coordinate.
         * @zh Y 轴坐标。
         */
        y: number;
        /**
         * @en Constructor method.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @zh 构造方法
         * @param x X 轴坐标。
         * @param y Y 轴坐标。
         */
        constructor(x?: number, y?: number);
        /**
         * @en Sets the x and y values of the vector.
         * @param x The x value to set.
         * @param y The y value to set.
         * @zh 设置向量的 x 和 y 值。
         * @param x 要设置的 X 值。
         * @param y 要设置的 Y 值。
         */
        setValue(x: number, y: number): Vector2;
        /**
         * @en Scales a two-dimensional vector.
         * @param a Source two-dimensional vector.
         * @param b Scale value.
         * @param out Output two-dimensional vector.
         * @zh 缩放二维向量。
         * @param a 源二维向量。
         * @param b 缩放值。
         * @param out 输出二维向量。
         */
        static scale(a: Vector2, b: number, out: Vector2): void;
        /**
         * @en Determines whether two two-dimensional vectors are equal.
         * @param a First two-dimensional vector.
         * @param b Second two-dimensional vector.
         * @returns Whether the vectors are equal.
         * @zh 判断两个二维向量是否相等。
         * @param a 第一个二维向量。
         * @param b 第二个二维向量。
         * @returns 是否相等。
         */
        static equals(a: Vector2, b: Vector2): boolean;
        /**
         * @en Copies values from an array.
         * @param array The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param array 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(array: ArrayLike<number>, offset?: number): void;
        /**
         * @en Converts the vector to an array.
         * @returns An array representation of the vector.
         * @zh 将向量转换为数组。
         * @returns 表示向量的数组。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector to a array.
         * @param array The target array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量写入数组。
         * @param array 目标数组。
         * @param offset 数组偏移。默认值为 0。
         */
        writeTo(array: {
            [n: number]: number;
        }, offset?: number): void;
        /**
         * @en Clones the vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将向量克隆到另一个对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector2): Vector2;
        /**
         * @en Calculates the dot product of two 2D vectors.
         * @param a The left vector.
         * @param b The right vector.
         * @returns The dot product.
         * @zh 计算两个二维向量的点积。
         * @param a 左向量。
         * @param b 右向量。
         * @returns 点积。
         */
        static dot(a: Vector2, b: Vector2): number;
        /**
         * @en Normalizes a 2D vector.
         * @param s The source 2D vector.
         * @param out The output normalized 2D vector.
         * @zh 归一化二维向量。
         * @param s 源二维向量。
         * @param out 输出的归一化二维向量。
         */
        static normalize(s: Vector2, out: Vector2): void;
        /**
         * @en Calculates the scalar length of a 2D vector.
         * @param a The source 2D vector.
         * @returns The scalar length.
         * @zh 计算二维向量的标量长度。
         * @param a 源二维向量。
         * @returns 标量长度。
         */
        static scalarLength(a: Vector2): number;
        /**
         * 计算两个二维向量的距离
         * @param a
         * @param b
         * @returns
         */
        static distance(a: Vector2, b: Vector2): number;
        /**
         * @en Creates a clone of this Vector2.
         * @returns Cloned copy of Vector2.
         * @zh 创建此Vector2的克隆。
         * @returns 克隆副本。
         */
        clone(): Vector2;
    }
    /**
     * @en The `Vector2Keyframe` class is used to create instances of two-dimensional vector keyframes.
     * @zh `Vector2Keyframe` 类用于创建二维向量关键帧实例。
     */
    class Vector2Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector2;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector2;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector2;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector2;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector2;
        /**
         * @en Weight mode.
         * @zh 权重模式。
         */
        weightedMode: Vector2;
        /**
         * @en Creates an instance of Vector2Keyframe.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建 Vector2Keyframe 的实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector2Keyframe): void;
    }
    /**
     * @en The `Vector3` class is used to create three-dimensional vectors.
     * @zh `Vector3` 类用于创建三维向量。
     */
    class Vector3 implements IClone {
        /**
         * @en Zero vector (0, 0, 0).
         * @zh 零向量 (0, 0, 0)。
         */
        static readonly ZERO: Readonly<Vector3>;
        /**
         * @en One vector (1, 1, 1).
         * @zh 单位向量 (1, 1, 1)。
         */
        static readonly ONE: Readonly<Vector3>;
        /**
         * @en Negative X axis (-1, 0, 0).
         * @zh 负X轴 (-1, 0, 0)。
         */
        static readonly NegativeUnitX: Readonly<Vector3>;
        /**
         * @en Positive X axis (1, 0, 0).
         * @zh 正X轴 (1, 0, 0)。
         */
        static readonly UnitX: Readonly<Vector3>;
        /**
         * @en Positive Y axis (0, 1, 0).
         * @zh 正Y轴 (0, 1, 0)。
         */
        static readonly UnitY: Readonly<Vector3>;
        /**
         * @en Positive Z axis (0, 0, 1).
         * @zh 正Z轴 (0, 0, 1)。
         */
        static readonly UnitZ: Readonly<Vector3>;
        /**
         * @en Forward vector in right-handed coordinate system (0, 0, -1).
         * @zh 右手坐标系中的前向量 (0, 0, -1)。
         */
        static readonly ForwardRH: Readonly<Vector3>;
        /**
         * @en Forward vector in left-handed coordinate system (0, 0, 1).
         * @zh 左手坐标系中的前向量 (0, 0, 1)。
         */
        static readonly ForwardLH: Readonly<Vector3>;
        /**
         * @en Up vector (0, 1, 0).
         * @zh 上向量 (0, 1, 0)。
         */
        static readonly Up: Readonly<Vector3>;
        /**
         * @en Temporary vector.
         * @zh 临时向量。
         */
        static readonly TEMP: Vector3;
        /**
         * @en Calculates the squared distance between two three-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The squared distance.
         * @zh 计算两个三维向量之间距离的平方。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离的平方。
         */
        static distanceSquared(value1: Vector3, value2: Vector3): number;
        /**
         * @en Calculates the distance between two three-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The distance.
         * @zh 计算两个三维向量之间的距离。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离。
         */
        static distance(value1: Vector3, value2: Vector3): number;
        /**
         * @en Calculates a new three-dimensional vector by taking the minimum of x, y, and z from two vectors.
         * @param a The first Vector3.
         * @param b The second Vector3.
         * @param out The resulting Vector3.
         * @zh 通过取两个三维向量的 x、y、z 的最小值计算新的三维向量。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @param out 结果三维向量。
         */
        static min(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Calculates a new three-dimensional vector by taking the maximum of x, y, and z from two vectors.
         * @param a The first Vector3.
         * @param b The second Vector3.
         * @param out The resulting Vector3.
         * @zh 通过取两个三维向量的 x、y、z 的最大值计算新的三维向量。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @param out 结果三维向量。
         */
        static max(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Rotates a three-dimensional vector by a quaternion.
         * @param source The source vector3 to be rotated.
         * @param rotation The rotation quaternion.
         * @param out The output vector3.
         * @zh 根据四元数旋转三维向量。
         * @param source 要旋转的源三维向量。
         * @param rotation 旋转四元数。
         * @param out 输出三维向量。
         */
        static transformQuat(source: Vector3, rotation: Quaternion, out: Vector3): void;
        /**
         * @en Calculates the scalar length of a vector.
         * @param a The source vector.
         * @returns The scalar length.
         * @zh 计算向量的标量长度。
         * @param a 源向量。
         * @returns 标量长度。
         */
        static scalarLength(a: Vector3): number;
        /**
         * @en Calculates the squared scalar length of a vector.
         * @param a The source three-dimensional vector.
         * @returns The squared scalar length.
         * @zh 计算标量长度的平方。
         * @param a 源三维向量。
         * @returns 标量长度的平方。
         */
        static scalarLengthSquared(a: Vector3): number;
        /**
         * @en Normalizes a three-dimensional vector.
         * @param s The source vector to be normalized.
         * @param out The output normalized vector.
         * @zh 归一化三维向量。
         * @param s 要归一化的源向量。
         * @param out 输出的归一化向量。
         */
        static normalize(s: Vector3, out: Vector3): void;
        /**
         * @en Calculates the product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param out The output vector3.
         * @zh 计算两个三维向量的乘积。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param out 输出三维向量。
         */
        static multiply(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Scales a three-dimensional vector.
         * @param a The source vector3 to be scaled.
         * @param b The scaling factor.
         * @param out The output scaled vector3.
         * @zh 缩放三维向量。
         * @param a 要缩放的源三维向量。
         * @param b 缩放因子。
         * @param out 输出的缩放后的三维向量。
         */
        static scale(a: Vector3, b: number, out: Vector3): void;
        /**
         * @en Performs a linear interpolation between two three-dimensional vectors.
         * @param a The starting vector.
         * @param b The ending vector.
         * @param t The interpolation coefficient in the range [0, 1].
         * @param out The output interpolated vector.
         * @zh 在两个三维向量之间进行线性插值。
         * @param a 起始向量。
         * @param b 结束向量。
         * @param t 插值系数，范围为 [0, 1]。
         * @param out 输出的插值向量。
         */
        static lerp(a: Vector3, b: Vector3, t: number, out: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to another three-dimensional vector using a matrix.
         * @param vector The source vector3.
         * @param transform The transformation matrix.
         * @param result The output transformed vector3.
         * @zh 使用矩阵将一个三维向量转换为另一个三维向量。
         * @param vector 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的转换后的三维向量。
         */
        static transformV3ToV3(vector: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to a four-dimensional vector using a matrix.
         * @param vector The source vector3.
         * @param transform The transformation matrix.
         * @param result The output vector4.
         * @zh 使用矩阵将三维向量转换为四维向量。
         * @param vector 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的四维向量。
         */
        static transformV3ToV4(vector: Vector3, transform: Matrix4x4, result: Vector4): void;
        /**
         * @en Transforms a normal three-dimensional vector to another three-dimensional vector using a normal transformation matrix.
         * @param normal The source normal vector3.
         * @param transform The normal transformation matrix.
         * @param result The output transformed normal vector3.
         * @zh 使用法线变换矩阵将法线三维向量转换为另一个三维向量。
         * @param normal 源法线三维向量。
         * @param transform 法线变换矩阵。
         * @param result 输出转换后的法线三维向量。
         */
        static TransformNormal(normal: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Transforms a three-dimensional vector to another normalized three-dimensional vector using a matrix.
         * @param coordinate The source three-dimensional vector.
         * @param transform The transformation matrix.
         * @param result The output normalized three-dimensional vector.
         * @zh 使用矩阵将三维向量转换为另一个归一化的三维向量。
         * @param coordinate 源三维向量。
         * @param transform 变换矩阵。
         * @param result 输出的归一化三维向量。
         */
        static transformCoordinate(coordinate: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * @en Clamps a vector within a specified range.
         * @param value The vector to be clamped.
         * @param min The minimum values for each component.
         * @param max The maximum values for each component.
         * @param out The output clamped vector.
         * @zh 将向量限制在指定范围内。
         * @param value 要限制的向量。
         * @param min 每个分量的最小值。
         * @param max 每个分量的最大值。
         * @param out 输出的限制后的向量。
         */
        static Clamp(value: Vector3, min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * @en Calculates the sum of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param out The output vector3.
         * @zh 计算两个三维向量的和。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param out 输出向量。
         */
        static add(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * @en Calculates the difference between two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param o The output vector3.
         * @zh 计算两个三维向量的差。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param o 输出向量。
         */
        static subtract(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * @en Calculates the cross product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @param o The output vector3.
         * @zh 计算两个三维向量的叉乘。
         * @param a 左侧三维向量。
         * @param b 右侧三维向量。
         * @param o 输出三维向量。
         */
        static cross(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * @en Calculates the dot product of two three-dimensional vectors.
         * @param a The left vector3.
         * @param b The right vector3.
         * @returns The dot product.
         * @zh 计算两个三维向量的点积。
         * @param a 左侧向量。
         * @param b 右侧向量。
         * @returns 点积。
         */
        static dot(a: Vector3, b: Vector3): number;
        /**
         * @en Determines whether two three-dimensional vectors are equal.
         * @param a The first vector3.
         * @param b The second vector3.
         * @returns Whether the vectors are equal.
         * @zh 判断两个三维向量是否相等。
         * @param a 第一个三维向量。
         * @param b 第二个三维向量。
         * @returns 是否相等。
         */
        static equals(a: Vector3, b: Vector3): boolean;
        /**
         * @en X-axis coordinate
         * @zh X轴坐标
         */
        x: number;
        /**
         * @en Y-axis coordinate
         * @zh Y轴坐标
         */
        y: number;
        /**
         * @en Z-axis coordinate
         * @zh Z轴坐标
         */
        z: number;
        /**
         * @en Constructor method, 3D vector initialization.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param z Z-axis coordinate.
         * @zh 构造方法，初始化三维向量。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param z Z轴坐标。
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * @en Determines whether the three-dimensional vector is equal to another vector.
         * @param value The vector to compare with.
         * @returns Returns true if the vectors are equal, false otherwise.
         * @zh 判断三维向量是否与另一个向量相等。
         * @param value 对比值
         * @returns 如果向量相等则返回 true，否则返回 false。
         */
        equal(value: Vector3): boolean;
        /**
         * @en Sets the x, y, and z values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @zh 设置向量的 x、y 和 z 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         */
        setValue(x: number, y: number, z: number): Vector3;
        /**
         * @en Sets the x, y, and z values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @zh 设置向量的 x、y 和 z 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         */
        set(x: number, y: number, z: number): this;
        /**
         * @en Copies values from an array.
         * @param arr The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param arr 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): void;
        /**
         * @en Converts the vector to an array.
         * @zh 将向量转换为数组。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector values to an array.
         * @param arr The target array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量值写入数组。
         * @param arr 目标数组。
         * @param offset 数组偏移。默认值为 0。
         */
        writeTo(arr: {
            [n: number]: number;
        }, offset?: number): void;
        /**
         * @en Calculates the length of the vector.
         * @zh 计算向量的长度。
         */
        length(): number;
        /**
         * @en Calculates the squared length of the vector.
         * @zh 计算向量长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Subtracts a vector from this vector.
         * @param b The vector to subtract.
         * @param out The output vector.
         * @returns The resulting vector.
         * @zh 向量相减
         * @param b 被减向量。
         * @param out 输出向量。
         * @returns 相减后的结果向量。
         */
        vsub(b: Vector3, out: Vector3): Vector3;
        /**
         * @en Adds a vector to this vector.
         * @param b The vector to add.
         * @param out The output vector.
         * @returns The resulting vector.
         * @zh 向量相加。
         * @param b 加向量。
         * @param out 输出向量。
         * @returns returns 相加后的结果向量。
         */
        vadd(b: Vector3, out: Vector3): Vector3;
        /**
         * @en Scales this vector by a scalar value.
         * @param s The scalar value.
         * @param out The output vector.
         * @returns The scaled vector.
         * @zh 缩放向量。
         * @param s 缩放值。
         * @param out 输出向量。
         * @returns 缩放后的向量。
         */
        scale(s: number, out: Vector3): Vector3;
        /**
         * @en Normalizes this vector.
         * @returns The normalized vector.
         * @zh 归一化向量。
         * @returns 归一化后的向量。
         */
        normalize(): this;
        /**
         * @en Calculates the dot product of this vector with another vector.
         * @param b The vector to dot product with.
         * @returns The dot product.
         * @zh 计算向量点乘。
         * @param b 点乘向量。
         * @returns 点乘结果。
         */
        dot(b: Vector3): number;
        /**
         * @en Calculates the cross product of this vector with another vector.
         * @param b The vector to cross product with.
         * @param o The output vector.
         * @returns The resulting cross product vector.
         * @zh 计算向量叉乘。
         * @param b 叉乘向量。
         * @param o 输出向量。
         * @returns 叉乘结果向量。
         */
        cross(b: Vector3, o: Vector3): Vector3;
        /**
         * @en Clones this vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将当前向量克隆到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector3): Vector3;
        /**
         * @en Creates a clone of this vector.
         * @returns A new Vector3 object with the same values as this vector.
         * @zh 创建当前向量的克隆。
         * @returns 返回一个新的 Vector3 对象，其值与当前向量相同。
         */
        clone(): Vector3;
        /**
         * @en Sets this vector to its default value (0, 0, 0).
         * @zh 将当前向量设置为默认值 (0, 0, 0)。
         */
        toDefault(): void;
    }
    /**
     * @en The `Vector3Keyframe` class is used to create instances of three-dimensional vector keyframes.
     * @zh `Vector3Keyframe` 类用于创建三维向量关键帧实例。
     */
    class Vector3Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector3;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector3;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector3;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector3;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector3;
        /**
         * @en Weight mode.
         * @zh 权重模式。
         */
        weightedMode: Vector3;
        /**
         * @en Creates an instance of Vector3Keyframe.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建一个Vector3Keyframe实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector3Keyframe): void;
    }
    /**
     * @en The `Vector4` class is used to create four-dimensional vectors.
     * @zh `Vector4` 类用于创建四维向量。
     */
    class Vector4 implements IClone {
        /**
         * @en Zero vector (0, 0, 0, 0).
         * @zh 零向量 (0, 0, 0, 0)。
         */
        static readonly ZERO: Readonly<Vector4>;
        /**
         * @en One vector (1, 1, 1, 1).
         * @zh 一向量 (1, 1, 1, 1)。
         */
        static readonly ONE: Readonly<Vector4>;
        /**
         * @en Unit X vector (1, 0, 0, 0).
         * @zh X 单位向量 (1, 0, 0, 0)。
         */
        static readonly UnitX: Readonly<Vector4>;
        /**
         * @en Unit Y vector (0, 1, 0, 0).
         * @zh Y 单位向量 (0, 1, 0, 0)。
         */
        static readonly UnitY: Readonly<Vector4>;
        /**
         * @en Unit Z vector (0, 0, 1, 0).
         * @zh Z 单位向量 (0, 0, 1, 0)。
         */
        static readonly UnitZ: Readonly<Vector4>;
        /**
         * @en Unit W vector (0, 0, 0, 1).
         * @zh W 单位向量 (0, 0, 0, 1)。
         */
        static readonly UnitW: Readonly<Vector4>;
        static readonly TEMP: Vector4;
        /**
         * @en X coordinate.
         * @zh X 轴坐标。
         */
        x: number;
        /**
         * @en Y coordinate.
         * @zh Y 轴坐标。
         */
        y: number;
        /**
         * @en Z coordinate.
         * @zh Z 轴坐标。
         */
        z: number;
        /**
         * @en W coordinate.
         * @zh W 轴坐标。
         */
        w: number;
        /**
         * @en Constructor method, initializes the vector4.
         * @param x X coordinate. Default is 0.
         * @param y Y coordinate. Default is 0.
         * @param z Z coordinate. Default is 0.
         * @param w W coordinate. Default is 0.
         * @zh 构造方法，初始化四维向量。
         * @param x X 轴坐标。默认为 0。
         * @param y Y 轴坐标。默认为 0。
         * @param z Z 轴坐标。默认为 0。
         * @param w W 轴坐标。默认为 0。
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @en Sets the x, y, z, and w values of the vector.
         * @param x The x value.
         * @param y The y value.
         * @param z The z value.
         * @param w The w value.
         * @zh 设置向量的 x、y、z 和 w 值。
         * @param x X值。
         * @param y Y值。
         * @param z Z值。
         * @param w W值。
         */
        setValue(x: number, y: number, z: number, w: number): this;
        /**
         * @en Copies values from an array.
         * @param arr The source array.
         * @param offset The offset in the array. Default is 0.
         * @zh 从数组中拷贝值。
         * @param arr 源数组。
         * @param offset 数组偏移。默认值为 0。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): this;
        /**
         * @en Converts the vector to an array.
         * @returns An array containing the vector components [x, y, z, w].
         * @zh 将向量转换为数组。
         * @returns 包含向量分量的数组 [x, y, z, w]。
         */
        toArray(): Array<number>;
        /**
         * @en Writes the vector values to a array.
         * @param arr The target array.
         * @param offset The offset in the array. Default is 0.
         * @zh 将向量值写入数组。
         * @zh arr 目标数组。
         * @zh offset 数组偏移。默认值为 0。
         */
        writeTo(arr: {
            [n: number]: number;
        }, offset?: number): this;
        /**
         * @en Clones this vector to another object.
         * @param destObject The destination object to clone to.
         * @zh 将当前向量克隆到目标对象。
         * @param destObject 克隆的目标对象。
         */
        cloneTo(destObject: Vector4): Vector4;
        /**
         * @en Creates a clone of this vector.
         * @returns A new Vector4 object with the same values as this vector.
         * @zh 创建当前向量的克隆。
         * @returns 返回一个新的 Vector4 对象，其值与当前向量相同。
         */
        clone(): Vector4;
        /**
         * @en Performs a linear interpolation between two vectors.
         * @param a The first vector.
         * @param b The second vector.
         * @param t The interpolation coefficient.
         * @param out The output vector.
         * @zh 在两个向量之间进行线性插值。
         * @param a 起始向量。
         * @param b 目标向量。
         * @param t 插值系数。
         * @param out 输出向量。
         */
        static lerp(a: Vector4, b: Vector4, t: number, out: Vector4): void;
        /**
         * @en Transforms a Vector4 by a 4x4 matrix.
         * @param vector4 The vector to transform.
         * @param m4x4 The transformation matrix.
         * @param out The output vector.
         * @zh 通过 4x4 矩阵转换一个四维向量。
         * @param vector4 待转换的四维向量。
         * @param m4x4 4x4 变换矩阵。
         * @param out 转换后的四维向量。
         */
        static transformByM4x4(vector4: Vector4, m4x4: Matrix4x4, out: Vector4): void;
        /**
         * 判断两个四维向量是否相等。
         * @param a 四维向量。
         * @param b 四维向量。
         * @return  是否相等。
         */
        static equals(a: Vector4, b: Vector4): boolean;
        /**
         * @en Determines whether this vector is equal to another vector.
         * @param value The vector to compare with.
         * @returns True if the vectors are equal, false otherwise.
         * @zh 判断当前向量是否与另一个向量相等。
         * @param value 用于比较的向量。
         * @returns 如果向量相等则返回 true，否则返回 false。
         */
        equal(value: Vector4): boolean;
        /**
         * @en Calculates the length of the vector4.
         * @returns The length of the vector4.
         * @zh 计算四维向量的长度。
         * @return  四维向量的长度。
         */
        length(): number;
        /**
         * @en Calculates the squared length of the vector4.
         * @returns The squared length of the vector4.
         * @zh 计算四维向量长度的平方。
         * @returns 返回四维向量长度的平方。
         */
        lengthSquared(): number;
        /**
         * @en Normalize a vector4.
         * @param s Source vector4.
         * @param out Output vector4.
         * @zh 归一化四维向量。
         * @param s 源四维向量。
         * @param out 输出四维向量。
         */
        static normalize(s: Vector4, out: Vector4): void;
        /**
         * @en Calculate the sum of two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 求两个四维向量的和。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static add(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate the difference between two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 求两个四维向量的差。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static subtract(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate the product of two four-dimensional vectors.
         * @param a First vector4.
         * @param b Second vector4.
         * @param out Output vector.
         * @zh 计算两个四维向量的乘积。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 输出向量。
         */
        static multiply(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Scale a four-dimensional vector.
         * @param a Source vector4.
         * @param b Scale value.
         * @param out Output vector4.
         * @zh 缩放四维向量。
         * @param a 源四维向量。
         * @param b 缩放值。
         * @param out 输出四维向量。
         */
        static scale(a: Vector4, b: number, out: Vector4): void;
        /**
         * @en Clamp a four-dimensional vector within a specified range.
         * @param value Vector to be clamped.
         * @param min Minimum values.
         * @param max Maximum values.
         * @param out Output vector.
         * @zh 将四维向量限制在指定的范围内。
         * @param value 要限制的向量。
         * @param min 最小值。
         * @param max 最大值。
         * @param out 输出向量。
         */
        static Clamp(value: Vector4, min: Vector4, max: Vector4, out: Vector4): void;
        /**
         * @en Calculate the squared distance between two four-dimensional vectors.
         * @param value1 The first vector4.
         * @param value2 The second vector4.
         * @returns The squared distance.
         * @zh 计算两个四维向量之间距离的平方。
         * @param value1 第一个四维向量。
         * @param value2 第二个四维向量。
         * @returns 距离的平方。
         */
        static distanceSquared(value1: Vector4, value2: Vector4): number;
        /**
         * @en Calculate the distance between two four-dimensional vectors.
         * @param value1 The first vector.
         * @param value2 The second vector.
         * @returns The distance.
         * @zh 计算两个四维向量之间的距离。
         * @param value1 第一个向量。
         * @param value2 第二个向量。
         * @returns 距离。
         */
        static distance(value1: Vector4, value2: Vector4): number;
        /**
         * @en Calculate the dot product of two four-dimensional vectors.
         * @param a The first vector.
         * @param b The second vector.
         * @returns The dot product.
         * @zh 计算两个四维向量的点积。
         * @param a 第一个向量。
         * @param b 第二个向量。
         * @returns 点积。
         */
        static dot(a: Vector4, b: Vector4): number;
        /**
         * @en Calculate a new four-dimensional vector using the minimum values of x, y, z, and w from two vectors.
         * @param a The first vector4.
         * @param b The second vector4.
         * @param out The resulting vector4.
         * @zh 分别取两个四维向量x、y、z、w的最小值计算新的四维向量。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 结果四维向量。
         */
        static min(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * @en Calculate a new four-dimensional vector using the maximum values of x, y, z, and w from two vectors.
         * @param a The first vector4.
         * @param b The second vector4.
         * @param out The resulting vector4.
         * @zh 分别取两个四维向量x、y、z、w的最大值计算新的四维向量。
         * @param a 第一个四维向量。
         * @param b 第二个四维向量。
         * @param out 结果四维向量。
         */
        static max(a: Vector4, b: Vector4, out: Vector4): void;
    }
    /**
     * @en The `Vector4Keyframe` class is used to create instances of four-dimensional vector keyframes.
     * @zh `Vector4Keyframe` 类用于创建四维向量关键帧实例。
     */
    class Vector4Keyframe extends Keyframe {
        /**
         * @en In tangent.
         * @zh 内切线。
         */
        inTangent: Vector4;
        /**
         * @en Out tangent.
         * @zh 外切线。
         */
        outTangent: Vector4;
        /**
         * @en Frame data.
         * @zh 帧数据。
         */
        value: Vector4;
        /**
         * @en In weight.
         * @zh 内权重。
         */
        inWeight: Vector4;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        outWeight: Vector4;
        /**
         * @en Out weight.
         * @zh 外权重。
         */
        weightedMode: Vector4;
        /**
         * @en Creates an instance of the `Vector4Keyframe` class.
         * @param weightMode Whether to use weight mode. Default is false.
         * @zh 创建 `Vector4Keyframe` 类的实例。
         * @param weightMode 是否使用权重模式。默认为 false。
         */
        constructor(weightMode?: boolean);
        /**
        * @override
        * @en Clone
        * @param dest The target object to clone to.
        * @zh 克隆
        * @param dest 克隆源。
        */
        cloneTo(dest: Vector4Keyframe): void;
    }
    /**
     * @en The `Viewport` class is used to create a viewport.
     * @zh `Viewport` 类用于创建视口。
     */
    class Viewport {
        static readonly TEMP: Viewport;
        /**
         * @en X-axis coordinate
         * @zh X轴坐标
         */
        x: number;
        /**
         * @en Y-axis coordinate
         * @zh Y轴坐标
         */
        y: number;
        /**
         * @en Width
         * @zh 宽度
         */
        width: number;
        /**
         * @en Height
         * @zh 高度
         */
        height: number;
        /**
         * @en Minimum depth
         * @zh 最小深度
         */
        minDepth: number;
        /**
         * @en Maximum depth
         * @zh 最大深度
         */
        maxDepth: number;
        /**
         * @en Constructor method, initialize viewport.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param width Width.
         * @param height Height.
         * @zh 构造方法，初始化视口。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param width 宽度。
         * @param height 高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * @en Project a three-dimensional vector to viewport space.
         * @param source vector3.
         * @param matrix Transformation matrix.
         * @param out x, y, z are viewport space coordinates; in perspective projection, w is the z-axis coordinate relative to the transformation matrix.
         * @zh 投影一个三维向量到视口空间。
         * @param source 三维向量。
         * @param matrix 变换矩阵。
         * @param out x、y、z为视口空间坐标，透视投影下w为相对于变换矩阵的z轴坐标。
         */
        project(source: Vector3, matrix: Matrix4x4, out: Vector4): void;
        /**
         * @en Unproject a three-dimensional vector.
         * @param source Source vector3.
         * @param matrix Transformation matrix.
         * @param out Output vector3.
         * @zh 反变换一个三维向量。
         * @param source 源三维向量。
         * @param matrix 变换矩阵。
         * @param out 输出三维向量。
         */
        unprojectFromMat(source: Vector3, matrix: Matrix4x4, out: Vector3): void;
        /**
         * @en Unproject a three-dimensional vector using World-View-Projection matrices.
         * @param source Source vector3.
         * @param projection Perspective projection matrix.
         * @param view View matrix.
         * @param world World matrix, can be set to null.
         * @param out Output vector.
         * @zh 使用世界-视图-投影矩阵反变换一个三维向量。
         * @param source 源三维向量。
         * @param projection 透视投影矩阵。
         * @param view 视图矩阵。
         * @param world 世界矩阵，可设置为null。
         * @param out 输出向量。
         */
        unprojectFromWVP(source: Vector3, projection: Matrix4x4, view: Matrix4x4, world: Matrix4x4, out: Vector3): void;
        /**
         * @en Set viewport values.
         * @param x X-axis coordinate.
         * @param y Y-axis coordinate.
         * @param width Width.
         * @param height Height.
         * @zh 设置视口值。
         * @param x X轴坐标。
         * @param y Y轴坐标。
         * @param width 宽度。
         * @param height 高度。
         */
        set(x: number, y: number, width: number, height: number): void;
        /**
         * @en Clone the viewport.
         * @param out Output viewport.
         * @zh 克隆视口。
         * @param out 输出视口。
         */
        cloneTo(out: Viewport): void;
    }
    /**
     * @en Audio data cache manager. It uses a least recently used (LRU) caching strategy to manage cached audio data.
     * @zh 音频数据缓存管理器。内部使用了最少最近使用（LRU）缓存策略来管理缓存的音频数据。
     */
    class AudioDataCache {
        private _items;
        private _size;
        private _lastCheck;
        constructor();
        /**
         * @en Add an audio data to the cache.
         * @param url The URL of the audio data.
         * @param obj The AudioBuffer object.
         * @param size The size of the audio data in bytes.
         * @zh 将音频数据添加到缓存中。
         * @param url 音频数据的 URL。
         * @param obj AudioBuffer 对象。
         * @param size 音频数据的大小（字节）。
         */
        add(url: string, obj: any, size: number): void;
        /**
         * @en Get an audio data from the cache.
         * @param url The URL of the audio data.
         * @param callback The callback function to be called with the audio data.
         * @param callbackThis The context of the callback function.
         * @zh 从缓存中获取音频数据。
         * @param url 音频数据的 URL。
         * @param callback 回调函数，将音频数据传递给它。
         * @param callbackThis 回调函数的上下文。
         */
        get(url: string, callback: (obj: any) => void, callbackThis?: any): void;
    }
    /**
     * @ignore
     */
    class HTMLAudioChannel extends SoundChannel {
        private _ele;
        private static elementPool;
        get position(): number;
        get duration(): number;
        protected onPlay(url: string): void;
        protected onPlayAgain(): void;
        protected onStop(): void;
        protected onPause(): void;
        protected onResume(): void;
        protected onVolumeChanged(): void;
        protected onMuted(): void;
    }
    /**
     * @ignore
     */
    class HTMLVideoPlayer extends VideoPlayer {
        readonly element: HTMLVideoElement;
        constructor();
        get currentTime(): number;
        set currentTime(value: number);
        get volume(): number;
        set volume(value: number);
        get readyState(): any;
        get duration(): number;
        get ended(): boolean;
        get loop(): boolean;
        set loop(value: boolean);
        get playbackRate(): number;
        set playbackRate(value: number);
        get muted(): boolean;
        set muted(value: boolean);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onTransformChanged(): void;
        protected onDestroy(): void;
        static createElement(): HTMLVideoElement;
        static setSrc(ele: HTMLVideoElement, url: string): void;
    }
    /**
     * @ignore
     */
    class HTMLVideoTexture extends VideoTexture {
        readonly element: HTMLVideoElement;
        private _needUpdate;
        private _hasRequestVideoFrame;
        constructor();
        get currentTime(): number;
        set currentTime(value: number);
        get volume(): number;
        set volume(value: number);
        get readyState(): any;
        get duration(): number;
        get ended(): boolean;
        get loop(): boolean;
        set loop(value: boolean);
        get playbackRate(): number;
        set playbackRate(value: number);
        get muted(): boolean;
        set muted(value: boolean);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onRender(): boolean;
        protected onDestroy(): void;
    }
    /**
     * @en The `SoundChannel` class is used to control sounds in the program. Each sound is assigned to a channel, and an application can have multiple channels mixed together.
     * The `SoundChannel` class contains methods for controlling sound playback, pause, stop, volume, as well as methods for getting information about the sound's playback status, total time, current playback time, total loop count, and playback address.
     * @zh `SoundChannel` 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * `SoundChannel` 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。
     */
    class SoundChannel extends EventDispatcher {
        /**
         * @en The URL of the sound.
         * @zh 声音地址。
         */
        readonly url: string;
        /**
         * @en The number of loops. Zero indicates an infinite loop.
         * @zh 循环次数。零表示无限循环。
         */
        loops: number;
        /**
         * @en The start time of sound playback. In seconds.
         * @zh 播放声音开始时间。以秒为单位。
         */
        startTime: number;
        /**
         * @en Sound playback rate. default value is 1.
         * @zh 声音播放速率。默认值为1。
         */
        playbackRate: number;
        /**
         * @en The handler for playback completion.
         * @zh 播放完成处理器。
         */
        completeHandler: Handler | ((success: boolean) => void);
        protected _started: boolean;
        protected _paused: boolean;
        protected _loaded: boolean;
        protected _completed: boolean;
        protected _repeated: number;
        protected _volumeSet: number;
        protected _volume: number;
        protected _muted: boolean;
        protected _startTime: number;
        protected _pauseTime: number;
        /** @internal */
        _isMusic: boolean;
        /** @internal */
        _autoResume: boolean;
        constructor(url: string);
        /**
         * @en The volume. The volume range is from 0 (mute) to 1 (maximum volume).
         * @zh 音量。音量范围从 0（静音）至 1（最大音量）。
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en Indicates whether the mute switch is turned on. Note that this property is controlled by the SoundManager's mute switch, so it is generally not recommended to set this value directly.
         * @zh 表示静音开关是否已打开。请注意，这个属性受SoundManager的静音开关控制，因此一般不要直接设置这个值。
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * @en The current playback position in seconds
         * @zh 当前播放位置，以秒为单位
         */
        get position(): number;
        /**
         * @en The duration of the audio in seconds
         * @zh 音频的持续时间，以秒为单位
         */
        get duration(): number;
        /**
         * @en Indicates whether the sound is paused.
         * @zh 表示声音是否已暂停。
         */
        get paused(): boolean;
        /**
         * @en Indicates whether the sound is stopped.
         * @zh 表示声音是否已停止
         */
        get isStopped(): boolean;
        /**
         * @en Play the sound.
         * @zh 播放声音。
         */
        play(): void;
        /**
         * @en Stop playing the sound.
         * @zh 停止播放。
         */
        stop(): void;
        /**
         * @en Pause the sound playback.
         * @zh 暂停播放。
         */
        pause(): void;
        /**
         * @en Resume the sound playback.
         * @zh 继续播放。
         */
        resume(): void;
        protected onPlay(url: string): void;
        protected onPlayAgain(): void;
        protected onStop(): void;
        protected onPause(): void;
        protected onResume(): void;
        protected onVolumeChanged(): void;
        protected onMuted(): void;
        protected onPlayEnd(): void;
        protected callComplete(success: boolean): void;
    }
    /**
     * @en The `SoundManager` is a sound management class. It provides control methods for playing background music and sound effects.
     * - The engine has two default sound schemes: WebAudio and H5Audio.
     * - For playing sound effects, WebAudio is prioritized. If WebAudio is not available, H5Audio is used. H5Audio may have compatibility issues on some devices (such as inability to mix sounds or playback delays).
     * - For playing background music, H5Audio is used (using WebAudio would significantly increase memory usage and cause a delay as it needs to wait for the sound to load completely before playing).
     * - It is recommended to use mp3 format for background music and wav or mp3 format for sound effects (if packaging as an app, only wav format can be used for sound effects).
     * @zh `SoundManager` 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
     * - 引擎默认有两套声音方案：WebAudio和H5Audio。
     * - 播放音效时，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放。H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
     * - 播放背景音乐时，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）。
     * - 建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
     * @blueprintable
     */
    class SoundManager {
        /**
         * @en Sound playback rate. default value is 1.
         * @zh 声音播放速率。默认值为1。
         */
        static playbackRate: number;
        /**
         * @en Determines whether background music is played using the Audio tag.
         * @zh 背景音乐是否使用Audio标签播放。
         */
        static useAudioMusic: boolean;
        /**
         * @en Whether to automatically stop background music when losing focus.
         * @zh 失去焦点后是否自动停止背景音乐。
         */
        static autoStopMusic: boolean;
        /**@internal */
        static __init__(): void;
        private static _muted;
        private static _soundMuted;
        private static _musicMuted;
        private static _musicVolume;
        private static _soundVolume;
        private static _musicChannel;
        private static _channels;
        /**
         * @en Background music volume. default value is 1.
         * @zh 背景音乐音量。默认值为1。
         */
        static get musicVolume(): number;
        static set musicVolume(value: number);
        /**
         * @en Sound effect volume. default value is 1.
         * @zh 音效音量。默认值为1。
         */
        static get soundVolume(): number;
        static set soundVolume(value: number);
        /**
         * @en Whether background music and all sound effects are muted.
         * @zh 背景音乐和所有音效是否静音。
         */
        static get muted(): boolean;
        static set muted(value: boolean);
        /**
         * @en Whether all sound effects (excluding background music) are muted.
         * @zh 所有音效（不包括背景音乐）是否静音。
         */
        static get soundMuted(): boolean;
        static set soundMuted(value: boolean);
        /**
         * @en Whether background music (excluding sound effects) is muted.
         * @zh 背景音乐（不包括音效）是否静音。
         */
        static get musicMuted(): boolean;
        static set musicMuted(value: boolean);
        /**
         * @en Play a sound effect. Multiple sound effects can be played simultaneously.
         * @param url The URL of the sound file.
         * @param loops The number of times to loop the sound. 0 means infinite loop.
         * @param complete The callback function when the sound playback is complete.
         * @param startTime The start time of the sound playback. In seconds.
         * @returns A SoundChannel object, through which you can control the sound and get sound information.
         * @zh 播放音效。音效可以同时播放多个。
         * @param url 声音文件地址。
         * @param loops 循环次数，0表示无限循环。
         * @param complete 声音播放完成回调。
         * @param startTime 声音播放起始时间。以秒为单位。
         * @returns SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playSound(url: string, loops?: number, complete?: () => void, startTime?: number): SoundChannel;
        /** @deprecated */
        static playSound(url: string, loops?: number, complete?: Handler, startTime?: number): SoundChannel;
        /** @deprecated */
        static playSound(url: string, loops?: number, complete?: Handler, soundClass?: new () => any, startTime?: number): SoundChannel;
        /**
         * @en Play background music. Only one background music can be played at a time. If this method is called while background music is already playing, the previous music will be stopped before playing the current one.
         * @param url The URL of the sound file.
         * @param loops The number of times to loop the music. 0 means infinite loop. Default is 1.
         * @param complete The callback function when the music playback is complete. The result parameter is true if playback is completed, false/undefined if triggered by stop.
         * @param startTime The start time of the music playback. In seconds.
         * @returns A SoundChannel object, through which you can control the sound and get sound information.
         * @zh 播放背景音乐。背景音乐同时只能播放一个，如果在播放背景音乐时再次调用本方法，会先停止之前的背景音乐，再播放当前的背景音乐。
         * @param url 声音文件地址。
         * @param loops 循环次数，0表示无限循环。默认为1。
         * @param complete 声音播放完成回调，complete 结果参数 true: 播放完成, false/undefined：stop触发的complete。
         * @param startTime 声音播放起始时间。以秒为单位。
         * @returns SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playMusic(url: string, loops?: number, complete?: (success: boolean) => void, startTime?: number): SoundChannel;
        /** @deprecated */
        static playMusic(url: string, loops?: number, complete?: Handler, startTime?: number): SoundChannel;
        /**
         * @en Stop playing a specific sound. This method can stop the playback of any sound (including background music and sound effects) by providing the corresponding sound file address.
         * @param url The URL of the sound file.
         * @zh 停止声音播放。此方法能够停止任意声音的播放（包括背景音乐和音效），只需传入对应的声音播放地址。
         * @param url 声音文件地址。
         */
        static stopSound(url: string): void;
        /**
         * @en Stop playing all sounds (including background music and sound effects).
         * @zh 停止播放所有声音（包括背景音乐和音效）。
         */
        static stopAll(): void;
        /**
         * @en Stop playing all sound effects (excluding background music).
         * @zh 停止播放所有音效（不包括背景音乐）。
         */
        static stopAllSound(): void;
        /**
         * @en Stop playing background music (excluding sound effects).
         * @zh 停止播放背景音乐（不包括音效）。
         */
        static stopMusic(): void;
        /**
         * @deprecated Use SoundManager.soundVolume instead.
         */
        static setSoundVolume(volume: number, url?: string): void;
        /**
         * @deprecated Use SoundManager.musicVolume instead.
         */
        static setMusicVolume(volume: number): void;
        /**
         * @en Find a sound channel by its URL.
         * @param url The URL of the sound file.
         * @returns The SoundChannel object corresponding to the URL, or null if not found.
         * @zh 通过声音地址查找声音通道。
         * @param url 声音文件地址。
         * @returns 对应声音地址的SoundChannel对象，如果没有找到则返回null。
         */
        static findChannel(url: string): SoundChannel | null;
        private static updateMutedStatus;
        /** @internal */
        static addChannel(channel: SoundChannel): void;
        /** @internal */
        static removeChannel(channel: SoundChannel): void;
    }
    /**
     * @en Nodes used for playing background music or sound effects
     * @zh 用于播放背景音乐或者音效的节点
     */
    class SoundNode extends Sprite {
        private _channel;
        private _tar;
        private _playEvents;
        private _stopEvents;
        private _source;
        private _isMusic;
        private _autoPlay;
        private _loop;
        constructor();
        /**
         * @en Audio source
         * @zh 音频源
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Determines if the audio type is background music. If true, it's background music; otherwise, it's a sound effect.
         * @zh 确定音频类型是否为背景音乐。如果为true，音乐类型为背景音乐，否则为音效
         */
        get isMusic(): boolean;
        set isMusic(value: boolean);
        /**
         * @en The number of times the audio should loop
         * @zh 循环次数
         */
        get loop(): number;
        set loop(value: number);
        /**
         * @en Determines if the audio should auto-play
         * @zh 是否自动播放
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Play the audio
         * @param loops The number of times to loop the audio
         * @param complete The callback function to be called when playback is complete
         * @param startTime The time to start playing the audio from
         * @zh 播放音频
         * @param loops 循环次数
         * @param complete 完成回调函数
         * @param startTime 播放开始时间
         */
        play(loops?: number, complete?: (success: boolean) => void, startTime?: number): void;
        /** @deprecated */
        play(loops?: number, complete?: Handler, startTime?: number): void;
        /**
         * @en Stop playing the audio
         * @zh 停止播放音频
         */
        stop(): void;
        private _setPlayAction;
        private _setPlayActions;
        /**
         * @en The events string that trigger audio playback
         * @zh 触发播放的事件字符串
         */
        set playEvent(events: string);
        /**
         * @en The target sprite object that controls audio playback
         * @zh 控制播放的精灵对象
         */
        set target(tar: Sprite);
        /**
         * @en Set the events string that trigger audio stop
         * @zh 设置触发停止的事件字符串
         */
        set stopEvent(events: string);
        private onDisplay;
        private onUndisplay;
    }
    /**
     * @en VideoNode displays video on Canvas. Video may not be effective in all platforms.
     * On PC, you can call play() at any time, so the Video can start playing as soon as the program starts running.
     * However, on mobile devices, play() can only be called after the user's first touch on the screen, so it's not possible to automatically start playing Video when the program starts running on mobile devices.
     * @zh VideoNode将视频显示到Canvas上。Video可能不会在所有平台有效。
     * 在PC端可以在任何时机调用play()，因此可以在程序开始运行时就使Video开始播放。
     * 但是在移动端，只有在用户第一次触碰屏幕后才可以调用play()，所以移动端不可能在程序开始运行时就自动开始播放Video。
     */
    class VideoNode extends Sprite {
        /**
         * @en Video player options. These options need to be set before setting the source, and if you change the settings, you need to reset the source.
         * @zh 视频播放器选项。这些选项需要在设置source前设置好，如果更改设置，需要重新设置source。
         */
        readonly options: IVideoPlayerOptions;
        /**
         * @zh 视频播放模式。如果设置的模式不支持，会尝试使用另外一种模式。
         * -- player: 使用播放器。这时播放器是浮动在主画布上面（或下面）的，不能与嵌套在UI层级中。
         * -- decoder: 使用解码器。视频会被捕获到Texture再显示，因此可以嵌套在UI层级中。
         * @en Video playback mode. If the set mode is not supported, it will try to use another mode.
         * -- player: Use the player. The player is floating above (or below) the main canvas and cannot be nested in the UI hierarchy.
         * -- decoder: Use the decoder. The video is captured to a Texture and then displayed, so it can be nested in the UI hierarchy.
         */
        mode: "player" | "decoder";
        private _tex;
        private _vtex;
        private _player;
        private _api;
        private _source;
        private _autoPlay;
        private _loop;
        private _volume;
        private _muted;
        private _playbackRate;
        private _allowBackground;
        private _paused;
        /** @ignore */
        constructor();
        /**
         * @en Video player
         * @zh 视频播放器
         */
        get player(): VideoPlayer | VideoTexture | null;
        /**
         * @en Video source
         * @zh 视频源
         */
        get source(): string;
        set source(value: string);
        /**
         * @en Whether to automatically play the video after loading. Default is true.
         * @zh 视频加载完成后是否自动播放。默认值为true。
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Whether to allow background playback. Default is false.
         * @zh 是否允许后台播放。默认值为false。
         */
        get allowBackground(): boolean;
        set allowBackground(value: boolean);
        /**
         * @en The current playback position in seconds.
         * @zh 当前播放头位置（以秒为单位）。
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * @en The ready state of the video element:
         * - 0 = HAVE_NOTHING - No information is available about the audio/video readiness
         * - 1 = HAVE_METADATA - Metadata about the audio/video is ready
         * - 2 = HAVE_CURRENT_DATA - Data for the current playback position is available, but not enough to play the next frame/millisecond
         * - 3 = HAVE_FUTURE_DATA - Data for the current and at least the next frame is available
         * - 4 = HAVE_ENOUGH_DATA - Enough data is available to begin playback
         * @zh 视频元素的就绪状态：
         * - 0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息
         * - 1 = HAVE_METADATA - 关于音频/视频就绪的元数据
         * - 2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒
         * - 3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的
         * - 4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放
         */
        get readyState(): number;
        /**
         * @en The video source width. Available after the ready event is triggered.
         * @zh 视频源宽度。ready 事件触发后可用。
         */
        get videoWidth(): number;
        /**
         * @en The video source height. Available after the ready event is triggered.
         * @zh 视频源高度。ready 事件触发后可用。
         */
        get videoHeight(): number;
        /**
         * @en The video duration in seconds. Available after the ready event is triggered.
         * @zh 视频长度（秒）。ready 事件触发后可用。
         */
        get duration(): number;
        /**
         * @en Returns whether the playback of the audio/video has ended.
         * @zh 返回音频/视频的播放是否已结束。
         */
        get ended(): boolean;
        /**
         * @en Whether the video should loop when it ends.
         * @zh 视频是否应在结束时重新播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The current playback speed of the video. For example:
         * - 1.0: Normal speed
         * - 0.5: Half speed (slower)
         * - 2.0: Double speed (faster)
         * - -1.0: Backwards, normal speed
         * - -0.5: Backwards, half speed
         * Note: Only Google Chrome and Safari support the playbackRate property.
         * @zh 视频的当前播放速度。例如：
         * - 1.0：正常速度
         * - 0.5：半速（更慢）
         * - 2.0：倍速（更快）
         * - -1.0：向后，正常速度
         * - -0.5：向后，半速
         * 注意：只有 Google Chrome 和 Safari 支持 playbackRate 属性。
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * @en The current volume level.
         * @zh 当前音量。
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en The muted state of the video.
         * @zh 视频的静音状态。
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * @en If the video is paused.
         * @zh 视频是否暂停。
         */
        get paused(): boolean;
        /**
         * @en Set playback source
         * @param url Play source path.
         * @zh 设置播放源。
         * @param url 播放源路径。
         */
        load(url: string): void;
        /**
         * @en Start playing the video
         * @zh 开始播放视频
         */
        play(): void;
        /**
         * @en Pause video playback
         * @zh 暂停视频播放
         */
        pause(): void;
        /**
         * @en Reload the video
         * @zh 重新加载视频
         */
        reload(): void;
        /**
         * @en Check if the specified video format is supported for playback.
         * @param type The video format type, such as "mp4", "ogg", "webm", "m3u8", etc.
         * @returns The level of support. Possible values:
         * - "probably": The browser most likely supports this audio/video type
         * - "maybe": The browser might support this audio/video type
         * - "": (empty string) The browser does not support this audio/video type
         * @zh 检测是否支持播放指定格式视频。
         * @param type	视频格式类型，如 "mp4"、"ogg"、"webm"、"m3u8" 等。
         * @returns 表示支持的级别。可能的值：
         * - "probably"：浏览器最可能支持该音频/视频类型
         * - "maybe"：浏览器也许支持该音频/视频类型
         * - ""：（空字符串）浏览器不支持该音频/视频类型
         */
        canPlayType(type: string): CanPlayTypeResult;
        private _load;
        private _vtReady;
        private _unload;
        private onDisplay;
        private onUndisplay;
        /**
         * @ignore
         */
        destroy(detroyChildren?: boolean): void;
        /** @deprecated */
        get currentSrc(): string;
        /** @deprecated */
        get videoTexture(): VideoTexture | null;
        /** @deprecated */
        set videoTexture(value: VideoTexture);
    }
    interface IVideoPlayerOptions {
        /**
         * @en Whether to show the video controls. Default is false.
         * @zh 是否显示视频控制。默认否。
         */
        controls?: boolean;
        /**
         * @en Whether the video is displayed under the game canvas (the canvas needs to be set to transparent). Default is false.
         * @zh 视频是否显示在游戏画布之下（画布需设置为透明)。默认否。
         */
        underGameView?: boolean;
        /**
         * @en Video scaling mode. Default is contain.
         * @zh 视频的缩放模式。默认contain。
         */
        objectFit?: "fill" | "contain" | "cover";
        /**
         * @en Whether to show the video progress bar.
         * @zh 是否显示视频进度条。
         */
        showProgress?: boolean;
        /**
         * @en Whether to show the progress bar in the control bar.
         * @zh 是否显示控制栏的进度条。
         */
        showProgressInControlMode?: boolean;
        /**
         * @en Whether it is live broadcast。
         * @zh 是否是直播。
         */
        live?: boolean;
        /**
         * @en Whether to show the play button in the center of the video。
         * @zh 是否在视频中间显示播放按钮。
         */
        showCenterPlayBtn?: boolean;
        /**
         * @en Whether the video follows the system mute switch setting (iOS only)。
         * @zh 视频是否遵循系统静音开关设置（仅iOS）。
         */
        obeyMuteSwitch?: boolean;
    }
    /**
     * @en Video player class
     * @zh 视频播放器类
     */
    class VideoPlayer {
        /**
         * @en Video player options
         * @zh 视频播放器选项
         */
        options: IVideoPlayerOptions;
        /**
         * @en Whether to allow the video to continue playing in the background。
         * @zh 视频是否允许在后台继续播放。
         */
        allowBackground: boolean;
        protected _owner: Sprite;
        protected _playing: boolean;
        protected _loaded: boolean;
        /** @internal */
        _autoResume: boolean;
        /**
         * @en The current playback position in seconds
         * @zh 当前播放头位置（以秒为单位）
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
        * @en The current volume level
        * @zh 当前音量
        */
        get volume(): number;
        set volume(value: number);
        /**
         * @en The muted state of the video
         * @zh 视频的静音状态
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
        * @en The duration of the video in seconds. Available after the ready event is triggered.
        * @zh 视频长度（秒）。ready 事件触发后可用。
        */
        get duration(): number;
        /**
         * @en If the playback of the audio/video has ended
         * @zh 音频/视频的播放是否已结束
         */
        get ended(): boolean;
        /**
         * @en Whether the audio/video should loop when it reaches the end
         * @zh 音频/视频是否应在结束时重新播放
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The current playback speed of the audio/video. For example:
         * - 1.0: Normal speed
         * - 0.5: Half speed (slower)
         * - 2.0: Double speed (faster)
         * - -1.0: Backwards, normal speed
         * - -0.5: Backwards, half speed
         * Note: Only Google Chrome and Safari support the playbackRate property.
         * @zh 音频/视频的当前播放速度。例如：
         * - 1.0：正常速度
         * - 0.5：半速（更慢）
         * - 2.0：倍速（更快）
         * - -1.0：向后，正常速度
         * - -0.5：向后，半速
         * 注意：只有 Google Chrome 和 Safari 支持 playbackRate 属性。
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
        * @en If the video is paused
        * @zh 视频是否暂停
        */
        get paused(): boolean;
        attachTo(owner: Sprite): void;
        /**
         * @en Load the video
         * @zh 加载视频
         */
        load(url: string): void;
        /**
         * @en Start playing the video
         * @zh 开始播放视频
         */
        play(): void;
        /**
         * @en Pause the video playback
         * @zh 暂停播放视频
         */
        pause(): void;
        /**
         * @en Resume the video playback
         * @zh 继续播放视频
         */
        resume(): void;
        protected setLoaded(): void;
        protected getNodeTransform(): {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        protected onTransformChanged(): void;
        /**
         * @en Destroy the video player
         * @zh 销毁视频播放器
         */
        destroy(): void;
        protected onBlur(): void;
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onDestroy(): void;
    }
    /**
     * @en Video texture class, used to create video textures.
     * @zh 视频纹理
     * @blueprintIgnoreSubclasses
     */
    class VideoTexture extends BaseTexture {
        /**
         * @en Whether to allow the video to continue playing in the background。
         * @zh 视频是否允许在后台继续播放。
         */
        allowBackground: boolean;
        protected _source: string;
        protected _playing: boolean;
        protected _loaded: boolean;
        protected _frameRender: boolean;
        protected _interval: number;
        protected _lastTimer: number;
        protected _frameRate: number;
        protected _useMediaFrameRate: boolean;
        protected _loop: boolean;
        /** @internal */
        _autoResume: boolean;
        /**
         * @en Create a video texture instance. You need to create a video texture in this way. You cannot directly use the new VideoTexture() method to create it.
         * @zh 创建一个视频纹理实例，需要通过这种方式创建视频纹理，不能直接使用new VideoTexture()的方式创建。
         * @returns
         */
        static createInstance(): VideoTexture;
        /**
         * @ignore
         */
        constructor();
        /**
         * @en The frame rate of the video texture, which indicates the number of renderings in one second. It only takes effect when useMediaFrameRate is false or the current platform does not support obtaining the video frame rate.
         * @zh 视频纹理更新帧率，表示一秒内的渲染次数。只有useMediaFrameRate为false或者当前平台不支持获取视频自身帧率时才生效。
         */
        get frameRate(): number;
        set frameRate(value: number);
        /**
         * @en Whether to use the video itself frame rate to update the texture, default is true.
         * @zh 是否使用视频自身的帧率来更新纹理，默认true。
         */
        get useMediaFrameRate(): boolean;
        set useMediaFrameRate(value: boolean);
        /**
         * @en Whether to call the render function internally. If not, the user needs to call the render function manually. Default is true.
         * @zh 是否内部驱动调用render函数。如果否，则需要用户自行调用render函数。默认true。
         */
        get frameRender(): boolean;
        set frameRender(value: boolean);
        /**
         * @en The source URL for the video
         * @zh 视频的源 URL
         */
        get source(): string;
        set source(url: string);
        /**
         * @en The current playback position in seconds
         * @zh 当前播放头位置（以秒为单位）
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * @en The current volume level
         * @zh 当前音量
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en The muted state of the video
         * @zh 视频的静音状态
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * @en The readiness state of the video element:
         * - 0 = HAVE_NOTHING - No information is available about the audio/video
         * - 1 = HAVE_METADATA - Metadata for the audio/video is ready
         * - 2 = HAVE_CURRENT_DATA - Data for the current playback position is available, but not enough to play the next frame/millisecond
         * - 3 = HAVE_FUTURE_DATA - Data for the current and at least the next frame is available
         * - 4 = HAVE_ENOUGH_DATA - Enough data is available to start playing
         * @zh 视频元素的就绪状态：
         * - 0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息
         * - 1 = HAVE_METADATA - 关于音频/视频就绪的元数据
         * - 2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒
         * - 3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的
         * - 4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放
         */
        get readyState(): number;
        /**
         * @en The width of the video source. Available after the ready event is triggered.
         * @zh 视频源宽度。ready 事件触发后可用。
         */
        get videoWidth(): number;
        /**
         * @en The height of the video source. Available after the ready event is triggered.
         * @zh 视频源高度。ready 事件触发后可用。
         */
        get videoHeight(): number;
        /**
         * @en The duration of the video in seconds. Available after the ready event is triggered.
         * @zh 视频长度（秒）。ready 事件触发后可用。
         */
        get duration(): number;
        /**
         * @en If the playback of the audio/video has ended
         * @zh 音频/视频的播放是否已结束
         */
        get ended(): boolean;
        /**
         * @en Whether the audio/video should loop when it reaches the end
         * @zh 音频/视频是否应在结束时重新播放
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The current playback speed of the audio/video. For example:
         * - 1.0: Normal speed
         * - 0.5: Half speed (slower)
         * - 2.0: Double speed (faster)
         * - -1.0: Backwards, normal speed
         * - -0.5: Backwards, half speed
         * Note: Only Google Chrome and Safari support the playbackRate property.
         * @zh 音频/视频的当前播放速度。如：
         * - 1.0：正常速度
         * - 0.5：半速（更慢）
         * - 2.0：倍速（更快）
         * - -1.0：向后，正常速度
         * - -0.5：向后，半速
         * 注意：只有 Google Chrome 和 Safari 支持 playbackRate 属性。
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * @en If the video is paused
         * @zh 视频是否暂停
         */
        get paused(): boolean;
        /**
         * @en Check if the specified video format is supported for playback
         * @param type Video format type, such as "mp4", "ogg", "webm", "m3u8", etc.
         * @returns  The level of support. Possible values:
         * - "probably": The browser most likely supports this audio/video type
         * - "maybe": The browser might support this audio/video type
         * - "": (empty string) The browser does not support this audio/video type
         * @zh 检测是否支持播放指定格式视频
         * @param type	视频格式类型 "mp4","ogg","webm","m3u8"等。
         * @return 表示支持的级别。可能的值：
         * - "probably": 浏览器最可能支持该音频/视频类型
         * - "maybe": 浏览器也许支持该音频/视频类型
         * - "": （空字符串）浏览器不支持该音频/视频类型
         */
        canPlayType(type: string): CanPlayTypeResult;
        protected setLoaded(width: number, height: number, rgba: boolean): void;
        /**
         * @internal
         */
        render(force?: boolean): void;
        /**
         * @en Load the video texture.
         * @param url Video URL
         * @zh 加载视频纹理。
         * @param url 视频 URL
         */
        load(url: string): void;
        /**
         * @en Start playing the video
         * @zh 开始播放视频
         */
        play(): void;
        /**
         * @en Pause the video playback
         * @zh 暂停播放视频
         */
        pause(): void;
        /**
         * @en Resume the video playback
         * @zh 继续播放视频
         */
        resume(): void;
        /** @internal */
        get gammaCorrection(): number;
        /** @internal */
        _getSource(): any;
        /** @internal */
        get defaultTexture(): Texture2D;
        /**
         * @en Destroys the current instance and releases resources.
         * @zh 销毁当前实例并释放资源。
         */
        destroy(): void;
        protected onBlur(): void;
        protected onLoad(url: string): void;
        protected onRender(): boolean;
        protected onPlay(): void;
        protected onPause(): void;
        protected onDestroy(): void;
        /** @deprecated */
        get currentSrc(): string;
        /** @deprecated */
        get updateFrame(): number;
        /** @deprecated */
        set updateFrame(value: number);
        /** @deprecated */
        get useFrame(): boolean;
        /** @deprecated */
        set useFrame(value: boolean);
    }
    /**
     * @ignore
     */
    class WebAudioChannel extends SoundChannel {
        private _gainNode;
        private _sourceNode;
        private _buffer;
        private static gainNodePool;
        get duration(): number;
        protected onPlay(url: string): void;
        protected onPlayAgain(): void;
        protected onStop(): void;
        protected onPause(): void;
        protected onResume(): void;
        protected onVolumeChanged(): void;
        protected onMuted(): void;
        private onLoaded;
        private startPlay;
        private reset;
    }
    /**
     * <code>Nav2DAgent</code> 类用于创建2D导航代理。
     */
    class Nav2DAgent extends BaseNavAgent {
        private _destination;
        readonly owner: Sprite;
        /**
        * @en The destination for the agent.
        * @zh 代理的目的地。
        */
        get destination(): Vector2;
        set destination(value: Vector2);
        /**@ignore */
        constructor();
        /**@ignore */
        onAwake(): void;
        /**@internal */
        _getcollisionQueryRange(): number;
        /**@internal */
        _getpathOptimizationRange(): number;
        /**
         * @internal
         */
        _getradius(): number;
        /**
        * @internal
        */
        _getheight(): number;
        /**
         * @internal
         * @en Get the current rendering world coordinates
         * @zh 获取当前渲染世界坐标
         */
        _getpos(pos: Vector3): void;
        protected _getManager(): BaseNavigationManager;
        /**
         * @internal
         * 同步寻路位置和方向到渲染引擎
         */
        _updatePosition(pos: Vector3, dir: Vector3): void;
    }
    /**
     * @en NavMesh2DSurface is a 2D component that modifies the navigation mesh surface.
     * @zh NavMesh2DSurface 是一个修改2D导航网格表面的组件。
     */
    class NavMesh2DSurface extends BaseNavMeshSurface {
        protected _navMeshAreas: NavMesh2DModifierArea[];
        protected _navMeshObstacles: NavMesh2DObstacles[];
        protected _navMeshLink: NavMesh2DLink[];
        protected _transfrom: Matrix4x4;
        readonly owner: Sprite;
        /**
         * @en Modified areas of the navigation mesh surface.
         * @zh 导航网格表面的修改区域。
         */
        get areas(): NavMesh2DModifierArea[];
        set areas(value: NavMesh2DModifierArea[]);
        /**
         * @en The obstacles that modify the surface of the navigation mesh.
         * @zh 导航网格表面的障碍物。
         */
        get obstacles(): NavMesh2DObstacles[];
        set obstacles(value: NavMesh2DObstacles[]);
        /**
         * @en Links on the navigation mesh surface.
         * @zh 导航网格表面的链接。
         */
        get navMeshLink(): NavMesh2DLink[];
        set navMeshLink(value: NavMesh2DLink[]);
        /**
         * <code>实例化一个寻路功能<code>
         * @ignore
         */
        constructor();
        /**
         * @ignore
         */
        onAwake(): void;
        /**@internal */
        _getManager(): Navigation2DManage;
        protected _crateNavMesh(config: RecastConfig, min: Vector3, max: Vector3): NavMesh2D;
    }
    /** @internal*/
    class Navgiation2DUtils {
        private static _colorMap;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @internal
         */
        static _vec2ToVec3: (value: Vector2, out: Vector3) => void;
        /**
         * @internal
         */
        static _setValue3(x: number, y: number, out: Vector3): void;
        /**
         * @internal
         */
        static _getSpriteGlobalPos(sprite: Sprite, out: Vector3): void;
        /**
         * @internal
         */
        static _transfromVec2ToVec3(vec2: Vector2, mat: Matrix, out: Vector3): void;
        /** @internal*/
        static _getSpriteMatrix4x4(sprite: Sprite, out: Matrix4x4): void;
        /** @internal*/
        static _getTransfromMatrix4x4(pos: Vector2, rot: number, scale: Vector2, out: Matrix4x4): void;
        /** @internal*/
        private static _getTitleData;
        /** @internal*/
        private static _updateMesh2DData;
        /**
         * @internal
         * create navMesh tile to Laya Mesh
         * @param navMesh
         * @param mesh
         */
        static _createDebugMesh(navMesh: NavMesh2D, mesh?: Mesh2D, isGlobal?: boolean): Mesh2D;
    }
    enum NavObstacles2DType {
        RECT = 0,
        CIRCLE = 1,
        CUSTOMER = 2
    }
    class Navigation2DManage extends BaseNavigationManager {
        /**@internal */
        static _managerName: string;
        static _obstacleMap: Map<NavObstacles2DType, NavTileCache>;
        /**
         * 获取导航管理器
         * @internal
         * @param comp
         */
        static _getNavManager(comp: Component): Navigation2DManage;
        /** @internal */
        static __initialize(): Promise<void>;
        protected static __init__(): void;
        /** @internal */
        static _getObstacleData(type: NavObstacles2DType): NavTileCache;
        /**@ignore */
        constructor();
        /**
         * @internal
         */
        _init(): void;
    }
    class NavMesh2D extends BaseNavMesh {
        protected _debugMesh: Mesh2D;
        _surface: NavMesh2DSurface;
        /** @ignore */
        constructor(config: RecastConfig, min: Vector3, max: Vector3, surface: NavMesh2DSurface);
        /**
         * @internal
         * @param cache
         * @param binds
         * @param partitionType
         */
        _addTile(cache: NavTileCache, binds: any[], partitionType: number, maxSimplificationError: number): void;
        /**
        * get Mesh
        *
        */
        buildDebugMesh(): Mesh2D;
    }
    /**
     * @en nav mesh link.
     * @zh 网格外链接。
     */
    class NavMesh2DLink {
        private _data;
        private _agentType;
        private _start;
        private _end;
        /**
         * @en Agent type for the navigation node
         * @zh 导航节点的代理类型
         */
        get agentType(): string;
        set agentType(value: string);
        /**
         * @en Area type for the navigation node
         * @zh 导航节点的区域类型
         */
        get areaFlag(): string;
        set areaFlag(value: string);
        /**
         * @en The width of the link
         * @zh 链接的宽度
         */
        get width(): number;
        set width(value: number);
        /**
         * @en Whether the link is bidirectional
         * @zh 链接是否可双向通行
         */
        get bidirectional(): boolean;
        set bidirectional(value: boolean);
        /**
         * @en The start position of the link（local position）
         * @zh 链接的起始位置(局部坐标)
         */
        get start(): Vector2;
        set start(value: Vector2);
        /**
         * @en The end position of the link （local position）
         * @zh 链接的结束位置(局部坐标)
         */
        get end(): Vector2;
        set end(value: Vector2);
        /**
         * 创建一个 <code>NavNavMeshLink</code> 实例。
         */
        constructor();
        _bindSurface(surface: NavMesh2DSurface): void;
        destroy(): void;
    }
    /**
     * @en NavMesh2DModifierArea is a 2D component that modifies the navigation mesh in a specific area.
     * @zh NavMesh2DModifierArea 一个在特定的凸多边形2D区域内修改导航网格的组件。
     */
    class NavMesh2DModifierArea {
        private _areaData;
        private _position;
        private _rotation;
        private _scale;
        /**
         * @en Agent type for the navigation node
         * @zh 导航节点的代理类型
         */
        get agentType(): string;
        set agentType(value: string);
        /**
         * @en The flag for this area.
         * @zh 该区域的标志。
         */
        get areaFlag(): string;
        set areaFlag(value: string);
        private _pointDatas;
        /**
         * @en The point data of the modifier area.
         * @zh 修改凸多边形区域的多边形顶点数据。
        */
        get datas(): number[];
        set datas(value: number[]);
        /**
         * @en The center of the modifier Polygen.
         * @zh 凸多边形区域的中心点。
         */
        get position(): Vector2;
        set position(value: Vector2);
        /**
         * @en The rotation of the modifier Polygen.
         * @zh 凸多边形区域的旋转。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The scale of the modifier Polygen.
         * @zh 凸多边形区域的缩放。
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**@ignore */
        constructor();
        /**
         * @internal
         */
        _bindSurface(surface: NavMesh2DSurface): void;
        /**
         * @internal
         */
        _destroy(): void;
        private _vector2dTo3d;
        /**@internal */
        _transfromChange(): void;
    }
    class NavMesh2DObstacles {
        private _modifierData;
        private _position;
        private _rotation;
        private _scale;
        private _size;
        private _radius;
        private _meshType;
        /**@internal load*/
        _oriTiles: NavTileData;
        /**
         * @en Agent type for the navigation node
         * @zh 导航节点的代理类型
         */
        get agentType(): string;
        set agentType(value: string);
        /**
         * @en Area type for the navigation node
         * @zh 导航节点的区域类型
         */
        get areaFlag(): string;
        set areaFlag(value: string);
        /**
         * @en The center of the modifier Obstacles.
         * @zh 障碍的中心点。
         */
        get position(): Vector2;
        set position(value: Vector2);
        /**
         * @en The rotation of the modifier Obstacles.
         * @zh 障碍的旋转。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * @en The scale of the modifier Obstacles.
         * @zh 障碍的缩放。
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * @en The data of the modifier Obstacles.
         * @zh 障碍的数据。
         */
        get datas(): TextResource;
        set datas(value: TextResource);
        /**
         * @en The type of the modifier Obstacles.
         * - NavObstacles2DType.RECT : rectangle Mesh
         * - NavObstacles2DType.CIRCLE : circle Mesh
         * - NavObstacles2DType.CUSTOMER : Custom Mesh
         * @zh 修改障碍的类型。
         * - NavObstacles2DType.RECT : 矩形网格
         * - NavObstacles2DType.CIRCLE : 圆形网格
         * - NavObstacles2DType.CUSTOMER : 自定义网格
         */
        get meshType(): NavObstacles2DType;
        set meshType(value: NavObstacles2DType);
        /**
         * @en The size of the modifier Obstacles.
         * @zh 障碍的大小。
         */
        get size(): Vector2;
        set size(value: Vector2);
        /**
         * @en The radius of the modifier Obstacles.
         * @zh 障碍的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**@ignore */
        constructor();
        /**
         * @internal
         */
        _bindSurface(surface: NavMesh2DSurface): void;
        /**@internal */
        _destroy(): void;
        /**@internal */
        _changeData(): void;
        /**@internal */
        _transfromChange(): void;
    }
    /**
     * @en BaseNav3DModifle is the base class for dynamic navigation nodes.
     * @zh BaseNav3DModifle 是动态导航节点的基类。
     */
    class BaseNav3DModifle extends Component {
        /**@internal */
        protected _modifierData: BaseData;
        /**@internal */
        protected _manager: NavigationManager;
        readonly owner: Sprite3D;
        /**
         * @en Agent type for the navigation node
         * @zh 导航节点的代理类型
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Area type for the navigation node
         * @zh 导航节点的区域类型
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        constructor();
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onWorldMatNeedChange(): void;
        /**
         * @internal
         */
        _refeashTranfrom(mat: Matrix4x4, min: Vector3, max: Vector3): void;
    }
    class NavAgent extends BaseNavAgent {
        /**@internal */
        protected _destination: Vector3;
        readonly owner: Sprite3D;
        /**
         * @en Offset of the pivot point.
         * @zh 轴心点的偏移。
         */
        set baseOffset(value: number);
        get baseOffset(): number;
        /**
         * @en Set the destination for the agent.
         * @param value The destination vector.
         * @zh 设置代理的目的地。
         * @param value 目的地位置向量。
         */
        set destination(value: Vector3);
        get destination(): Vector3;
        /**
         * @overload
         * @internal
         */
        protected _getManager(): NavigationManager;
        /**
         * @internal
         */
        _getpos(vec: Vector3): void;
        /**
         * @internal
         */
        _getheight(): number;
        /**
         * @internal
         */
        _getradius(): number;
        /**
         * @override
         */
        protected _updatePosition(pos: Vector3, dir: Vector3): void;
    }
    /**
     * @en NavMeshLink represents a connection between two points outside the navigation mesh.
     * @zh NavMeshLink 表示导航网格外的两点之间的连接。
     */
    class NavMeshLink extends BaseNav3DModifle {
        /**@internal */
        private _agentType;
        /**
         * @en The width of the link
         * @zh 链接的宽度
         */
        set width(value: number);
        get width(): number;
        /**
         * @en Whether the link is bidirectional
         * @zh 链接是否可双向通行
         */
        set bidirectional(value: boolean);
        get bidirectional(): boolean;
        /**
         * @en The start position of the link（local position）
         * @zh 链接的起始位置(局部坐标)
         */
        set start(value: Vector3);
        get start(): Vector3;
        /**
         * @en The end position of the link （local position）
         * @zh 链接的结束位置(局部坐标)
         */
        set end(value: Vector3);
        get end(): Vector3;
        /**
         * @ignore
         * 创建一个 <code>NavNavMeshLink</code> 实例。
         */
        constructor();
        private get _data();
        /**@internal */
        protected _onEnable(): void;
        /**
         * @internal
         */
        _refeashTranfrom(mat: Matrix4x4, min: Vector3, max: Vector3): void;
        /**@internal */
        _cloneTo(dest: NavMeshLink): void;
    }
    /**
     * @en NavMeshModifierVolume is a component that modifies the navigation mesh in a specific volume.
     * @zh NavMeshModifierVolume 是一个在特定体积内修改导航网格的组件。
     */
    class NavMeshModifierVolume extends Component {
        /**@internal */
        protected _volumeData: ModifierVolumeData;
        /**@internal */
        private _center;
        /**@internal */
        private _size;
        readonly owner: Sprite3D;
        /**
         * @en The agent type that this volume applies to.
         * @zh 该体积适用的代理类型。
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en The area flag for this volume.
         * @zh 该体积的区域标志。
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @en The center of the modifier volume.
         * @zh 修改体积的中心点。
         */
        get center(): Vector3;
        set center(value: Vector3);
        /**
         * @en The size of the modifier volume.
         * @zh 修改体积的大小。
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * <code>NavModifleBase<Code>
         */
        constructor();
        /**
         * @internal
         */
        protected _onEnable(): void;
        /**
         * @internal
         */
        protected _onDisable(): void;
        /**
         * @override
         */
        protected _onWorldMatNeedChange(): void;
        /**@internal */
        _cloneTo(dest: NavMeshModifierVolume): void;
    }
    /**
     * @en NavMeshModifileSurface is a component that modifies the navigation mesh surface.
     * @zh NavMeshModifileSurface 是一个修改导航网格表面的组件。
     */
    class NavMeshModifileSurface extends BaseNav3DModifle {
        /**@internal load*/
        _oriTiles: NavTileData;
        /**@internal */
        _oriNavTileCache: NavTileCache;
        /**
         * <code>NavMeshModifileSurface<Code>
         */
        constructor();
        /**
        * @en Sets or gets the baked navigation data.
        * @param value The TextResource containing the navigation data.
        * @returns The TextResource containing the navigation data.
        * @zh 设置或获取烘焙的导航数据。
        * @param value 包含导航数据的 TextResource。
        * @returns 包含导航数据的 TextResource。
        */
        set datas(value: TextResource);
        get datas(): TextResource;
        /**@internal */
        protected _onEnable(): void;
        /**
         * @internal
         */
        _refeashTranfrom(mat: Matrix4x4, min: Vector3, max: Vector3): void;
        /**@internal */
        _changeData(): void;
        _cloneTo(dest: NavMeshModifileSurface): void;
    }
    /**
     * @en NavMeshObstacles Common shapes for navigation mesh obstacles.
     * @zh NavMeshObstacles 常用的导航网格障碍物形状。
     */
    class NavMeshObstacles extends BaseNav3DModifle {
        /**@internal */
        static _boundMin: Vector3;
        /**@internal */
        static _boundMax: Vector3;
        /**@internal */
        private _meshType;
        /**@internal */
        private _localMat;
        /**@internal */
        private _center;
        /**@internal */
        private _size;
        /**@internal */
        private _height;
        /**@internal */
        private _radius;
        /**@internal load*/
        _oriTiles: NavTileData;
        /**
         * @en The mesh type of the obstacle.
         * @param value The mesh type to set.
         * @zh 障碍物的网格类型。
         * @param value 障碍物的网格类型。
         */
        set meshType(value: NavObstaclesMeshType);
        get meshType(): NavObstaclesMeshType;
        /**
         * @en The center offset of the obstacle.
         * @param value The center offset vector to set.
         * @zh 障碍物的中心偏移。
         * @param value 障碍物的中心偏移向量。
         */
        set center(value: Vector3);
        get center(): Vector3;
        /**
         * @en The size of the box obstacle.
         * @param value The size vector to set.
         * @zh 盒型障碍物的大小。
         * @param value 盒型障碍物的大小向量。
         */
        set size(value: Vector3);
        get size(): Vector3;
        /**
         * @en The height of the cylinder obstacle.
         * @param value The height to set.
         * @zh 圆柱体的圆柱高度。
         * @param value  圆柱体障碍物的高度。
         */
        set height(value: number);
        get height(): number;
        /**
         * @en Set the radius of the cylinder obstacle.
         * @param value The radius to set.
         * @zh 设置圆柱体障碍物的圆柱半径。
         * @param value 圆柱体障碍物的圆柱半径。
         */
        set radius(value: number);
        get radius(): number;
        /**
         * @en Sets the baked navigation data.
         * @param value The TextResource containing the navigation data.
         * @zh 设置获取烘焙的导航数据。
         * @param value 包含导航数据的 TextResource。
         */
        set datas(value: TextResource);
        get datas(): TextResource;
        constructor();
        /**@internal */
        protected _onEnable(): void;
        /**
         * @internal
         */
        _refeashTranfrom(mat: Matrix4x4, min: Vector3, max: Vector3): void;
        /**@internal */
        _changeData(): void;
        /**@internal */
        protected _onDestroy(): void;
        /**@internal */
        _cloneTo(dest: Component): void;
    }
    /**
     * @en NavMeshSurface is a 3D component used to generate navigation mesh.
     * @zh NavMeshSurface 是一个用于3D生成导航网格的组件。
     */
    class NavMeshSurface extends BaseNavMeshSurface {
        get navMesh(): NavMesh;
        /**
         * <code>实例化一个寻路功能<code>
         */
        constructor();
        /**
         * @overload
         * @internal
         */
        _getManager(): NavigationManager;
        /**
         * @override
         */
        protected _crateNavMesh(config: RecastConfig, min: Vector3, max: Vector3): NavMesh;
    }
    /**
     * @internal
     */
    class Navgiation3DUtils {
        static __init__(): void;
        /**@internal  */
        static _resetMesh(mesh: Mesh, vertexDeclaration: VertexDeclaration, vertices: Float32Array, indices: Uint16Array): void;
        /**@internal  */
        static _getTitleData(title: any, vbDatas: number[], center: Vector3, ibs: number[]): void;
        /**
         * create navMesh tile to Laya Mesh
         * @param navMesh
         * @param mesh
         */
        static _createDebugMesh(navMesh: NavMesh, mesh: Mesh): Mesh;
    }
    enum NavObstaclesMeshType {
        BOX = 0,
        CYLINDER = 1,
        CUSTOMER = 2
    }
    class NavigationManager extends BaseNavigationManager {
        /**@internal  */
        static _managerName: string;
        /**@internal  */
        static _obstacleMap: Map<NavObstaclesMeshType, NavTileCache>;
        /**@internal */
        static _getNavManager(comp: Component): NavigationManager;
        /**@internal */
        static _initialize(): Promise<void>;
        /**@internal */
        private static __init__;
        /**@internal */
        static _getObstacleData(type: NavObstaclesMeshType): NavTileCache;
        constructor();
    }
    /**<code>NavMesh</code> 3D导航网格*/
    class NavMesh extends BaseNavMesh {
        /**@internal */
        protected _debugMesh: Mesh;
        /**
        * 创建一个 NavMesh 实例
        */
        constructor(config: RecastConfig, min: Vector3, max: Vector3, surface: NavMeshSurface);
        /**
         * @param cache
         * @param binds
         * @param partitionType
         */
        _addTile(cache: NavTileCache, binds: any[], partitionType: number, maxSimplificationError: number): void;
        /**
         * get Mesh
         *
         */
        buildDebugMesh(): Mesh;
    }
    /**
     * @en Indicate the navigation area types that the agent can pass through.
     * @zh 表示代理可以通过的导航区域类型。
     */
    class AreaMask {
        /**@internal */
        private _flags;
        /**@internal */
        private _excludeflag;
        /**@internal */
        private _areaFlagMap;
        /**
         * @en The exclude flag.
         * @zh 排除标志。
         */
        get excludeflag(): number;
        /**
         * @en The current flag.
         * @zh 获取当前标志。
         */
        get flag(): number;
        set flag(value: number);
        /**
         * @en Creates a new instance of AreaMask.
         * @zh 创建 AreaMask 的新实例。
         */
        constructor();
        /**
         * @internal
         */
        _setAreaMap(areaFlagMap: Map<string, NavAreaFlag>): void;
        /**
         * @internal
         */
        _calculFlagVale(): void;
    }
    /**
     * @en BaseNavigationManager is a base navigation manager responsible for managing navigation meshes.
     * @zh BaseNavigationManager 是一个基础导航管理器，负责管理导航网格。
     */
    class BaseNavigationManager implements IElementComponentManager {
        /**
         * 初始化系统，由系统内部调用
         * @internal
         */
        protected static _initialize(callback: () => void | Promise<void>): Promise<void>;
        /**
        * find all
        * @param surfaces
        * @param sprite
        */
        static findNavMeshSurface(surfaces: Array<BaseNavMeshSurface>, sprite: Node, agentFlags: string[]): void;
        /**@internal */
        name: string;
        /**@internal */
        _navConfigMap: Map<string, RecastConfig>;
        /**@internal */
        _areaFlagMap: Map<string, NavAreaFlag>;
        /**@internal */
        _naveMeshMaps: Map<string, SingletonList<BaseNavMeshSurface>>;
        /**@internal */
        _naveMeshLinkMaps: Map<string, Array<NavMeshLinkData>>;
        /**@internal */
        _deflatAllMask: AreaMask;
        /**
          * @en Instantiates a Navigation manager.
          * @zh 实例化一个 Navigation 管理器。
          */
        constructor(name: string);
        destroy(): void;
        /**
         * 初始化默认配置
         * @internal
         * @param {*}
         * @return {*}
         */
        protected _init(): void;
        /**
        * 获得key值
        * @internal
        * @param {*}
        * @return {*}
        */
        private _getLinkIdByNavMeshSurfaces;
        /**
         * @internal
         * @param data
         */
        Init(data: any): void;
        /**
         * @internal
         */
        setFilterCost(filer: any): void;
        /**
         * @internal
         */
        update(dt: number): void;
        /**
         * @en Registers a navigation mesh agent type configuration.
         * @param config The RecastConfig object containing the agent configuration.
         * @zh 注册导航网格的 agent 类型配置。
         * @param config RecastConfig 对象，包含 agent 的配置。
         */
        regNavConfig(config: RecastConfig): void;
        /**
         * @en Gets the navigation mesh agent configuration for a specific type.
         * @param type The agent type name.
         * @returns The RecastConfig for the specified agent type, or undefined if not found.
         * @zh 获取指定类型的导航网格 agent 配置。
         * @param type agent 类型名称。
         * @returns 指定 agent 类型的 RecastConfig，如果未找到则返回 undefined。
         */
        getNavConfig(type: string): RecastConfig;
        /**
         * @en Registers a navigation area type.
         * @param area The NavAreaFlag object representing the area type.
         * @zh 注册导航区域类型。
         * @param area 表示区域类型的 NavAreaFlag 对象。
         */
        regArea(area: NavAreaFlag): void;
        /**
         * @en Gets the configuration for a specific navigation area type.
         * @param type The area type name.
         * @returns The NavAreaFlag for the specified area type, or undefined if not found.
         * @zh 获取指定导航区域类型的配置。
         * @param type 区域类型名称。
         * @returns 指定区域类型的 NavAreaFlag，如果未找到则返回 undefined。
         */
        getArea(type: string): NavAreaFlag;
        /**
         * @en Gets the map of all registered navigation area flags.
         * @returns A Map of area names to NavAreaFlag objects.
         * @zh 获取所有已注册的导航区域标志的映射。
         * @returns 区域名称到 NavAreaFlag 对象的 Map。
         */
        getAreaFlagMap(): Map<string, NavAreaFlag>;
        /**
         * @en Registers a NavMeshLink between two different NavMeshSurfaces.
         * @param start The starting NavMeshSurface.
         * @param end The ending NavMeshSurface.
         * @param link The NavMeshLink to register.
         * @zh 注册连接两个不同 NavMeshSurface 的 NavMeshLink。
         * @param start 起始 NavMeshSurface。
         * @param end 结束 NavMeshSurface。
         * @param link 要注册的 NavMeshLink。
         */
        regNavMeshLink(start: BaseNavMeshSurface, end: BaseNavMeshSurface, link: NavMeshLinkData): void;
        /**
         * @en remove a NavMeshLink between two different NavMeshSurfaces.
         * @param start The starting NavMeshSurface.
         * @param end The ending NavMeshSurface.
         * @param link The NavMeshLink to register.
         * @zh 移除两个不同 NavMeshSurface 的 NavMeshLink。
         * @param start 起始 NavMeshSurface。
         * @param end 结束 NavMeshSurface。
         * @param link 要注册的 NavMeshLink。
         */
        removeMeshLink(start: BaseNavMeshSurface, end: BaseNavMeshSurface, link: NavMeshLinkData): void;
        /**
         * 根据两个不同的BaseNavMeshSurface查找直接是否存在BaseNavMeshLink
         * @internal
         * @param from NavMeshSurface
         * @param to NavMeshSurface
         * @returns NavMeshLink[]
         */
        getNavMeshLink(from: BaseNavMeshSurface, to: BaseNavMeshSurface): NavMeshLinkData[];
        /**
         * regist NavMeshSurface
         * @internal
         * @param nav
         */
        regNavMeshSurface(nav: BaseNavMeshSurface): void;
        /**
         * remove NavMeshSurface
         * @internal
         * @param nav
         */
        removeNavMeshSurface(nav: BaseNavMeshSurface): void;
        /**
         * @en Get the corresponding NavMeshSurface based on a world position.
         * @param pos World coordinate position.
         * @param agentType Agent type.
         * @returns NavMeshSurface or null if not found.
         * @zh 通过空间位置获得对应的 NavMeshSurface。
         * @param pos 世界坐标位置。
         * @param agentType agent 类型。
         * @returns NavMeshSurface，如果未找到则返回 null。
         */
        getNavMeshSurface(pos: Vector3, agentType: string): BaseNavMeshSurface;
        /**
         * @en Get all NavMeshSurfaces that contain a given world position.
         * @param pos World coordinate position.
         * @returns Array of NavMeshSurface objects.
         * @zh 通过空间坐标获得所有包含该位置的 NavMeshSurface。
         * @param pos 世界坐标位置。
         * @returns NavMeshSurface 对象数组。
         */
        getNavMeshSurfaces(pos: Vector3): BaseNavMeshSurface[];
        /**
         * @en Get all NavMeshSurfaces that contain a given world bound box.
         * @param min World min position.
         * @param max World max position.
         * @param type Navigation type.
         * @returns Array of NavMeshSurface objects.
         * @zh 获得包围盒内包含的所有 NavMeshSurface。
         * @param min 包围盒的最小值。
         * @param max 包围盒的最大值。
         * @param type 寻路类型。
         * @returns NavMeshSurface 对象数组。
         */
        getNavMeshSurfacesByBound(min: Vector3, max: Vector3, type: string): BaseNavMeshSurface[];
    }
    /**
     * @internal
     * <code>BaseNavMesh</code> 类用于创建导航网格。
    */
    class BaseNavMesh {
        /**@internal ori navMesh*/
        protected _navMesh: any;
        /**@internal ori navQuery*/
        protected _navQuery: any;
        /**@internal ori meshLink*/
        protected _navMeshLink: any;
        /**@internal ori convexVolume*/
        protected _navConvexVolume: any;
        /**@internal 寻路代理 */
        protected _crowd: any;
        /**@internal 过滤信息 */
        protected _defatfilter: any;
        /**@internal TODO */
        protected _extents: number[];
        /**@internal */
        _surface: BaseNavMeshSurface;
        /**@internal */
        protected _titileConfig: TitleConfig;
        /**@internal */
        protected _maxAgents: number;
        /**@internal */
        protected _navcreateedTileMaps: Set<number>;
        /**@internal */
        protected _delayCreates: Map<number, BaseNavAgent[]>;
        /**@internal */
        protected _allAgents: Map<number, BaseNavAgent>;
        /**@internal */
        protected _fiterMap: Map<number, any>;
        /** @internal */
        protected _grid: NavMeshGrid;
        /**@internal */
        protected _is3D: boolean;
        /**
         * @internal
         * @en Find the nearest point's range
         * @zh 寻找最近点的范围
         */
        get extents(): number[];
        /**
         * @internal
         * @en Get the navigation mesh
         */
        get navMesh(): any;
        /**
        * @internal
        */
        get navQuery(): any;
        /**
        * @internal
        */
        get crowd(): any;
        /**
         * @internal
         */
        get navTileGrid(): NavMeshGrid;
        /**
         * @internal
         */
        get is3D(): boolean;
        /**
         * <code>实例化一个NavMesh<code>
         */
        constructor(config: RecastConfig, min: Vector3, max: Vector3, surface: BaseNavMeshSurface, is3D?: boolean);
        /**
         * get filter
         *  @internal
         */
        private _getFilter;
        /**
         * create agent
         * @param agent
         */
        protected _createAgents(agent: BaseNavAgent): void;
        /**
         * add Agent
         * @internal
         * @param agent
         */
        _addAgent(agent: BaseNavAgent): void;
        /**
         * remove agent
         * @internal
         * @param agent
         */
        _removeAgent(agent: BaseNavAgent): void;
        /**
         * @internal
         * @en Get the current point's Flag
         * @zh 获得当前点的Flag
         * @param pos 世界坐标
         * @param fiter
         * @return flag
         */
        _getPolyFlags(pos: Vector3, fiter?: any): number;
        /**
         * @internal
         * @en Get the current point's Area
         * @zh 获得当前点的Area
         * @param pos 世界坐标
         * @param fiter
         * @return area
         */
        _getPolyArea(pos: Vector3, fiter?: any): number;
        /**
         * @internal
         * @en Find the nearest point
         * @zh 查找最近点
         * @param pos 世界坐标
         * @param fiter
         * @param out 返回世界坐标
         * @return polyRef
         */
        _findNearestPoly(pos: Vector3, fiter: any, out: Vector3): number;
        /**
         * @internal
         */
        _findFllowPath(fllowPaths: NavigationPathData[], startPos: Vector3, endPos: Vector3, speed: number, filter?: any): boolean;
        /**
         * @internal
         * @en Find the distance to the wall
         * @zh 查找到墙的距离
         * @param pos:Vector3
         * @param filter
         * @returns {dist:number,pos:Array<number>(3),normal:Array<number>(3)}
         */
        _findDistanceToWall(pos: Vector3, filter?: any): {
            dist: number;
            pos: Array<number>;
            normal: Array<number>;
        };
        /**
         * @internal
         * @param agent
         * @returns
         */
        _requestMoveTarget(agent: BaseNavAgent, destination: Vector3): boolean;
        /**
         * @internal
         * @en create a navMesh and navQuery
         */
        _creatNavMesh(): void;
        /**
         * @internal
         * @en init the navMesh
         * @zh 初始化导航网格
         */
        _navMeshInit(): void;
        /**
         * @internal
         * @en The heartbeat of pathfinding, updating the navigation mesh, synchronizing the agent's position, orientation
         * @zh 寻路的心跳，更新导航网格,同步agent的位置,朝向
         * @param dt (秒)
         */
        _updateNavMesh(dt: number): void;
        /**
         * @internal
         * @en add a navigation grid link
         * @zh 添加一个导航网格链接
         * @param index
         * @param start
         * @param end
         * @param width
         * @param bidirectional
         * @param areaFlag
         * @returns
         */
        _addNavMeshLink(index: number, start: Vector3, end: Vector3, width: number, bidirectional: boolean, areaFlag: number): void;
        /**
         * @internal
         * @en remove a navigation grid link
         * @zh 删除一个导航网格链接
         * @param linkid
         */
        _removeNavMeshLink(index: number): void;
        /**
         * @internal
         * @en add a convexVolume
         * @zh 添加一个凸体
         */
        _updateConvexVolume(index: number, buffer: Float32Array, miny: number, maxy: number, areaType: number): boolean;
        /**
         * @internal
         * @en remove a convexVolume
         * @zh 删除一个凸体
         * @param index
         */
        _deleteConvexVoume(index: number): boolean;
        /**
         * @internal
         * @en add a tile
         * @zh 添加一个tile
         * @param cellX
         * @param cellY
         * @param binds
         * @param bound
         */
        _addTile(cache: NavTileCache, binds: any[], partitionType: number, maxSimplificationError: number): void;
        /**
         * @internal
         * @en remove a tile
         * @zh 删除一个tile
         * @param cellX
         * @param cellY
         */
        _removeTile(tileX: number, tileY: number): void;
        /**@internal */
        _clearn(): void;
        /**
         * @internal
         */
        _destroy(): void;
    }
    /**
     * @en Class used to instantiate a navigation agent
     * @zh 类用来实例化一个寻路代理
     */
    class BaseNavAgent extends Component {
        /**@internal */
        private _targetPos;
        /**@internal */
        protected _agentType: string;
        /**@internal */
        protected _currentNaveSurface: BaseNavMeshSurface;
        /**@internal 速度*/
        protected _speed: number;
        /**@internal 加速度*/
        protected _maxAcceleration: number;
        /**@internal */
        protected _angularSpeed: number;
        /**@internal TODO*/
        protected _stopDistance: number;
        /**@internal TODO*/
        protected _Acceleration: number;
        /**@internal TODO*/
        protected _autoBraking: boolean;
        /**@internal */
        protected _radius: number;
        /**@internal */
        protected _height: number;
        /**@internal */
        protected _quality: ObstacleAvoidanceType;
        /**@internal */
        protected _priority: number;
        /**@internal */
        protected _fllowPath: NavigationPathData[];
        /**@internal */
        protected _baseOffset: number;
        /**@internal */
        _navManager: BaseNavigationManager;
        /**@internal */
        _navAgentLinkAnim: NavAgentLinkAnim;
        /**@internal */
        _crowAgent: any;
        /**@internal */
        _agentId: number;
        /**@internal */
        _areaMask: AreaMask;
        /**@internal */
        _filter: any;
        /**@internal */
        _curentSpeed: Vector3;
        /**@internal navMeshSurface是否准备好，这里处理先添加agent再初始化navMeshSurface的情况*/
        private _navMeshSurfaceReady;
        /**
         * @en Radius of the agent.
         * @zh 代理的半径。
         */
        set radius(value: number);
        get radius(): number;
        /**
         * @en Height of the agent.
         * @zh 代理的高度。
         */
        set height(value: number);
        get height(): number;
        /**
         * @en Movement speed of the agent.
         * @zh 代理的移动速度。
         */
        set speed(value: number);
        get speed(): number;
        /**
         * @en Maximum acceleration of the agent.
         * @zh 代理的最大加速度。
         */
        set maxAcceleration(value: number);
        get maxAcceleration(): number;
        /**
         * @en Angular speed of the agent.
         * @zh 代理的转身速度。
         */
        set angularSpeed(value: number);
        get angularSpeed(): number;
        /**
         * @en Obstacle avoidance quality level.
         * @zh 障碍物规避品质级别。
         */
        set quality(value: ObstacleAvoidanceType);
        get quality(): ObstacleAvoidanceType;
        /**
         * @en Avoidance priority level.
         * @zh 规避优先级别。
         */
        set priority(value: number);
        get priority(): number;
        /**
         * @en Whether the agent is bound to a navigation mesh.
         * @zh 代理是否绑定到导航网格。
         */
        get isOnNavMesh(): boolean;
        /**
         * @en Whether the agent is currently on an OffMeshLink.
         * @zh 代理当前是否位于 OffMeshLink 上。
         */
        get isOnOffMeshLink(): boolean;
        /**
         * @en Set the agent type.
         * @param value The agent type.
         * @zh 设置代理类型。
         * @param value 代理类型。
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Set the area mask for the agent.
         * @zh 设置代理的区域掩码。
         */
        set areaMask(value: number);
        get areaMask(): number;
        /**
         * 创建一个 <code>NavAgent</code> 实例。
         */
        constructor();
        /**
         * 由系统调用
         */
        onUpdate(): void;
        /**
         * @en Whether the agent has stopped moving.
         * @zh 代理是否已停止移动。
         */
        isStop(): boolean;
        /**
         * @en Get the current path of the agent.
         * @zh 获取代理的当前路径。
         */
        getCurrentPath(): Array<NavigationPathData>;
        /**
         * 到墙面的距离
         * @returns {dist:距离,pos:碰撞点, normal:法向量}
         */
        findDistanceToWall(): {
            dist: number;
            pos: Array<number>;
            normal: Array<number>;
        };
        /**
         * 目的地
         */
        protected _setTarget(value: Vector3): void;
        /**
         * @internal
         */
        _getpos(vec: Vector3): void;
        /**@internal */
        _getcollisionQueryRange(): number;
        /**@internal */
        _getpathOptimizationRange(): number;
        /**@internal */
        protected _getManager(): BaseNavigationManager;
        /**
         * @internal
         */
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @internal
         */
        protected _addAgent(): void;
        /**
         * @internal
         */
        protected _removeAgent(): void;
        /**
         * @internal
         */
        _getheight(): number;
        /**
         * @internal
         */
        _getradius(): number;
        _getUpdateFlags(): number;
        _onDestroy(): void;
        /**
         * 由系统调用
         * @internal
         */
        _updateNavMesh(pos: number[], dir: number[]): void;
        /**
         * @internal
         */
        protected _updatePosition(pos: Vector3, dir: Vector3): void;
        /**@internal */
        _cloneTo(dest: Component): void;
    }
    /**
     * @en BaseNavMeshSurface is a base component used to generate navigation mesh. 2d and 3d integrate this class respectively.
     * @zh BaseNavMeshSurface 是一个用于生成导航网格的基础组件，2d 和 3d 分别集成该类。
     */
    class BaseNavMeshSurface extends Component {
        /**@internal 网格模型的数据 */
        private _datas;
        private _maxSimplificationError;
        private _agentType;
        private _partitionType;
        private _boundMin;
        private _boundMax;
        /**@internal load*/
        private _oriTiles;
        private _cachedata;
        /**@internal 是否开启异步处理*/
        private _needAsyn;
        private _cacheDataMap;
        /** @internal */
        private _meshlinkOffMaps;
        /** @internal */
        private _meshVolumeMaps;
        /**@internal */
        _navMesh: BaseNavMesh;
        /**@internal */
        _buildTileList: Set<number>;
        /**@internal */
        _manager: BaseNavigationManager;
        /**@internal 延时改变列表*/
        _delayCacheMap: Set<CacheData>;
        /**@internal */
        _featureCache: Map<number, Set<any>>;
        /**
         * @en Agent type
         * @zh 代理类型
         */
        set agentType(value: string);
        get agentType(): string;
        /**
         * @en Area type
         * @zh 区域类型
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * 是否需要异步处理
         */
        set asyn(value: boolean);
        get asyn(): boolean;
        /**
         * @en Set the method for generating navMesh
         * @zh 设置生成导航网格的方法
         */
        set partitionType(value: PartitionType);
        get partitionType(): PartitionType;
        /**
         * @en The minimum bounds of the navigation mesh
         * @zh 导航网格的最小边界
         */
        get min(): Vector3;
        /**
         * @en The maximum bounds of the navigation mesh
         * @zh 导航网格的最大边界
         */
        get max(): Vector3;
        /**
         * @en Set navigation data
         * @zh 设置导航数据
         */
        set datas(value: TextResource);
        get datas(): TextResource;
        /**
         * @en The maximum amount of simplification error for the border of the polygon.
         * @zh 简化多边形边框可偏移的最大量
         */
        set maxSimplificationError(value: number);
        get maxSimplificationError(): number;
        /**
         * <code>实例化一个寻路功能<code>
         */
        constructor();
        /**
         * @internal
         * @en Clean all Tile
         * @zh 清理所有的Tile
         */
        cleanAllTile(): void;
        /**
         * @internal
         * @en Rebuild the tile at the specified location
         * @zh 重建指定位置的Tile
         */
        rebuildTile(pos: Vector3): void;
        /**
         * @en Get the current point's Flag
         * @param pos World coordinates;
         * @param fiter Optional query filter.
         * @returns flag
         * @zh 获得当前点的Flag
         * @param pos 世界坐标
         * @param fiter 可选的查询过滤器。
         * @return flag
         */
        getPolyFlags(pos: Vector3, fiter?: any): number;
        /**
         * @en Find the nearest polygon to the specified position.
         * @param pos World coordinates.
         * @param fiter Optional filter for the query.
         * @param out Used to store the position.
         * @returns Information about the nearest polygon.
         * @zh 查找指定位置最近的多边形。
         * @param pos 世界坐标。
         * @param fiter 可选的查询过滤器。
         * @param out 用于存储位置。
         * @returns 最近多边形的引用id。
         */
        findNearestPoly(pos: Vector3, fiter: any, out: Vector3): number;
        /**
         * @en Find a follow path for the specified agent.
         * @param outPaths The generated path.
         * @param startPos The starting position.
         * @param endPos The destination position.
         * @param speed The speed of the agent.
         * @param filter Optional filter for the query.
         * @returns True if the path is found.
         * @zh 为指定代理查找跟随路径。
         * @param outPaths 生成的路径。
         * @param startPos 起始位置。
         * @param endPos 目标位置。
         * @param speed 代理的速度。
         * @param filter 可选的查询过滤器。
         * @returns 如果找到路径则返回 true。
         */
        findFllowPath(outPaths: NavigationPathData[], startPos: Vector3, endPos: Vector3, speed: number, filter?: any): boolean;
        /**
         * @en Find the distance to the nearest wall for the specified position.
         * @param pos The world position.
         * @param filter Optional filter for the query.
         * @returns An object containing the distance, position, and normal of the nearest wall, or null if not found.
         * @zh 查找指定位置到最近墙壁的距离。
         * @param pos 世界位置。
         * @param filter 可选的查询过滤器。
         * @returns 包含最近墙壁的距离、位置和法线的对象，如果未找到则返回 null。
         */
        findDistanceToWall(pos: Vector3, filter: any): {
            dist: number;
            pos: Array<number>;
            normal: Array<number>;
        };
        /**
         * @en refresh the original data Flag
         * @zh 刷新原始数据的Flag
        */
        protected _updateOrigTileCache(cache: CacheData, areaflags: number): void;
        /**
         * @en create CacheData
         * @zh 创建CacheData
         *
        */
        protected _createCacheData(): CacheData;
        protected _getCahceData(data: any): CacheData;
        protected _removeCacheData(data: any): CacheData;
        protected _crateNavMesh(config: RecastConfig, min: Vector3, max: Vector3): BaseNavMesh;
        protected _updateNavData(): void;
        /**@internal */
        _getManager(): BaseNavigationManager;
        /**
        * @internal
        */
        _onEnable(): void;
        /**
         * @internal
         * @param dt
         */
        _update(dt: number): void;
        /**
         * @internal
         * build one Mesh
         */
        protected _buildOneTileMesh(): void;
        /**
         * build all Mesh
         */
        protected _buildAllTileMesh(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**
         * @internal
         */
        _cloneTo(dest: Component): void;
        /**
         * @internal
         */
        _cleanBindData(): void;
        /**
         * @internal
         * add one modifile navMesh
         * @param navModifile
         */
        _addModifileNavMesh(navModifile: NavModifleData): CacheData;
        /**
         * @internal
         * remove one Modifile NavMesh
         * @param navModifile
         */
        _removeModifileNavMesh(navModifile: NavModifleData): void;
        /** @internal */
        _addModifileLink(link: NavMeshLinkData): CacheData;
        /** @internal */
        _addConvexVoume(volume: ModifierVolumeData): CacheData;
        /**
         * @internal
         * @param volume
         */
        _deleteCovexVoume(volume: ModifierVolumeData): void;
    }
    /**
     * @internal
     *
     */
    class BaseData {
        /**@internal */
        _transfrom: Matrix4x4;
        /**@internal */
        _min: Vector3;
        /**@internal */
        _max: Vector3;
        /**@internal */
        _agentType: string;
        /**@internal */
        _areaFlags: string;
        /**@internal */
        _cacheDatas: Array<CacheData>;
        /**
        * agentType
        */
        set agentType(value: string);
        get agentType(): string;
        /**
         * area 类型
         */
        set areaFlag(value: string);
        get areaFlag(): string;
        /**
         * @internal
         * 刷新数据
         */
        _refeashData(): void;
        /**
         * @internal
         * 刷新transfrom
         */
        _refeahTransfrom(): void;
        /**
         * @internal
         * 刷新包围盒
         */
        _refeahBound(): void;
    }
    /**
     * @internal
     * 存储缓存数据
     * 当数据有修改的时候;会调用对应的方法进行更新。
     */
    class CacheData {
        static TransfromFlag: number;
        static AreaFlag: number;
        static MinFlag: number;
        static MaxFlag: number;
        static DataFlag: number;
        static DeleteFlag: number;
        static OtherDataFlag: number;
        static ResetDataFlag: number;
        /**@internal */
        protected _cacheflag: number;
        /**@internal */
        protected _areaFlag: string;
        /**@internal */
        protected _data: any;
        /**@internal */
        _surface: BaseNavMeshSurface;
        /**@internal */
        _transfrom: Matrix4x4;
        /**@internal */
        _min: Vector3;
        /**@internal */
        _max: Vector3;
        /**@internal */
        _titleIndex: Set<number>;
        /**@internal */
        _flagChangeHander: Handler;
        /**@internal */
        _tileHander: Handler;
        /**@internal */
        id: number;
        /**@internal */
        constructor(surface: BaseNavMeshSurface);
        /**@internal */
        _setUpdateDataHander(handler: Handler): void;
        /**@internal */
        _setTileHander(handler: Handler): void;
        /**@internal */
        _updateTransfrom(mat: Matrix4x4): void;
        /**@internal */
        _updateAreaFlag(flag: string): void;
        /**@internal */
        get areaFlag(): string;
        /**@internal */
        _cacheBound(min: Vector3, max: Vector3): void;
        /**@internal */
        set _cacheData(data: any);
        /**@internal */
        get _cacheData(): any;
        /**@internal */
        _destroy(): void;
        /**@internal */
        _setCacheFlag(type: number): void;
        /**@internal */
        _getCacheFlag(type: number): boolean;
        /**@internal */
        _updateCache(): void;
        /**@internal */
        _resetData(): void;
    }
    /**
     * @internal
     * @en Convex polygon data
     * @zh 凸多边形数据
     */
    class ModifierVolumeData extends BaseData {
        /**@internal */
        _datas: number[];
        /**@internal */
        _buffer: Float32Array;
        /**@internal 用于设置包围盒y方向偏移 */
        _yOffset: number;
        constructor(yOff?: number);
        /**
         * @internal
         * 更新buffer
         */
        private _updateBuffer;
        /**
         * @internal
         */
        _initSurface(surface: Array<BaseNavMeshSurface>): void;
        /**
         * @internal
         */
        _destory(): void;
    }
    class NavMeshLinkData extends BaseData {
        /**@internal */
        _startPoint: Vector3;
        /**@internal */
        _endPoint: Vector3;
        /**@internal */
        _width: number;
        /**@internal */
        _bidirectional: boolean;
        /**@internal */
        globalStart: Vector3;
        /**@internal */
        globalEnd: Vector3;
        /**@internal */
        _startNavSurfaces: BaseNavMeshSurface[];
        /**@internal */
        _endNavSurfaces: BaseNavMeshSurface[];
        /**@internal */
        private _regisgMaps;
        constructor();
        _updateWidth(value: number): void;
        _updateBidirectional(value: boolean): void;
        _updateStartPoint(value: Vector3): void;
        _updateEndPoint(value: Vector3): void;
        private _updateData;
        /**
         * @internal
         */
        _initSurface(surface: Array<BaseNavMeshSurface>): void;
        /**
         * @internal
         */
        _updateBuffer(cache: CacheData, areaFlag: number): void;
        /**@internal */
        getDistance(): number;
        destroy(): void;
    }
    class NavModifleData extends BaseData {
        /**@internal */
        _datas: NavTileCache;
        /**@internal */
        _bindData: any;
        set datas(value: NavTileCache);
        get datas(): NavTileCache;
        constructor();
        /**
         * @internal
         * 更新buffer
         */
        private _updateBuffer;
        private _updateTileIndexs;
        /**
         * @internal
         */
        _initSurface(surface: Array<BaseNavMeshSurface>): void;
        /**
         * @internal
         */
        _destory(): void;
    }
    /**
     * @internal
     * 一个用于映射对象和id的类
     */
    class ItemMapId<T> {
        /**@internal */
        private _idMap;
        private _idArray;
        constructor(maxCount: number);
        haveId(): boolean;
        getId(value: T): number;
        removeItem(value: T): number;
    }
    /**
     * @internal
     * @en Navigation agent link animation between two NavMeshSurfaces
     * @zh 作用于两个NavMeshSurface之间的导航代理链接动画
     */
    class NavAgentLinkAnim {
        /**@internal */
        _startPos: Vector3;
        /**@internal */
        _endPos: Vector3;
        /**@internal */
        _initPos: Vector3;
        /**@internal */
        targetSurface: BaseNavMeshSurface;
        /**@internal */
        _active: boolean;
        /**@internal */
        _isStart: boolean;
        /**@internal */
        _runTime: number;
        /**@internal */
        _totalTime: number;
        /**@internal */
        _clearn(): void;
        /**@internal */
        _setStartPos(value: Vector3): void;
        /**@internal */
        _getSartPos(): Vector3;
        /**@internal */
        _setEndPos(value: Vector3): void;
        /**@internal */
        _getEndPos(): Vector3;
        /**@internal */
        _nearerStartPos(value: Vector3): boolean;
        /**@internal */
        _nearerEndPos(value: Vector3): boolean;
        /**@internal */
        _start(maxSpeed: number, postions: Vector3): void;
        /**@internal */
        _update(position: Vector3, dir: Vector3): void;
        /**@internal */
        _tween(t: number, t0: number, t1: number): number;
    }
    /**
    * 数据分块算法
    */
    enum PartitionType {
        PARTITION_WATERSHED = 0,
        PARTITION_MONOTONE = 1,
        PARTITION_LAYERS = 2
    }
    enum UpdateFlags {
        DT_CROWD_ANTICIPATE_TURNS = 1,
        DT_CROWD_OBSTACLE_AVOIDANCE = 2,
        DT_CROWD_SEPARATION = 4,
        DT_CROWD_OPTIMIZE_VIS = 8,
        DT_CROWD_OPTIMIZE_TOPO = 16
    }
    enum CrowdAgentState {
        DT_CROWDAGENT_STATE_INVALID = 0,
        DT_CROWDAGENT_STATE_WALKING = 1,
        DT_CROWDAGENT_STATE_OFFMESH = 2
    }
    enum ObstacleAvoidanceType {
        NoObstacle = 0,
        LowQuality = 1,
        MedQuality = 2,
        GoodQuality = 3,
        HighQuality = 4
    }
    enum NavigationConfig {
        defaltAgentName = "humanoid",
        defaltUnWalk = "unwalk",
        defaltWalk = "walk",
        defaltJump = "jump"
    }
    class NavAreaFlag {
        index: number;
        cost: number;
        name: string;
        get flag(): number;
    }
    class NavigationPathData {
        /** @internal */
        _pos: Vector3;
        /** @internal */
        _flag: number;
        /**
         * @en position
         * @zh 位置
         */
        get pos(): Vector3;
        /**
         * @en flag of the position
         * @zh 位置的标记
         */
        get flag(): number;
        constructor();
    }
    /**
     * @en NavigationUtils is a utility class for handling operations related to navigation meshes.
     * @zh NavigationUtils 是一个导航工具类,主要用于处理与导航网格相关的操作。
     */
    class NavigationUtils {
        /**@internal */
        private static _MAX_SMOOTH;
        /**@internal 超了怎么办 */
        private static _MAX_POLYS;
        /**@internal */
        static _TitleMeshIbOff: number[];
        /**@internal ori recast Data */
        static _recast: any;
        /**@internal */
        static _dtCrowdAgentParams: any;
        /**@internal */
        static _TemprefPoint: any;
        /**@internal */
        static _TemprefPoint1: any;
        /** @internal */
        static _boundContentPoint(min: Vector3, max: Vector3, point: Vector3): boolean;
        /** @internal */
        static _boundInterection(min1: Vector3, max1: Vector3, min2: Vector3, max2: Vector3): number;
        /**
         * @internal
         * @param fllowPath
         * @param index
         * @param data
         * @param flag
         */
        private static _setDatastoArray;
        /**@internal  */
        static _inRange(v1: number[], v2: number[], radius: number, height: number, offIndex: number): boolean;
        /**@internal
         * calculate the boundBox of the transform
         * @param min vector3
         * @param max vector3
         * @param transfrom matrix4x4
         * @param outMin vector3
         * @param outMax vector3
         */
        static _transfromBoundBox(min: Vector3, max: Vector3, transfrom: Matrix4x4, outMin: Vector3, outMax: Vector3): void;
        /**@internal  */
        static _isFlags(data: number, flag: any): number;
        /**@internal  */
        static _addVector3ToArray(vec1: Vector3, vec2: Vector3, scale: number): number[];
        /**@internal  */
        static _getSteerTarget(navMesh: BaseNavMesh, startRef: any, endRef: any, minTargetDist: number, paths: number[], pathSize: number, out: Vector3): {
            steerPosFlag: any;
            steerPosRef: any;
        };
        /**@internal  */
        static _dtMergeCorridorStartMoved(path: number[], npath: number, maxPath: number, visited: number[], nvisited: number): number;
        /**@internal  */
        static _findFllowPath(navMesh: BaseNavMesh, filter: any, startPos: Vector3, endPos: Vector3, steplength: number, minTarget: number, fllowPath: NavigationPathData[]): void;
        /**@internal  */
        static _initialize(Recast: any): void;
        /**@internal  */
        static _getRecast(): any;
        /**
         * create NavMesh
         * @return any
         */
        static _createNavMesh(): any;
        /**
         * create NavMeshQuery
         * @return any
         */
        static _createNavMeshQuery(): any;
        /**
         * create RefPointData
         * @return any
         */
        static _createRefPointData(): any;
        /**
        * create MeshOffLink
        * @return any
        */
        static _createMeshOffLink(): any;
        /**
        * create ConvexVolum
        * @return any
        */
        static _createConvexVolume(): any;
        /**
         * create QueryFilter
         * @return any
         */
        static _createQueryFilter(): any;
        /**
         * create Crowd
         * @return any
         */
        static _createCrowd(): any;
        /**
         * create NavTileData
         * @internal
         */
        static _createdtNavTileData(): any;
        /**
         * create NavTileCache
         * @internal
         */
        static _createdtNavTileCache(): any;
        /**
        * get CrowdAgentParams
        * @return any
        */
        static _getCrowdAgentParams(): any;
        /**
         * free NavMeshQuery
         */
        static _freeNavMeshQuery(data: any): void;
        /**
         * free NavMesh
         */
        static _freeNavMesh(data: any): void;
        /**
         * free Crowd
         */
        static _freeCrowd(data: any): void;
        /**
         * free any other
         */
        static _free(data: any): void;
        /**
        * free any layaData
        */
        static _freeLayaData(data: any): void;
        /**
         * check Status is Succeed
         */
        static _statusSucceed(data: any): boolean;
        /**
         * update crowd
         */
        static _updateCrowd(crowd: any, dt: number): any;
    }
    /**
     * @en The NavMeshGrid class manages the grid division of the navigation mesh.
     * @zh NavMeshGrid 类用于管理导航网格的网格划分。
    */
    class NavMeshGrid {
        private _config;
        private _min;
        private _max;
        private _tileSize;
        private _cellSize;
        private _bordWidth;
        /**
         * @internal
         * @en The width of a single tile.
         * @zh 单个瓦片的宽度。
        */
        get tileWidth(): number;
        /**
         * @internal
         * @en The bounding box of the navigation mesh.
         * @zh 导航网格的最小值。
        */
        get max(): Vector3;
        /**
         * @internal
         * @en The bounding box of the navigation mesh.
         * @zh 导航网格的最大值。
        */
        get min(): Vector3;
        /**
         * @internal
         * @en The configuration of the navigation mesh.
         * @zh 导航网格的配置。
         */
        get config(): RecastConfig;
        /**
         *@internal
        * @en Get the maximum number of tiles.
        * @zh 获取最大瓦片数量。
        */
        get maxtiles(): number;
        /**
         * @internal
         * @en Get the maximum number of tiles along the x-axis.
         * @zh 获取 x 轴方向的最大瓦片数量。
         */
        get maxXTileCount(): number;
        /**
         * @internal
         * @en Get the maximum number of tiles along the z-axis.
         * @zh 获取 z 轴方向的最大瓦片数量。
         */
        get maxZTileCount(): number;
        /**
         * <code>实例化一个NavMeshGrid组件<code>
         * @ignore
         */
        constructor(config: RecastConfig, min: Vector3, max: Vector3);
        /**
         * @internal
         * @en Update the configuration and bounding box based on the given tile data.
         * @param tile The navigation tile data.
         * @zh 根据给定的瓦片数据更新配置和边界框。
         * @param tile 导航瓦片数据。
         */
        _refeashBound(tile: NavTileData): void;
        /**
         * @internal
         * @en Get the tile indices that intersect with the given bounding box defined by minimum and maximum coordinates.
         * @param min The minimum coordinates of the bounding box.
         * @param max The maximum coordinates of the bounding box.
         * @param isbord Whether to include a border around the bounding box.
         * @returns An array of tile indices.
         * @zh 获取与由最小和最大坐标定义的给定边界框相交的瓦片索引。
         * @param min 边界框的最小坐标。
         * @param max 边界框的最大坐标。
         * @param isbord 是否在边界框周围包含边界。
         * @returns 瓦片索引数组。
         */
        getBoundTileIndex(min: Vector3, max: Vector3, isbord?: boolean): number[];
        /**
         * @internal
        * get tile index of map by position
        * @param x  世界坐标x
        * @param z  世界坐标z
        */
        getTileIndexByPos(x: number, z: number): number;
        /**
         * @internal
         * @en get tile index of map
         * @zh 获取地图的tile索引
         */
        getTileIndex(xIndex: number, zIndex: number): number;
        /**
        * get tile x index
        */
        private _getTileXIndex;
        /**
        * get tile z index
        */
        private _getTileZIndex;
        /**
         * get tile index of map
         */
        private _getLeftValue;
        /**
         * update bound
         */
        private _updateBound;
    }
    /**
     * @en The class NavTileCache is used to cache and manage the tile data of the navigation mesh.
     * @zh 类 NavTileCache 用于缓存和管理导航网格的瓦片数据。
     */
    class NavTileCache {
        /**
         * @internal
         */
        _bindData: any;
        /**
         * @internal
         */
        _triVertex: Float32Array;
        /**
         * @internal
         */
        _triIndex: Uint32Array;
        /**
         * @internal
         */
        _triFlag: Uint8Array;
        /** @internal tile bounds */
        _boundMin: Vector3;
        /** @internal tile bounds */
        _boundMax: Vector3;
        /**
         * @en The x offset of the tile.
         * @zh 瓦片的x偏移。
         */
        x: number;
        /**
         * @en The y offset of the tile.
         * @zh 瓦片的y偏移。
         */
        y: number;
        /**
         * @en Create a new instance of NavTileCache.
         * @zh 创建 NavTileCache 类的新实例。
         */
        constructor();
        /**
         * @en Triangle vertices
         * @zh 三角形顶点
         */
        set triVertex(data: Float32Array);
        get triVertex(): Float32Array;
        /**
         * @en Triangle indices
         * @zh 三角形索引
         */
        set triIndex(data: Uint32Array);
        get triIndex(): Uint32Array;
        /**
         * @en Triangle flags
         * @zh 三角形标记
         */
        set triFlag(data: Uint8Array);
        get triFlag(): Uint8Array;
        /**
         * @en Bounding box
         * @zh 包围盒大小
         */
        get boundMin(): Vector3;
        get boundMax(): Vector3;
        /**
         * @en Bound data
         * @zh 绑定数据
         */
        get bindData(): any;
        /**
         * @en Destroy the NavTileCache
         * @zh 销毁 NavTileCache
         */
        destroy(): void;
    }
    /**
     * @en NavTileData class for parsing and storing navigation mesh data
     * @zh NavTileData 类用于解析和存储导航网格数据
     */
    class NavTileData {
        /**@internal load*/
        _dirtyFlag: number;
        /**@internal load*/
        _oriTiles: Array<NavTileCache>;
        /**@internal load*/
        _res: TextResource;
        /**@internal load*/
        _boundMin: Vector3;
        /**@internal load*/
        _boundMax: Vector3;
        /**
         * @en Create a new instance of NavTileData.
         * @param res TextResource containing navigation data
         * @zh 创建 NavTileData 类的新实例。
         * @param res 包含导航数据的 TextResource
         */
        constructor(res: TextResource);
        /**@internal load*/
        _parse(): void;
        /**
         * @en Get the dirty flag
         * @zh 获取脏标记
         */
        get dirtyFlag(): number;
        /**
         * @en Get NavTileCache data by index
         * @param index The index of the NavTileCache
         * @zh 通过索引获取 NavTileCache 数据
         * @param index NavTileCache 的索引
         */
        getNavData(index: number): NavTileCache;
        /**
         * @en Get the number of NavTileCache objects
         * @zh 获取 NavTileCache 对象的数量
         */
        get length(): number;
        destroy(): void;
    }
    /**
     * @en create Recast navMesh Config
     * @zh 创建Recast navMesh配置
     */
    class RecastConfig implements IClone {
        /**
         * @internal
         *内部标记；用于记录数据是否有变化需要重新生成
         */
        _dirtyFlag: number;
        /**
         * @internal
         *像素格子尺寸 单位/m
         */
        _cellSize: number;
        /**name */
        agentName: string;
        /**像素格子高度 单位/m */
        cellHeight: number;
        /**路径最大坡度 单位/角度 */
        agentMaxSlope: number;
        /**路径最大高度跨度 单位/m */
        agentHeight: number;
        /**路径最大高度 单位/m */
        agentMaxClimb: number;
        /**代理半径 单位/m */
        agentRadius: number;
        /**每个tile的格子数量 单位/个 */
        tileSize: number;
        /**
         * 像素格子尺寸 单位/m
         */
        set cellSize(value: number);
        get cellSize(): number;
        constructor();
        /**
        * clone
        * @returns
        */
        clone(): RecastConfig;
        /**
        * 克隆。
        * @param destObject 克隆源。
        */
        cloneTo(destObject: RecastConfig): void;
    }
    /**
     * @internal
     * @zh js向wasm 写入数据，内部使用；不对外开放。
     */
    class TitleConfig {
        tx: number;
        ty: number;
        bmin: number[];
        bmax: number[];
        agentHeight: number;
        agentRadius: number;
        agentMaxClimb: number;
        maxEdgeLen: number;
        maxSimplificationError: number;
        partitionType: any;
        constructor();
        /**
         * 设置Title序列
         * @param {*}
         * @return {*}
         */
        _setOff(tx: number, ty: number): void;
        /**
         * 设置包围盒最小值
         * @param {*}
         * @return {*}
         */
        _setMin(value: Vector3): void;
        /**
         *设置包围盒最大值
         */
        _setMax(value: Vector3): void;
        /**
         * 设置运行代理的参数
         * @param {number} height
         * @param {number} radius
         * @param {number} maxClimb
         */
        _setAgent(height: number, radius: number, maxClimb: number): void;
        /** 设置最大边长 */
        _setMaxEdgeLen(value: number): void;
    }
    /**
     * 自动图集管理类
     * @ignore
     */
    class AtlasInfoManager {
        static readonly _fileLoadDic: Record<string, {
            url: string;
            baseUrl?: string;
        }>;
        static enable(infoFile: string, callback?: Handler | null): void;
        static addAtlases(data: Record<string, [
            string,
            string[]
        ]>): void;
        static addAtlas(atlasUrl: string, prefix: string, frames: Array<string>, allowOverride?: boolean): void;
        static getFileLoadPath(file: string): {
            url: string;
            baseUrl?: string;
        };
    }
    type ProgressCallback = (progress: number) => void;
    interface IBatchProgress {
        readonly itemCount: number;
        createCallback(weight?: number): ProgressCallback;
        update(index: number, progress: number): void;
    }
    /**
     * @en Represents a batch progress tracker that manages multiple progress items.
     * @zh 表示一个批量进度跟踪器,用于管理多个进度项。
     */
    class BatchProgress implements IBatchProgress {
        private _callback;
        private _items;
        private _weights;
        private _progress;
        /**
         * @en Creates a new BatchProgress instance.
         * @param callback The callback function to be called when progress updates.
         * @zh 创建一个新的 BatchProgress 实例。
         * @param callback 进度更新时要调用的回调函数。
         */
        constructor(callback: ProgressCallback);
        /**
         * @en The number of progress items.
         * @zh 进度项的数量。
         */
        get itemCount(): number;
        /**
         * @en Resets the progress tracker, clearing all items and weights.
         * @zh 重置进度跟踪器,清除所有项目和权重。
         */
        reset(): void;
        /**
         * @en Creates a callback function for a new progress item.
         * @param weight The weight of the progress item. Defaults to null.
         * @returns A callback function for updating the progress of this item.
         * @zh 为新的进度项创建一个回调函数。
         * @param weight 进度项的权重。默认为null。
         * @returns 用于更新此项目进度的回调函数。
         */
        createCallback(weight?: number): ProgressCallback;
        /**
         * @en Updates the progress of a specific item and recalculates the overall progress.
         * @param index The index of the item to update. Use -1 to update overall progress directly.
         * @param value The new progress value (0-1).
         * @zh 更新特定项目的进度并重新计算总体进度。
         * @param index 要更新的项目索引。使用-1直接更新总体进度。
         * @param value 新的进度值(0-1)。
         */
        update(index: number, value: number): void;
    }
    type DownloadCompleteCallback = (data: any, error?: string) => void;
    /**
     * @en Downloader class responsible for handling various types of resource downloads.
     * @zh Downloader类负责处理各种类型的资源下载。
     * @blueprintIgnore
     */
    class Downloader {
        /**
         * @en Downloads common resources using HTTP request.
         * @param owner The owner of the download request.
         * @param url The URL of the resource to download.
         * @param originalUrl The original URL of the resource.
         * @param contentType The content type of the resource.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 使用HTTP请求下载通用资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的资源的URL。
         * @param originalUrl 资源的原始URL。
         * @param contentType 资源的内容类型。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        common(owner: any, url: string, originalUrl: string, contentType: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        /**
         * @en Downloads an image resource.
         * @param owner The owner of the download request.
         * @param url The URL of the image to download.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 下载图像资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的图像的URL。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        image(owner: any, url: string, originalUrl: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        /**
         * @en Downloads an image from a Blob.
         * @param owner The owner of the download request.
         * @param blob The ArrayBuffer containing the image data.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 从Blob下载图像。
         * @param owner 下载请求的所有者。
         * @param blob 包含图像数据的ArrayBuffer。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        imageWithBlob(owner: any, blob: ArrayBuffer, originalUrl: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        /**
         * @en Downloads an image using a worker.
         * @param owner The owner of the download request.
         * @param url The URL of the image to download.
         * @param originalUrl The original URL of the image.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 使用worker下载图像。
         * @param owner 下载请求的所有者。
         * @param url 要下载的图像的URL。
         * @param originalUrl 图像的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        imageWithWorker(owner: any, url: string, originalUrl: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        /**
         * @en Downloads an audio resource.
         * @param owner The owner of the download request.
         * @param url The URL of the audio to download.
         * @param originalUrl The original URL of the audio.
         * @param onProgress Callback function for download progress.
         * @param onComplete Callback function when download is complete.
         * @zh 下载音频资源。
         * @param owner 下载请求的所有者。
         * @param url 要下载的音频的URL。
         * @param originalUrl 音频的原始URL。
         * @param onProgress 下载进度的回调函数。
         * @param onComplete 下载完成时的回调函数。
         */
        audio(owner: any, url: string, originalUrl: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        package(path: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        /**
         * @en Pool of HttpRequest instances.
         * @zh HttpRequest实例池。
         */
        httpRequestPool: Array<HttpRequest>;
        protected getRequestInst(): HttpRequest;
        protected returnRequestInst(inst: HttpRequest): void;
    }
    /**
     * @en The `HttpRequest` class encapsulates the HTML `XMLHttpRequest` object to provide full access to the HTTP protocol, including the ability to make POST and HEAD requests as well as regular GET requests. `HttpRequest` only provides asynchronous responses from web servers and can return content in either text or binary form.
     * - Note: It is recommended to use a new `HttpRequest` object for each request, as each call to the send method of this object will clear previously set data and reset the HTTP request status. This can cause previously unreturned responses to be reset, resulting in the loss of response results from previous requests.
     * - EventType Event.PROGRESS: Dispatch when the request progress changes.
     * - EventType Event.COMPLETE: Dispatch after the request ends.
     * - EventType Event.ERROR: Dispatch when the request fails.
     * @zh `HttpRequest` 类通过封装 HTML `XMLHttpRequest` 对象提供了对 HTTP 协议的完全访问，包括发送 POST 和 HEAD 请求以及普通的 GET 请求的能力。`HttpRequest` 只以异步形式返回 Web 服务器的响应，并且能够以文本或二进制形式返回内容。
     * - 注意：建议每次请求都使用新的 `HttpRequest` 对象，因为每次调用该对象的 send 方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。
     * - EventType Event.PROGRESS: 请求进度改变时调度。
     * - EventType Event.COMPLETE: 请求结束后调度。
     * - EventType Event.ERROR: 请求出错时调度。
     */
    class HttpRequest extends EventDispatcher {
        protected _http: XMLHttpRequest;
        protected _responseType: string;
        protected _data: any;
        protected _url: string;
        /**
         * @en Send an HTTP request.
         * @param url The URL to request. Most browsers implement a same-origin security policy and require that the URL has the same hostname and port as the script.
         * @param data (default = null) The data to be sent.
         * @param method (default = "get") The HTTP method used for the request. Values include "get", "post", "head".
         * @param responseType (default = "text") The response type from the web server, can be set to "text", "json", "xml", "arraybuffer".
         * @param headers (default = null) The header information for the HTTP request. Parameters are in the form of a key-value array: key is the name of the header, should not include whitespace, colon, or newline; value is the value of the header, should not include newline. For example ["Content-Type", "application/json"].
         * @zh 发送 HTTP 请求。
         * @param url 请求的地址。大多数浏览器实施了同源安全策略，要求此 URL 与包含脚本的文本具有相同的主机名和端口。
         * @param data (默认值 = null) 发送的数据。
         * @param method (默认值 = "get") 用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
         * @param responseType (默认值 = "text") Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
         * @param headers (默认值 = null) HTTP 请求的头部信息。参数形如 key-value 数组：key 是头部的名称，不应包括空白、冒号或换行；value 是头部的值，不应包括换行。例如 ["Content-Type", "application/json"]。
         */
        send(url: string, data?: any, method?: "get" | "post" | "head", responseType?: string, headers?: string[]): void;
        /**
         * @en The listening and processing function for requesting progress.
         * @param e The event object.
         * @zh 请求进度的侦听处理函数。
         * @param e 事件对象。
         */
        protected _onProgress(e: any): void;
        /**
         * @en The listening and processing function for request interruption.
         * @param e The event object.
         * @zh 请求中断的侦听处理函数。
         * @param e 事件对象。
         */
        protected _onAbort(e: any): void;
        /**
         * @en The listening and processing function for request errors.
         * @param e The event object.
         * @zh 请求出错侦的听处理函数。
         * @param e 事件对象。
         */
        protected _onError(e: any): void;
        /**
         * @en The listening and processing function for request completion.
         * @param e The event object.
         * @zh 请求消息返回的侦听处理函数。
         * @param e 事件对象。
         */
        protected _onLoad(e: any): void;
        /**
         * @en Request error handling function.
         * @param message The error message.
         * @zh 请求错误的处理函数。
         * @param message 错误信息。
         */
        protected error(message: string): void;
        /**
         * @en The processing function for successfully completing the request.
         * @zh 请求成功完成的处理函数。
         */
        protected complete(): void;
        /**
         * @en Clear the current request.
         * @zh 清除当前请求。
         */
        protected clear(): void;
        /**
         * @en The requested URL.
         * @zh 请求的地址。
         */
        get url(): string;
        /**
         * @en The data.
         * @zh 数据。
         */
        get data(): any;
        /**
         * @en The reference to the native XMLHttpRequest object encapsulated by this object.
         * @zh 本对象所封装的原生 XMLHttpRequest 引用。
         */
        get http(): any;
        /**
         * @en Reset the HttpRequest object, clearing all event listeners and data.
         * @zh 重置 HttpRequest 对象，清除所有事件监听器和数据。
         */
        reset(): void;
    }
    /**
     * @ignore
     */
    interface IWebSocket {
        onOpen: (result: any) => void;
        onClose: () => void;
        onError: (e: any) => void;
        onMessage: (data: string | ArrayBuffer) => void;
        open(url: string, options?: IWebSocketConnectOptions): void;
        close(): void;
        send(data: string | ArrayBuffer): Promise<void>;
    }
    /**
     * @en WebSocket connection options. Please note that the supported options may vary across different platforms.
     * @zh WebSocket连接选项。请注意，在不同的平台上，支持的选项可能会有所不同。
     */
    interface IWebSocketConnectOptions {
        /**
         * @en The subprotocol array.
         * @zh 子协议数组。
         */
        protocols?: string[];
        /**
         * @en The headers to include in the request.
         * @zh 请求中包含的头部。
         */
        headers?: Record<string, string>;
        /**
         * @en The timeout in milliseconds.
         * @zh 超时时间，单位为毫秒
         */
        timeout?: number;
        /**
         * @en Whether to enable the compression extension
         * @zh 是否开启压缩扩展
         */
        perMessageDeflate?: boolean;
        /**
         * @en Whether to enable TCP_NODELAY.
         * @zh 是否启用TCP_NODELAY。
         */
        tcpNoDelay?: boolean;
        /**
         * @en Force to use cellular network to send request
         * @zh 强制使用蜂窝网络发送请求
         */
        forceCellularNetwork?: boolean;
    }
    interface ILoadTask {
        readonly type: string;
        readonly url: string;
        readonly uuid: string;
        readonly ext: string;
        readonly loader: Loader;
        readonly obsoluteInst: Resource;
        readonly options: Readonly<ILoadOptions>;
        readonly progress: IBatchProgress;
    }
    interface IResourceLoader {
        load(task: ILoadTask): Promise<any>;
        postLoad?(task: ILoadTask, content: any): Promise<void>;
    }
    interface ILoadOptions {
        /**
         * @en The type of resource to load. If not specified, it will be determined based on the file extension.
         * @zh 要加载的资源类型。如果未指定，将根据文件扩展名确定。
         */
        type?: string;
        /**
         * @en Only used when the resource type cannot be determined from the extension.
         * @zh 只有当无法从扩展名获取资源类型时，才使用这里指定的类型。
         */
        maybeType?: string;
        /**
         * @en The priority of the loading task. Higher numbers indicate higher priority. Default is 0.
         * @zh 加载任务的优先级。数字越大，优先级越高。默认为 0。
         */
        priority?: number;
        /**
         * @en The group name for resource management. Resources in the same group can be loaded together or managed collectively.
         * @zh 资源分组名称，用于资源管理。同一组中的资源可以一起加载或进行集体管理。
         */
        group?: string;
        /**
         * @en Whether to cache the resource after loading. Default is true.
         * @zh 加载后是否缓存资源。默认为 true。
         */
        cache?: boolean;
        /**
         * @en Whether to ignore the cache and always load the resource from the network. Default is false.
         * @zh 是否忽略缓存，始终从网络加载资源。默认为 false。
         */
        ignoreCache?: boolean;
        /**
         * @en Whether to retry loading if it fails. Default is true.
         * @zh 加载失败时是否重试。默认为 true。
         */
        noRetry?: boolean;
        /**
         * @en Whether not to display error messages in the console if loading fails. Default is false.
         * @zh 加载失败时是否不在控制台显示错误信息。默认为 false。
         */
        silent?: boolean;
        /**
         * @en Whether to use a worker for loading. This is only effective for IMAGE types, and only if the browser supports it. Default is false.
         * @zh 是否使用 worker 进行加载。仅对 IMAGE 类型有效，且浏览器支持时生效。默认为 false。
         */
        useWorkerLoader?: boolean;
        /**
         * @en Parameters for constructing a Texture. This is only effective for TEXTURE2D, TEXTURECUBE, and TEXTURE2DARRAY types.
         * @zh 用于构造 Texture 的参数。仅对 TEXTURE2D、TEXTURECUBE 和 TEXTURE2DARRAY 类型有效。
         */
        constructParams?: TextureConstructParams;
        /**
         * @en Parameters for setting texture properties. This is only effective for TEXTURE2D, TEXTURECUBE, and TEXTURE2DARRAY types.
         * @zh 用于设置纹理属性的参数。仅对 TEXTURE2D、TEXTURECUBE 和 TEXTURE2DARRAY 类型有效。
         */
        propertyParams?: TexturePropertyParams;
        /**
         * @en Create an image bitmap from the array buffer.
         * @zh 从数组缓冲区创建图像位图。
         */
        blob?: ArrayBuffer;
        /**
         * @en The initiator of the loading task. This can be used to track which task initiated the load, or to pass additional context information.
         * @zh 加载任务的发起者。可以用于跟踪哪个任务发起了加载，或传递其他上下文信息。
         */
        initiator?: ILoadTask;
        /**
         * @en Custom data that can be used to pass additional information or parameters to the loader.
         * @zh 自定义数据，可以用于向加载器传递额外的信息或参数。
         */
        [key: string]: any;
    }
    interface ILoadURL extends ILoadOptions {
        url: string;
    }
    interface ContentTypeMap {
        "text": string;
        "json": any;
        "xml": XML;
        "arraybuffer": ArrayBuffer;
        "image": HTMLImageElement | ImageBitmap;
        "sound": HTMLAudioElement;
    }
    type TypeMapEntry = {
        typeId: number;
        loaderType: new () => IResourceLoader;
        hotReloadable?: boolean;
    };
    interface URLInfo {
        ext: string;
        typeId: number;
        main: boolean;
        loaderType: new () => IResourceLoader;
    }
    /**
     * @en The `Loader` class can be used to load resources such as text, JSON, XML, binary, images, etc.
     * @zh `Loader` 类可用来加载文本、JSON、XML、二进制、图像等资源。
     */
    class Loader extends EventDispatcher {
        /**
         * @en Text type, returns a TextResource object containing a string after loading is complete.
         * @zh 文本类型，加载完成后返回包含 string 的 TextResource 对象。
         */
        static readonly TEXT = "text";
        /**
         * @en JSON type, returns a TextResource object containing JSON data after loading is complete.
         * @zh JSON 类型，加载完成后返回包含 json 数据的 TextResource 对象。
         */
        static readonly JSON = "json";
        /**
         * @en XML type, returns a TextResource object containing domXML after loading is complete.
         * @zh XML 类型，加载完成后返回包含 domXML 的 TextResource 对象。
         */
        static readonly XML = "xml";
        /**
         * @en Binary type, returns a TextResource object containing arraybuffer after loading is complete.
         * @zh 二进制类型，加载完成后返回包含 arraybuffer 的 TextResource 对象。
         */
        static readonly BUFFER = "arraybuffer";
        /**
         * @en Texture type, returns a Texture after loading is complete.
         * @zh 纹理类型，加载完成后返回 Texture。
         */
        static readonly IMAGE = "image";
        /**
         * @en Sound type, returns a Sound after loading is complete.
         * @zh 声音类型，加载完成后返回 Sound。
         */
        static readonly SOUND = "sound";
        /**
         * @en Video type, returns a VideoTexture after loading is complete.
         * @zh 视频类型，加载完成后返回 VideoTexture。
         */
        static readonly VIDEO = "video";
        /**
         * @en Atlas type, returns atlas JSON information (and creates small Textures within the atlas) after loading is complete.
         * @zh 图集类型，加载完成后返回图集 json 信息（并创建图集内小图 Texture）。
         */
        static readonly ATLAS = "atlas";
        /**
         * @en Bitmap font type, returns a BitmapFont after loading is complete. It will be automatically registered as a bitmap font based on the file name.
         * @zh 位图字体类型，加载完成后返回 BitmapFont，加载后，会根据文件名自动注册为位图字体。
         */
        static readonly FONT = "font";
        /**
         * @en TTF font type, returns an object after loading is complete.
         * @zh TTF 字体类型，加载完成后返回一个对象。
         */
        static readonly TTF = "ttf";
        /**
         * @en Hierarchy resource.
         * @zh Hierarchy 资源。
         */
        static readonly HIERARCHY = "HIERARCHY";
        /**
         * @en Mesh resource.
         * @zh Mesh 资源。
         */
        static readonly MESH = "MESH";
        /**
         * @en Material resource.
         * @zh Material 资源。
         */
        static readonly MATERIAL = "MATERIAL";
        /**
         * @en Texture2D resource. This is for compatibility, it should actually be BaseTexture.
         * @zh Texture2D 资源。这里是为了兼容，实际应该是 BaseTexture。
         */
        static readonly TEXTURE2D = "TEXTURE2D";
        /**
         * @en TextureCube resource. For compatibility, now TEXTURE2D type can load Texture or TextureCube.
         * @zh TextureCube 资源。兼容处理，现在 TEXTURE2D 类型可以载入 Texture 或者 TextureCube。
         */
        static readonly TEXTURECUBE = "TEXTURE2D";
        /**
         * @en TEXTURE2DARRAY resource.
         * @zh TEXTURE2DARRAY 资源。
         */
        static readonly TEXTURE2DARRAY = "TEXTURE2D";
        /**
         * @en AnimationClip resource.
         * @zh AnimationClip 资源。
         */
        static readonly ANIMATIONCLIP = "ANIMATIONCLIP";
        /**
         * @en Terrain height data resource.
         * @zh Terrain 高度数据资源。
         */
        static readonly TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
        /**
         * @en Terrain resource.
         * @zh Terrain 资源。
         */
        static readonly TERRAINRES = "TERRAIN";
        /**
         * @en Spine resource.
         * @zh Spine 资源。
         */
        static readonly SPINE = "SPINE";
        /**
         * @en Number of retry attempts after loading fails, default is 1.
         * @zh 加载出错后的重试次数，默认重试一次。
         */
        retryNum: number;
        /**
         * @en Delay time before retrying after an error, default is to retry immediately.
         * @zh 延迟时间多久再进行错误重试，默认立即重试。
         */
        retryDelay: number;
        /**
         * @en Maximum number of download threads, default is 5.
         * @zh 最大下载线程，默认为 5 个。
         */
        maxLoader: number;
        /**
         * @en List of resource loaders.
         * @zh 资源加载器列表。
         * @blueprintIgnore
         */
        static readonly extMap: {
            [ext: string]: Array<TypeMapEntry>;
        };
        /**
         * @en Resource type mapping table.
         * @zh 资源类型对应表。
         * @blueprintIgnore
         */
        static readonly typeMap: {
            [type: string]: TypeMapEntry;
        };
        /**
         * @en Hot overload identification.
         * @zh 热重载标识。
         * @blueprintIgnore
         */
        static readonly hotReloadableFlags: Record<number, boolean>;
        /**
         * @en If an extension corresponds to multiple loading types, you can define a mapping here, which can be used to obtain the correct loading type through the resource type recorded in the file during deserialization.
         * @zh 如果一个扩展名对应多种加载类型时，那么在可以在这里定义一个映射，用于在反序列化时，通过文件中记录的资源类型获得正确的加载类型。
         * @blueprintIgnore
         */
        static readonly assetTypeToLoadType: Record<string, string>;
        /**
         * @en The downloader used to download resources.
         * @zh 下载器，用来下载资源。
         */
        static downloader: Downloader;
        /**
         * @en Register a resource loader.
         * @param exts Extensions
         * @param cls Loader class
         * @param type Type identifier. If this kind of resource needs to support identification without extension, or if one extension corresponds to multiple resource types, specifying the type parameter is the best practice.
         * @param hotReloadable Whether to support hot reload
         * @zh 注册一种资源装载器。
         * @param exts 扩展名
         * @param cls 加载器类
         * @param type 类型标识。如果这种资源需要支持识别没有扩展名的情况，或者一个扩展名对应了多种资源类型的情况，那么指定 type 参数是个最优实践。
         * @param hotReloadable 是否支持热重载
         * @blueprintIgnore
         */
        static registerLoader(exts: string[], cls: new () => IResourceLoader, type?: string, hotReloadable?: boolean): void;
        /**
         * @en Resource group mapping table.
         * @zh 资源分组对应表。
         * @blueprintIgnore
         */
        static groupMap: {
            [name: string]: Set<string>;
        };
        /**
         * @en Pool of loaded resources.
         * @zh 已加载的资源池。
         * @blueprintIgnore
         */
        static loadedMap: {
            [url: string]: Array<any>;
        };
        /**
         * @en Preloaded data files. If a url has a record here, the data here will be used directly when requested, abandoning network loading.
         * @zh 预加载的数据文件。如果一个 url 在这里有记录，则请求时直接使用这里的数据，放弃网络加载。
         * @blueprintIgnore
         */
        static preLoadedMap: {
            [url: string]: any;
        };
        private _loadings;
        private _queue;
        private _downloadings;
        /** @ignore @blueprintIgnore */
        constructor();
        /**
         * @en Indicates whether there are any loading tasks in progress.
         * @zh 是否有任何的加载任务在进行。
         */
        get loading(): boolean;
        /**
         * @en Loads resources.
         * @param url The URL or array of URLs of the resource(s) to load.
         * @param type The type of resource. For example: Loader.IMAGE.
         * @param onProgress The progress callback function.
         * @returns A Promise that resolves with the loaded resource(s). If url is a single resource, it returns the loaded resource or null if failed. If url is an array, it returns an array of loaded resources or null for each failed load.
         * @zh 加载资源。
         * @param url 要加载的资源地址或资源地址数组。
         * @param type 资源类型。比如：Loader.IMAGE。
         * @param onProgress 进度回调函数。
         * @returns 返回一个 Promise。根据 url 类型不同分为两种情况：1. url 为字符串或 ILoadURL 类型时，如果加载成功，则返回加载完成的资源，否则为 null；2. url 为数组类型时，返回一个数组，数组每个元素为加载完成的资源或 null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], type?: string, onProgress?: ProgressCallback): Promise<any>;
        /**
         * @en Loads resources with options.
         * @param url The URL or array of URLs of the resource(s) to load.
         * @param options The loading options.
         * @param onProgress The progress callback function.
         * @returns A Promise that resolves with the loaded resource(s). If url is a single resource, it returns the loaded resource or null if failed. If url is an array, it returns an array of loaded resources or null for each failed load.
         * @zh 使用选项加载资源。
         * @param url 要加载的资源地址或资源地址数组。
         * @param options 加载选项。
         * @param onProgress 进度回调函数。
         * @returns 返回一个 Promise。根据 url 类型不同分为两种情况：1. url 为字符串或 ILoadURL 类型时，如果加载成功，则返回加载完成的资源，否则为 null；2. url 为数组类型时，返回一个数组，数组每个元素为加载完成的资源或 null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], options?: Readonly<ILoadOptions>, onProgress?: ProgressCallback): Promise<any>;
        /**
         * @en Loads resources (compatible with engine 2.0 loading interface).
         * @param url The URL or array of URLs of the resource(s) to load. Can be a simple array ["a.png", "b.png"] or a complex array [{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}].
         * @param complete The completion callback. Returns the loaded resource if url is a string, or an array of loaded resources (or null for failed loads) if url is an array.
         * @param progress The progress callback. The callback parameter is the current resource loading progress (0-1).
         * @param type The resource type. For example: Loader.IMAGE.
         * @param priority The loading priority. Higher numbers indicate higher priority. Default is 0.
         * @param cache Whether to cache the resource. Default is true.
         * @param group The group name for resource management.
         * @param ignoreCache Whether to ignore the cache. Default is false.
         * @param useWorkerLoader Whether to use worker loading (only for IMAGE types, and when browser supports it). Default is false.
         * @returns A Promise object.
         * @zh 加载资源（兼容 2.0 引擎的加载接口）。
         * @param url 要加载的单个资源地址或资源信息数组。可以是简单数组 ["a.png", "b.png"] 或复杂数组 [{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
         * @param complete 加载完成回调。如果 url 是字符串，返回加载完成的资源；如果 url 是数组，返回加载完成的资源数组（加载失败的项为 null）。
         * @param progress 加载进度回调。回调参数为当前资源的加载进度（0-1）。
         * @param type 资源类型。比如：Loader.IMAGE。
         * @param priority 加载优先级，数字越大优先级越高。默认为 0。
         * @param cache 是否缓存资源。默认为 true。
         * @param group 分组名称，用于资源管理。
         * @param ignoreCache 是否忽略缓存。默认为 false。
         * @param useWorkerLoader 是否使用 worker 加载（仅针对 IMAGE 类型，且浏览器支持时生效）。默认为 false。
         * @returns Promise 对象。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], complete?: Handler, progress?: Handler, type?: string, priority?: number, cache?: boolean, group?: string, ignoreCache?: boolean, useWorkerLoader?: boolean): Promise<any>;
        /** @internal */
        _load1(url: string, type: string, options: ILoadOptions, onProgress: ProgressCallback): Promise<any>;
        /** @internal */
        _load2(url: string, uuid: string, type: string, options: ILoadOptions, onProgress: ProgressCallback): Promise<any>;
        /**
         * @en Download from the specified URL. This is a low-level method for downloading resources. Unlike the load method, it doesn't parse the returned data or cache the downloaded content. Returns the downloaded data on success, null on failure.
         * @param url The URL to download from.
         * @param contentType The expected content type of the resource.
         * @param onProgress Optional callback for progress updates.
         * @param options Optional loading options.
         * @returns A promise that resolves with the downloaded content. If the download fails, the promise resolves with null.
         * @zh 从指定URL下载。这是较为底层的下载资源的方法，它和load方法不同，不对返回的数据进行解析，也不会缓存下载的内容。成功则返回下载的数据，失败返回null。
         * @param url 要下载的URL。
         * @param contentType 预期的资源内容类型。
         * @param onProgress 可选的进度更新回调。
         * @param options 可选的加载选项。
         * @returns 解析为下载内容的Promise，加载失败则返回null
         */
        fetch<K extends keyof ContentTypeMap>(url: string, contentType: K, onProgress?: ProgressCallback, options?: Readonly<ILoadOptions>): Promise<ContentTypeMap[K]>;
        private queueToDownload;
        private download;
        private completeItem;
        /**
         * @en Get URL information based on the provided URL and optional type.
         * @param url The URL to analyze.
         * @param type Optional type specification.
         * @returns URLInfo object containing extension, main flag, typeId, and loaderType.
         * @zh 根据提供的URL和可选类型获取URL信息。
         * @param url 要分析的URL。
         * @param type 可选的类型规范。
         * @returns 包含扩展名、主要标志、类型ID和加载器类型的URLInfo对象。
         */
        static getURLInfo(url: string, type?: string, maybeType?: string): URLInfo;
        /**
         * @en Log a warning about a failed resource load, optionally including the initiator URL.
         * @param url The URL of the resource that failed to load.
         * @param err Optional error object or message.
         * @param initiatorUrl Optional URL of the resource that initiated the load.
         * @zh 记录资源加载失败的警告，可选择包含启动器URL。
         * @param url 加载失败的资源URL。
         * @param err 可选的错误对象或消息。
         * @param initiatorUrl 可选的启动加载的资源URL。
         */
        static warnFailed(url: string, err?: any, initiatorUrl?: string): void;
        /**
         * @en Log a warning message, optionally including an error object.
         * @param msg The warning message to log.
         * @param err Optional error object to include in the warning.
         * @zh 记录警告消息，可选择包含错误对象。
         * @param msg 要记录的警告消息。
         * @param err 可选的要包含在警告中的错误对象。
         */
        static warn(msg: string, err?: any): void;
        /**
         * @en Retrieve resources from the specified resource address.
         * @param url The resource address.
         * @return Returns the resource.
         * @zh 获取指定资源地址的资源。
         * @param url 资源地址。
         * @return 返回资源。
         */
        static getRes(url: string, type?: string): any;
        /** @internal */
        static _getRes(url: string, type?: string): any;
        /**
         * @en Get a Texture2D resource by URL.
         * @param url The URL of the Texture2D resource.
         * @returns The Texture2D resource.
         * @zh 通过 URL 获取 Texture2D 资源。
         * @param url Texture2D 资源的 URL。
         * @returns Texture2D 资源。
         */
        static getTexture2D(url: string): Texture2D;
        /**
         * @en Get a BaseTexture resource by URL.
         * @param url The URL of the BaseTexture resource.
         * @returns The BaseTexture resource.
         * @zh 通过 URL 获取 BaseTexture 资源。
         * @param url BaseTexture 资源的 URL。
         * @returns BaseTexture 资源。
         */
        static getBaseTexture<T extends BaseTexture>(url: string): T;
        /**
         * @en Get the atlas resource by URL.
         * @param url The URL of the atlas.
         * @returns Return the set of addresses.
         * @zh 获取指定资源地址的图集资源。
         * @param url 图集地址。
         * @returns 返回地址集合。
         */
        static getAtlas(url: string): AtlasResource;
        /**
         * @en Get a resource by URL and type.
         * @param url The URL of the resource.
         * @param type The type of the resource.
         * @returns The resource.
         * @zh 通过 URL 和类型获取资源。
         * @param url 资源的 URL。
         * @param type 资源的类型。
         * @returns 资源。
         */
        getRes(url: string, type?: string): any;
        /**
         * @en Create nodes from a prefab resource.
         * @param url The URL of the prefab resource.
         * @returns The created node.
         * @zh 从预制资源创建节点。
         * @param url 预制资源的 URL。
         * @returns 创建的节点。
         */
        static createNodes<T extends Node>(url: string): T;
        /**
         * @en Cache a resource.
         * @param url The URL of the resource.
         * @param data The content to be cached.
         * @param type The type of the resource.
         * @zh 缓存资源。
         * @param url 资源地址。
         * @param data 要缓存的内容。
         * @param type 资源类型。
         */
        static cacheRes(url: string, data: any, type?: string): void;
        /** @internal */
        static _cacheRes(url: string, data: any, typeId: number, main: boolean): void;
        /**
         * @en Cache a resource.
         * @param url The URL of the resource.
         * @param data The content to be cached.
         * @param type The type of the resource.
         * @zh 缓存资源。
         * @param url 资源地址。
         * @param data 要缓存的内容。
         * @param type 资源类型。
         */
        cacheRes(url: string, data: any, type?: string): void;
        /**
         * @en Clear the cached resource at the specified URL.
         * @param url The URL of the resource.
         * @param checkObj If provided, only clear the resource if it matches this object.
         * @zh 清理指定资源地址的缓存。
         * @param url 资源地址。
         * @param checkObj 如果提供，只有缓存中的对象匹配这个才清除，否则不清除。
         */
        static clearRes(url: string, checkObj?: any): void;
        /**
         * @en Clear the cached resource at the specified URL.
         * @param url The URL of the resource.
         * @param checkObj If provided, only clear the resource if it matches this object.
         * @zh 清理指定资源地址的缓存。
         * @param url 资源地址。
         * @param checkObj 如果提供，只有缓存中的对象匹配这个才清除，否则不清除。
         */
        clearRes(url: string, checkObj?: any): void;
        /**
         * @internal
         */
        static _clearRes(url: string, checkObj?: any): void;
        /**
         * @en Destroy the image resource used by a Texture, keeping the texture shell. If the texture's image resource is found to be missing during the next render, it will be automatically restored. Compared to clearRes, clearTextureRes only clears the image resource used in the texture without destroying the texture itself. The image resource will be automatically restored when used again. While clearRes completely destroys the texture, making it unusable, clearTextureRes ensures immediate destruction of the image resource without worrying about incorrect destruction.
         * @param url The URL of the atlas or texture, e.g., "res/atlas/comp.atlas" or "hall/bg.jpg".
         * @zh 销毁 Texture 使用的图片资源，保留 texture 壳。如果下次渲染时发现 texture 使用的图片资源不存在，则会自动恢复。相比 clearRes，clearTextureRes 只是清理 texture 里面使用的图片资源，并不销毁 texture，再次使用到的时候会自动恢复图片资源。而 clearRes 会彻底销毁 texture，导致不能再使用；clearTextureRes 能确保立即销毁图片资源，并且不用担心销毁错误。
         * @param url 图集地址或者 texture 地址，比如 "res/atlas/comp.atlas" 或 "hall/bg.jpg"。
         */
        clearTextureRes(url: string): void;
        /**
         * @en Set the resource group.
         * @param url The URL of the resource.
         * @param group The name of the group.
         * @zh 设置资源分组。
         * @param url 资源地址。
         * @param group 分组名。
         */
        static setGroup(url: string, group: string): void;
        /**
         * @en Clean up resources based on grouping.
         * @param group The name of the group.
         * @zh 根据分组清理资源。
         * @param group 分组名
         */
        static clearResByGroup(group: string): void;
        /**
         * @en Clears all unfinished loading tasks. All unloaded content will stop loading.
         * @zh 清理当前未完成的加载，所有未加载的内容全部停止加载。
         */
        clearUnLoaded(): void;
        /**
         * @en Clears unloaded content based on a collection of URLs.
         * @param urls An array of resource URLs.
         * @zh 根据地址集合清理掉未加载的内容。
         * @param urls 资源地址集合。
         */
        cancelLoadByUrls(urls: any[]): void;
        /**
         * @en Clears unloaded content based on a specific URL.
         * @param url The resource URL.
         * @zh 根据地址清理掉未加载的内容。
         * @param url 资源地址。
         */
        cancelLoadByUrl(url: string): void;
        /**
         * @en Loads a sub-package.
         * @param path The path of the sub-package in mini-game.
         * @param onProgress The callback for loading progress.
         * @returns A Promise that resolves when the package is loaded.
         * @zh 载入一个分包。
         * @param path 小游戏的分包路径。
         * @param onProgress 加载进度回调。
         * @returns 当包加载完成时解析的 Promise。
         */
        loadPackage(path: string, onProgress?: ProgressCallback): Promise<boolean>;
        /**
         * @en Loads a sub-package.
         * @param path The path of the sub-package.
         * @param remoteUrl If the package is a remote package, provide the remote resource server address, e.g., "http://cdn.com/"
         * @param onProgress The callback for loading progress.
         * @returns A Promise that resolves when the package is loaded.
         * @zh 载入一个分包。
         * @param path 分包路径。
         * @param remoteUrl 如果分包是一个远程包，那需要提供远程资源服务器的地址，例如"http://cdn.com/"
         * @param onProgress 加载进度回调。
         * @returns 当包加载完成时解析的 Promise。
         */
        loadPackage(path: string, remoteUrl?: string, onProgress?: ProgressCallback): Promise<boolean>;
        /** @ignore */
        _loadFileConfig(path: string, loadScript: boolean, onProgress: ProgressCallback): Promise<boolean>;
        /** @ignore */
        _parseFileConfig(fileConfig: any): void;
    }
    /**
     * @en The `LocalStorage` class is used for data storage without time limit.
     * @zh `LocalStorage` 类用于没有时间限制的数据存储。
     */
    class LocalStorage {
        /**
         * @en Stores a key-value pair as strings.
         * @param key The key name.
         * @param value The value to store.
         * @zh 存储指定键名和键值，字符串类型。
         * @param key 键名。
         * @param value 键值。
         */
        static setItem(key: string, value: string): void;
        /**
         * @en Retrieves the value for the specified key.
         * @param key The key name.
         * @returns The string value associated with the key.
         * @zh 获取指定键名的值。
         * @param key 键名。
         * @returns 与键关联的字符串值。
         */
        static getItem(key: string): string | null;
        /**
         * @en Stores a key-value pair where the value is an Object.
         * @param key The key name.
         * @param value The value to store. It's an Object type and will be converted to a JSON string for storage.
         * @zh 存储指定键名及其对应的 Object 类型值。
         * @param key 键名。
         * @param value 键值。是 Object 类型，会被转化为 JSON 字符串存储。
         */
        static setJSON(key: string, value: any): void;
        /**
         * @en Retrieves the Object value for the specified key.
         * @param key The key name.
         * @returns The Object value associated with the key.
         * @zh 获取指定键名对应的 Object 类型值。
         * @param key 键名。
         * @returns 与键关联的 Object 类型值。
         */
        static getJSON(key: string): any;
        /**
         * @en Removes the item associated with the specified key.
         * @param key The key name.
         * @zh 删除指定键名的信息。
         * @param key 键名。
         */
        static removeItem(key: string): void;
        /**
         * @en Clears all locally stored information.
         * @zh 清除所有本地存储的信息。
         */
        static clear(): void;
        /**
         * @en Retrieves the number of items stored in local storage.
         * @returns The number of items.
         * @zh 获取本地存储中存储的项目数量。
         * @returns 存储的项目数量。
         */
        static get count(): number;
    }
    /**
     * @en Socket encapsulates HTML5 WebSocket, allowing full-duplex real-time communication between server and client, and cross-domain communication. After establishing a connection, both server and Browser/Client Agent can actively send or receive text and binary data to each other.
     * -  To use Socket class methods, first create a Socket object using the constructor new Socket. Socket transmits and receives data asynchronously.
     * - Event.OPEN event: dispatched after successful connection establishment.
     * - Event.MESSAGE event: dispatched after receiving data.
     * - Event.CLOSE event: dispatched after connection closed.
     * - Event.ERROR event: dispatched after an error occurred.
     * @zh Socket 封装了 HTML5 WebSocket，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。
     * - 要使用Socket 类的方法，请先使用构造函数 new Socket 创建一个 Socket 对象。 Socket 以异步方式传输和接收数据。
     * - Event.OPEN 事件：连接建立成功后调度。
     * - Event.MESSAGE 事件：接收到数据后调度。
     * - Event.CLOSE 事件：连接被关闭后调度。
     * - Event.ERROR 事件：出现异常后调度。
     * @blueprintable
     */
    class Socket extends EventDispatcher {
        /**
         * @en The data received from the server.
         * @zh 服务端发来的缓存数据。
         */
        readonly input: Byte;
        /**
         * @en The data in the buffer that needs to be sent to the server.
         * @zh 需要发送至服务端的缓冲区中的数据。
         */
        readonly output: Byte;
        /**
         * @en Whether to disable caching of data received from the server. If the transmitted data is in string format, it is recommended to set this to true to reduce binary conversion overhead.
         * @zh 是否禁用服务端发来的数据缓存。如果传输的数据为字符串格式，建议设置为true，减少二进制转换消耗。
         */
        disableInput: boolean;
        protected _socket: IWebSocket;
        protected _connected: boolean;
        protected _inputPos: number;
        /**
         * @en Create a new Socket object. The default byte order is Socket.BIG_ENDIAN. If no parameters are specified, a socket initially in a disconnected state will be created. If valid parameters are specified, it attempts to connect to the specified host and port.
         * @param host The server address.
         * @param port The server port.
         * @param protocols Subprotocol names. A string or an array of strings of subprotocol names.
         * @param isSecure Whether to use the WebSocket secure protocol wss, default (false) uses the ordinary protocol ws.
         * @zh 创建新的 Socket 对象。默认字节序为 Socket.BIG_ENDIAN 。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了有效参数，则尝试连接到指定的主机和端口。
         * @param host 服务器地址。
         * @param port 服务器端口。
         * @param protocols 子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。
         * @param isSecure 是否使用WebSocket安全协议wss，默认（false）使用普通协议ws。
         */
        constructor(host?: string, port?: number, protocols?: string[], isSecure?: boolean);
        /**
         * @en Indicates whether this Socket object is currently connected.
         * @zh 表示此 Socket 对象目前是否已连接。
         */
        get connected(): boolean;
        /**
         * @en The byte order used by this Socket object.
         * @zh 此 Socket 对象使用的字节序。
         */
        get endian(): string;
        set endian(value: string);
        /**
         * @en Connect to the specified host and port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param host The server address.
         * @param port The server port.
         * @param isSecure Whether to use the WebSocket secure protocol wss, default (false) uses the ordinary protocol ws.
         * @param protocols Subprotocol names. A string or an array of strings of subprotocol names.
         * @zh 连接到指定的主机和端口。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param host 服务器地址。
         * @param port 服务器端口。
         * @param isSecure 是否使用WebSocket安全协议wss，默认（false）使用普通协议ws。
         * @param protocols 子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。
         */
        connect(host: string, port: number, isSecure?: boolean, protocols?: string[]): void;
        /**
         * @en Connect to the specified host and port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param host The server address.
         * @param port The server port.
         * @param isSecure Whether to use the WebSocket secure protocol wss, default (false) uses the ordinary protocol ws.
         * @param options Options for the WebSocket connection.
         * @zh 连接到指定的主机和端口。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param host 服务器地址。
         * @param port 服务器端口。
         * @param isSecure 是否使用WebSocket安全协议wss，默认（false）使用普通协议ws。
         * @param options WebSocket 连接的选项。
         */
        connect(host: string, port: number, isSecure?: boolean, options?: IWebSocketConnectOptions): void;
        /**
         * @en Connect to the specified server WebSocket URL. The URL is similar to ws://yourdomain:port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param url The server WebSocket URL to connect to. The URL is similar to ws://yourdomain:port.
         * @param protocols Subprotocol names. A string or an array of strings of subprotocol names.
         * @zh 连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         * @param protocols 子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。
         */
        connectByUrl(url: string, protocols?: string[]): void;
        /**
         * @en Connect to the specified server WebSocket URL. The URL is similar to ws://yourdomain:port.
         * - Dispatches Event.OPEN on successful connection; Event.ERROR on connection failure; Event.CLOSE when the connection is closed; Event.MESSAGE when data is received. Except for Event.MESSAGE where the event parameter is the data content, other event parameters are native HTML DOM Event objects.
         * @param url The server WebSocket URL to connect to. The URL is similar to ws://yourdomain:port.
         * @param options Options for the WebSocket connection.
         * @zh 连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         * - 连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。
         * @param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         * @param options WebSocket 连接的选项。
         */
        connectByUrl(url: string, options?: IWebSocketConnectOptions): void;
        /**
         * @en Close the connection.
         * @zh 关闭连接。
         */
        close(): void;
        /** @deprecated */
        cleanSocket(): void;
        /**
         * @en Send data to the server.
         * @param data The data to be sent.
         * @zh 发送数据到服务器。
         * @param data 需要发送的数据。
         */
        send(data: string): Promise<void>;
        /**
         * @en Send data to the server.
         * @param buffer The data to be sent.
         * @zh 发送数据到服务器。
         * @param buffer 需要发送的数据。
         */
        send(buffer: ArrayBuffer): Promise<void>;
        /**
         * @en Send the data in the buffer to the server.
         * @zh 发送缓冲区中的数据到服务器。
         */
        flush(): void;
        protected _onMessage(data: string | ArrayBuffer): void;
        /** @internal @blueprintEvent */
        Socket_bpEvent: {
            [Event.OPEN]: () => void;
            [Event.CLOSE]: () => void;
            [Event.ERROR]: (e: any) => void;
            [Event.MESSAGE]: (data: string | ArrayBuffer) => void;
        };
    }
    /**
     * @en The `URL` class provides URL formatting and version management.
     * - The engine automatically calls the formatURL function to format URL paths when loading resources.
     * - You can set the network base path through the basePath property.
     * - By setting the customFormat function, you can customize the way URLs are formatted.
     * @zh `URL` 类提供URL格式化和版本管理功能。
     * - 引擎加载资源时，会自动调用formatURL函数格式化URL路径。
     * - 通过basePath属性可以设置网络基础路径。
     * - 通过设置customFormat函数，可以自定义URL格式化的方式。
     */
    class URL {
        /**
         * @en URL address version mapping table. For example, {"aaa/bb.png":"edcba","aaa/bb.png":"1342a"}. By default, after formatting through formatURL, it will automatically generate an address like "aaa/bb-1342a.png".
         * @zh URL地址版本映射表。例如，{"aaa/bb.png":"edcba","aaa/bb.png":"1342a"}。默认情况下，通过formatURL格式化后，会自动生成为"aaa/bb-1342a.png"的地址。
         */
        static readonly version: Record<string, string>;
        /**
         * @en Base path. If not set, it defaults to the path of the current web page. The final address will be formatted as basePath + relative URL address.
         * @zh 基础路径。如果不设置，默认为当前网页的路径。最终地址将被格式化为 basePath + 相对URL地址。
         */
        static basePath: string;
        /**
         * @en Extended base path mapping table. For example, {"aa/":"http://abc.com/"}, then resources with paths starting with aa/ will be mapped to http://abc.com/.
         * @zh 扩展的基础路径映射表。例如，{"aa/":"http://abc.com/"}，则把路径以aa/开头的资源映射到http://abc.com/下。
         */
        static basePaths: Record<string, string>;
        /**
         * @en URL mapping table. For example, {"aa/bb.png":"cc/dd.png"}. This is used to map URLs to different paths.
         * @zh URL映射表。例如，{"aa/bb.png":"cc/dd.png"}。用于将URL映射到不同的路径。
         */
        static readonly urlMapping: Record<string, string>;
        private _url;
        private _path;
        private static overrideFileExts;
        private static hasExtOverrides;
        private static usingSafeFileExts;
        private static readonly safeFileExtConversionMap;
        /**
         * @en Initialize file extension overrides for mini-game.
         * @zh 初始化小游戏的文件扩展名覆盖。
         */
        static initMiniGameExtensionOverrides(): void;
        /**
         * @en Create a new `URL` instance.
         * @param url The URL to be formatted.
         * @zh 创建一个新的 `URL` 实例。
         * @param url 要格式化的URL地址。
         */
        constructor(url: string);
        /**
         * @en The formatted address.
         * @zh 格式化后的地址。
         */
        get url(): string;
        /**
         * @en The folder path of the address (excluding the file name).
         * @zh 地址的文件夹路径（不包括文件名）。
         */
        get path(): string;
        /**
         * @en Custom URL formatting function. For example: customFormat = function(url:String):String{}
         * @zh 自定义URL格式化的方式。例如：customFormat = function(url:String):String{}
         */
        static customFormat: (url: string) => string;
        /**
         * 指以'~/'开头的的url路径的映射。
         * 不推荐使用，应该使用basePaths。
        */
        static get rootPath(): string;
        static set rootPath(value: string);
        /**
         * 包含normalizedURL功能，并且合并base，如果base没有提供，则使用URL.basePath或者URL.rootPath。
         * @param url 地址。
         * @param base 基础路径，如果没有，则使用URL.basePath或者URL.rootPath。
         * @return 格式化处理后的地址。
         */
        static formatURL(url: string, base?: string): string;
        /**
         * @en Process automatic conversion of file extensions.
         * @param url The address to be processed.
         * @returns The processed address.
         * @zh 处理扩展名的自动转换。
         * @param url 要处理的地址。
         * @return 处理后的地址。
         */
        static postFormatURL(url: string): string;
        /**
         * @en Normalize a relative path. Mainly handles cases with '.' and '..'.
         * @param url The URL to normalize.
         * @returns The normalized URL.
         * @zh 格式化相对路径。主要是处理 '.' 和 '..' 这些情况。
         * @param url 要格式化的路径。
         * @return 格式化后的路径。
         */
        static normalize(url: string): string;
        /**
         * @en Get the resource URL by UUID.
         * @param url The input URL or UUID.
         * @returns The resource URL.
         * @zh 通过 UUID 获取资源 URL。
         * @param url 输入的 URL 或 UUID。
         * @return 资源 URL。
         */
        static getResURLByUUID(url: string): string;
        /**
         * @en Combine and normalize relative paths.
         * @param base The base path.
         * @param path The path to join.
         * @returns The combined and normalized path.
         * @zh 组合相对路径并格式化。
         * @param base 基础路径。
         * @param path 要合并的路径。
         * @return 合并并格式化后的路径。
         */
        static join(base: string, path: string): string;
        /**
         * @en Get the folder path of the specified URL (excluding the file name). Note: the returned path has a trailing slash (/).
         * @param url The URL address.
         * @returns The folder path with a trailing slash (/).
         * @zh 获取指定 URL 的文件夹路径（不包括文件名）。注意：末尾有斜杠（/）。
         * @param url 地址。
         * @return 文件夹路径。
         */
        static getPath(url: string): string;
        /**
         * @en Get the file name of the specified URL.
         * @param url The URL address.
         * @returns The file name.
         * @zh 获取指定 URL 的文件名。
         * @param url 地址。
         * @return 文件名。
         */
        static getFileName(url: string): string;
        /**
         * @en Get the version string of the URL.
         * @param url The URL to check.
         * @returns The version string or null if not found.
         * @zh 获取 URL 版本字符。
         * @param url 要检查的 URL。
         * @return 版本字符串或 null（如果未找到）。
         */
        static getURLVerion(url: string): string;
        /**
         * @en Override the file extension for downloading.
         * @param originalExts The original extensions. For example, ["scene"].
         * @param targetExt The target extension to convert to. For example, "json".
         * @zh 下载时，转换 URL 的扩展名。
         * @param originalExts 原始扩展名。例如["scene"]。
         * @param targetExt 要转换为的扩展名。例如"json"。
         */
        static overrideExtension(originalExts: Array<string>, targetExt: string, miniGameOnly?: boolean): void;
    }
    /** @internal */
    class _WebSocket implements IWebSocket {
        ws: WebSocket;
        onOpen: (result: any) => void;
        onClose: () => void;
        onError: (e: any) => void;
        onMessage: (data: string | ArrayBuffer) => void;
        open(url: string, options?: IWebSocketConnectOptions): void;
        close(): void;
        send(data: string | ArrayBuffer): Promise<void>;
    }
    /**
     * @en Image loader that uses a Web Worker for asynchronous loading.
     * @zh 使用Web Worker进行异步加载的图像加载器。
     */
    class WorkerLoader {
        /**
         * @en Path to the worker.js file
         * @zh worker.js的路径
         */
        static workerPath: string;
        private static _worker;
        private static _enable;
        private static _queue;
        /**
         * @en Check if worker is supported
         * @returns Whether worker is supported
         * @zh 检查是否支持worker
         * @returns 是否支持worker
         */
        static workerSupported(): boolean;
        /**
         * @en Whether to enable the worker loader.
         * @zh 是否启用worker加载器。
         */
        static get enable(): boolean;
        static set enable(value: boolean);
        /**
         * @en Loads an image asynchronously using the worker.
         * @param url The URL of the image to load.
         * @param options Additional options for loading.
         * @return A promise that resolves with the loaded image.
         * @zh 使用worker异步加载图像。
         * @param url 要加载的图像URL。
         * @param options 加载的附加选项。
         * @return 返回解析后的加载图像。
         */
        static load(url: string, options?: ImageBitmapOptions): Promise<any>;
        /**
         * @en Handles messages received from the worker.
         * @param evt Event data from the worker.
         * @zh 处理从worker接收到的消息。
         * @param evt worker传递的事件数据。
         */
        private static workerMessage;
    }
    enum Render2DOrderMode {
        elementIndex = 0,
        ysort = 1
    }
    /**
     * 2D 渲染基类
     */
    class BaseRenderNode2D extends Component {
        /**@internal */
        private static _uniqueIDCounter;
        /**
         * 渲染节点颜色ID
         * @readonly
         */
        static BASERENDER2DCOLOR: number;
        /**
         * 渲染节点纹理ID
         * @readonly
         */
        static BASERENDER2DTEXTURE: number;
        /**
         * 渲染节点size ID
         * @readonly
         */
        static BASERENDERSIZE: number;
        /**
         * 渲染节点纹理ID
         * @readonly
         */
        static NORMAL2DTEXTURE: number;
        /**
         * @readonly
         */
        static NORMAL2DSTRENGTH: number;
        /**
         * 2D渲染节点宏
         * @readonly
         */
        static SHADERDEFINE_BASERENDER2D: ShaderDefine;
        /**
         * 2D灯光宏
         * @readonly
         */
        static SHADERDEFINE_LIGHT2D_ENABLE: ShaderDefine;
        /** @readonly */
        static SHADERDEFINE_LIGHT2D_EMPTY: ShaderDefine;
        /** @readonly */
        static SHADERDEFINE_LIGHT2D_ADDMODE: ShaderDefine;
        /** @readonly */
        static SHADERDEFINE_LIGHT2D_SUBMODE: ShaderDefine;
        /** @readonly */
        static SHADERDEFINE_LIGHT2D_NORMAL_PARAM: ShaderDefine;
        /**
         * @internal
         */
        static initBaseRender2DCommandEncoder(): void;
        /**
        * @internal
        */
        static _setRenderElement2DMaterial(element: IRenderElement2D, material: Material): void;
        /**
         * @internal
         * 渲染节点
         */
        _renderElements: IRenderElement2D[];
        /**
         * @internal
         * 材质集
         */
        _materials: Material[];
        /**
         * @internal
         * 渲染类型
         */
        _renderType: BaseRender2DType;
        /**
         * @internal
         * 帧循环标记
         */
        _renderUpdateMask: number;
        /**
         * @internal
         * sprite ShaderData,可以为null
         */
        _spriteShaderData: ShaderData;
        /**
         * @internal
         */
        _struct: IRenderStruct2D;
        /**
         * 唯一ID
         */
        private _renderid;
        /**
         * 渲染标签位,用于渲染分层
         */
        private _layer;
        /**
         * 节点内的渲染排序模式
         */
        private _ordingMode;
        /**
         * 渲染目标大小
         */
        private _rtsize;
        protected _lightReceive: boolean;
        /**
         * @internal Light params
         */
        _lightUpdateMark: number;
        /**
         *@internal Light params
         *render是否已经记录在manager中，避免重复记录
         */
        _lightRecord: boolean;
        readonly owner: Sprite;
        /**
         * 渲染层掩码，用于裁剪规则一
         */
        private _renderLayer;
        /**
         * 渲染范围，用于裁剪规则二
         */
        protected _rect: Vector4;
        protected _boundsChange: boolean;
        protected _renderHandle: I2DBaseRenderDataHandle;
        /**
         * 获取渲染层掩码
         */
        get renderLayer(): number;
        /**
         * 设置渲染层掩码
         */
        set renderLayer(value: number);
        /**
         * 获取渲染范围
         */
        get rect(): Vector4;
        get boundsChange(): boolean;
        set boundsChange(value: boolean);
        /**
         * 基于不同BaseRender的uniform集合
         */
        protected _getcommonUniformMap(): Array<string>;
        protected _initDefaultRenderData?(): void;
        /** @internal */
        _transformChange(): void;
        private _changeMaterialReference;
        /**@ignore */
        constructor();
        /**
         * 帧更新，可以放一些顶点更新，数据计算等
         * @param context
         */
        renderUpdate?(context: IRenderContext2D): void;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * override it
         */
        protected _onDestroy(): void;
        /** @ignore */
        _getRenderHandle(): I2DBaseRenderDataHandle;
        protected _createRenderHandle(): I2DBaseRenderDataHandle;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * @en render layer
         * @zh 渲染层。
         */
        get layer(): number;
        set layer(value: number);
        set lightReceive(value: boolean);
        get lightReceive(): boolean;
        _resetUpdateMark(): void;
        _updateLight(): void;
        /**
         * light Manager
         */
        private _addRenderToLightManager;
        /**
         * lightManager
         */
        private _removeRenderFromLightManager;
        /**
         * @en get first Material
         * @zh 第一个材质。
         */
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        /** @internal */
        _getRenderElements(): IRenderElement2D[];
        /**
         * @en Get 2D render component ID
         * @zh 获得2D渲染组件标识ID
         * @returns 获得ID
         */
        getRenderID(): number;
        /**
         * @internal
         */
        clear(): void;
    }
    /**
     * @en The `GradientDataNumber` class is used to create floating-point gradients.
     * @zh `GradientDataNumber` 类用于创建浮点渐变。
     */
    class GradientDataNumber implements IClone {
        /**
         * @internal
         * @en Create a constant gradient curve data.
         * @param constantValue The constant value for the gradient.
         * @returns A new GradientDataNumber instance with constant value.
         * @zh 创建一个常数渐变曲线数据。
         * @param constantValue 常数值。
         * @returns 包含常数值的 GradientDataNumber 实例。
         */
        static createConstantData(constantValue: number): GradientDataNumber;
        private _currentLength;
        /**
         * @internal
         */
        _dataBuffer: Float32Array;
        /**
         * @internal
         */
        get _elements(): Float32Array;
        /**
         * @internal
         */
        set _elements(value: Float32Array);
        /**@internal 曲线编辑范围*/
        _curveMin: number;
        /**@internal 曲线编辑范围*/
        _curveMax: number;
        /**
         * @en The number of gradient floats.
         * @zh 渐变浮点数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the GradientDataNumber class.
         * @zh 创建一个 GradientDataNumber 类的实例。
         */
        constructor();
        /**
         * @internal
         * @en Format data, ensure the maximum value is 1.
         * @zh 格式化数据，确保数据的最大值为 1。
         */
        _formatData(): void;
        /**
         * @en Add a floating-point gradient.
         * @param key Lifecycle, ranging from 0 to 1.
         * @param value The float value.
         * @zh 增加浮点渐变。
         * @param key 生命周期，范围为 0 到 1。
         * @param value 浮点值。
         */
        add(key: number, value: number): void;
        /**
         * @en Get the key by index.
         * @param index The index.
         * @returns The key.
         * @zh 通过索引获取键。
         * @param index 索引。
         * @returns 键。
         */
        getKeyByIndex(index: number): number;
        /**
         * @en Get the value by index.
         * @param index The index.
         * @returns The value.
         * @zh 通过索引获取值。
         * @param index 索引。
         * @returns 值。
         */
        getValueByIndex(index: number): number;
        /**
         * @en Get the average value.
         * @returns The average value of the gradient.
         * @zh 获取平均值。
         * @returns 渐变的平均值。
         */
        getAverageValue(): number;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataNumber): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientDataNumber;
    }
    class ColorOverLifetimeModule implements IClone {
        enable: boolean;
        color: ParticleMinMaxGradient;
        constructor();
        cloneTo(destObject: ColorOverLifetimeModule): void;
        clone(): ColorOverLifetimeModule;
    }
    class EmissionBurst implements IClone {
        time: number;
        count: number;
        constructor();
        cloneTo(destObject: EmissionBurst): void;
        clone(): EmissionBurst;
    }
    class EmissionModule implements IClone {
        enable: boolean;
        private _rateOverTime;
        get rateOverTime(): number;
        set rateOverTime(value: number);
        /** @internal */
        _lastPosition: Vector3;
        rateOverDistance: number;
        /**
         * @internal
         * 粒子发射间隔时间
         */
        _emissionInterval: number;
        private _bursts;
        get bursts(): EmissionBurst[];
        set bursts(value: EmissionBurst[]);
        /** @internal */
        _sortedBursts: EmissionBurst[];
        constructor();
        destroy(): void;
        cloneTo(destObject: EmissionModule): void;
        clone(): EmissionModule;
    }
    enum TextureSheetAnimationMode {
        SingleRow = 0,
        WholeSheet = 1
    }
    class TextureSheetAnimationModule implements IClone {
        enable: boolean;
        tiles: Vector2;
        animation: TextureSheetAnimationMode;
        rowIndex: number;
        frame: ParticleMinMaxCurve;
        startFrame: ParticleMinMaxCurve;
        cycles: number;
        constructor();
        /** @internal */
        _sheetFrameData: Vector4;
        /** @internal */
        _calculateSheetFrameData(): void;
        cloneTo(destObject: TextureSheetAnimationModule): void;
        clone(): TextureSheetAnimationModule;
    }
    abstract class ParticleControler {
        particlePool: ParticlePool;
        /** @internal */
        _initParticlePool(maxParticles: number, particleByteStride: number, particleInfo: ParticleInfo): void;
        /**
         * 播放时间（单位: 秒）
         */
        time: number;
        /**
         * 总播放时间（单位: 秒）
         */
        totalTime: number;
        /**
         * @internal
         * 上次 emit 的时间
         */
        _lastEmitTime: number;
        /** @internal */
        _emitDistance: number;
        /** @internal */
        _nextBurstIndex: number;
        /** @internal */
        _burstLoopCount: number;
        protected _isEmitting: boolean;
        get isEmitting(): boolean;
        protected _isPlaying: boolean;
        get isPlaying(): boolean;
        protected _isPaused: boolean;
        get isPaused(): boolean;
        protected _isStopped: boolean;
        get isStopped(): boolean;
        play(): void;
        pause(): void;
        stop(): void;
        clear(): void;
        abstract simulate(time: number, restart: boolean): void;
        destroy(): void;
    }
    enum ParticleMinMaxCurveMode {
        Constant = 0,
        Curve = 1,
        TwoConstants = 2,
        TwoCurves = 3
    }
    class ParticleMinMaxCurve implements IClone {
        mode: ParticleMinMaxCurveMode;
        private _constantMin;
        private _constantMax;
        get constant(): number;
        set constant(value: number);
        get constantMin(): number;
        set constantMin(value: number);
        get constantMax(): number;
        set constantMax(value: number);
        private _curveMin;
        private _curveMax;
        get curve(): GradientDataNumber;
        set curve(value: GradientDataNumber);
        get curveMin(): GradientDataNumber;
        set curveMin(value: GradientDataNumber);
        get curveMax(): GradientDataNumber;
        set curveMax(value: GradientDataNumber);
        constructor();
        evaluate(time: number, lerp: number): number;
        destroy(): void;
        cloneTo(dest: ParticleMinMaxCurve): void;
        clone(): ParticleMinMaxCurve;
    }
    enum ParticleMinMaxGradientMode {
        Color = 0,
        Gradient = 1,
        TwoColors = 2,
        TwoGradients = 3
    }
    class ParticleMinMaxGradient implements IClone {
        mode: ParticleMinMaxGradientMode;
        colorMin: Color;
        colorMax: Color;
        get color(): Color;
        set color(value: Color);
        gradientMin: Gradient;
        gradientMax: Gradient;
        get gradient(): Gradient;
        set gradient(value: Gradient);
        constructor();
        evaluate(time: number, lerp: number): Color;
        cloneTo(destObject: ParticleMinMaxGradient): void;
        clone(): ParticleMinMaxGradient;
    }
    class ParticleInfo {
        /**
         * emit time
         */
        timeIndex: number;
        lifetimeIndex: number;
    }
    class ParticlePool {
        private _maxCount;
        private _particleStride;
        get particleStride(): number;
        private _particleByteStride;
        get particleByteStride(): number;
        particleDatas: Float32Array;
        readonly particleInfo: ParticleInfo;
        /**
         * @internal
         * active range [activeStartIndex, activeEndIndex)
         */
        activeStartIndex: number;
        /** @internal */
        activeEndIndex: number;
        /** @internal */
        updateStartIndex: number;
        /** @internal */
        updateEndIndex: number;
        get activeParticleCount(): number;
        constructor(maxCount: number, particleByteStride: number, particleInfo: ParticleInfo);
        clear(): void;
        retireParticles(totleTime: number): void;
        addParticleData(data: Float32Array): void;
        destroy(): void;
    }
    enum Particle2DSimulationSpace {
        Local = 0,
        World = 1
    }
    enum Particle2DScalingMode {
        Hierarchy = 0,
        Local = 1
    }
    /**
     * @blueprintIgnore
     */
    class Main2DModule implements IClone {
        duration: number;
        looping: boolean;
        playOnAwake: boolean;
        startDelay: ParticleMinMaxCurve;
        startLifetime: ParticleMinMaxCurve;
        startSpeed: ParticleMinMaxCurve;
        startSize2D: boolean;
        private _startSizeX;
        get startSizeX(): ParticleMinMaxCurve;
        set startSizeX(value: ParticleMinMaxCurve);
        private _startSizeY;
        get startSizeY(): ParticleMinMaxCurve;
        set startSizeY(value: ParticleMinMaxCurve);
        get startSize(): ParticleMinMaxCurve;
        set startSize(value: ParticleMinMaxCurve);
        startRotation: ParticleMinMaxCurve;
        startColor: ParticleMinMaxGradient;
        /** @internal */
        _gravity: Vector2;
        gravityModifier: number;
        /** @internal */
        _spriteRotAndScale: Vector4;
        /** @internal */
        _spriteTranslateAndSpace: Vector3;
        simulationSpace: Particle2DSimulationSpace;
        simulationSpeed: number;
        scaleMode: Particle2DScalingMode;
        private _maxParticles;
        get maxParticles(): number;
        set maxParticles(value: number);
        autoRandomSeed: boolean;
        randomSeed: number;
        unitPixels: number;
        constructor();
        cloneTo(destObject: Main2DModule): void;
        clone(): Main2DModule;
    }
    class Rotation2DOverLifetimeModule implements IClone {
        enable: boolean;
        angularVelocity: ParticleMinMaxCurve;
        constructor();
        cloneTo(destObject: Rotation2DOverLifetimeModule): void;
        clone(): Rotation2DOverLifetimeModule;
    }
    class Shape2DModule implements IClone {
        enable: boolean;
        shape: Base2DShape;
        constructor();
        cloneTo(destObject: Shape2DModule): void;
        clone(): Shape2DModule;
    }
    enum Base2DShapeType {
        Fan = 0,
        Circle = 1,
        Box = 2,
        Semicircle = 3,
        None = 4
    }
    abstract class Base2DShape implements IClone {
        type: Base2DShapeType;
        protected posAndDir: Vector4;
        constructor(type: Base2DShapeType);
        abstract getPositionAndDirection(): Vector4;
        abstract clone(): Base2DShape;
        abstract cloneTo(destObject: Base2DShape): void;
    }
    class Box2DShape extends Base2DShape {
        size: Vector2;
        randomDirection: boolean;
        constructor();
        getPositionAndDirection(): Vector4;
        cloneTo(destObject: Box2DShape): void;
        clone(): Box2DShape;
    }
    class Circle2DShape extends Base2DShape {
        radius: number;
        emitFromEdge: boolean;
        randomDirction: boolean;
        constructor();
        getPositionAndDirection(): Vector4;
        cloneTo(destObject: Circle2DShape): void;
        clone(): Circle2DShape;
    }
    enum FanShapeEmitType {
        Base = 0,
        Area = 1
    }
    class FanShape extends Base2DShape {
        angle: number;
        radius: number;
        emitType: FanShapeEmitType;
        length: number;
        constructor();
        getPositionAndDirection(): Readonly<Vector4>;
        cloneTo(destObject: FanShape): void;
        clone(): FanShape;
    }
    class SemicircleShap extends Base2DShape {
        radius: number;
        emitFromEdge: boolean;
        randomDirction: boolean;
        constructor();
        getPositionAndDirection(): Vector4;
        cloneTo(destObject: SemicircleShap): void;
        clone(): SemicircleShap;
    }
    class Size2DOverLifetimeModule implements IClone {
        enable: boolean;
        separateAxes: boolean;
        private _x;
        get x(): ParticleMinMaxCurve;
        set x(value: ParticleMinMaxCurve);
        private _y;
        get y(): ParticleMinMaxCurve;
        set y(value: ParticleMinMaxCurve);
        get size(): ParticleMinMaxCurve;
        set size(value: ParticleMinMaxCurve);
        constructor();
        cloneTo(destObject: Size2DOverLifetimeModule): void;
        clone(): Size2DOverLifetimeModule;
    }
    enum Velocity2DSimulateSpace {
        Local = 0,
        World = 1
    }
    class Velocity2DOverLifetimeModule implements IClone {
        enable: boolean;
        space: Velocity2DSimulateSpace;
        private _x;
        get x(): ParticleMinMaxCurve;
        set x(value: ParticleMinMaxCurve);
        private _y;
        get y(): ParticleMinMaxCurve;
        set y(value: ParticleMinMaxCurve);
        constructor();
        cloneTo(destObject: Velocity2DOverLifetimeModule): void;
        clone(): Velocity2DOverLifetimeModule;
    }
    class Particle2DGeomotry {
        bufferState: IBufferState;
        geometry: IRenderGeometryElement;
        indexBuffer: IIndexBuffer;
        particleBuffer: IVertexBuffer;
        particleDatas: Float32Array;
        readonly maxParitcleCount: number;
        constructor(maxParticleCount: number, particleDeclaration: VertexDeclaration, meshDeclaration: VertexDeclaration);
        destroy(): void;
    }
    class Particle2DShader {
        static ColorOverLifetimeDef: ShaderDefine;
        static ColorOverLifetimeRandom: ShaderDefine;
        static ColorOVerLifetimeColorKey_8: ShaderDefine;
        static GradientRGB: number;
        static GradientAlpha: number;
        static GradientTimeRange: number;
        static GradientMaxRGB: number;
        static GradientMaxAlpha: number;
        static GradientMaxTimeRange: number;
        static VelocityOverLifetimeDef: ShaderDefine;
        static VelocityCurveMinX: number;
        static VelocityCurveMinY: number;
        static VelocityCurveMaxX: number;
        static VelocityCurveMaxY: number;
        static VelocityOverLifetimeSpace: number;
        static SizeOverLifetimeDef: ShaderDefine;
        static SizeCurveMinX: number;
        static SizeCurveMinY: number;
        static SizeCurveMinTimeRange: number;
        static SizeCurveMaxX: number;
        static SizeCurveMaxY: number;
        static SizeCurveMaxTimeRange: number;
        static RotationOverLifetimeDef: ShaderDefine;
        static RotationCurveMin: number;
        static RotationCurveMax: number;
        static TextureSheetAnimationDef: ShaderDefine;
        static TextureSheetFrameData: number;
        static TextureSheetFrame: number;
        static TextureSheetFrameRange: number;
        static TextureSheetFrameMax: number;
        static CurrentTime: number;
        static UnitPixels: number;
        static SpriteRotAndScale: number;
        static init(): void;
    }
    enum Particle2DVertex {
        PositionAndUV = 0,
        /**
         * vec4;
         * x: texture sheet start frame index
         * y: texture sheet frame count
         * z: texture sheet Row index
         */
        SheetFrameData = 7,
        /**
         * vec4;
         * x: direction x,
         * y: direction y,
         * z: position x,
         * w: position y
         */
        DirectionAndPosition = 8,
        /**
         * vec4;
         * x: size x,
         * y: size y,
         * z: emit time,
         * w: lifetime
         */
        SizeAndTimes = 9,
        /**
         * vec4;
         * x: direction speed,
         * y: space,
         * z: mesh rot cos,
         * w: mesh rot sin
         */
        SpeedSpaceAndRot = 10,
        /**
         * vec4
         * start color
         */
        StartColor = 11,
        /**
         * vec4;
         * x: sprite rotation cos,
         * y: sprite rotation sin,
         * z: sprite scale x,
         * w: sprite scale y
         */
        RotationAndScale = 12,
        /**
         * vec4
         * x: sprite translate x,
         * y: sprite translate y,
         * z: gravity X,
         * w: gravity Y
         */
        TransAndGravity = 13,
        /**
         * vec4
         * x: color random,
         * y: velocity x random,
         * z: velocity y random,
         * w: rotation random
         */
        Random0 = 14,
        /**
         * vec4
         * x: SizeOverLifetime x random,
         * y: SizeOverLifetime y random,
         * z: texture sheet animation frame random,
         */
        Random1 = 15
    }
    class Particle2D {
        readonly data: Float32Array;
        constructor();
        setDirection(x: number, y: number): void;
        setPosition(x: number, y: number): void;
        setSize(x: number, y: number): void;
        setEmitTime(emitTime: number): void;
        setLifetime(lifetime: number): void;
        setSpeed(speed: number): void;
        setSimulationSpace(space: number): void;
        setRot(cos: number, sin: number): void;
        setColor(r: number, g: number, b: number, a: number): void;
        setSpriteRotAndScale(x: number, y: number, z: number, w: number): void;
        setSpriteTrans(x: number, y: number): void;
        setGravity(gravityX: number, gravityY: number): void;
        setRandom(x: number, y: number, z: number, w: number): void;
        setRandom1(x: number, y: number, z: number, w: number): void;
        setSheetFrameData(x: number, y: number, z: number, w: number): void;
    }
    class Particle2DVertexMesh {
        static Particle2DDeclaration: VertexDeclaration;
        static Particle2DMeshDeclaration: VertexDeclaration;
        static Particle2DInfo: ParticleInfo;
        static TempParticle2D: Particle2D;
        static init(): void;
    }
    class ShurikenParticle2DRenderer extends BaseRenderNode2D {
        readonly owner: Sprite;
        private _particleSystem;
        get particleSystem(): ShurikenParticle2DSystem;
        _setOwner(node: Sprite): void;
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        private particleGeometry;
        private _gradientRGBBuffer;
        private _gradientAlphaBuffer;
        private _gradientTimeRange;
        private _gradientMaxRGBBuffer;
        private _gradientMaxAlphaBuffer;
        private _gradientMaxTimeRange;
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        protected _getcommonUniformMap(): Array<string>;
        private setParticleColorOverLifetime;
        private setParticleVelocityOverLifetime;
        private setSize2DOverLifetime;
        private setRotationOverlifetime;
        private setTextureSheetAnimation;
        private setParticleData;
        addCMDCall(px: number, py: number): void;
        private _createRenderGeometry;
        private _createRenderElements;
        private _updateParticleBuffer;
        private _updateMark;
        renderUpdate(context: IRenderContext2D): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _cloneTo(dest: ShurikenParticle2DRenderer): void;
    }
    /** @internal */
    enum Particle2DSystemDirtyFlagBits {
        Velocity2DOverLifetimeBit = 1,
        ColorOverLifetimeBit = 2,
        Size2DOverLifetimeBit = 4,
        Rotation2DOverLifetimeBit = 8,
        TextureSheetAnimationBit = 16
    }
    class ShurikenParticle2DSystem extends ParticleControler implements IClone {
        owner: Sprite;
        _dirtyFlags: number;
        private _main;
        get main(): Main2DModule;
        private _emission;
        get emission(): EmissionModule;
        shape: Shape2DModule;
        private _velocity2DOverLifetime;
        get velocity2DOverLifetime(): Velocity2DOverLifetimeModule;
        set velocity2DOverLifetime(value: Velocity2DOverLifetimeModule);
        private _colorOverLifetime;
        get colorOverLifetime(): ColorOverLifetimeModule;
        set colorOverLifetime(value: ColorOverLifetimeModule);
        private _size2DOverLifetime;
        get size2DOverLifetime(): Size2DOverLifetimeModule;
        set size2DOverLifetime(value: Size2DOverLifetimeModule);
        private _rotation2DOverLifetime;
        get rotation2DOverLifetime(): Rotation2DOverLifetimeModule;
        set rotation2DOverLifetime(value: Rotation2DOverLifetimeModule);
        private _textureSheetAnimation;
        get textureSheetAnimation(): TextureSheetAnimationModule;
        set textureSheetAnimation(value: TextureSheetAnimationModule);
        _initParticleData(particleByteStride: number, particleInfo: ParticleInfo): void;
        constructor();
        play(): void;
        protected getPositionAndDirection(): Vector4;
        _emit(emitTime: number, age: number): boolean;
        _emitOverTime(elapsedTime: number): void;
        _emitOverDistance(): void;
        _emitBurst(burst: EmissionBurst, emitTime: number): void;
        _emitBursts(): void;
        _update(deltaTime: number): void;
        simulate(time: number, restart?: boolean): void;
        cloneTo(destObject: ShurikenParticle2DSystem): void;
        clone(): ShurikenParticle2DSystem;
        destroy(): void;
    }
    /**
     * @en The Burst class is used to describe the burst of particles.
     * @zh Burst 类用于粒子的爆发描述。
     */
    class Burst implements IClone {
        /** 爆发时间,单位为秒。*/
        private _time;
        /** 爆发的最小数量。*/
        private _minCount;
        /** 爆发的最大数量。*/
        private _maxCount;
        /**
         * @en The burst time in seconds.
         * @zh 爆发时间，单位为秒。
         */
        get time(): number;
        /**
         * @en The minimum count of particles in a burst.
         * @zh 爆发的最小粒子数量。
         */
        get minCount(): number;
        /**
         * @en The maximum count of particles in a burst.
         * @zh 爆发的最大粒子数量。
         */
        get maxCount(): number;
        /**
         * @en Creates an instance of the Burst class.
         * @param time Burst time in seconds. Default is 0.
         * @param minCount Minimum count of particles in a burst. Default is 0.
         * @param maxCount Maximum count of particles in a burst. Default is 0.
         * @zh 创建Burst类的实例。
         * @param time 爆发时间,单位为秒。
         * @param minCount 爆发的最小数量。
         * @param time 爆发的最大数量。
         */
        constructor(time?: number, minCount?: number, maxCount?: number);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: Burst): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): Burst;
    }
    /**
     * @en The ColorOverLifetime class is used for the lifecycle color of particles.
     * @zh ColorOverLifetime 类用于粒子的生命周期颜色。
     */
    class ColorOverLifetime {
        private _color;
        /**
         * @en Whether to enable.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The color.
         * @zh 颜色。
         */
        get color(): GradientColor;
        /**
         * @ignore
         * @en creates an instance of the ColorOverLifetime class.
         * @param color gradient color.
         * @zh 创建ColorOverLifetime类的实例。
         * @param color 渐变颜色。
         */
        constructor(color: GradientColor);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ColorOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): ColorOverLifetime;
    }
    /**
     * @en The Emission class is used for particle emitters.
     * @zh Emission 类用于粒子发射器。
     */
    class Emission implements IClone {
        /** @internal */
        private _destroyed;
        /** @internal */
        private _emissionRate;
        private _emissionRateOverDistance;
        /**
         * @internal
         * @en Particle bursts, not allowed to modify.
         * @zh 粒子的爆发，不允许修改。
         */
        _bursts: Burst[];
        /**
         * @en Whether the emission is enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The particle emission rate.
         * @zh 粒子发射速率。
         */
        get emissionRate(): number;
        set emissionRate(value: number);
        /**
         * @en Particle emission rate based on distance (particles/meter).
         * @zh 粒子基于距离的发射速率（个/米）。
         */
        get emissionRateOverDistance(): number;
        set emissionRateOverDistance(value: number);
        /**
         * @en Whether the object has been destroyed.
         * @zh 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * @ignore
         * @en Creates an instance of the Emission class.
         * @zh 创建Emission类的实例。
         */
        constructor();
        /**
         * @private
         * @en Destroy the object.
         * @zh 销毁对象。
         */
        destroy(): void;
        /**
         * @en Get the number of particle bursts.
         * @zh 获取粒子爆发个数。
         */
        getBurstsCount(): number;
        /**
         * @en Get a particle burst by index.
         * @param index The burst index.
         * @returns The particle burst.
         * @zh 通过索引获取粒子爆发。
         * @param index 粒子爆发索引。
         * @return 粒子爆发。
         */
        getBurstByIndex(index: number): Burst;
        /**
         * @en Add a particle burst.
         * @param burst The burst to add.
         * @zh 增加粒子爆发。
         * @param burst 要添加的爆发。
         */
        addBurst(burst: Burst): void;
        /**
         * @en Remove a particle burst.
         * @param burst The burst to remove.
         * @zh 移除粒子爆发。
         * @param burst 要移除的爆发。
         */
        removeBurst(burst: Burst): void;
        /**
         * @en Remove a particle burst by index.
         * @param index The burst index to remove.
         * @zh 通过索引移除粒子爆发。
         * @param index 爆发索引。
         */
        removeBurstByIndex(index: number): void;
        /**
         * @en Clear all particle bursts.
         * @zh 清空粒子爆发。
         */
        clearBurst(): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: Emission): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): Emission;
    }
    /**
     * @en The FrameOverTime class is used to create time frames.
     * @zh FrameOverTime 类用于创建时间帧。
     */
    class FrameOverTime implements IClone {
        /**
         * @en Create a FrameOverTime instance with a constant frame.
         * @param constant The constant frame.
         * @returns The time frame.
         * @zh 通过固定帧创建一个 FrameOverTime 实例。
         * @param constant 固定帧。
         * @return 时间帧。
         */
        static createByConstant(constant?: number): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with a time frame.
         * @param overTime The time frame.
         * @returns The time frame.
         * @zh 通过时间帧创建一个 FrameOverTime 实例。
         * @param overTime 时间帧。
         * @return 时间帧。
         */
        static createByOverTime(overTime: GradientDataInt): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with random two constant frames.
         * @param constantMin The minimum constant frame.
         * @param constantMax The maximum constant frame.
         * @returns The time frame.
         * @zh 通过随机双固定帧创建一个 FrameOverTime 实例。
         * @param constantMin 最小固定帧。
         * @param constantMax 最大固定帧。
         * @return 时间帧。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): FrameOverTime;
        /**
         * @en Create a FrameOverTime instance with random two time frames.
         * @param gradientFrameMin The minimum time frame.
         * @param gradientFrameMax The maximum time frame.
         * @returns The time frame.
         * @zh 通过随机双时间帧创建一个 FrameOverTime 实例。
         * @param gradientFrameMin 最小时间帧。
         * @param gradientFrameMax 最大时间帧。
         * @return 时间帧。
         */
        static createByRandomTwoOverTime(gradientFrameMin: GradientDataInt, gradientFrameMax: GradientDataInt): FrameOverTime;
        private _type;
        private _constant;
        private _overTime;
        private _constantMin;
        private _constantMax;
        private _overTimeMin;
        private _overTimeMax;
        /**
         * @en Lifecycle rotation type, 0: constant mode, 1: curve mode, 2: random double constant mode, 3: random double curve mode.
         * @zh 生命周期旋转类型，0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Constant frame.
         * @zh 固定帧。
         */
        get constant(): number;
        /**
         * @en Time frame.
         * @zh 时间帧。
         */
        get frameOverTimeData(): GradientDataInt;
        /**
         * @en Minimum constant frame.
         * @zh 最小固定帧。
         */
        get constantMin(): number;
        /**
         * @en Maximum constant frame.
         * @zh 最大固定帧。
         */
        get constantMax(): number;
        /**
         * @en Minimum time frame.
         * @zh 最小时间帧。
         */
        get frameOverTimeDataMin(): GradientDataInt;
        /**
         * @en Maximum time frame.
         * @zh 最大时间帧。
         */
        get frameOverTimeDataMax(): GradientDataInt;
        /**
         * @ignore
         * @en Creation via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destFrameOverTime The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destFrameOverTime 要克隆到的目标对象。
         */
        cloneTo(destFrameOverTime: FrameOverTime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): FrameOverTime;
    }
    /**
     * @en The GradientAngularVelocity class is used to create gradient angular velocities.
     * @zh GradientAngularVelocity 类用于创建渐变角速度。
     */
    class GradientAngularVelocity implements IClone {
        /**
         * @en Create a `GradientAngularVelocity` instance with a constant angular velocity.
         * @param constant The constant angular velocity.
         * @return The gradient angular velocity.
         * @zh 通过固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param constant 固定角速度。
         * @return 渐变角速度。
         */
        static createByConstant(constant: number): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with separate constant angular velocities for each axis.
         * @param separateConstant The separate constant angular velocities for each axis.
         * @return The gradient angular velocity instance.
         * @zh 通过分轴固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param separateConstant  分轴固定角速度。
         * @return 渐变角速度实例。
         */
        static createByConstantSeparate(separateConstant: Vector3): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with a gradient angular velocity.
         * @param gradient The gradient angular velocity.
         * @return The gradient angular velocity instance.
         * @zh 通过渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradient 渐变角速度。
         * @return 渐变角速度实例。
         */
        static createByGradient(gradient: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with separate gradient angular velocities for each axis.
         * @param gradientX The gradient angular velocity for the X-axis.
         * @param gradientY The gradient angular velocity for the Y-axis.
         * @param gradientZ The gradient angular velocity for the Z-axis.
         * @returns The gradient angular velocity instance.
         * @zh 通过分轴渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientX X轴渐变角速度。
         * @param gradientY Y轴渐变角速度。
         * @param gradientZ Z轴渐变角速度。
         * @returns 渐变角速度实例。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random constant angular velocities between two values.
         * @param constantMin The minimum constant angular velocity.
         * @param constantMax The maximum constant angular velocity.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机双固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param constantMin 最小固定角速度。
         * @param constantMax 最大固定角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random separate constant angular velocities between two values for each axis.
         * @param separateConstantMin The minimum separate constant angular velocities for each axis.
         * @param separateConstantMax The maximum separate constant angular velocities for each axis.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机分轴双固定角速度创建一个 `GradientAngularVelocity` 实例。
         * @param separateConstantMin 最小分轴固定角速度。
         * @param separateConstantMax 最大分轴固定角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoConstantSeparate(separateConstantMin: Vector3, separateConstantMax: Vector3): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random gradient angular velocities between two gradients.
         * @param gradientMin The minimum gradient angular velocity.
         * @param gradientMax The maximum gradient angular velocity.
         * @returns The gradient angular velocity instance.
         * @zh 通过随机双渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientMin 最小渐变角速度。
         * @param gradientMax 最大渐变角速度。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientAngularVelocity;
        /**
         * @en Create a `GradientAngularVelocity` instance with random separate gradient angular velocities between two gradients for each axis.
         * @param gradientXMin The minimum gradient angular velocity for the X-axis.
         * @param gradientXMax The maximum gradient angular velocity for the X-axis.
         * @param gradientYMin The minimum gradient angular velocity for the Y-axis.
         * @param gradientYMax The maximum gradient angular velocity for the Y-axis.
         * @param gradientZMin The minimum gradient angular velocity for the Z-axis.
         * @param gradientZMax The maximum gradient angular velocity for the Z-axis.
         * @param gradientWMin Reserved data.
         * @param gradientWMax Reserved data.
         * @returns The gradient angular velocity instance.
         * @zh 通过分轴随机双渐变角速度创建一个 `GradientAngularVelocity` 实例。
         * @param gradientXMin 最小X轴渐变角速度。
         * @param gradientXMax 最大X轴渐变角速度。
         * @param gradientYMin 最小Y轴渐变角速度。
         * @param gradientYMax 最大Y轴渐变角速度。
         * @param gradientZMin 最小Z轴渐变角速度。
         * @param gradientZMax 最大Z轴渐变角速度。
         * @param gradientWMin 预留数据。
         * @param gradientWMax 预留数据。
         * @returns 渐变角速度实例。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber, gradientWMin: GradientDataNumber, gradientWMax: GradientDataNumber): GradientAngularVelocity;
        private _type;
        private _separateAxes;
        private __constantSeparate;
        /**
         * @en The separate constant angular velocities for each axis.
         * @zh 分轴固定角速度。
         */
        get _constantSeparate(): Vector3;
        set _constantSeparate(value: Vector3);
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _gradientW;
        /**@internal */
        _constantGradientDdata: GradientDataNumber;
        /**@internal */
        _constantMinGradientDdata: GradientDataNumber;
        /**@internal */
        _constantMaxGradientDdata: GradientDataNumber;
        private __constant;
        private __constantMin;
        private __constantMax;
        /**
         * @internal
         */
        get _constant(): number;
        /**
         * @internal
         */
        set _constant(value: number);
        /**
         * @internal
         */
        get _constantMin(): number;
        /**
         * @internal
         */
        set _constantMin(value: number);
        /**
         * @internal
         */
        get _constantMax(): number;
        /**
         * @internal
         */
        set _constantMax(value: number);
        private __constantMinSeparate;
        private __constantMaxSeparate;
        _constantXGradientDdata: GradientDataNumber;
        _constantYGradientDdata: GradientDataNumber;
        _constantZGradientDdata: GradientDataNumber;
        _constantXMinGradientDdata: GradientDataNumber;
        _constantYMinGradientDdata: GradientDataNumber;
        _constantZMinGradientDdata: GradientDataNumber;
        _constantXMaxGradientDdata: GradientDataNumber;
        _constantYMaxGradientDdata: GradientDataNumber;
        _constantZMaxGradientDdata: GradientDataNumber;
        /**
         * @en The minimum constant separate vector.
         * @zh 最小常量分离向量。
         */
        get _constantMinSeparate(): Vector3;
        set _constantMinSeparate(value: Vector3);
        /**
         * @en The maximum constant separate vector.
         * @zh 最大常量分离向量。
         */
        get _constantMaxSeparate(): Vector3;
        set _constantMaxSeparate(value: Vector3);
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        private _gradientWMin;
        private _gradientWMax;
        /**
         * @en The type of lifetime angular velocity. 0: Constant mode, 1: Curve mode, 2: Random between two constants mode, 3: Random between two curves mode.
         * @zh 生命周期角速度类型。0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Whether the axes are separated.
         * @zh 是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * @en The constant angular velocity.
         * @zh 固定角速度。
         */
        get constant(): number;
        /**
         * @en The constant angular velocity for separate axes.
         * @zh 分轴固定角速度。
         */
        get constantSeparate(): Vector3;
        /**
         * @en The gradient angular velocity.
         * @zh 渐变角速度。
         */
        get gradient(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for X axis.
         * @zh X轴渐变角速度。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for Y axis.
         * @zh Y轴渐变角速度。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for Z axis.
         * @zh Z轴渐变角速度。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The gradient angular velocity for W component.
         * @zh W分量渐变角速度。
         */
        get gradientW(): GradientDataNumber;
        /**
         * @en The minimum constant angular velocity for random between two constants mode.
         * @zh 随机双固定角速度的最小值。
         */
        get constantMin(): number;
        /**
         * @en The maximum constant angular velocity for random between two constants mode.
         * @zh 随机双固定角速度的最大值。
         */
        get constantMax(): number;
        /**
         * @en The minimum constant angular velocity for separate axes in random between two constants mode.
         * @zh 分轴随机双固定角速度的最小值。
         */
        get constantMinSeparate(): Vector3;
        /**
         * @en The maximum constant angular velocity for separate axes in random between two constants mode.
         * @zh 分轴随机双固定角速度的最大值。
         */
        get constantMaxSeparate(): Vector3;
        /**
         * @en The minimum gradient angular velocity.
         * @zh 最小渐变角速度。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity.
         * @zh 最大渐变角速度。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for X axis.
         * @zh X轴最小渐变角速度。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for X axis.
         * @zh X轴最大渐变角速度。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for Y axis.
         * @zh Y轴最小渐变角速度。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for Y axis.
         * @zh Y轴最大渐变角速度。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for Z axis.
         * @zh Z轴最小渐变角速度。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for Z axis.
         * @zh Z轴最大渐变角速度。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @en The minimum gradient angular velocity for W axis.
         * @zh W轴最小渐变角速度。
         */
        get gradientWMin(): GradientDataNumber;
        /**
         * @en The maximum gradient angular velocity for W axis.
         * @zh W轴最大渐变角速度。
         */
        get gradientWMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Creating an instance via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientAngularVelocity): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientAngularVelocity;
    }
    /**
     * @en The GradientColor class is used to create gradient colors.
     * @zh GradientColor 类用于创建渐变颜色。
     */
    class GradientColor implements IClone {
        /**
         * @en Create a GradientColor instance with a constant color.
         * @param constant The constant color.
         * @returns A new GradientColor instance.
         * @zh 通过固定颜色创建一个 GradientColor 实例。
         * @param constant 固定颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByConstant(constant: Vector4): GradientColor;
        /**
         * @en Create a GradientColor instance with a gradient color.
         * @param gradient The gradient color.
         * @returns A new GradientColor instance.
         * @zh 通过渐变颜色创建一个 GradientColor 实例。
         * @param gradient 渐变色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByGradient(gradient: Gradient): GradientColor;
        /**
         * @en Create a GradientColor instance with two random constant colors.
         * @param minConstant The minimum constant color.
         * @param maxConstant The maximum constant color.
         * @returns A new GradientColor instance.
         * @zh 通过随机双固定颜色创建一个 GradientColor 实例。
         * @param minConstant 最小固定颜色。
         * @param maxConstant 最大固定颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByRandomTwoConstant(minConstant: Vector4, maxConstant: Vector4): GradientColor;
        /**
         * @en Create a GradientColor instance with two random gradient colors.
         * @param minGradient The minimum gradient color.
         * @param maxGradient The maximum gradient color.
         * @returns A new GradientColor instance.
         * @zh 通过随机双渐变颜色创建一个 GradientColor 实例。
         * @param minGradient 最小渐变颜色。
         * @param maxGradient 最大渐变颜色。
         * @returns 一个新的 GradientColor 实例。
         */
        static createByRandomTwoGradient(minGradient: Gradient, maxGradient: Gradient): GradientColor;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        private _gradient;
        private _gradientMin;
        private _gradientMax;
        /**
         * @en The type of lifetime color. 0 for constant color mode, 1 for gradient mode, 2 for random two constant colors mode, 3 for random two gradients mode.
         * @zh 生命周期颜色类型。0为固定颜色模式，1为渐变模式，2为随机双固定颜色模式，3为随机双渐变模式。
         */
        get type(): number;
        /**
         * @en The constant color.
         * @zh 固定颜色。
         */
        get constant(): Vector4;
        /**
         * @en The minimum constant color.
         * @zh 最小固定颜色。
         */
        get constantMin(): Vector4;
        /**
         * @en The maximum constant color.
         * @zh 最大固定颜色。
         */
        get constantMax(): Vector4;
        /**
         * @en The gradient color.
         * @zh 渐变颜色。
         */
        get gradient(): Gradient;
        /**
         * @en The minimum gradient color.
         * @zh 最小渐变颜色。
         */
        get gradientMin(): Gradient;
        /**
         * @en The maximum gradient color.
         * @zh 最大渐变颜色。
         */
        get gradientMax(): Gradient;
        /**
         * @ignore
         * @en Creating an instance via `new` is not allowed; please use the static creation function.
         * @zh 不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientColor): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientColor;
    }
    /**
     * @en The GradientDataInt class is used to create integer gradients.
     * @zh GradientDataInt 类用于创建整形渐变。
     */
    class GradientDataInt implements IClone {
        private _currentLength;
        /**
         * @internal
         * @en Developers are prohibited from modifying this.
         * @zh 开发者禁止修改。
         */
        _elements: Float32Array;
        /**
         * @internal
         * @en Curve editing range (minimum).
         * @zh 曲线编辑范围（最小值）。
         */
        _curveMin: number;
        /**
         * @internal
         * @en Curve editing range (maximum).
         * @zh 曲线编辑范围（最大值）。
         */
        _curveMax: number;
        /**
         * @en The number of integer gradients.
         * @zh 整形渐变数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the GradientDataInt class.
         * @zh 创建一个 GradientDataInt 类的实例。
         */
        constructor();
        /**
         * @internal
         * @en Format the data to ensure the maximum value is 1.
         * @zh 格式化数据；保证数据的最大值为1。
         */
        _formatData(): void;
        /**
         * @en Add an integer gradient.
         * @param key - The lifecycle key, ranging from 0 to 1.
         * @param value - The integer value.
         * @zh 增加整形渐变。
         * @param key - 生命周期，范围为0到1。
         * @param value - 整形值。
         */
        add(key: number, value: number): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataInt): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientDataInt;
    }
    /**
     * @en The `GradientDataVector2` class is used to create two-dimensional vector gradients.
     * @zh `GradientDataVector2` 类用于创建二维向量渐变。
     */
    class GradientDataVector2 implements IClone {
        private _currentLength;
        /**
         * @internal
         * @en Developers are prohibited from modifying this.
         * @zh 开发者禁止修改。
         */
        _elements: Float32Array;
        /**
         * @en The number of two-dimensional vector gradients.
         * @zh 二维向量渐变数量。
         */
        get gradientCount(): number;
        /**
         * @ignore
         * @en creates an instance of the `GradientDataVector2` class.
         * @zh 创建一个 `GradientDataVector2` 实例。
         */
        constructor();
        /**
         * @en Add a two-dimensional vector gradient.
         * @param key Lifecycle, ranging from 0 to 1.
         * @param value The two-dimensional vector value.
         * @zh 增加二维向量渐变。
         * @param key 生命周期，范围为 0 到 1。
         * @param value 二维向量值。
         */
        add(key: number, value: Vector2): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientDataVector2): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientDataVector2;
    }
    /**
     * @en The `GradientSize` class is used to create gradient sizes.
     * @zh `GradientSize` 类用于创建渐变尺寸。
     */
    class GradientSize implements IClone {
        /**
         * @en Create a `GradientSize` instance by gradient size.
         * @param gradient  The gradient size.
         * @returns The gradient size instance.
         * @zh 通过渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradient 渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByGradient(gradient: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis gradient sizes.
         * @param gradientX The gradient size for X axis.
         * @param gradientY The gradient size for Y axis.
         * @param gradientZ The gradient size for Z axis.
         * @returns The gradient size instance.
         * @zh 通过分轴渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientX 渐变尺寸X。
         * @param gradientY 渐变尺寸Y。
         * @param gradientZ 渐变尺寸Z。
         * @returns 渐变尺寸实例。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by random two constant sizes.
         * @param constantMin The minimum constant size.
         * @param constantMax The maximum constant size.
         * @returns The gradient size instance.
         * @zh 通过随机双固定尺寸创建一个 `GradientSize` 实例。
         * @param constantMin 最小固定尺寸。
         * @param constantMax 最大固定尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis random two constant sizes.
         * @param constantMinSeparate The minimum constant size for separate axes.
         * @param constantMaxSeparate The maximum constant size for separate axes.
         * @returns The gradient size instance.
         * @zh 通过分轴随机双固定尺寸创建一个 `GradientSize` 实例。
         * @param constantMinSeparate 分轴最小固定尺寸。
         * @param constantMaxSeparate 分轴最大固定尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoConstantSeparate(constantMinSeparate: Vector3, constantMaxSeparate: Vector3): GradientSize;
        /**
         * @en Create a `GradientSize` instance by random two gradient sizes.
         * @param gradientMin The minimum gradient size.
         * @param gradientMax The maximum gradient size.
         * @returns The gradient size instance.
         * @zh 通过随机双渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientMin 最小渐变尺寸。
         * @param gradientMax 最大渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientSize;
        /**
         * @en Create a `GradientSize` instance by separate axis random two gradient sizes.
         * @param gradientXMin The minimum gradient size for X axis.
         * @param gradientXMax The maximum gradient size for X axis.
         * @param gradientYMin The minimum gradient size for Y axis.
         * @param gradientYMax The maximum gradient size for Y axis.
         * @param gradientZMin The minimum gradient size for Z axis.
         * @param gradientZMax The maximum gradient size for Z axis.
         * @returns The gradient size instance.
         * @zh 通过分轴随机双渐变尺寸创建一个 `GradientSize` 实例。
         * @param gradientXMin X轴最小渐变尺寸。
         * @param gradientXMax X轴最大渐变尺寸。
         * @param gradientYMin Y轴最小渐变尺寸。
         * @param gradientYMax Y轴最大渐变尺寸。
         * @param gradientZMin Z轴最小渐变尺寸。
         * @param gradientZMax Z轴最大渐变尺寸。
         * @returns 渐变尺寸实例。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientSize;
        private _type;
        private _separateAxes;
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _constantMin;
        private _constantMax;
        private _constantMinSeparate;
        private _constantMaxSeparate;
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         * @en The type of lifecycle size. 0: Curve mode, 1: Random double constant mode, 2: Random double curve mode.
         * @zh 生命周期尺寸类型，0：曲线模式，1：随机双常量模式，2：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en Whether to separate axes.
         * @zh 是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * @en The gradient size.
         * @zh 渐变尺寸。
         */
        get gradient(): GradientDataNumber;
        /**
         * @en The gradient size for X axis.
         * @zh 渐变尺寸X。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient size for Y axis.
         * @zh 渐变尺寸Y。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient size for Z axis.
         * @zh 渐变尺寸Z。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The minimum random double constant size.
         * @zh 最小随机双固定尺寸。
         */
        get constantMin(): number;
        /**
         * @en The maximum random double constant size.
         * @zh 最大随机双固定尺寸。
         */
        get constantMax(): number;
        /**
         * @en The minimum separate axis random double constant size.
         * @zh 最小分轴随机双固定尺寸。
         */
        get constantMinSeparate(): Vector3;
        /**
         * @en The maximum separate axis random double constant size.
         * @zh 最大分轴随机双固定尺寸。
         */
        get constantMaxSeparate(): Vector3;
        /**
         * @en The minimum gradient size.
         * @zh 渐变最小尺寸。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size.
         * @zh 渐变最大尺寸。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for X axis.
         * @zh 渐变最小尺寸X。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for X axis.
         * @zh 渐变最大尺寸X。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for Y axis.
         * @zh 渐变最小尺寸Y。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for Y axis.
         * @zh 渐变最大尺寸Y。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient size for Z axis.
         * @zh 渐变最小尺寸Z。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient size for Z axis.
         * @zh 渐变最大尺寸Z。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Retrieves the maximum size within a gradient, based on the specified parameters and mode.
         * @param meshMode Indicates whether the calculation is for mesh mode.
         * @returns The maximum size found in the gradient.
         * @zh 获取渐变中的最大尺寸。
         * @param meshMode 是否是网格模式
         * @returns 返回渐变中找到的最大尺寸。
         */
        getMaxSizeInGradient(meshMode?: boolean): number;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientSize): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientSize;
    }
    /**
     * @en The `GradientVelocity` class is used to create gradient velocities.
     * @zh `GradientVelocity` 类用于创建渐变速度。
     */
    class GradientVelocity implements IClone {
        /**
         * @en Create a `GradientVelocity` instance with constant velocity.
         * @param constant The constant velocity.
         * @returns The gradient velocity instance.
         * @zh 通过固定速度创建一个 `GradientVelocity` 实例。
         * @param constant 固定速度。
         * @returns 渐变速度实例。
         */
        static createByConstant(constant: Vector3): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with gradient velocities.
         * @param gradientX Gradient velocity for X axis.
         * @param gradientY Gradient velocity for Y axis.
         * @param gradientZ Gradient velocity for Z axis.
         * @returns The gradient velocity instance.
         * @zh 通过渐变速度创建一个 `GradientVelocity` 实例。
         * @param gradientX 渐变速度X。
         * @param gradientY 渐变速度Y。
         * @param gradientZ 渐变速度Z。
         * @returns 渐变速度实例。
         */
        static createByGradient(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with random two constant velocities.
         * @param constantMin The minimum constant velocity.
         * @param constantMax The maximum constant velocity.
         * @returns The gradient velocity instance.
         * @zh 通过随机双固定速度创建一个 `GradientVelocity` 实例。
         * @param constantMin 最小固定速度。
         * @param constantMax 最大固定速度。
         * @returns 渐变速度实例。
         */
        static createByRandomTwoConstant(constantMin: Vector3, constantMax: Vector3): GradientVelocity;
        /**
         * @en Create a `GradientVelocity` instance with random two gradient velocities.
         * @param gradientXMin Minimum gradient velocity for X axis.
         * @param gradientXMax Maximum gradient velocity for X axis.
         * @param gradientYMin Minimum gradient velocity for Y axis.
         * @param gradientYMax Maximum gradient velocity for Y axis.
         * @param gradientZMin Minimum gradient velocity for Z axis.
         * @param gradientZMax Maximum gradient velocity for Z axis.
         * @returns The gradient velocity instance.
         * @zh 通过随机双渐变速度创建一个 `GradientVelocity` 实例。
         * @param gradientXMin X轴最小渐变速度。
         * @param gradientXMax X轴最大渐变速度。
         * @param gradientYMin Y轴最小渐变速度。
         * @param gradientYMax Y轴最大渐变速度。
         * @param gradientZMin Z轴最小渐变速度。
         * @param gradientZMax Z轴最大渐变速度。
         * @returns 渐变速度实例。
         */
        static createByRandomTwoGradient(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientVelocity;
        private _type;
        private __constant;
        /**
         * @en The constant velocity.
         * @zh 固定速度。
         */
        get _constant(): Vector3;
        set _constant(value: Vector3);
        private __constantMin;
        /**
         * @en The minimum constant velocity.
         * @zh 最小固定速度。
         */
        get _constantMin(): Vector3;
        set _constantMin(value: Vector3);
        private __constantMax;
        /**
         * @en The maximum constant velocity.
         * @zh 最大固定速度。
         */
        get _constantMax(): Vector3;
        set _constantMax(value: Vector3);
        private _gradientConstantX;
        private _gradientConstantY;
        private _gradientConstantZ;
        private _gradientConstantXMin;
        private _gradientConstantXMax;
        private _gradientConstantYMin;
        private _gradientConstantYMax;
        private _gradientConstantZMin;
        private _gradientConstantZMax;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         * @en The lifecycle velocity type. 0: constant mode, 1: curve mode, 2: random double constant mode, 3: random double curve mode.
         * @zh 生命周期速度类型。0：常量模式，1：曲线模式，2：随机双常量模式，3：随机双曲线模式。
         */
        get type(): number;
        /**
         * @en The constant velocity.
         * @zh 固定速度。
         */
        get constant(): Vector3;
        /**
         * @en The gradient velocity for X axis.
         * @zh X轴渐变速度。
         */
        get gradientX(): GradientDataNumber;
        /**
         * @en The gradient velocity for Y axis.
         * @zh Y轴渐变速度。
         */
        get gradientY(): GradientDataNumber;
        /**
         * @en The gradient velocity for Z axis.
         * @zh Z轴渐变速度。
         */
        get gradientZ(): GradientDataNumber;
        /**
         * @en The minimum constant velocity.
         * @zh 最小固定速度。
         */
        get constantMin(): Vector3;
        /**
         * @en The maximum constant velocity.
         * @zh 最大固定速度。
         */
        get constantMax(): Vector3;
        /**
         *@internal
         */
        get gradientConstantX(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantY(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantZ(): GradientDataNumber;
        /**
         *@internal
         */
        get gradientConstantXMin(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantXMax(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantYMin(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantYMax(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantZMin(): GradientDataNumber;
        /**
         * @internal
         */
        get gradientConstantZMax(): GradientDataNumber;
        /**
         * @en The minimum gradient velocity for X axis.
         * @zh X轴最小渐变速度。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for X axis.
         * @zh X轴最大渐变速度。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * @en The minimum gradient velocity for Y axis.
         * @zh Y轴最小渐变速度。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for Y axis.
         * @zh Y轴最大渐变速度。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * @en The minimum gradient velocity for Z axis.
         * @zh Z轴最小渐变速度。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * @en The maximum gradient velocity for Z axis.
         * @zh Z轴最大渐变速度。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: GradientVelocity): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): GradientVelocity;
    }
    /**
     * @en The `RotationOverLifetime` class is used for particle rotation over its lifecycle.
     * @zh `RotationOverLifetime` 类用于控制粒子在其生命周期内的旋转。
     */
    class RotationOverLifetime implements IClone {
        private _angularVelocity;
        /**
         * @en Indicates whether the rotation over lifetime is enabled.
         * @zh 是否启用生命周期旋转。
         */
        enable: boolean;
        /**
         * @en The angular velocity of the particle.
         * @zh 粒子的角速度。
         */
        get angularVelocity(): GradientAngularVelocity;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor(angularVelocity: GradientAngularVelocity);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: RotationOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): RotationOverLifetime;
    }
    /**
     * @en Enumeration of particle system shape types.
     * @zh 粒子系统形状类型枚举。
     */
    enum ParticleSystemShapeType {
        /**
         * @en Box shape.
         * @zh 盒子形状。
         */
        Box = 0,
        /**
         * @en Circle shape.
         * @zh 环形形状。
         */
        Circle = 1,
        /**
         * @en Cone shape.
         * @zh 锥体形状。
         */
        Cone = 2,
        /**
         * @en Hemisphere shape.
         * @zh 半球体形状。
         */
        Hemisphere = 3,
        /**
         * @en Sphere shape.
         * @zh 球体形状。
         */
        Sphere = 4
    }
    /**
     * @en BaseShape class for particle shapes.
     * @zh BaseShape类用于粒子形状。
     * @blueprintable @blueprintableSubclasses
     */
    class BaseShape implements IClone {
        /**
         * @en Whether the shape is enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en Random direction.
         * @zh 随机方向，默认0为不随机。
         */
        randomDirection: number;
        /**
         * @en Particle shape type.
         * @zh 粒子形状类型。
         */
        shapeType: ParticleSystemShapeType;
        /**
         * @ignore
         * @en Creates an instance of the BaseShape class.
         * @zh 创建一个BaseShape实例。
         */
        constructor();
        /**@internal */
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        /**@internal */
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @internal
         */
        _calculateProceduralBounds(boundBox: BoundBox, emitterPosScale: Vector3, minMaxBounds: Vector2): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: BaseShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): BaseShape;
    }
    /**
     * @en BoxShape class for creating box-shaped particle emitters.
     * @zh BoxShape 类用于创建盒形粒子发射器。
     */
    class BoxShape extends BaseShape {
        /**
         * @en Length of the emitter along the X-axis.
         * @zh 发射器X轴长度。
         */
        x: number;
        /**
         * @en Length of the emitter along the Y-axis.
         * @zh 发射器Y轴长度。
         */
        y: number;
        /**
         * @en Length of the emitter along the Z-axis.
         * @zh 发射器Z轴长度。
         */
        z: number;
        /**
         * @ignore
         * @en Creates an instance of the BoxShape class.
         * @zh 创建一个BoxShape实例。
         */
        constructor();
        /**
         * @internal
         */
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: BoxShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): BoxShape;
    }
    /**
     * @en CircleShape class for creating circular particle emitters.
     * @zh CircleShape 类用于创建环形粒子发射器。
     */
    class CircleShape extends BaseShape {
        protected static _tempPositionPoint: Vector2;
        /**
         * @en Emitter radius.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Arc angle.
         * @zh 环形弧度。
         */
        arc: number;
        /**
         * @en Whether to emit from the edge.
         * @zh 是否从边缘发射。
         */
        emitFromEdge: boolean;
        /**
         * @ignore
         * @en Creates an instance of the CircleShape class.
         * @zh 创建一个CircleShape实例。
         */
        constructor();
        /**
         * @en Emission angle 0-360
         * @zh 发射角度 0-360
         */
        get arcDEG(): number;
        set arcDEG(deg: number);
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: CircleShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): CircleShape;
    }
    /**
     * @en ConeShape class is used to create cone-shaped particle emitters.
     * @zh ConeShape类用于创建锥形粒子发射器。
     */
    class ConeShape extends BaseShape {
        protected static _tempPositionPoint: Vector2;
        protected static _tempDirectionPoint: Vector2;
        /**
         * @en The emission angle in radians.
         * @zh 发射角度，单位为弧度。
         */
        angle: number;
        /**
         * @en The radius of the emitter.
         * @zh 发射器的半径。
         */
        radius: number;
        /**
         * @en The length of the cone.
         * @zh 锥体的长度。
         */
        length: number;
        /**
         * @en The emission type. 0 for Base, 1 for BaseShell, 2 for Volume, 3 for VolumeShell.
         * @zh 发射类型：0 表示基础发射，1 表示基础外壳发射，2 表示体积发射，3 表示体积外壳发射。
         */
        emitType: number;
        /**
         * @ignore
         * @en Creates an instance of the ConeShape class.
         * @zh 创建一个ConeShape实例。
         */
        constructor();
        /**
         * @en Emission angle 0-360
         * @zh 发射角度0-360
         */
        get angleDEG(): number;
        set angleDEG(deg: number);
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ConeShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): ConeShape;
    }
    /**
     * @en The HemisphereShape class is used to create hemispherical particle shapes emitters.
     * @zh HemisphereShape 类用于创建半球形粒子形状发射器。
     */
    class HemisphereShape extends BaseShape {
        /**
         * @en The radius of the hemisphere.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Whether to emit from the shell.
         * @zh 是否从外壳发射。
         */
        emitFromShell: boolean;
        /**
         * @ignore
         * @en Creats an instance of the HemisphereShape class.
         * @zh 创建一个HemisphereShape实例。
         */
        constructor();
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: HemisphereShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): HemisphereShape;
    }
    /**
     * @internal
     * @en Utility class for generating random points in various shapes.
     * @zh 用于在各种形状中生成随机点的实用工具类。
     */
    class ShapeUtils {
        /**
         * @en Generates a random point on the arc of a unit circle.
         * @param arc The arc angle in radians.
         * @param out The output Vector2 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位圆弧上生成一个随机点。
         * @param arc 弧度角度。
         * @param out 输出 Vector2 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointUnitArcCircle(arc: number, out: Vector2, rand?: Rand): void;
        /**
         * @en Generates a random point inside the arc of a unit circle.
         * @param arc The arc angle in radians.
         * @param out The output Vector2 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位圆弧内生成一个随机点。
         * @param arc 弧度角度。
         * @param out 输出 Vector2 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointInsideUnitArcCircle(arc: number, out: Vector2, rand?: Rand): void;
        /**
         * @en Generates a random point on the circumference of a unit circle.
         * @param out The output Vector2 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位圆周上生成一个随机点。
         * @param out 输出 Vector2 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointUnitCircle(out: Vector2, rand?: Rand): void;
        /**
         * @en Generates a random point inside a unit circle.
         * @param out The output Vector2 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位圆内生成一个随机点。
         * @param out 输出 Vector2 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointInsideUnitCircle(out: Vector2, rand?: Rand): void;
        /**
         * @en Generates a random point on the surface of a unit sphere.
         * @param out The output Vector3 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位球面上生成一个随机点。
         * @param out 输出 Vector3 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointUnitSphere(out: Vector3, rand?: Rand): void;
        /**
         * @en Generates a random point inside a unit sphere.
         * @param out The output Vector3 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在单位球体内生成一个随机点。
         * @param out 输出 Vector3 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointInsideUnitSphere(out: Vector3, rand?: Rand): void;
        /**
         * @en Generates a random point inside half of a unit box (cube).
         * @param out The output Vector3 to store the result.
         * @param rand Optional random number generator. If not provided, Math.random() will be used.
         * @zh 在半单位立方体内生成一个随机点。
         * @param out 输出 Vector3 用于存储结果。
         * @param rand 可选的随机数生成器。如果不提供，则使用 Math.random()。
         */
        static _randomPointInsideHalfUnitBox(out: Vector3, rand?: Rand): void;
        constructor();
    }
    /**
     * @en SphereShape class is used to create spherical particle shapes.
     * @zh SphereShape 类用于创建球形粒子发射器。
     */
    class SphereShape extends BaseShape {
        /**
         * @en Emitter radius.
         * @zh 发射器半径。
         */
        radius: number;
        /**
         * @en Whether to emit from the shell.
         * @zh 是否从外壳发射。
         */
        emitFromShell: boolean;
        /**
         * @ignore
         * @en Creates an instance of the SphereShape class.
         * @zh 创建一个 SphereShape 实例。
         */
        constructor();
        protected _getShapeBoundBox(boundBox: BoundBox): void;
        protected _getSpeedBoundBox(boundBox: BoundBox): void;
        /**
         * @en Generates initial position and direction for particles.
         * @param position The particle position.
         * @param direction The particle direction.
         * @param rand Random number.
         * @param randomSeeds Array of random seeds.
         * @zh 用于生成粒子初始位置和方向。
         * @param position 粒子位置。
         * @param direction 粒子方向。
         * @param rand 随机数。
         * @param randomSeeds 随机种子数组。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: SphereShape): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): SphereShape;
    }
    /**
     * @en The `SizeOverLifetime` class is used to control the size of particles over their lifetime.
     * @zh `SizeOverLifetime` 类用于控制粒子在其生命周期内的尺寸变化。
     */
    class SizeOverLifetime implements IClone {
        private _size;
        /**
         * @en Whether to enable.
         * @zh 是否启用
         */
        enable: boolean;
        /**
         * @en The size.
         * @zh 尺寸。
         */
        get size(): GradientSize;
        /**
         * @ignore
         * @en Creates an instance of the `SizeOverLifetime` class.
         * @param size gradient size.
         * @zh 创建一个 `SizeOverLifetime` 实例。
         * @param size 渐变尺寸
         */
        constructor(size: GradientSize);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: SizeOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): SizeOverLifetime;
    }
    /**
     * @en The `StartFrame` class is used to create start frames.
     * @zh `StartFrame` 类用于创建起始帧。
     */
    class StartFrame implements IClone {
        /**
         * @en Create a `StartFrame` instance with a constant frame value.
         * @param constant The fixed frame value. Default is 0.
         * @returns A new StartFrame instance.
         * @zh 通过固定帧值创建一个 `StartFrame` 实例。
         * @param constant 固定帧值。默认为0。
         * @returns 新的 StartFrame 实例。
         */
        static createByConstant(constant?: number): StartFrame;
        /**
         * @en Create a `StartFrame` instance with a random range between two constant frame values.
         * @param constantMin The minimum fixed frame value. Default is 0.
         * @param constantMax The maximum fixed frame value. Default is 0.
         * @returns A new StartFrame instance.
         * @zh 通过随机范围在两个固定帧值之间创建一个 `StartFrame` 实例。
         * @param constantMin 最小固定帧值。默认为0。
         * @param constantMax 最大固定帧值。默认为0。
         * @returns 新的 StartFrame 实例。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): StartFrame;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        /**
         * @en The start frame type. 0 for constant mode, 1 for random between two constants mode.
         * @zh 起始帧类型。0表示常量模式，1表示随机双常量模式。
         */
        get type(): number;
        /**
         * @en The constant frame value.
         * @zh 固定帧值。
         */
        get constant(): number;
        /**
         * @en The minimum constant frame value.
         * @zh 最小固定帧值。
         */
        get constantMin(): number;
        /**
         * @en The maximum constant frame value.
         * @zh 最大固定帧值。
         */
        get constantMax(): number;
        /**
         * @ignore
         * @en Constructor, not allowed to use "new", please use the static creation function.
         * @zh 构造方法。不允许new，请使用静态创建函数。
         */
        constructor();
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: StartFrame): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): StartFrame;
    }
    /**
     * @en The `TextureSheetAnimation` class is used to create particle frame animations.
     * @zh `TextureSheetAnimation` 类用于创建粒子帧动画。
     */
    class TextureSheetAnimation implements IClone {
        /**@internal */
        private _frame;
        /**@internal */
        private _startFrame;
        /**
         * @en Texture tiling.
         * @zh 纹理平铺。
         */
        tiles: Vector2;
        /**
         * @en Type, 0 for whole sheet, 1 for single row.
         * @zh 类型，0 表示整个纹理表，1 表示纹理表中的某一行。
         */
        type: number;
        /**
         * @en Whether to use random row, effective when type is 1.
         * @zh 是否随机行，type属性 为 1 时，该属性才会生效。
         */
        randomRow: boolean;
        /**
         * @en Row index, effective when type is 1.
         * @zh 行索引，type属性 为 1 时，该属性才会生效。
         */
        rowIndex: number;
        /**
         * @en Number of cycles.
         * @zh 循环次数。
         */
        cycles: number;
        /**
         * @en UV channel type, 0 for Nothing, 1 for Everything.
         * @zh UV 通道类型，0 表示 Nothing，1 表示 Everything。
         */
        enableUVChannels: number;
        /**
         * @en Whether enabled.
         * @zh 是否启用。
         */
        enable: boolean;
        /**
         * @en The time frame rate.
         * @zh 时间帧率。
         */
        get frame(): FrameOverTime;
        /**
         * @en The start frame rate.
         * @zh 开始帧率。
         */
        get startFrame(): StartFrame;
        /**
         * @en Creates an instance of the `TextureSheetAnimation` class.
         * @param frame Animation frames.
         * @param  startFrame Start frame.
         * @zh 创建一个 `TextureSheetAnimation` 类的实例。
         * @param frame 动画帧。
         * @param  startFrame 开始帧。
         */
        constructor(frame: FrameOverTime, startFrame: StartFrame);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: TextureSheetAnimation): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): TextureSheetAnimation;
    }
    /**
     * @en The `VelocityOverLifetime` class is used for particle velocity over its lifetime.
     * @zh `VelocityOverLifetime` 类用于控制粒子在生命周期内的速度变化。
     */
    class VelocityOverLifetime implements IClone {
        /**@internal */
        private _velocity;
        /**
         * @en Whether to enable.
         * @zh 是否启用*/
        enable: boolean;
        /**
         * @en Velocity space, 0 for local, 1 for world.
         * @zh 速度空间，0 表示局部空间，1 表示世界空间。
         */
        space: number;
        /**
         * @en The gradient velocity.
         * @zh 渐变速度。
         */
        get velocity(): GradientVelocity;
        /**
         * @ignore
         * @en Creates an instance of `VelocityOverLifetime` class.
         * @param velocity gradient velocity.
         * @zh 创建一个 `VelocityOverLifetime` 类的实例。
         * @param velocity 渐变速度。
         */
        constructor(velocity: GradientVelocity);
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: VelocityOverLifetime): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): VelocityOverLifetime;
    }
    /**
     * ParticleShuriKen Shader init
     */
    class ParticleShuriKenShaderInit {
        static init(): void;
    }
    /**
     * @en ShuriKenParticle3D is a class of 3D particle system.
     * @zh ShuriKenParticle3D 是3D粒子系统的类。
     */
    class ShuriKenParticle3D extends RenderableSprite3D {
        _render: ShurikenParticleRenderer;
        private _particleSystem;
        /**
         * @en The particle system.
         * @zh 粒子系统。
         */
        get particleSystem(): ShurikenParticleSystem;
        /**
         * @en The particle renderer.
         * @zh 粒子渲染器。
         */
        get particleRenderer(): ShurikenParticleRenderer;
        /**
         * @ignore
         * @en creates an instance of the ShuriKenParticle3D class.
         * @zh 创建Particle3D类的实例。
         */
        constructor();
        /**
         * @en Destroy this object.
         * @param destroyChild Whether to destroy the child node. If true, the child node will be destroyed, otherwise it will not be destroyed.
         * @zh 销毁此对象。
         * @param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @internal
     */
    class ShuriKenParticle3DShaderDeclaration {
        /**@internal */
        static SHADERDEFINE_RENDERMODE_BILLBOARD: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_COLORKEYCOUNT_8: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_COLOROVERLIFETIME: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_RANDOMCOLOROVERLIFETIME: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_VELOCITYOVERLIFETIMECURVE: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_TEXTURESHEETANIMATIONCURVE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ROTATIONOVERLIFETIME: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_ROTATIONOVERLIFETIMECURVE: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_SIZEOVERLIFETIMECURVE: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_RENDERMODE_MESH: ShaderDefine;
        /**@internal Mul Shuriken Define*/
        static SHADERDEFINE_SHAPE: ShaderDefine;
        /**@internal */
        static WORLDPOSITION: number;
        /**@internal */
        static WORLDROTATION: number;
        /**@internal */
        static POSITIONSCALE: number;
        /**@internal */
        static SIZESCALE: number;
        /**@internal */
        static SCALINGMODE: number;
        /**@internal */
        static GRAVITY: number;
        /**@internal */
        static THREEDSTARTROTATION: number;
        /**@internal */
        static SHAPE: number;
        /**@internal */
        static STRETCHEDBILLBOARDLENGTHSCALE: number;
        /**@internal */
        static STRETCHEDBILLBOARDSPEEDSCALE: number;
        /**@internal */
        static SIMULATIONSPACE: number;
        /**@internal */
        static CURRENTTIME: number;
        /**@internal */
        static DRAG: number;
        /**@internal  Mul Shuriken Define*/
        static VOLVELOCITYCONST: number;
        /**@internal */
        static VOLVELOCITYGRADIENTX: number;
        /**@internal */
        static VOLVELOCITYGRADIENTY: number;
        /**@internal */
        static VOLVELOCITYGRADIENTZ: number;
        /**@internal  Mul Shuriken Define*/
        static VOLVELOCITYCONSTMAX: number;
        /**@internal */
        static VOLVELOCITYGRADIENTXMAX: number;
        /**@internal */
        static VOLVELOCITYGRADIENTYMAX: number;
        /**@internal */
        static VOLVELOCITYGRADIENTZMAX: number;
        /**@internal */
        static VOLSPACETYPE: number;
        /**@internal */
        static COLOROVERLIFEGRADIENTALPHAS: number;
        /**@internal */
        static COLOROVERLIFEGRADIENTCOLORS: number;
        /**@internal */
        static COLOROVERLIFEGRADIENTRANGES: number;
        /**@internal */
        static MAXCOLOROVERLIFEGRADIENTALPHAS: number;
        /**@internal */
        static MAXCOLOROVERLIFEGRADIENTCOLORS: number;
        /**@internal */
        static MAXCOLOROVERLIFEGRADIENTRANGES: number;
        /**@internal */
        static SOLSIZEGRADIENT: number;
        /**@internal */
        static SOLSIZEGRADIENTX: number;
        /**@internal */
        static SOLSIZEGRADIENTY: number;
        /**@internal */
        static SOLSizeGradientZ: number;
        /**@internal */
        static SOLSizeGradientMax: number;
        /**@internal */
        static SOLSIZEGRADIENTXMAX: number;
        /**@internal */
        static SOLSIZEGRADIENTYMAX: number;
        /**@internal */
        static SOLSizeGradientZMAX: number;
        /**@internal  Mul Shuriken Define*/
        static ROLANGULARVELOCITYCONST: number;
        /**@internal  Mul Shuriken Define*/
        static ROLANGULARVELOCITYCONSTSEPRARATE: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENT: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTX: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTY: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTZ: number;
        /**@internal  Mul Shuriken Define*/
        static ROLANGULARVELOCITYCONSTMAX: number;
        /**@internal  Mul Shuriken Define*/
        static ROLANGULARVELOCITYCONSTMAXSEPRARATE: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTMAX: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTXMAX: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTYMAX: number;
        /**@internal */
        static ROLANGULARVELOCITYGRADIENTZMAX: number;
        /**@internal  Mul Shuriken Define*/
        static ROLANGULARVELOCITYGRADIENTWMAX: number;
        /**@internal */
        static TEXTURESHEETANIMATIONCYCLES: number;
        /**@internal */
        static TEXTURESHEETANIMATIONSUBUVLENGTH: number;
        /**@internal */
        static TEXTURESHEETANIMATIONGRADIENTUVS: number;
        /**@internal */
        static TEXTURESHEETANIMATIONGRADIENTMAXUVS: number;
        /**
        * @en
        * Is it a multi macro mode
        * If this value is true, multi macro mode will be enabled, and the single compilation time of particles will be shorter, but the macro variables of particles will increase, and the number of compiled shaders will increase
        * If resignation is set to false, the multi macro mode of particles will be turned off, and the single compilation time of particles will be longer, but the number of compiled shaders will correspondingly decrease
        * @zh
        * 是否为多宏模式
        * 如果此值为true，那么将开启多宏模式，粒子的单个编译时间较短，但是粒子的宏变量会增多，编译的shader数量将会增加
        * 如果辞职为false，那么将关闭粒子的多宏模式，粒子的单个编译时间会变长，但是编译的shader数量会相应减少
        */
        static mulShaderDefineMode: boolean;
        /**
         * init
         */
        static __init__(): void;
    }
    /**
     *  @internal
     */
    class ShurikenParticleData {
        static startLifeTime: number;
        static startColor: Vector4;
        static startSize: Float32Array;
        static startRotation: Float32Array;
        static startUVInfo: Float32Array;
        constructor();
        /**
         * @internal
         */
        private static _getStartLifetimeFromGradient;
        /**
         * @internal
         */
        private static _randomInvertRoationArray;
        /**
         * @internal
         */
        private static _randomInvertRoation;
        /**
         * @internal
         */
        static create(particleSystem: ShurikenParticleSystem, particleRender: ShurikenParticleRenderer): void;
    }
    /**
     * @en ShurikenParticleInstanceSystem class is used to implement instanced particle rendering.
     * @zh ShurikenParticleInstanceSystem 类用于实现实例化粒子渲染。
     */
    class ShurikenParticleInstanceSystem extends ShurikenParticleSystem {
        private _instanceParticleVertexBuffer;
        private _instanceVertex;
        private _meshIndexCount;
        private _meshFloatCountPreVertex;
        /**
         * 每个粒子数据 float 个数
         */
        private _floatCountPerParticleData;
        /**
         * @ignore
         * @en creates an instance of ShurikenParticleInstanceSystem class.
         * @param render The ShurikenParticleRenderer associated with this particle system.
         * @zh 创建 ShurikenParticleInstanceSystem 类的实例。
         * @param render 与该粒子系统关联的 ShurikenParticleRenderer。
         */
        constructor(render: ShurikenParticleRenderer);
        /***
         * 重排 mesh vb
         */
        private _initMeshVertex;
        /**
         * @en Initialize buffer
         * @zh 初始化 buffer
         */
        _initBufferDatas(): void;
        protected _retireActiveParticles(): void;
        protected _freeRetiredParticles(): void;
        /**
         * @en Add a new particle to the particle system.
         * @param position The initial position of the particle.
         * @param direction The initial direction of the particle.
         * @param time The current simulation time.
         * @returns Whether the particle was successfully added.
         * @zh 向粒子系统添加一个新粒子。
         * @param position 粒子的初始位置。
         * @param direction 粒子的初始方向。
         * @param time 当前的模拟时间。
         * @returns 粒子是否成功添加。
         */
        addParticle(position: Vector3, direction: Vector3, time: number, elapsedTime: number): boolean;
        /**
         * @internal
         * @en Add new particles to the vertex buffer.
         * @zh 将新粒子添加到顶点缓冲区。
         */
        addNewParticlesToVertexBuffer(): void;
        /**
         * @en Update the render parameters for the particle system.
         * @param stage The current render context.
         * @zh 更新粒子系统的渲染参数。
         * @param stage 当前渲染上下文。
         */
        _updateRenderParams(stage: RenderContext3D): void;
        /**
         * @en Destroy the particle system and release resources.
         * @zh 销毁粒子系统并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en ShurikenParticleMaterial class is used to implement particle materials.
     * @zh ShurikenParticleMaterial 类用于实现粒子材质。
     */
    class ShurikenParticleMaterial extends Material {
        /**
         * @en Render mode for transparent blending.
         * @zh 渲染状态_透明混合。
         */
        static RENDERMODE_ALPHABLENDED: number;
        /**
         * @en Render mode for additive blending.
         * @zh 渲染状态_加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**@internal */
        static SHADERDEFINE_DIFFUSEMAP: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_TINTCOLOR: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_ADDTIVEFOG: ShaderDefine;
        /**@internal */
        static DIFFUSETEXTURE: number;
        /**@internal */
        static TINTCOLOR: number;
        /**@internal */
        static TILINGOFFSET: number;
        /**
         * @en Default material, modification prohibited.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: ShurikenParticleMaterial;
        /**
         * @internal
         */
        static __initDefine__(): void;
        /**
         * @en Color of the particle material.
         * @zh 粒子材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en Texture tiling and offset.
         * @zh 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * @en Diffuse texture.
         * @zh 漫反射贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @ignore
         * @en creates a new instance of the ShurikenParticleMaterial class.
         * @zh 创建ShurikenParticleMaterial类的新实例。
         */
        constructor();
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): ShurikenParticleMaterial;
        /**
         * @deprecated
         * 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @deprecated
         * 纹理平铺和偏移X分量。
         */
        get tilingOffsetX(): number;
        set tilingOffsetX(x: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Y分量。
         */
        get tilingOffsetY(): number;
        set tilingOffsetY(y: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Z分量。
         */
        get tilingOffsetZ(): number;
        set tilingOffsetZ(z: number);
        /**
         * @deprecated
         * 纹理平铺和偏移W分量。
         */
        get tilingOffsetW(): number;
        set tilingOffsetW(w: number);
        /**
         * @deprecated
         * @internal
         */
        get _TintColor(): Color;
        /**
         * @deprecated
         * @internal
         */
        set _TintColor(value: Color);
        /**
         * @deprecated
         * @internal
         */
        get _TintColorR(): number;
        /**
         * @deprecated
         * @internal
         */
        set _TintColorR(value: number);
        /**
         * @deprecated
         * @internal
         */
        get _TintColorG(): number;
        /**
         * @deprecated
         * @internal
         */
        set _TintColorG(value: number);
        /**
         * @deprecated
         * @internal
         */
        get _TintColorB(): number;
        /**
         * @deprecated
         * @internal
         */
        set _TintColorB(value: number);
        /**
         * @deprecated
         * @internal
         */
        get _TintColorA(): number;
        /**
         * @deprecated
         * @internal
         */
        set _TintColorA(value: number);
        /**
         * @deprecated
         * @internal
         */
        get _MainTex_ST(): Vector4;
        /**
         * @deprecated
         * @internal
         */
        set _MainTex_ST(value: Vector4);
        /**
         * @deprecated
         * @internal
         */
        get _MainTex_STX(): number;
        /**
         * @deprecated
         * @internal
         */
        set _MainTex_STX(x: number);
        /**
         * @deprecated
         * @internal
         */
        get _MainTex_STY(): number;
        /**
         * @deprecated
         * @internal
         */
        set _MainTex_STY(y: number);
        /**
         * @deprecated
         * @internal
         */
        get _MainTex_STZ(): number;
        /**
         * @deprecated
         * @internal
         */
        set _MainTex_STZ(z: number);
        /**
         * @deprecated
         * @internal
         */
        get _MainTex_STW(): number;
        /**
         * @deprecated
         * @internal
         */
        set _MainTex_STW(w: number);
        /**
         * @deprecated
         * 颜色R分量。
         */
        get colorR(): number;
        set colorR(value: number);
        /**
         * @deprecated
         * 颜色G分量。
         */
        get colorG(): number;
        set colorG(value: number);
        /**
         * @deprecated
         * 颜色B分量。
         */
        get colorB(): number;
        set colorB(value: number);
        /**
         * @deprecated
         * 颜色Z分量。
         */
        get colorA(): number;
        set colorA(value: number);
    }
    /**
     * @en The `ShurikenParticleRenderer` class is used to create 3D particle renderers.
     * @zh `ShurikenParticleRenderer` 类用于创建3D粒子渲染器。
     */
    class ShurikenParticleRenderer extends BaseRender {
        /**
         * @en Gravity value.
         * @zh 重力值。
         */
        static gravity: Vector3;
        private _finalGravity;
        private _dragConstant;
        private _renderMode;
        private _mesh;
        /**@internal */
        _particleSystem: ShurikenParticleSystem;
        /**
         * @en Scale of camera speed in stretched billboard mode (currently not supported).
         * @zh 拉伸广告牌模式摄像机速度缩放（暂不支持）。
         */
        stretchedBillboardCameraSpeedScale: number;
        /**
         * @en Speed scale in stretched billboard mode.
         * @zh 拉伸广告牌模式速度缩放。
         */
        stretchedBillboardSpeedScale: number;
        /**
         * @en Length scale in stretched billboard mode.
         * @zh 拉伸广告牌模式长度缩放。
         */
        stretchedBillboardLengthScale: number;
        /**
         * @en The particle management system.
         * @zh 粒子管理系统。
         */
        get particleSystem(): ShurikenParticleSystem;
        /**
         * @en The render mode. 0: BILLBOARD, 1: STRETCHEDBILLBOARD, 2: HORIZONTALBILLBOARD, 3: VERTICALBILLBOARD, 4: MESH.
         * @zh 渲染模式。0：粒子始终面向摄像机。、1：粒子面向摄像机，但会应用各种缩放、2：粒子平面与 XZ“地板”平面平行、3：粒子在世界 Y 轴上直立，但转向面向摄像机、4：从 3D 网格而非从纹理渲染粒子。。
         */
        get renderMode(): number;
        set renderMode(value: number);
        /**
         * @en The Mesh used in mesh render mode. Effective when renderMode is 4.
         * @zh 网格渲染模式所使用的Mesh。renderMode为4时生效。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        /**
         * @ignore
         * @en Creates a new instance of ShurikenParticleRender class.
         * @zh 创建ShurikenParticleRender类的新实例。
         */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        protected _getcommonUniformMap(): Array<string>;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @internal
         */
        _calculateBoundingBox(): void;
        /**
         * @internal
         */
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        /**
         * @internal
         */
        _renderUpdate(context: IRenderContext3D): void;
        /**
         * @en Update the render state.
         * @param context The render context.
         * @zh 更新渲染状态。
         * @param context 渲染上下文。
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en The bounding box. Read-only, not allowed to modify its value.
         * @zh 包围盒。只读，不允许修改其值。
         */
        get bounds(): Bounds;
        /**
         * @internal
         */
        _cloneTo(dest: ShurikenParticleRenderer): void;
        protected _onDestroy(): void;
        protected _statAdd(): void;
        protected _statRemove(): void;
    }
    /**
     * @en The ShurikenParticleSystem class is used to create 3D particle data templates.
     * @zh ShurikenParticleSystem 类用于创建3D粒子数据模板。
     */
    class ShurikenParticleSystem extends GeometryElement implements IClone {
        /** @internal 0:Burst,1:预留,2:StartDelay,3:StartColor,4:StartSize,5:StartRotation,6:randomizeRotationDirection,7:StartLifetime,8:StartSpeed,9:VelocityOverLifetime,10:ColorOverLifetime,11:SizeOverLifetime,12:RotationOverLifetime,13-15:TextureSheetAnimation,16-17:Shape*/
        static _RANDOMOFFSET: Uint32Array;
        protected static halfKSqrtOf2: number;
        protected static g: number;
        /** @internal */
        static _maxElapsedTime: number;
        protected static _type: number;
        /** @internal */
        _bounds: Bounds;
        /**
         * @internal
         * @en Gravity effect offset, used to calculate the world bounding box
         * @zh 重力影响偏移, 用于计算世界包围盒
         */
        _gravityOffset: Vector2;
        /** @internal */
        _customBounds: Bounds;
        /** @internal */
        _useCustomBounds: boolean;
        protected _owner: Sprite3D;
        protected _ownerRender: ShurikenParticleRenderer;
        protected _vertices: Float32Array;
        protected _floatCountPerVertex: number;
        protected _startLifeTimeIndex: number;
        protected _timeIndex: number;
        protected _simulationUV_Index: number;
        protected _simulateUpdate: boolean;
        protected _firstActiveElement: number;
        protected _firstNewElement: number;
        protected _firstFreeElement: number;
        protected _firstRetiredElement: number;
        protected _drawCounter: number;
        /** 最大粒子数量*/
        protected _bufferMaxParticles: number;
        protected _emission: Emission;
        protected _shape: BaseShape;
        protected _isEmitting: boolean;
        protected _isPlaying: boolean;
        protected _isPaused: boolean;
        protected _playStartDelay: number;
        /** 发射的累计时间。*/
        protected _frameRateTime: number;
        /** 一次循环内的累计时间。*/
        protected _emissionTime: number;
        /** 用来计算时间是否超过发射延迟时间*/
        protected _totalDelayTime: number;
        /** 上次发射到当前的移动总距离，每次根据距离发射粒子后清空 */
        protected _emissionDistance: number;
        protected _emissionLastPosition: Vector3;
        protected _burstsIndex: number;
        protected _velocityOverLifetime: VelocityOverLifetime;
        protected _colorOverLifetime: ColorOverLifetime;
        protected _sizeOverLifetime: SizeOverLifetime;
        protected _rotationOverLifetime: RotationOverLifetime;
        protected _textureSheetAnimation: TextureSheetAnimation;
        protected _startLifetimeType: number;
        protected _startLifetimeConstant: number;
        protected _startLifeTimeGradient: GradientDataNumber;
        protected _startLifetimeConstantMin: number;
        protected _startLifetimeConstantMax: number;
        protected _startLifeTimeGradientMin: GradientDataNumber;
        protected _startLifeTimeGradientMax: GradientDataNumber;
        protected _maxStartLifetime: number;
        protected _uvLength: Vector2;
        protected _vertexStride: number;
        protected _indexStride: number;
        protected _vertexBuffer: VertexBuffer3D;
        protected _indexBuffer: IndexBuffer3D;
        protected _bufferState: BufferState;
        protected _updateMask: number;
        /** 多宏模式 */
        protected _mulDefMode: boolean;
        /**@internal */
        _currentTime: number;
        /**@internal */
        _startUpdateLoopCount: number;
        /**@internal */
        _rand: Rand;
        /**@internal */
        _randomSeeds: Uint32Array;
        /**
         * @en Total duration of particle system runtime, in seconds.
         * @zh 粒子运行的总时长，单位为秒。
         */
        duration: number;
        /**
         * @en Whether the particle system is looping.
         * @zh 是否循环。
         */
        looping: boolean;
        /**
         * @en Whether to prewarm the particle system. Currently not supported.
         * @zh 是否预热。暂不支持。
         */
        prewarm: boolean;
        /**
         * @en Start delay type. 0 for constant mode, 1 for random between two constants. Cannot be used with prewarm.
         * @zh 开始延迟类型，0为常量模式，1为随机双常量模式。不能和prewarm一起使用。
         */
        startDelayType: number;
        /**
         * @en Start play delay. Cannot be used with prewarm.
         * @zh 开始播放延迟。不能和prewarm一起使用。
         */
        startDelay: number;
        /**
         * @en Minimum start play delay. Cannot be used with prewarm.
         * @zh 开始播放最小延迟。不能和prewarm一起使用。
         */
        startDelayMin: number;
        /**
         * @en Maximum start play delay. Cannot be used with prewarm.
         * @zh 开始播放最大延迟。不能和prewarm一起使用。
         */
        startDelayMax: number;
        /**
         * @en Start speed mode. 0 for constant speed, 2 for random between two constants. Modes 1 and 3 are missing.
         * @zh 开始速度模式。0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式。
         */
        startSpeedType: number;
        /**
         * @en Start speed for mode 0.
         * @zh 开始速度，0模式。
         */
        startSpeedConstant: number;
        /**
         * @en Minimum start speed for mode 1.
         * @zh 最小开始速度，1模式。
         */
        startSpeedConstantMin: number;
        /**
         * @en Maximum start speed for mode 1.
         * @zh 最大开始速度，1模式。
         */
        startSpeedConstantMax: number;
        /**
         * @en Drag type. 0 for constant speed, 2 for random between two constants.
         * @zh 阻力模式。0为恒定速度，2为两个恒定速度的随机插值。
         */
        dragType: number;
        /**
         * @en Constant drag for mode 0.
         * @zh 恒定阻力，0模式。
         */
        dragConstant: number;
        /**
         * @en Minimum drag speed for mode 1.
         * @zh 最小阻力速度，1模式。
         */
        dragSpeedConstantMin: number;
        /**
         * @en Maximum drag speed for mode 1.
         * @zh 最大阻力速度，1模式。
         */
        dragSpeedConstantMax: number;
        /**
         * @en Whether the start size is in 3D mode.
         * @zh 开始尺寸是否为3D模式。
         */
        threeDStartSize: boolean;
        /**
         * @en Start size mode. 0 for constant size, 2 for random between two constants. Modes 1 and 3 and corresponding 3D modes are missing.
         * @zh 开始尺寸模式。0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的两种3D模式。
         */
        startSizeType: number;
        /**
         * @en Start size for mode 0.
         * @zh 开始尺寸，0模式。
         */
        startSizeConstant: number;
        /**
         * @en Start 3D size for mode 0.
         * @zh 开始三维尺寸，0模式。
         */
        startSizeConstantSeparate: Vector3;
        /**
         * @en Minimum start size for mode 2.
         * @zh 最小开始尺寸，2模式。
         */
        startSizeConstantMin: number;
        /**
         * @en Maximum start size for mode 2.
         * @zh 最大开始尺寸，2模式。
         */
        startSizeConstantMax: number;
        /**
         * @en Minimum 3D start size for mode 2.
         * @zh 最小三维开始尺寸，2模式。
         */
        startSizeConstantMinSeparate: Vector3;
        /**
         * @en Maximum 3D start size for mode 2.
         * @zh 最大三维开始尺寸，2模式。
         */
        startSizeConstantMaxSeparate: Vector3;
        /**
         * @en Whether to use 3D start rotation.
         * @zh 是否使用3D开始旋转。
         */
        threeDStartRotation: boolean;
        /**
         * @en Start rotation mode. 0 for constant rotation, 2 for random between two constants. Two modes and corresponding four 3D modes are missing.
         * @zh 开始旋转模式。0为恒定旋转，2为两个恒定旋转的随机插值。缺少2种模式和对应的四种3D模式。
         */
        startRotationType: number;
        /**
         * @en Start rotation for mode 0.
         * @zh 开始旋转，0模式。
         */
        startRotationConstant: number;
        /**
         * @en Start 3D rotation for mode 0.
         * @zh 开始三维旋转，0模式。
         */
        startRotationConstantSeparate: Vector3;
        /**
         * @en Minimum start rotation for mode 1.
         * @zh 最小开始旋转，1模式。
         */
        startRotationConstantMin: number;
        /**
         * @en Maximum start rotation for mode 1.
         * @zh 最大开始旋转，1模式。
         */
        startRotationConstantMax: number;
        /**
         * @en Minimum start 3D rotation for mode 1.
         * @zh 最小开始三维旋转，1模式。
         */
        startRotationConstantMinSeparate: Vector3;
        /**
         * @en Maximum start 3D rotation for mode 1.
         * @zh 最大开始三维旋转，1模式。
         */
        startRotationConstantMaxSeparate: Vector3;
        /**
         * @en Random rotation direction, range from 0.0 to 1.0.
         * @zh 随机旋转方向，范围为0.0到1.0。
         */
        randomizeRotationDirection: number;
        /**
         * @en Start color mode. 0 for constant color, 2 for random between two constant colors. Two modes are missing.
         * @zh 开始颜色模式。0为恒定颜色，2为两个恒定颜色的随机插值。缺少2种模式。
         */
        startColorType: number;
        /**
         * @en Start color for mode 0.
         * @zh 开始颜色，0模式。
         */
        startColorConstant: Vector4;
        /**
         * @en Minimum start color for mode 1.
         * @zh 最小开始颜色，1模式。
         */
        startColorConstantMin: Vector4;
        /**
         * @en Maximum start color for mode 1.
         * @zh 最大开始颜色，1模式。
         */
        startColorConstantMax: Vector4;
        /**
         * @en Gravity modifier.
         * @zh 重力敏感度。
         */
        gravityModifier: number;
        /**
         * @en Simulation space. 0 for World, 1 for Local. Custom is currently not supported.
         * @zh 模拟器空间。0为World，1为Local。暂不支持Custom。
         */
        simulationSpace: number;
        /**
         * @en Playback speed of particles.
         * @zh 粒子的播放速度。
         */
        simulationSpeed: number;
        /**
         * @en Scale mode. 0 for Hierarchy (world), 1 for Local, 2 for World.
         * @zh 缩放模式。0为Hierarchy (world)，1为Local，2为World。
         */
        scaleMode: number;
        /**
         * @en Whether to play automatically when activated.
         * @zh 激活时是否自动播放。
         */
        playOnAwake: boolean;
        /**
         * @en Random seed. Note: Effective when set before play().
         * @zh 随机种子。注：在play()之前设置有效。
         */
        randomSeed: Uint32Array;
        /**
         * @en Whether to use a random seed.
         * @zh 是否使用随机种子。
         */
        autoRandomSeed: boolean;
        /**
         * @en Whether it's in performance mode. In performance mode, particle release will be delayed.
         * @zh 是否为性能模式。性能模式下会延迟粒子释放。
         */
        isPerformanceMode: boolean;
        /**
         * @en Maximum number of particles
         * @zh 最大粒子数。
         */
        get maxParticles(): number;
        set maxParticles(value: number);
        /**
         * @en Emission.
         * @zh 发射器。
         */
        get emission(): Emission;
        /**
         * @en Number of alive particles
         * @zh 粒子存活个数。
         */
        get aliveParticleCount(): number;
        /**
         * @en Accumulated time within one cycle.
         * @zh 一次循环内的累计时间。
         */
        get emissionTime(): number;
        /**
         * @en Particle shape
         * @zh 粒子形状。
         */
        get shape(): BaseShape;
        set shape(value: BaseShape);
        /**
         * @en If the particle system is still alive.
         * @zh 粒子系统是否仍然存活。
         */
        get isAlive(): boolean;
        /**
         * @en If the particle system is currently emitting particles.
         * @zh 粒子系统是否正在发射粒子。
         */
        get isEmitting(): boolean;
        /**
         * @en If the particle system is currently playing.
         * @zh 粒子系统是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * @en If the particle system is currently paused.
         * @zh 粒子系统是否已暂停。
         */
        get isPaused(): boolean;
        /**
         * @en The lifectime mode of particles. 0: Constant, 1: Gradient, 2: Random Between Two Constants, 3: Random Between Two Gradients.
         * @zh 粒子的生命周期模式。0: 固定时间, 1: 渐变时间, 2: 两个固定值之间的随机插值, 3: 两个渐变时间的随机插值。
         */
        get startLifetimeType(): number;
        set startLifetimeType(value: number);
        /**
         * @en The lifecycle mode of particles: Constant(0), unit is seconds.
         * @zh 粒子生命周期模式：固定时间(模式0)，单位为秒。
         */
        get startLifetimeConstant(): number;
        set startLifetimeConstant(value: number);
        /**
         * @en The lifecycle mode of particles: Gradient(1), unit is seconds.
         * @zh 粒子生命周期模式：渐变时间(模式1)，单位为秒。
         */
        get startLifeTimeGradient(): GradientDataNumber;
        set startLifeTimeGradient(value: GradientDataNumber);
        /**
         * @en The minimum particle lifecycle, the lifecycle mode of particles: Random Between Two Constants（2）, unit is seconds.
         * @zh 最小粒子生命周期，粒子生命周期模式: 两个固定值之间的随机插值(模式2)，单位为秒。
         */
        get startLifetimeConstantMin(): number;
        set startLifetimeConstantMin(value: number);
        /**
         * @en The maximum particle lifecycle, the lifecycle mode of particles: Random Between Two Constants（2）, unit is seconds.
         * @zh 最大粒子生命周期，粒子生命周期模式: 两个固定值之间的随机插值(模式2)，单位为秒。
         */
        get startLifetimeConstantMax(): number;
        set startLifetimeConstantMax(value: number);
        /**
         * @en Minimum value of gradient time, the lifecycle mode of particles: Random Between Two Gradients（3）, unit is seconds.
         * @zh 渐变时间的最小值，粒子生命周期模式: 两个渐变时间的随机插值(模式3)，单位为秒。
         */
        get startLifeTimeGradientMin(): GradientDataNumber;
        set startLifeTimeGradientMin(value: GradientDataNumber);
        /**
         * @en Maximum value of gradient time, the lifecycle mode of particles: Random Between Two Gradients（3）, unit is seconds.
         * @zh 渐变时间的最大值，粒子生命周期模式: 两个渐变时间的随机插值(模式3)，单位为秒。
         */
        get startLifeTimeGradientMax(): GradientDataNumber;
        set startLifeTimeGradientMax(value: GradientDataNumber);
        /**
         * @en The velocity over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期速度。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get velocityOverLifetime(): VelocityOverLifetime;
        set velocityOverLifetime(value: VelocityOverLifetime);
        /**
         * @en The color over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期颜色。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get colorOverLifetime(): ColorOverLifetime;
        set colorOverLifetime(value: ColorOverLifetime);
        /**
         * @en The size over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期尺寸。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get sizeOverLifetime(): SizeOverLifetime;
        set sizeOverLifetime(value: SizeOverLifetime);
        /**
         * @en The rotation over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期旋转。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get rotationOverLifetime(): RotationOverLifetime;
        set rotationOverLifetime(value: RotationOverLifetime);
        /**
         * @en The texture sheet animation over lifetime. Note: If you modify certain properties of this value, you need to reassign this property for it to take effect.
         * @zh 生命周期纹理动画。注意：如修改该值的某些属性，需重新赋值此属性才可生效。
         */
        get textureSheetAnimation(): TextureSheetAnimation;
        set textureSheetAnimation(value: TextureSheetAnimation);
        /**
         * @en Creates a new instance of the ParticleSystem class.
         * @param render The ShurikenParticleRenderer associated with this particle system.
         * @param meshTopology The topology used by the mesh, default is MeshTopology.Triangles.
         * @param drawType The draw type used for rendering, default is DrawType.DrawElement.
         * @zh 创建ShuriknParticleSystem类的新实例。
         * @param render 与该粒子系统关联的 ShurikenParticleRenderer。
         * @param meshTopology 网格使用的拓扑结构，默认为 MeshTopology.Triangles。
         * @param drawType 用于渲染的绘制类型，默认为 DrawType.DrawElement。
         * @blueprintIgnore
         */
        constructor(render: ShurikenParticleRenderer, meshTopology?: MeshTopology, drawType?: DrawType);
        /**
         * @internal
         */
        _getVertexBuffer(index?: number): VertexBuffer3D;
        /**
         * @internal
         */
        _getIndexBuffer(): IndexBuffer3D;
        /**
         * @internal
         */
        _generateBounds(): void;
        /**
         * @en Custom bounds
         * @zh 自定义 包围盒
         */
        get customBounds(): Bounds;
        set customBounds(value: Bounds);
        /**
         * @internal
         */
        _simulationSupported(): boolean;
        /**
         * 计算粒子更新时间
         */
        protected _updateEmission(): void;
        /**
         * 传入粒子间隔时间，更新粒子状态
         */
        protected _updateParticles(elapsedTime: number): void;
        protected _updateParticlesSimulationRestart(time: number): void;
        protected _retireActiveParticles(): void;
        protected _freeRetiredParticles(): void;
        /**
         * @en add burst particle count.
         * @zh 增加爆炸粒子数量
         */
        protected _burst(fromTime: number, toTime: number): number;
        protected _advanceTime(elapsedTime: number, emitTime: number): void;
        /**
         * @internal
         */
        protected _advanceDistance(emitTime: number, elapsedTime: number): void;
        /**
         * @internal
         */
        _initBufferDatas(): void;
        /**
         * @internal
         */
        destroy(): void;
        /**
         * @en Emits a particle.
         * @zh 发射一个粒子。
         */
        emit(time: number, elapsedTime: number): boolean;
        /**
         * @en Add a new particle to the particle system.
         * @param position The initial position of the particle.
         * @param direction The initial direction of the particle.
         * @param time The current simulation time.
         * @returns Whether the particle was successfully added.
         * @zh 向粒子系统添加一个新粒子。
         * @param position 粒子的初始位置。
         * @param direction 粒子的初始方向。
         * @param time 当前的模拟时间。
         * @returns 粒子是否成功添加。
         */
        addParticle(position: Vector3, direction: Vector3, time: number, elapsedTime: number): boolean;
        /**
         * @en Add new particles to the vertex buffer.
         * @zh 将新粒子添加到顶点缓冲区。
         */
        addNewParticlesToVertexBuffer(): void;
        _getType(): number;
        /**
         * @internal
         */
        _prepareRender(state: RenderContext3D): boolean;
        /**
         * @internal
         */
        _updateRenderParams(state: RenderContext3D): void;
        /**
         * @en Start emitting particles
         * @zh 开始发射粒子。
         */
        play(): void;
        /**
         * @en Pause emitting particles
         * @zh 暂停发射粒子。
         */
        pause(): void;
        /**
         * @en Advance the particle simulation by a specified time and pause playback.
         * @param time The time to advance the simulation. If restart is true, the particle playback time will be reset to zero before updating progress.
         * @param restart Whether to reset the playback state. Default is true.
         * @zh 通过指定时间增加粒子播放进度，并暂停播放。
         * @param time 进度时间。如果restart为true，粒子播放时间会归零后再更新进度。
         * @param restart 是否重置播放状态。默认为true。
         */
        simulate(time: number, restart?: boolean): void;
        /**
         * @en Stop emitting particles.
         * @zh 停止发射粒子。
         */
        stop(): void;
        /**
         * @en Clones to a target object.
         * @param destObject The target object to clone to.
         * @zh 克隆到目标对象。
         * @param destObject 要克隆到的目标对象。
         */
        cloneTo(destObject: ShurikenParticleSystem): void;
        /**
         * @en Clone.
         * @returns Clone copy.
         * @zh 克隆。
         * @returns 克隆副本。
         */
        clone(): ShurikenParticleSystem;
    }
    /**
     * @internal
     */
    class VertexShuriKenParticle {
        static PARTICLE_DIRECTIONTIME: number;
        static PARTICLE_POSITION0: number;
        static PARTICLE_COLOR0: number;
        static PARTICLE_TEXTURECOORDINATE0: number;
        static PARTICLE_SHAPEPOSITIONSTARTLIFETIME: number;
        static PARTICLE_CORNERTEXTURECOORDINATE0: number;
        static PARTICLE_STARTCOLOR0: number;
        static PARTICLE_ENDCOLOR0: number;
        static PARTICLE_STARTSIZE: number;
        static PARTICLE_STARTROTATION: number;
        static PARTICLE_STARTSPEED: number;
        static PARTICLE_RANDOM0: number;
        static PARTICLE_RANDOM1: number;
        static PARTICLE_SIMULATIONWORLDPOSTION: number;
        static PARTICLE_SIMULATIONWORLDROTATION: number;
        static PARTICLE_SIMULATIONUV: number;
        constructor();
    }
    /**
     * @internal
     * <code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
     */
    class VertexShurikenParticleBillboard extends VertexShuriKenParticle {
        /**@internal */
        private static _vertexDeclaration;
        static get vertexDeclaration(): VertexDeclaration;
        private static _vertexInstanceMeshDeclaration;
        static get vertexInstanceMeshDeclaration(): VertexDeclaration;
        private static _vertexInstanceParticleDeclaration;
        static get vertexInstanceParticleDeclaration(): VertexDeclaration;
        private static _billboardVertexArray;
        static get billboardVertexArray(): Float32Array;
        private static _billboardIndexArray;
        static get billboardIndexArray(): Uint16Array;
        static set billboardIndexArray(value: Uint16Array);
        /**
          * @internal
          */
        static __init__(): void;
        /**@internal */
        private _cornerTextureCoordinate;
        /**@internal */
        private _positionStartLifeTime;
        /**@internal */
        private _velocity;
        /**@internal */
        private _startColor;
        /**@internal */
        private _startSize;
        /**@internal */
        private _startRotation0;
        /**@internal */
        private _startRotation1;
        /**@internal */
        private _startRotation2;
        /**@internal */
        private _startLifeTime;
        /**@internal */
        private _time;
        /**@internal */
        private _startSpeed;
        /**@internal */
        private _randoms0;
        /**@internal */
        private _randoms1;
        /**@internal */
        private _simulationWorldPostion;
        get cornerTextureCoordinate(): Vector4;
        get positionStartLifeTime(): Vector4;
        get velocity(): Vector3;
        get startColor(): Vector4;
        get startSize(): Vector3;
        get startRotation0(): Vector3;
        get startRotation1(): Vector3;
        get startRotation2(): Vector3;
        get startLifeTime(): number;
        get time(): number;
        get startSpeed(): number;
        get random0(): Vector4;
        get random1(): Vector4;
        get simulationWorldPostion(): Vector3;
        constructor(cornerTextureCoordinate: Vector4, positionStartLifeTime: Vector4, velocity: Vector3, startColor: Vector4, startSize: Vector3, startRotation0: Vector3, startRotation1: Vector3, startRotation2: Vector3, ageAddScale: number, time: number, startSpeed: number, randoms0: Vector4, randoms1: Vector4, simulationWorldPostion: Vector3);
    }
    /**
     * @internal
     * <code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
     */
    class VertexShurikenParticleMesh extends VertexShuriKenParticle {
        /**@internal */
        private static _vertexDeclaration;
        /**
      * @internal
      */
        static __init__(): void;
        static get vertexDeclaration(): VertexDeclaration;
        private static _vertexInstanceMeshDeclaration;
        static get vertexInstanceMeshDeclaration(): VertexDeclaration;
        private static _vertexInstanceParticleDeclaration;
        static get vertexInstanceParticleDeclaration(): VertexDeclaration;
        /**@internal */
        private _cornerTextureCoordinate;
        /**@internal */
        private _positionStartLifeTime;
        /**@internal */
        private _velocity;
        /**@internal */
        private _startColor;
        /**@internal */
        private _startSize;
        /**@internal */
        private _startRotation0;
        /**@internal */
        private _startRotation1;
        /**@internal */
        private _startRotation2;
        /**@internal */
        private _startLifeTime;
        /**@internal */
        private _time;
        /**@internal */
        private _startSpeed;
        /**@internal */
        private _randoms0;
        /**@internal */
        private _randoms1;
        /**@internal */
        private _simulationWorldPostion;
        get cornerTextureCoordinate(): Vector4;
        get position(): Vector4;
        get velocity(): Vector3;
        get startColor(): Vector4;
        get startSize(): Vector3;
        get startRotation0(): Vector3;
        get startRotation1(): Vector3;
        get startRotation2(): Vector3;
        get startLifeTime(): number;
        get time(): number;
        get startSpeed(): number;
        get random0(): Vector4;
        get random1(): Vector4;
        get simulationWorldPostion(): Vector3;
        constructor(cornerTextureCoordinate: Vector4, positionStartLifeTime: Vector4, velocity: Vector3, startColor: Vector4, startSize: Vector3, startRotation0: Vector3, startRotation1: Vector3, startRotation2: Vector3, ageAddScale: number, time: number, startSpeed: number, randoms0: Vector4, randoms1: Vector4, simulationWorldPostion: Vector3);
    }
    /**
     * @deprecated
     * @en 2D rectangular collision body
     * @zh 2D矩形碰撞体
     */
    class BoxCollider extends StaticCollider {
        /**@internal 矩形宽度*/
        protected _width: number;
        /**@internal 矩形高度*/
        private _height;
        /**
         * @en Rectangle width of collision body
         * @zh 碰撞体矩形宽度
         */
        get width(): number;
        set width(value: number);
        /**
         * @en Rectangle height of collision body
         * @zh 碰撞体矩形高度
         */
        get height(): number;
        set height(value: number);
        /**
        * @en Constructor method
        * @zh 构造方法
        */
        constructor();
        /**
         * @internal
         * @override
         * @param shape
         */
        protected _setShapeData(shape: any): void;
    }
    /**
     * @deprecated
     * @en 2D chain collider
     * @zh 2D 链形碰撞体
     */
    class ChainCollider extends StaticCollider {
        /**
         * @internal
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        private _points;
        /**@internal 顶点数据*/
        private _datas;
        /**@internal 是否是闭环，注意不要有自相交的链接形状，它可能不能正常工作*/
        private _loop;
        /**
        * @deprecated
        * @en A collection of points separated by commas, format: x, y, x, y, ...
        * @zh 用逗号隔开的点的集合，格式：x,y,x,y ...
        */
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data x,y,x,y ...
         * @zh 顶点数据 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        /**
         * @en Whether it is a closed loop. Ensure there are no self-intersecting link shapes, as they may not function properly.
         * @zh 是否是闭环，注意不要有自相交的链接形状，否则它可能不能正常工作
         */
        get loop(): boolean;
        set loop(value: boolean);
        constructor();
        /**
         * @internal
         * @override
         */
        protected _setShapeData(shape: any): void;
        /**
         * @en Called after being added to the node, different from Awake, onAdded will be called even if the node is not active.
         * @zh 被添加到节点后调用，和 Awake 不同的是即使节点未激活 onAdded 也会调用。
         */
        onAdded(): void;
    }
    /**
     * @deprecated
     * @en 2D CircleCollider
     * @zh 2D圆形碰撞体
     */
    class CircleCollider extends StaticCollider {
        /**@internal 圆形半径，必须为正数*/
        private _radius;
        /**
         * @en Circular radius, must be a positive number
         * @zh 圆形半径，必须为正数
         */
        get radius(): number;
        set radius(value: number);
        constructor();
        /**
         * @internal 设置碰撞体数据
         * @param shape
         */
        protected _setShapeData(shape: any): void;
    }
    /**
     * @en 2DPhysics Collider base class
     * @zh 2D物理碰撞体基类
     */
    class ColliderBase extends Component {
        /**
         * @internal
         * @zh 碰撞体根据自定义的质量、质心、惯性张量计算质量（只在未开启自动质量计算的时候才使用）
         */
        protected _massData: any;
        /**
         * @internal
         * @zh 是否在激活状态
         */
        protected _isAwake: boolean;
        /**
         * @en The type of rigidbody, supports three types: dynamic and kinematic, default is dynamic.
         * dynamic: Dynamic type, affected by gravity.
         * kinematic: Kinematic type, not affected by gravity, can be moved by applying acceleration or force.
         * @zh 刚体类型，支持两种类型：dynamic 和 kinematic，默认为 dynamic 类型。
         * dynamic：动态类型，受重力影响。
         * kinematic：运动类型，不受重力影响，可以通过施加速度或者力的方式使其运动。
         */
        protected _type: RigidBody2DType;
        /**
         * @internal
         * @en Is the rigid body mass calculated based on the collider
         * @zh 是否根据碰撞体计算刚体质量
         */
        protected _useAutoMass: boolean;
        /**
         * @internal
         * @en The rigid body mass. (Only valid when not using automatic mass calculation)
         * @zh 刚体质量（只在未开启自动质量计算时才有效）
         */
        protected _mass: number;
        /**
         * @en The rigid body inertia tensor. (Only valid when not using automatic mass calculation)
         * @zh 刚体惯性张量（只在未开启自动质量计算时才有效）
        */
        protected _inertia: number;
        /**
         * @en The center of mass of the rigid body. (Only valid when not using automatic mass calculation)
         * @zh 刚体质心位置（只在未开启自动质量计算时才有效）
         */
        protected _centerOfMass: Vector2;
        /**
         * @internal
         * @zh 当前碰撞体所属场景的2D物理管理器
         */
        protected _physics2DManager: Physics2DWorldManager;
        /**
         * @internal
         * @zh 碰撞体的结构定义
         */
        protected _bodyDef: RigidBody2DInfo;
        /**
         * @internal
         * @zh 碰撞体box2D的结构定义
         */
        private _box2DBodyDef;
        /**
         * @internal
         * @zh 碰撞体box2D的对象
         */
        protected _box2DBody: any;
        /**@internal 相对节点的x轴偏移*/
        private _x;
        /**@internal 相对节点的y轴偏移*/
        private _y;
        /**
         * @en label
         * @zh 标签
         */
        label: string;
        readonly owner: Sprite;
        private _isConnectedJoint;
        /**
         * @zh 是否连接到关节
         * @en weather connect to joint
         */
        get isConnectedJoint(): boolean;
        set isConnectedJoint(value: boolean);
        /**
         * @en The Rigidbody's resistance to changes in angular velocity (rotation).(Only valid when not using automatic mass calculation)
         * @zh 刚体惯性张量（只在未开启自动质量计算时才有效）
         */
        get inertia(): number;
        set inertia(value: number);
        /**
         * @en The center of mass of the rigid body. (Only valid when not using automatic mass calculation)
         * @zh 刚体质心（只在未开启自动质量计算时才有效）
         */
        get centerOfMass(): IV2 | Vector2;
        set centerOfMass(value: IV2 | Vector2);
        /**
         * @en The rigid body mass. (Only valid when not using automatic mass calculation)
         * @zh 刚体质量（只在未开启自动质量计算时才有效）
         */
        get mass(): number;
        set mass(value: number);
        /**
         * @en Is the rigid body mass calculated based on the collider
         * @zh 是否根据碰撞体计算刚体质量
         */
        get useAutoMass(): boolean;
        set useAutoMass(value: boolean);
        /**
         * @zh 当前碰撞体在物理世界中是否在激活状态
         */
        get isAwake(): boolean;
        set isAwake(value: boolean);
        /**
         * @internal
         * 获得节点的全局缩放X
         */
        protected get scaleX(): number;
        /**
         * @internal
         * 获得节点的全局缩放Y
         */
        protected get scaleY(): number;
        /**@internal 创建获得相对于描点x的偏移 */
        protected get pivotoffx(): number;
        /**@internal 创建获得相对于描点y的偏移 */
        protected get pivotoffy(): number;
        /**
         * @deprecated
         * @en The x-axis offset relative to the node.
         * @zh 相对于节点的 x 轴偏移。
         */
        get x(): number;
        set x(value: number);
        /**
         * @deprecated
         * @en The y-axis offset relative to the node.
         * @zh 相对于节点的 y 轴偏移。
         */
        get y(): number;
        set y(value: number);
        /**
         * @en constructor method
         * @zh 构造方法
         */
        constructor();
        /**
         * @zh 获取对应box2D的碰撞体
         * @returns
         */
        getBox2DBody(): any;
        /**
         * @en Get the inertia of the rigid body.
         * @zh 获得刚体的惯性张量。
         * @returns
         */
        getInertia(): number;
        /**@internal*/
        protected _onEnable(): void;
        protected _getPhysicsManager(): void;
        /**
         * @en Get the world coordinates relative to the body.
         * @param x The x-coordinate in pixels.
         * @param y The y-coordinate in pixels.
         * @zh 获得相对于 body 的世界坐标。
         * @param x 像素坐标的 x 值。
         * @param y 像素坐标的 y 值。
         */
        getWorldPoint(x: number, y: number): Readonly<Point>;
        /**@internal 通知rigidBody 更新shape 属性值 */
        protected _needupdataShapeAttribute(flag?: number): void;
        /**@internal*/
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**@deprecated 兼容参数  */
        protected _box2DFilter: any;
        /**@deprecated 兼容参数 */
        protected _box2DShapeDef: any;
        /**@deprecated 兼容参数 */
        protected _shapeDef: Box2DShapeDef;
        /**@deprecated 兼容参数 */
        protected _box2DShape: any;
        /**@internal @deprecated shape类型标记*/
        protected _shapeType: EPhysics2DShape;
        /**@deprecated 兼容参数 */
        protected _rigidbody: RigidBody;
        /**@internal @deprecated 已废弃，是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应*/
        private _isSensor;
        /**@internal @deprecated 已废弃，密度值，值可以为零或者是正数，建议使用相似的密度，这样做可以改善堆叠稳定性，默认值为10*/
        private _density;
        /**@internal @deprecated 已废弃，摩擦力，取值范围0-1，值越大，摩擦越大，默认值为0.2*/
        private _friction;
        /**@internal @deprecated 已废弃，弹性系数，取值范围0-1，值越大，弹性越大，默认值为0*/
        private _restitution;
        /**
         * @deprecated This is only for compatibility. In subsequent versions, you can set whether the shape is a sensor.
         * @en Whether the object is a sensor. A sensor can trigger collision events but does not produce collision responses.
         * @deprecated 这个只做兼容，后续版本在shape中设置是否为传感器
         * @zh 是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应
         */
        get isSensor(): boolean;
        set isSensor(value: boolean);
        /**
         * @deprecated This is only for compatibility, and subsequent versions will set the density value in shape.
         * @en The density value. The value can be zero or a positive number. It is recommended to use similar densities to improve stacking stability. The default value is 10.
         * @deprecated 这个只做兼容，后续版本在shape中设置密度值大小.
         * @zh 密度值。值可以为零或者是正数，建议使用相似的密度以改善堆叠稳定性。默认值为 10。
         */
        get density(): number;
        set density(value: number);
        /**
         * @deprecated This is only for compatibility, and subsequent versions will set friction in the shape.
         * @en The friction coefficient. The value ranges from 0 to 1, the larger the value, the greater the friction. The default value is 0.2.
         * @deprecated 这个只做兼容,后续版本在shape中设置摩擦力.
         * @zh 摩擦力。取值范围0-1，值越大，摩擦越大。默认值为0.2。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @deprecated
         * @en The restitution coefficient. The value ranges from 0 to 1, the larger the value, the greater the elasticity. The default value is 0.
         * @deprecated
         * @zh 弹性系数。取值范围0-1，值越大，弹性越大。默认值为0。
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * @internal
         * @deprecated 兼容方法
         */
        createShape(collider: ColliderBase): void;
        /**
         * @deprecated 兼容方法，根据刚体的数据设置def
         * @param collider
         */
        protected _setRigidbodyValue(collider: RigidBody): void;
    }
    /**
     * @deprecated
     * @en 2D edge collider.
     * @zh 2D边缘碰撞体。
     */
    class EdgeCollider extends StaticCollider {
        /**
         * @internal
         * @deprecated
         * 用逗号隔开的点的集合，注意只有两个点，格式：x,y,x,y
         */
        private _points;
        /**@internal 顶点数据*/
        private _datas;
        /**
         * @deprecated
         * 用逗号隔开的点的集合，注意只有两个点，格式：x,y,x,y*/
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data in the format of x,y,x,y ...
         * @zh 顶点数据，格式为 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
        /**
         * @internal
         * @override
         */
        protected _setShapeData(shape: any): void;
    }
    /**
     * @deprecated
     * @en 2D polygon collider. Concave polygons are currently not supported. If it is a concave polygon, manually split it into multiple convex polygons first.
     * The maximum number of vertices is `b2_maxPolygonVertices`, which defaults to 8. So it is not recommended to exceed 8 points, and it cannot be less than 3.
     * @zh 2D多边形碰撞体，暂时不支持凹多边形，如果是凹多边形，先手动拆分为多个凸多边形。
     * 节点个数最多是 `b2_maxPolygonVertices`，这数值默认是8，所以点的数量不建议超过8个，也不能小于3个。
     */
    class PolygonCollider extends StaticCollider {
        /**
         * @internal
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        private _points;
        /**@internal 顶点数据*/
        private _datas;
        /**
        * @deprecated
        * 用逗号隔开的点的集合，格式：x,y,x,y ...
        */
        get points(): string;
        set points(value: string);
        /**
         * @en Vertex data in the format: x,y,x,y ...
         * @zh 顶点数据，格式：x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
        /**
        * @override
        */
        protected _setShapeData(shape: any): void;
    }
    type RigidBody2DType = "static" | "dynamic" | "kinematic";
    /**
     * @zh 绘制物理2D信息枚举
     * @en Physics2D Blit Enum
     */
    enum EPhycis2DBlit {
        /**
         * @zh 不绘制任何信息
         * @en do not draw any information
         */
        None = 0,
        /**
         * @zh 绘制刚体信息
         * @en draw RigidBody information
         */
        Shape = 1,
        /**
         * @zh 绘制关节信息
         * @en draw Joint information
         */
        Joint = 2,
        /**
         * @zh 绘制AABB信息
         * @en draw AABB information
         */
        AABB = 4,
        /**
         * @zh 绘制碰撞对
         * @en draw collision pair
         */
        Pair = 8,
        /**
         * @zh 绘制刚体的质心
         * @en draw RigidBody center of mass
         */
        CenterOfMass = 16,
        /**
         * @zh 绘制刚体的速度
         * @en draw RigidBody velocity
         */
        All = 31
    }
    /**
     * @zh 2D物理约束枚举
     * @en Physics2D Constraint Enum
     */
    enum EPhysics2DJoint {
        /**
         * @zh 距离关节
         * @en DistanceJoint
         */
        DistanceJoint = 0,
        /**
         * @zh 旋转关节
         * @en RevoluteJoint
         */
        RevoluteJoint = 1,
        /**
         * @zh 齿轮关节
         * @en GearJoint
         */
        GearJoint = 2,
        /**
         * @zh 轮子关节
         * @en PulleyJoint
         */
        PulleyJoint = 3,
        /**
         * @zh 轮子关节
         * @en WheelJoint
         */
        WheelJoint = 4,
        /**
         * @zh 焊接关节
         * @en WeldJoint
         */
        WeldJoint = 5,
        /**
         * @zh 鼠标关节
         * @en MouseJoint
         */
        MouseJoint = 6,
        /**
         * @zh 电机关节
         * @en MotorJoint
         */
        MotorJoint = 7,
        /**
         * @zh 刚体关节
         * @en PrismaticJoint
         */
        PrismaticJoint = 8
    }
    /**
     * @zh 2D物理形状枚举
     * @en Physics2D Shape Enum
     */
    enum EPhysics2DShape {
        /**
         * @zh 矩形
         * @en BoxShape
         */
        BoxShape = 0,
        /**
         * @zh 圆形
         * @en CircleShape
         */
        CircleShape = 1,
        /**
         * @zh 多边形
         * @en PolygonShape
         */
        PolygonShape = 2,
        /**
         * @zh 链状
         * @en ChainShape
         */
        ChainShape = 3,
        /**
         * @zh 边
         * @en EdgeShape
         */
        EdgeShape = 4
    }
    class Physics2DHitResult {
        /**
         * @zh 所属物理组件
         * @en The physical component to which it belongs
         */
        collider: ColliderBase;
        /**
         * @zh 碰撞点
         * @en collision point
         */
        hitPoint: Vector2;
        /**
         * @zh 碰撞法线
         * @en collision normal
         */
        hitNormal: Vector2;
        /**
         * @zh 碰撞点沿射线的比例（0 到 1 之间）
         * @en The ratio of collision points along the ray (between 0 and 1)
         */
        fraction: number;
    }
    /**
     * @zh 碰撞过滤数据
     * @en Collision filtering data
     */
    class FilterData {
        /**
         * @zh 指定了该主体所属的碰撞组，默认为0，碰撞规则如下：
         * 1. 如果两个对象 group 相等：
         *    - group 值大于零，它们将始终发生碰撞。
         *    - group 值小于零，它们将永远不会发生碰撞。
         *    - group 值等于0，则使用规则3。
         * 2. 如果 group 值不相等，则使用规则3。
         * 3. 每个刚体都有一个 category 类别，此属性接收位字段，范围为 [1,2^31] 范围内的2的幂。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         * @en Specifies the collision group to which the body belongs, default is 0, the collision rules are as follows:
         * 1. If the group values of two objects are equal:
         *    - If the group value is greater than zero, they will always collide.
         *    - If the group value is less than zero, they will never collide.
         *    - If the group value is equal to 0, then rule 3 is used.
         * 2. If the group values are not equal, then rule 3 is used.
         * 3. Each rigidbody has a category, this property receives a bit field, the range is the power of 2 in the range of [1,2^31].
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         */
        group: number;
        /**
         * @zh 碰撞类别，使用2的幂次方值指定，有32种不同的碰撞类别可用。
         * @en Collision category, specified using powers of 2, with 32 different collision categories available.
         */
        category: number;
        /**
         * @zh 指定冲突位掩码碰撞的类别，category 位操作的结果。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         * @en Specifies the category of collision bit mask, the result of category bitwise operation.
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         */
        mask: number;
    }
    /**
     * @internal
     * @zh 形状定义
     * @en Shape definition
     */
    class Box2DShapeDef {
        /**
         * @zh 密度
         * @en Density
         */
        density: number;
        /**
         * @zh 摩擦力
         * @en Friction
         */
        friction: number;
        /**
         * @zh 是否为传感器
         * @en Whether it is a sensor
         */
        isSensor: boolean;
        /**
         * @zh 弹力
         * @en Restitution
         */
        restitution: number;
        /**
         * @zh 恢复速度阈值（米/秒），高于此速度的碰撞将应用恢复即反弹
         */
        restitutionThreshold: number;
        /**
         * @zh 形状
         * @en Shape
         */
        shapeType: EPhysics2DShape;
        /**
         * @zh 碰撞过滤数据
         * @en Collision filtering data
         */
        filter: FilterData;
    }
    /**
     * @internal
     * @zh 刚体2D定义
     * @en The information of the rigid body in 2D physics.
     */
    class RigidBody2DInfo {
        /**
         * @zh 位置
         * @en Position
         */
        position: Vector2;
        /**
         * @zh 角度
         * @en Angle
         */
        angle: number;
        /**
         * @zh 允许睡眠
         * @en Whether to allow sleeping
         */
        allowSleep: boolean;
        /**
         * @zh 角速度阻尼
         * @en Angular velocity damping
         */
        angularDamping: number;
        /**
         * @zh 角速度
         * @en Angular velocity
         */
        angularVelocity: number;
        /**
         * @zh 是否bullet高速运动类型
         * @en Whether it is a bullet high speed motion type
         */
        bullet: boolean;
        /**
         * @zh 是否固定旋转
         * @en Whether to fix rotation
         */
        fixedRotation: boolean;
        /**
         * @zh 重力缩放
         * @en Gravity scale
         */
        gravityScale: number;
        /**
         * @zh 线性阻尼
         * @en Linear damping
         */
        linearDamping: number;
        /**
         * @zh 线性速度
         * @en Linear velocity
         */
        linearVelocity: Vector2;
        type: string;
        /**
         * @deprecated 碰撞分组，作为兼容使用
         */
        group: number;
    }
    /**
     * @internal
     * @zh 2D物理joint定义
     * @en 2D physics joint definition
     */
    class physics2D_BaseJointDef {
        /**
         * @zh 刚体A
         * @en Body A
         */
        bodyA: any;
        /**
         * @zh 刚体B
         * @en Body B
         */
        bodyB: any;
        /**
         * @zh 刚体之间是否可以互相碰撞
         */
        collideConnected: boolean;
    }
    /**
     * @internal
     * @zh Box2D 距离关节定义结构
     * @en Box2D distance Joint def Struct
     */
    class physics2D_DistancJointDef extends physics2D_BaseJointDef {
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        frequency: number;
        dampingRatio: number;
        length: number;
        maxLength: number;
        minLength: number;
        isLocalAnchor: boolean;
    }
    /**
     * @internal
     */
    class physics2D_GearJointDef extends physics2D_BaseJointDef {
        joint1: any;
        joint2: any;
        ratio: number;
    }
    /**
     * @internal
     */
    class physics2D_MotorJointDef extends physics2D_BaseJointDef {
        linearOffset: Vector2;
        angularOffset: number;
        maxForce: number;
        maxTorque: number;
        correctionFactor: number;
    }
    /**
     * @internal
     */
    class physics2D_MouseJointJointDef extends physics2D_BaseJointDef {
        maxForce: number;
        frequency: number;
        dampingRatio: number;
        target: Vector2;
    }
    /**
     * @internal
     */
    class physics2D_PrismaticJointDef extends physics2D_BaseJointDef {
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorForce: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
    }
    /**
     * @internal
     */
    class physics2D_PulleyJointDef extends physics2D_BaseJointDef {
        groundAnchorA: Vector2;
        groundAnchorB: Vector2;
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        ratio: number;
    }
    /**
     * @internal
     */
    class physics2D_RevoluteJointDef extends physics2D_BaseJointDef {
        anchor: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerAngle: number;
        upperAngle: number;
    }
    /**
     * @internal
     */
    class physics2D_WeldJointDef extends physics2D_BaseJointDef {
        anchor: Vector2;
        frequency: number;
        dampingRatio: number;
    }
    /**
     * @internal
     */
    class physics2D_WheelJointDef extends physics2D_BaseJointDef {
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
        frequency: number;
        dampingRatio: number;
    }
    /**
     * @internal
     */
    class box2DWorldDef {
        gravity: Vector2;
        pixelRatio: number;
        subStep: number;
        velocityIterations: number;
        positionIterations: number;
    }
    enum Ebox2DType {
        b2Color = 0,
        b2Vec2 = 1,
        b2Transform = 2,
        b2Contact = 3,
        b2Joint = 4,
        b2Fixture = 5,
        b2Filter = 6,
        b2QueryCallback = 7,
        b2RayCastCallback = 8
    }
    /**
     * @blueprintIgnore
     */
    interface IPhysics2DFactory {
        worldCount: number;
        worldMap: Map<number, Physics2DWorldManager>;
        createWorld(worldDef: box2DWorldDef): any;
        allowWorldSleep(world: any, allowSleep: boolean): void;
        destroyWorld(world: any): void;
        destroyData(data: any): void;
        setDestructionListener(world: any, destroyFun: Function): void;
        setContactListener(world: any, listener: Function): void;
        warpPoint(ins: any, type: Ebox2DType): any;
        getContactShapeA(contact: any): any;
        getContactShapeB(contact: any): any;
        createContactListener(): any;
        createJSQueryCallback(): any;
        createJSRayCastCallback(): any;
        clearForces(world: any): void;
        QueryAABB(world: any, jsquerycallback: any, bounds: any): void;
        RayCast(world: any, jsraycastcallback: any, startPoint: Vector2, endPoint: Vector2): void;
        shapeCast(): void;
        getBodyList(world: any): any[];
        getBodyCount(world: any): number;
        getJointList(world: any): any[];
        getJointCount(world: any): number;
        getContactList(world: any): any[];
        getContactCount(world: any): number;
        createPhyVec2(x: number, y: number): any;
        createBox2DDraw(world: any, flag: number): any;
        shiftOrigin(world: any, newOrigin: Vector2): void;
        appendFlags(jsDraw: any, flags: number): void;
        clearFlags(jsDraw: any, flags: number): void;
        /**
         * @internal
         * 初始化系统
         */
        initialize(): Promise<void>;
        /**
         * @internal
         * 更新物理
         */
        update(delta: number): void;
        createJointDef(world: any, type: EPhysics2DJoint, def: physics2D_BaseJointDef): any;
        /**
         * @internal
         */
        createJoint(world: any, type: EPhysics2DJoint, def: any): any;
        /**
         * @internal
         */
        removeJoint(world: any, joint: any): void;
        /**
         * 当前约束的反作用力(也就是为了维持约束对刚体施加的力)
         * @param joint
         */
        get_joint_recationForce(joint: any): any;
        /**
         * 当前约束的反扭距(为了维持约束对刚体施加的扭矩)
         * @param joint
         */
        get_joint_reactionTorque(joint: any): number;
        isValidJoint(joint: any): boolean;
        setJoint_userData(joint: any, data: any): void;
        /**
         * @internal
         */
        getJoint_userData(joint: any): any;
        /**
         * @internal
         */
        getJoint_userData_destroy(joint: any): boolean;
        /**
         * @internal
         */
        set_Joint_EnableMotor(joint: any, enableMotor: boolean): void;
        /**
         * @internal
         */
        set_Joint_SetMotorSpeed(joint: any, motorSpeed: number): void;
        /**
         * @internal
         */
        set_Joint_SetMaxMotorTorque(joint: any, maxTorque: number): void;
        /**
         * @internal
         */
        set_Joint_EnableLimit(joint: any, enableLimit: boolean): void;
        /**
         * @internal
         */
        set_Joint_SetLimits(joint: any, lowerAngle: number, upperAngle: number): void;
        /**
         * @internal
         */
        set_Joint_frequencyAndDampingRatio(joint: any, frequency: number, dampingRatio: number, isdamping: boolean): void;
        /**
         * @internal
         */
        set_DistanceJoint_length(joint: any, length: number): void;
        get_DistanceJoint_length(joint: any): number;
        /**
         * @internal
         */
        set_DistanceJoint_MaxLength(joint: any, length: number): void;
        /**
         * @internal
         */
        set_DistanceJoint_MinLength(joint: any, length: number): void;
        /**
         * @internal
         */
        set_DistanceJointStiffnessDamping(joint: any, steffness: number, damping: number): void;
        /**
         * @internal
         */
        set_GearJoint_SetRatio(joint: any, radio: number): void;
        /**
         * @internal
         */
        set_MouseJoint_target(joint: any, x: number, y: number): void;
        /**
         * @internal
         */
        set_MouseJoint_frequencyAndDampingRatio(joint: any, frequency: number, dampingRatio: number): void;
        /**
         * @internal
         */
        set_MotorJoint_linearOffset(joint: any, x: number, y: number): void;
        /**
         * @internal
         */
        set_MotorJoint_SetAngularOffset(joint: any, angular: number): void;
        /**
         * @internal
         */
        set_MotorJoint_SetMaxForce(joint: any, maxForce: number): void;
        /**
         * @internal
         */
        set_MotorJoint_SetMaxTorque(joint: any, maxTorque: number): void;
        /**
         * @internal
         */
        set_MotorJoint_SetCorrectionFactor(joint: any, correctionFactor: number): void;
        /**
         * @internal
         */
        set_collider_SetAsBox(shape: any, x: number, y: number, pos: IV2, scaleX: number, scaleY: number): any;
        /**
         * @internal
         */
        set_ChainShape_data(shape: any, x: number, y: number, arr: number[], loop: boolean, scaleX: number, scaleY: number): any;
        /**
         * @internal
         */
        set_CircleShape_radius(shape: any, radius: number, scale: number): void;
        /**
         * @internal
         */
        set_CircleShape_pos(shape: any, x: number, y: number, scaleX: number, scaleY: number): void;
        /**
         * @internal
         */
        set_EdgeShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): any;
        /**
         * @internal
         */
        set_PolygonShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): any;
        createShapeDef(world: any, shapeDef: Box2DShapeDef, filter: any): any;
        getShapeByDef(shapeDef: any, shapeType: EPhysics2DShape): any;
        createFilter(): any;
        createShape(world: any, body: any, shapeType: EPhysics2DShape, shapdeDef: any): any;
        destroyShape(world: any, body: any, shape: any): void;
        /**
         * @internal
         */
        set_shapeDef_GroupIndex(def: any, groupIndex: number): void;
        /**
         * @internal
         */
        set_shapeDef_CategoryBits(def: any, categoryBits: number): void;
        /**
         * @internal
         */
        set_shapeDef_maskBits(def: any, maskbits: number): void;
        /**
        * @internal
        */
        resetShapeData(shape: any, shapeDef: any): void;
        /**
         * @internal
         */
        set_shape_collider(shape: any, instance: any): void;
        /**
         * @internal
         */
        get_shape_body(shape: any): any;
        set_shape_isSensor(shape: any, sensor: boolean): void;
        get_shape_isSensor(shape: any): boolean;
        getShape(shape: any, type: EPhysics2DShape): any;
        setfilterData(shape: any, filterData: any): void;
        getfilterData(shape: any): any;
        set_shape_reFilter(shape: any): void;
        shape_rayCast(shape: any, output: any, input: any, childIndex: number): boolean;
        get_shape_massData(shape: any, massData: any): any;
        set_shape_density(shape: any, density: number): void;
        set_shape_friction(shape: any, friction: number): void;
        set_shape_restitution(shape: any, restitution: number): void;
        set_shape_restitutionThreshold(shape: any, restitutionThreshold: number): void;
        get_shape_AABB(shape: any): any;
        createMassData(): any;
        /**
         * @internal
         */
        createBody(world: any, def: any): any;
        /**
         * @internal
         */
        removeBody(world: any, body: any): void;
        get_rigidBody_isEnable(body: any): boolean;
        get_rigidBody_fixedRotation(body: any): boolean;
        get_rigidBody_next(body: any): any;
        set_rigidBody_userData(body: any, data: any): void;
        get_rigidBody_userData(body: any): any;
        /**
         * @internal
         */
        rigidBody_DestroyShape(body: any, shape: any): any;
        /**
         * @internal
         */
        createBodyDef(world: any, rigidbodyDef: RigidBody2DInfo): any;
        /**
         * @internal
         */
        get_RigidBody_Position(body: any, v2: Vector2): void;
        /**
         * @internal
         */
        get_RigidBody_Angle(body: any): number;
        /**
         * @internal
         */
        set_RigibBody_Enable(body: any, enable: boolean): void;
        /**
         * @internal
         */
        set_RigibBody_Transform(body: any, x: number, y: number, angle: number): void;
        get_RigibBody_Transform(body: any): any;
        /**
         * @internal
         */
        get_rigidBody_WorldPoint(body: any, x: number, y: number): IV2;
        get_rigidBody_WorldVector(body: any, value: Vector2): Vector2;
        /**
         * @internal
         */
        get_rigidBody_LocalPoint(body: any, x: number, y: number): IV2;
        get_rigidBody_LocalVector(body: any, value: Vector2): Vector2;
        /**
         * @internal
         */
        rigidBody_applyForce(body: any, force: IV2, position: IV2): void;
        /**
         * @internal
         */
        rigidBody_applyForceToCenter(body: any, force: IV2): void;
        /**
         * @internal
         */
        rigidbody_ApplyLinearImpulse(body: any, impulse: IV2, position: IV2): void;
        rigidbody_ApplyAngularImpulse(body: any, impulse: number): void;
        /**
         * @internal
         */
        rigidbody_ApplyLinearImpulseToCenter(body: any, impulse: IV2): void;
        /**
         * @internal
         */
        rigidbody_applyTorque(body: any, torque: number): void;
        /**
         * @internal
         */
        set_rigidBody_Awake(body: any, awake: boolean): void;
        /**
         * @internal
         */
        get_rigidBody_Mass(body: any): number;
        /**
         * @internal
         */
        set_rigidBody_Mass(body: any, massValue: number, centerOfMass: IV2, inertia: number, massData: any): void;
        /**
         * @internal
         */
        get_rigidBody_Center(body: any): IV2;
        /**
         * @internal
         */
        get_rigidBody_Inertia(body: any): number;
        /**
         * @internal
         */
        get_rigidBody_IsAwake(body: any): boolean;
        /**
         * @internal
         */
        get_rigidBody_WorldCenter(body: any): IV2;
        /**
         * @internal
         */
        set_rigidBody_type(body: any, value: string): void;
        get_rigidBody_type(body: any): string;
        /**
         * @internal
         */
        set_rigidBody_gravityScale(body: any, value: number): void;
        get_rigidBody_gravityScale(body: any): number;
        /**
         * @internal
         */
        set_rigidBody_allowRotation(body: any, value: boolean): void;
        /**
         * @internal
         */
        set_rigidBody_allowSleep(body: any, value: boolean): void;
        get_rigidBody_allowSleep(body: any): boolean;
        /**
         * @internal
         */
        set_rigidBody_angularDamping(body: any, value: number): void;
        get_rigidBody_angularDamping(body: any): number;
        /**
         * @internal
         */
        get_rigidBody_angularVelocity(body: any): number;
        /**
         * @internal
         */
        set_rigidBody_angularVelocity(body: any, value: number): void;
        /**
         * @internal
         */
        set_rigidBody_linearDamping(body: any, value: number): void;
        get_rigidBody_linearDamping(body: any): number;
        /**
         * @internal
         */
        get_rigidBody_linearVelocity(body: any): IV2;
        /**
         * @internal
         */
        set_rigidBody_linearVelocity(body: any, value: IV2): void;
        get_rigidBody_linearVelocityFromWorldPoint(body: any, worldPoint: Vector2): Vector2;
        get_rigidBody_linearVelocityFromLocalPoint(body: any, localPoint: Vector2): Vector2;
        /**
         * @internal
         */
        set_rigidBody_bullet(body: any, value: boolean): void;
        get_rigidBody_bullet(body: any): boolean;
        /**
        * @internal
        */
        retSet_rigidBody_MassData(body: any): void;
    }
    /**
     * @en Implements Box2D c++ version 2.4.1
     * @zh 实现Box2D c++ 2.4.1 版本
     */
    class physics2DwasmFactory implements IPhysics2DFactory {
        worldMap: Map<number, Physics2DWorldManager>;
        worldCount: number;
        private _tempVe21;
        private _tempVe22;
        /**@internal box2D Engine */
        _box2d: any;
        /**
         * @internal
         * @en The box2d engine instance.
         * @zh box2d引擎实例。
         */
        get box2d(): any;
        /**
         * @en Create a Vec2 object in the physical system.
         * @param x The x-coordinate (unit: meters).
         * @param y The y-coordinate (unit: meters).
         * @zh 创建物理系统的Vec2对象。
         * @param x x坐标（单位：米）。
         * @param y y坐标（单位：米）。
         */
        createPhyVec2(x: number, y: number): any;
        createPhyFromLayaVec2(world: any, x: number, y: number): any;
        convertLayaValueToPhysics(world: any, value: number): number;
        convertPhysicsValueToLaya(world: any, value: number): number;
        createBox2DDraw(world: any, flag: number): any;
        shiftOrigin(world: any, newOrigin: Vector2): void;
        appendFlags(jsDraw: any, flags: number): void;
        clearFlags(jsDraw: any, flags: number): void;
        /**
         * @en Initialize the Box2D physics engine.
         * @returns A promise that resolves when the initialization is complete.
         * @zh 初始化Box2D物理引擎。
         * @returns 初始化完成时解析的promise。
         */
        initialize(): Promise<void>;
        createWorld(worldDef: box2DWorldDef): any;
        allowWorldSleep(world: any, allowSleep: boolean): void;
        clearForces(world: any): void;
        QueryAABB(world: any, jsquerycallback: any, bounds: any): void;
        RayCast(world: any, jsraycastcallback: any, startPoint: Vector2, endPoint: Vector2): void;
        shapeCast(): void;
        getBodyList(world: any): any[];
        getBodyCount(world: any): number;
        getJointList(world: any): any[];
        getJointCount(world: any): number;
        getContactList(world: any): any[];
        getContactCount(world: any): number;
        /**
         * @en Create the Box2D world.
         * @zh 创建Box2D世界。
         */
        start(): void;
        destroyWorld(world: any): void;
        /**
         * @en Update the physics world.
         * @param delta The time step.
         * @zh 更新物理世界。
         * @param delta 时间步长。
         */
        update(delta: number): void;
        createJointDef(world: any, type: EPhysics2DJoint, def: physics2D_BaseJointDef): any;
        createJoint(world: any, type: EPhysics2DJoint, def: any): any;
        removeJoint(world: any, joint: any): void;
        _createBox2DJoint(world: any, def: any, cls: any): any;
        setJoint_userData(joint: any, data: any): void;
        /**
         * @en Get the user data of a joint.
         * @param joint The joint.
         * @returns The user data of the joint.
         * @zh 获取关节的用户数据。
         * @param joint 关节。
         * @returns 关节的用户数据。
         */
        getJoint_userData(joint: any): any;
        /**
         * @en Check if the user data of a joint is marked as destroyed.
         * @param joint The joint.
         * @returns True if the user data is marked as destroyed, false otherwise.
         * @zh 检查关节的用户数据是否被标记为已销毁。
         * @param joint 关节。
         * @returns 用户数据是否已被标记为已销毁。
         */
        getJoint_userData_destroy(joint: any): boolean;
        /**
         * @en Enable or disable the motor of a joint.
         * @param joint The joint.
         * @param enableMotor True to enable the motor, false to disable it.
         * @zh 启用或禁用关节的马达。
         * @param joint 关节。
         * @param enableMotor 是否启用马达。
         */
        set_Joint_EnableMotor(joint: any, enableMotor: boolean): void;
        /**
         * @en Set the motor speed of a joint.
         * @param joint The joint.
         * @param motorSpeed The motor speed.
         * @zh 设置关节的马达速度。
         * @param joint 关节。
         * @param motorSpeed 马达速度。
         */
        set_Joint_SetMotorSpeed(joint: any, motorSpeed: number): void;
        /**
         * @en Set the maximum motor torque of a joint.
         * @param joint The joint.
         * @param maxTorque The maximum motor torque.
         * @zh 设置关节的最大马达扭矩。
         * @param joint 关节。
         * @param maxTorque 最大马达扭矩。
         */
        set_Joint_SetMaxMotorTorque(joint: any, maxTorque: number): void;
        /**
         * @en Enable or disable the limit of a joint.
         * @param joint The joint.
         * @param enableLimit True to enable the limit, false to disable it.
         * @zh 启用或禁用关节的限制。
         * @param joint 关节。
         * @param enableLimit 是否启用限制。
         */
        set_Joint_EnableLimit(joint: any, enableLimit: boolean): void;
        /**
         * @en Set the limits of a joint.
         * @param joint The joint.
         * @param lowerAngle The lower angle limit.
         * @param upperAngle The upper angle limit.
         * @zh 设置关节的限制。
         * @param joint 关节。
         * @param lowerAngle 底角限制。
         * @param upperAngle 顶角限制。
         */
        set_Joint_SetLimits(joint: any, lowerAngle: number, upperAngle: number): void;
        /**
         * @en Set the frequency and damping ratio of a joint.
         * @param joint The joint.
         * @param frequency The frequency.
         * @param dampingRatio The damping ratio.
         * @param isdamping True to apply damping, false otherwise.
         * @zh 设置关节的频率和阻尼比。
         * @param joint 关节。
         * @param frequency 频率。
         * @param dampingRatio 阻尼比。
         * @param isdamping 是否应用阻尼。
         */
        set_Joint_frequencyAndDampingRatio(joint: any, frequency: number, dampingRatio: number, isdamping: boolean): void;
        /**
         * @en Set the length of a distance joint.
         * @param joint The distance joint.
         * @param length The length.
         * @zh 设置距离关节的长度。
         * @param joint 距离关节。
         * @param length 长度。
         */
        set_DistanceJoint_length(joint: any, length: number): void;
        get_DistanceJoint_length(joint: any): number;
        /**
         * @en Set the maximum length of a distance joint.
         * @param joint The distance joint.
         * @param length The maximum length.
         * @zh 设置距离关节的最大长度。
         * @param joint 距离关节。
         * @param length 最大长度。
         */
        set_DistanceJoint_MaxLength(joint: any, length: number): void;
        /**
         * @en Set the minimum length of a distance joint.
         * @param joint The distance joint.
         * @param length The minimum length.
         * @zh 设置距离关节的最小长度。
         * @param joint 距离关节。
         * @param length 最小长度。
         */
        set_DistanceJoint_MinLength(joint: any, length: number): void;
        /**
         * @en Set the stiffness and damping of a distance joint.
         * @param joint The distance joint.
         * @param stiffness The stiffness.
         * @param damping The damping.
         * @zh 设置距离关节的刚度和阻尼。
         * @param joint 距离关节。
         * @param stiffness 刚度。
         * @param damping 阻尼。
         */
        set_DistanceJointStiffnessDamping(joint: any, stiffness: number, damping: number): void;
        /**
         * @en Set the ratio of a gear joint.
         * @param joint The gear joint.
         * @param radio The ratio to set.
         * @zh 设置齿轮关节的比率。
         * @param joint 齿轮关节。
         * @param radio 要设置的比率。
         */
        set_GearJoint_SetRatio(joint: any, radio: number): void;
        /**
         * @en Set the target position of a mouse joint.
         * @param joint The mouse joint.
         * @param x The x-coordinate of the target position.
         * @param y The y-coordinate of the target position.
         * @zh 设置鼠标关节的目标位置。
         * @param joint 鼠标关节。
         * @param x 目标位置的x坐标。
         * @param y 目标位置的y坐标。
         */
        set_MouseJoint_target(joint: any, x: number, y: number): void;
        /**
         * @en Set the frequency and damping ratio of a mouse joint.
         * @param Joint The mouse joint.
         * @param frequency The frequency.
         * @param dampingRatio The damping ratio.
         * @zh 设置鼠标关节的频率和阻尼比。
         * @param Joint 鼠标关节。
         * @param frequency 频率。
         * @param dampingRatio 阻尼比。
         */
        set_MouseJoint_frequencyAndDampingRatio(Joint: any, frequency: number, dampingRatio: number): void;
        /**
         * @en Set the linear offset of a motor joint.
         * @param joint The motor joint.
         * @param x The x-coordinate of the linear offset.
         * @param y The y-coordinate of the linear offset.
         * @zh 设置马达关节的线性偏移量。
         * @param joint 马达关节。
         * @param x 线性偏移量的x坐标。
         * @param y 线性偏移量的y坐标。
         */
        set_MotorJoint_linearOffset(joint: any, x: number, y: number): void;
        /**
         * @en Set the angular offset of a motor joint.
         * @param joint The motor joint.
         * @param angular The angular offset.
         * @zh 设置马达关节的角度偏移量。
         * @param joint 马达关节。
         * @param angular 角度偏移量。
         */
        set_MotorJoint_SetAngularOffset(joint: any, angular: number): void;
        /**
         * @en Set the maximum force of a motor joint.
         * @param joint The motor joint.
         * @param maxForce The maximum force.
         * @zh 设置马达关节的最大力。
         * @param joint 马达关节。
         * @param maxForce 最大力。
         */
        set_MotorJoint_SetMaxForce(joint: any, maxForce: number): void;
        /**
         * @en Set the maximum torque of a motor joint.
         * @param joint The motor joint.
         * @param maxTorque The maximum torque.
         * @zh 设置马达关节的最大扭矩。
         * @param joint 马达关节。
         * @param maxTorque 最大扭矩。
         */
        set_MotorJoint_SetMaxTorque(joint: any, maxTorque: number): void;
        /**
         * @en Set the correction factor of a motor joint.
         * @param joint The motor joint.
         * @param correctionFactor The correction factor.
         * @zh 设置马达关节的校正因子。
         * @param joint 马达关节。
         * @param correctionFactor 校正因子。
         */
        set_MotorJoint_SetCorrectionFactor(joint: any, correctionFactor: number): void;
        get_joint_recationForce(joint: any): any;
        get_joint_reactionTorque(joint: any): number;
        isValidJoint(joint: any): boolean;
        createShapeDef(world: any, shapeDef: Box2DShapeDef, filter: any): any;
        getShapeByDef(shapeDef: any, shapeType: EPhysics2DShape): any;
        createFilter(): any;
        createShape(world: any, body: any, shapeType: EPhysics2DShape, shapdeDef: any): any;
        /**
         * @en Set the shape of a box collider as a box.
         * @param shape The box collider shape.
         * @param width The width of the box.
         * @param height The height of the box.
         * @param pos The position of the box.
         * @param scaleX The horizontal scale of the box.
         * @param scaleY The vertical scale of the box.
         * @zh 将盒子碰撞器的形状设置为盒子。
         * @param shape 盒子碰撞器形状。
         * @param width 盒子的宽度。
         * @param height 盒子的高度。
         * @param pos 盒子的位置。
         * @param scaleX 盒子的水平缩放。
         * @param scaleY 盒子的垂直缩放。
         */
        set_collider_SetAsBox(shape: any, width: number, height: number, pos: IV2, scaleX: number, scaleY: number): void;
        /**
         * @en Set the data of a chain shape.
         * @param shape The chain shape.
         * @param x The x-coordinate of the chain shape's position.
         * @param y The y-coordinate of the chain shape's position.
         * @param arr The vertex array of the chain shape.
         * @param loop Whether the chain shape is a loop.
         * @param scaleX The horizontal scale of the chain shape.
         * @param scaleY The vertical scale of the chain shape.
         * @zh 设置链条形状的数据。
         * @param shape 链条形状。
         * @param x 链条形状的位置的x坐标。
         * @param y 链条形状的位置的y坐标。
         * @param arr 链条形状的顶点数组。
         * @param loop 链条形状是否为循环。
         * @param scaleX 链条形状的水平缩放。
         * @param scaleY 链条形状的垂直缩放。
         */
        set_ChainShape_data(shape: any, x: number, y: number, arr: number[], loop: boolean, scaleX: number, scaleY: number): void;
        /**
         * @en Set the radius of a circle shape.
         * @param shape The circle shape.
         * @param radius The radius of the circle shape.
         * @param scale The scale of the circle shape.
         * @zh 设置圆形形状的半径。
         * @param shape 圆形形状。
         * @param radius 圆形形状的半径。
         * @param scale 圆形形状的缩放。
         */
        set_CircleShape_radius(shape: any, radius: number, scale: number): void;
        /**
         * @en Set the position of a circle shape.
         * @param shape The circle shape.
         * @param x The x-coordinate of the circle shape's position.
         * @param y The y-coordinate of the circle shape's position.
         * @param scaleX The horizontal scale of the circle shape's position.
         * @param scaleY The vertical scale of the circle shape's position.
         * @zh 设置圆形形状的位置。
         * @param shape 圆形形状。
         * @param x 圆形形状的位置的x坐标。
         * @param y 圆形形状的位置的y坐标。
         * @param scaleX 圆形形状位置的水平缩放。
         * @param scaleY 圆形形状位置的垂直缩放。
         */
        set_CircleShape_pos(shape: any, x: number, y: number, scaleX: number, scaleY: number): void;
        /**
         * @en Set the data of an edge shape.
         * @param shape The edge shape.
         * @param x The x-coordinate of the edge shape's position.
         * @param y The y-coordinate of the edge shape's position.
         * @param arr The vertex array of the edge shape.
         * @param scaleX The horizontal scale of the edge shape.
         * @param scaleY The vertical scale of the edge shape.
         * @zh 设置边缘形状的数据。
         * @param shape 边缘形状。
         * @param x 边缘形状的位置的x坐标。
         * @param y 边缘形状的位置的y坐标。
         * @param arr 边缘形状的顶点数组。
         * @param scaleX 边缘形状的水平缩放。
         * @param scaleY 边缘形状的垂直缩放。
         */
        set_EdgeShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        /**
         * @en Set the data of a polygon shape.
         * @param shape The polygon shape.
         * @param x The x-coordinate of the polygon shape's position.
         * @param y The y-coordinate of the polygon shape's position.
         * @param arr The vertex array of the polygon shape.
         * @param scaleX The horizontal scale of the polygon shape.
         * @param scaleY The vertical scale of the polygon shape.
         * @zh 设置多边形形状的数据。
         * @param shape 多边形形状。
         * @param x 多边形形状的位置的x坐标。
         * @param y 多边形形状的位置的y坐标。
         * @param arr 多边形形状的顶点数组。
         * @param scaleX 多边形形状的水平缩放。
         * @param scaleY 多边形形状的垂直缩放。
         */
        set_PolygonShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        destroyShape(world: any, body: any, shape: any): void;
        set_shapeDef_GroupIndex(def: any, groupIndex: number): void;
        set_shapeDef_CategoryBits(def: any, categoryBits: number): void;
        set_shapeDef_maskBits(def: any, maskbits: number): void;
        resetShapeData(shape: any, shapeDef: any): void;
        set_shape_collider(shape: any, instance: any): void;
        get_shape_body(shape: any): any;
        set_shape_isSensor(shape: any, sensor: boolean): void;
        get_shape_isSensor(shape: any): boolean;
        /**
         * @zh 获取夹具fixture的shape
         * @param shape 夹具
         * @returns 夹具的形状
         * @en get fixture's shape, for compatibility
         * @param shape fixture
         * @returns shape
         */
        getShape(shape: any, type: EPhysics2DShape): any;
        setfilterData(shape: any, filterData: any): void;
        getfilterData(shape: any): FilterData;
        set_shape_reFilter(shape: any): void;
        shape_rayCast(shape: any, output: any, input: any, childIndex: number): boolean;
        get_shape_massData(shape: any, massData: any): any;
        set_shape_density(shape: any, density: number): void;
        set_shape_friction(shape: any, friction: number): void;
        set_shape_restitution(shape: any, restitution: number): void;
        set_shape_restitutionThreshold(shape: any, restitutionThreshold: number): void;
        get_shape_AABB(shape: any): any;
        createMassData(): any;
        createBody(world: any, def: any): any;
        removeBody(world: any, body: any): void;
        rigidBody_DestroyShape(body: any, shape: any): void;
        createBodyDef(world: any, rigidbodyDef: RigidBody2DInfo): any;
        get_RigidBody_Position(body: any, v2: Vector2): void;
        get_RigidBody_Angle(body: any): number;
        set_RigibBody_Enable(body: any, enable: boolean): void;
        set_RigibBody_Transform(body: any, x: number, y: number, angle: any): void;
        get_rigidBody_WorldPoint(body: any, x: number, y: number): IV2;
        get_rigidBody_LocalPoint(body: any, x: number, y: number): IV2;
        rigidBody_applyForce(body: any, force: IV2, position: IV2): void;
        rigidBody_applyForceToCenter(body: any, force: IV2): void;
        rigidbody_ApplyLinearImpulse(body: any, impulse: IV2, position: IV2): void;
        rigidbody_ApplyLinearImpulseToCenter(body: any, impulse: IV2): void;
        rigidbody_applyTorque(body: any, torque: number): void;
        set_rigidbody_Velocity(body: any, velocity: IV2): void;
        set_rigidbody_Awake(body: any, awake: boolean): void;
        get_rigidbody_Mass(body: any): number;
        /**
         * @en Set the mass of a rigid body.
         * @param body The rigid body.
         * @param massValue The mass to set.
         * @param centerofMass The center of mass to set.
         * @param inertiaValue The inertia to set.
         * @param massData The mass data to set.
         * @zh 设置刚体的质量。
         * @param body 刚体。
         * @param massValue 要设置的质量。
         * @param centerofMass 要设置的质心。
         * @param inertiaValue 要设置的惯性张量。
         * @param massData 要设置的质量数据。
         */
        set_rigidBody_Mass(body: any, massValue: number, centerofMass: IV2, inertiaValue: number, massData: any): void;
        /**
         * @en Get the offset of the center of mass relative to the node (0, 0) point.
         * @param body The rigid body.
         * @returns The offset of the center of mass.
         * @zh 获取质心相对于节点 (0, 0) 点的位置偏移。
         * @param body 刚体。
         * @returns 质心相对于节点 (0, 0) 点的位置偏移。
         */
        get_rigidBody_Center(body: any): IV2;
        /**
         * @en Get the inertia tensor of the rigid body.
         * @param body The rigid body.
         * @returns The inertia tensor of the rigid body.
         * @zh 获取刚体的转动张量
         * @param body 刚体。
         * @returns 刚体的转动张量。
         */
        get_rigidbody_Inertia(body: any): number;
        /**
         * @en Check if a rigid body is awake.
         * @param body The rigid body.
         * @returns True if the rigid body is awake, false otherwise.
         * @zh 检查刚体是否处于唤醒状态。
         * @param body 刚体。
         * @returns 若刚体处于唤醒状态，则返回true，否则返回false。
         */
        get_rigidBody_IsAwake(body: any): any;
        /**
         * @en Get the world coordinates of the center of mass relative to the Physics.I.worldRoot node.
         * @param body The rigid body.
         * @returns The world coordinates of the center of mass.
         * @zh 获取质心相对于 Physics.I.worldRoot 节点的世界坐标。
         * @param body 刚体。
         * @returns 质心相对于 Physics.I.worldRoot 节点的世界坐标。
         */
        get_rigidBody_WorldCenter(body: any): IV2;
        /**
         * @en Set the type of a rigid body.
         * @param body The rigid body.
         * @param value The type of the rigid body.
         * @zh 设置刚体的类型。
         * @param body 刚体。
         * @param value 刚体的类型。
         */
        set_rigidBody_type(body: any, value: string): void;
        /**
         * @en Set the gravity scale of a rigid body.
         * @param body The rigid body.
         * @param value The gravity scale.
         * @zh 设置刚体的重力缩放因子。
         * @param body 刚体。
         * @param value 重力缩放因子。
         */
        set_rigidBody_gravityScale(body: any, value: number): void;
        /**
         * @en Set whether a rigid body allows rotation.
         * @param body The rigid body.
         * @param value True if the rigid body allows rotation, false otherwise.
         * @zh 设置刚体是否允许旋转。
         * @param body 刚体。
         * @param value 若为true，则刚体允许旋转；若为false，则刚体不允许旋转。
         */
        set_rigidBody_allowRotation(body: any, value: boolean): void;
        /**
         * @en Set whether a rigid body allows sleeping.
         * @param body The rigid body.
         * @param value True if the rigid body allows sleeping, false otherwise.
         * @zh 设置刚体是否允许休眠。
         * @param body 刚体。
         * @param value 若为true，则刚体允许休眠；若为false，则刚体不允许休眠。
         */
        set_rigidBody_allowSleep(body: any, value: boolean): void;
        /**
         * @en Set the angular damping of a rigid body.
         * @param body The rigid body.
         * @param value The angular damping.
         * @zh 设置刚体的角阻尼。
         * @param body 刚体。
         * @param value 角阻尼。
         */
        set_rigidBody_angularDamping(body: any, value: number): void;
        /**
         * @en Get the angular velocity of a rigid body.
         * @param body The rigid body.
         * @returns The angular velocity.
         * @zh 获取刚体的角速度。
         * @param body 刚体。
         * @returns 角速度。
         */
        get_rigidBody_angularVelocity(body: any): number;
        /**
         * @en Set the angular velocity of a rigid body.
         * @param body The rigid body.
         * @param value The angular velocity.
         * @zh 设置刚体的角速度。
         * @param body 刚体。
         * @param value 角速度。
         */
        set_rigidBody_angularVelocity(body: any, value: number): void;
        /**
         * @en Set the linear damping of a rigid body.
         * @param body The rigid body.
         * @param value The linear damping.
         * @zh 设置刚体的线性阻尼。
         * @param body 刚体。
         * @param value 线性阻尼。
         */
        set_rigidBody_linearDamping(body: any, value: number): void;
        /**
         * @en Get the linear velocity of a rigid body.
         * @param body The rigid body.
         * @returns The linear velocity.
         * @zh 获取刚体的线性速度。
         * @param body 刚体。
         * @returns 线性速度。
         */
        get_rigidBody_linearVelocity(body: any): IV2;
        /**
         * @en Set the linear velocity of a rigid body.
         * @param body The rigid body.
         * @param value The linear velocity.
         * @zh 设置刚体的线性速度。
         * @param body 刚体。
         * @param value 线性速度。
         */
        set_rigidBody_linearVelocity(body: any, value: IV2): void;
        /**
         * @en Set whether a rigid body is a bullet.
         * @param body The rigid body.
         * @param value True if the rigid body is a bullet, false otherwise.
         * @zh 设置刚体是否为子弹。
         * @param body 刚体。
         * @param value 若为true，则刚体为子弹；若为false，则刚体不是子弹。
         */
        set_rigidBody_bullet(body: any, value: boolean): void;
        /**
         * @en Reset the mass data of a rigid body.
         * @param body The rigid body.
         * @zh 重置刚体的质量数据。
         * @param body 刚体。
         */
        retSet_rigidBody_MassData(body: any): void;
        get_rigidBody_isEnable(body: any): boolean;
        get_rigidBody_fixedRotation(body: any): boolean;
        get_rigidBody_next(body: any): any;
        set_rigidBody_userData(body: any, data: any): void;
        get_rigidBody_userData(body: any): any;
        get_RigibBody_Transform(body: any): any;
        get_rigidBody_WorldVector(body: any, value: Vector2): Vector2;
        get_rigidBody_LocalVector(body: any, value: Vector2): Vector2;
        rigidbody_ApplyAngularImpulse(body: any, impulse: number): void;
        set_rigidBody_Awake(body: any, awake: boolean): void;
        get_rigidBody_Mass(body: any): number;
        get_rigidBody_Inertia(body: any): number;
        get_rigidBody_type(body: any): string;
        get_rigidBody_gravityScale(body: any): number;
        get_rigidBody_allowSleep(body: any): boolean;
        get_rigidBody_angularDamping(body: any): number;
        get_rigidBody_linearDamping(body: any): number;
        get_rigidBody_linearVelocityFromWorldPoint(body: any, worldPoint: Vector2): Vector2;
        get_rigidBody_linearVelocityFromLocalPoint(body: any, localPoint: Vector2): Vector2;
        get_rigidBody_bullet(body: any): boolean;
        /**
         * @internal
         * @en Get the body type based on the string representation.
         * @param type The string representation of the body type.
         * @returns The body type.
         * @zh 根据字符串表示获取刚体类型。
         * @param type 刚体类型字符串。
         * @returns 刚体类型。
         */
        getbodyType(type: string): any;
        setDestructionListener(world: any, destroyFun: Function): void;
        setContactListener(world: any, listener: Function): void;
        warpPoint(ins: any, type: Ebox2DType): any;
        getContactShapeA(contact: any): any;
        getContactShapeB(contact: any): any;
        createContactListener(): any;
        createJSQueryCallback(): any;
        createJSRayCastCallback(): any;
        /**
         * @internal
         * @en Destruction listener.
         * @zh 销毁监听器。
         */
        getDestructionListener(): any;
        /**
         * @internal
         * @en Cast an object to a specific class.
         * @param pointer The pointer.
         * @param cls The class.
         * @returns The casted object.
         * @zh 将对象转换为特定类。
         * @param pointer 指针。
         * @param cls 类。
         * @returns 转换后的对象。
         */
        castObject(pointer: any, cls: any): any;
        /**
         * @internal
         * @en Create a wrapped pointer from points.
         * @param points The points.
         * @returns The wrapped pointer.
         * @zh 从点创建包装的指针。
         * @param points 点。
         * @returns 包装的指针。
         */
        createWrapPointer(world: any, points: number[]): any;
        /**
         * @internal
         * @en Create a Vec2 pointer from points.
         * @param points The points.
         * @param x The x-coordinate.
         * @param y The y-coordinate.
         * @param scaleX The horizontal scale.
         * @param scaleY The vertical scale.
         * @returns The Vec2 pointer.
         * @zh 从点创建 Vec2 指针。
         * @param points 点。
         * @param x x坐标。
         * @param y y坐标。
         * @param scaleX 水平缩放。
         * @param scaleY 垂直缩放。
         * @returns Vec2 指针。
         */
        createVec2Pointer(world: any, points: number[], x: number, y: number, scaleX: number, scaleY: number): any;
        /**
         * @internal
         * @en Calculate linear stiffness.
         * @param def The definition.
         * @param frequencyHertz The frequency in Hertz.
         * @param dampingRatio The damping ratio.
         * @param bodyA The first body.
         * @param bodyB The second body.
         * @zh 计算线性刚度。
         * @param def 定义。
         * @param frequencyHertz 频率（赫兹）。
         * @param dampingRatio 阻尼比。
         * @param bodyA 第一个刚体。
         * @param bodyB 第二个刚体。
         */
        b2LinearStiffness(def: any, frequencyHertz: number, dampingRatio: number, bodyA: any, bodyB: any): void;
        /**
         * @internal
         * @en Utility to compute rotational stiffness values frequency and damping ratio.
         * @param def The definition.
         * @param frequencyHertz The frequency in Hertz.
         * @param dampingRatio The damping ratio.
         * @param bodyA The first body.
         * @param bodyB The second body.
         * @zh 用于计算旋转刚度值频率和阻尼比的实用程序。
         * @param def 定义。
         * @param frequencyHertz 频率（赫兹）。
         * @param dampingRatio 阻尼比。
         * @param bodyA 第一个刚体。
         * @param bodyB 第二个刚体。
         */
        b2AngularStiffness(def: any, frequencyHertz: number, dampingRatio: number, bodyA: any, bodyB: any): void;
        /**
         * @internal
         * @en Get the length between two vectors.
         * @param p1 The first vector.
         * @param p2 The second vector.
         * @returns The length between the two vectors.
         * @zh 获取两个向量之间的长度。
         * @param p1 第一个向量。
         * @param p2 第二个向量。
         * @returns 两个向量之间的长度。
         */
        getVec2Length(p1: any, p2: any): number;
        /**
         * @internal
         * @en Check if the data is null.
         * @param data The data to check.
         * @returns True if the data is null, false otherwise.
         * @zh 检查数据是否为空。
         * @param data 要检查的数据。
         * @returns 数据是否为空，如果为空则返回 true，否则返回 false。
         */
        isNullData(data: any): any;
        /**
         * @en Destroy the data.
         * @param data The data to destroy.
         * @zh 销毁数据。
         * @param data 要销毁的数据。
         */
        destroyData(data: any): void;
        /**
         * @internal
         * @en Get the fixture shape based on the physics shape.
         * @param shape The shape.
         * @param physicShape The physics shape.
         * @returns The fixture shape.
         * @zh 根据物理形状获取夹具形状。
         * @param shape 形状。
         * @param physicShape 物理形状。
         * @returns 夹具形状。
         */
        get_fixtureshape(shape: any, physicShape: EPhysics2DShape): any;
    }
    /**
     * @en Distance Joint: A joint that maintains a fixed distance between two points on two bodies.
     * @zh 距离关节描述了两个刚体锚点之间的距离，并且最终会保持着这个约束的距离。
     */
    class DistanceJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 约束的目标静止长度*/
        private _length;
        /**@internal 约束的最小长度，-1表示使用默认值*/
        private _maxLength;
        /**@internal 约束的最大长度，-1表示使用默认值*/
        private _minLength;
        /**@internal 弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**@internal 刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**
         * @en The joint's own rigid body, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The joint's connected rigid body, which can be unspecified and defaults to an empty rigid body at the top left corner, effective only on the first setting.
         * @zh [首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en The self body's anchor point, which is the offset relative to the top left corner of the own rigid body, effective only on the first setting.
         * @zh [首次设置有效]自身刚体链接点，是相对于自身刚体的左上角位置偏移。
         */
        selfAnchor: any[];
        /**
         * @en The connected body's anchor point, which is the offset relative to the top left corner of the other body, effective only on the first setting.
         * @zh [首次设置有效]链接刚体链接点，是相对于otherBody的左上角位置偏移。
         */
        otherAnchor: any[];
        /**
         * @en Whether the two rigid bodies can collide with each other, default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为false。
         */
        collideConnected: boolean;
        /**
         * @en The target rest length of the constraint.
         * @zh 约束的目标静止长度。
         */
        get length(): number;
        set length(value: number);
        /**
         * @en The minimum length of the constraint.
         * @zh 约束的最小长度。
         */
        get minLength(): number;
        set minLength(value: number);
        /**
         * @en The maximum length of the constraint.
         * @zh 约束的最大长度。
         */
        get maxLength(): number;
        set maxLength(value: number);
        /**
         * @en The vibration frequency of a spring system indicates how quickly it completes one oscillation cycle. A higher value signifies a higher frequency, meaning it completes one oscillation cycle in a shorter time. Consequently, the oscillation amplitude is relatively smaller, and the oscillation speed is faster. Conversely, a lower frequency results in a larger oscillation amplitude and slower oscillation speed.
         * @zh 弹簧系统的振动频率，值越大表示振动频率越高，意味着在更短的时间内完成一个振动周期，所以，振动幅度相对较小，振动速度更快。反之，振动幅度相对较大，振动速度更慢。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the node, which is recommended to be between 0 and 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值在 0 到 1 之间。
         */
        get damping(): number;
        set damping(value: number);
        /**
         * @en The current length of the joint.
         * @zh 关节的当前长度。
         */
        get jointLength(): number;
        /**
         * @internal
         * @override
         */
        protected _createJoint(): void;
        /**@internal */
        _refeahJoint(): void;
        /**
         * @en Called when the object is being destroyed. This method removes event listeners to prevent memory leaks.
         * @zh 在对象被销毁时调用。此方法移除事件监听器以防止内存泄漏。
         */
        onDestroy(): void;
    }
    /**
     * @en Gear joint: used to simulate the constraint relationship between two gears. When a gear rotates, the momentum generated has two output modes: one is the angular velocity of the gear itself, and the other is the linear velocity on the gear surface
     * @zh 齿轮关节：用来模拟两个齿轮间的约束关系，齿轮旋转时，产生的动量有两种输出方式，一种是齿轮本身的角速度，另一种是齿轮表面的线速度
     */
    class GearJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 两个齿轮角速度比例，默认1*/
        private _ratio;
        private _joint1;
        private _joint2;
        /**
         * @en The first joint to be connected, which can be a RevoluteJoint or a PrismaticJoint, effective only on the first setting.
         * @zh [首次设置有效]要绑定的第一个关节，类型可以是旋转关节（RevoluteJoint）或者棱形关节（PrismaticJoint）。
         */
        set joint1(value: RevoluteJoint | PrismaticJoint);
        get joint1(): RevoluteJoint | PrismaticJoint;
        /**
         * @en The second joint to be connected, which can be a RevoluteJoint or a PrismaticJoint, effective only on the first setting.
         * @zh [首次设置有效]要绑定的第二个关节，类型可以是旋转关节（RevoluteJoint）或者棱形关节（PrismaticJoint）。
         */
        set joint2(value: RevoluteJoint | PrismaticJoint);
        get joint2(): RevoluteJoint | PrismaticJoint;
        /**
         * @en Specifies whether the two connected bodies should collide with each other. Default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The ratio of the angular velocities of the two gears.
         * @zh 两个齿轮的角速度比例。
         */
        get ratio(): number;
        set ratio(value: number);
        /**
         * @internal
         * @override
         */
        protected _createJoint(): void;
    }
    /**
     * @en Joint base class
     * @zh 关节基类
     */
    class JointBase extends Component {
        /**@internal 原生关节对象*/
        protected _joint: any;
        /**@internal */
        protected _factory: IPhysics2DFactory;
        readonly owner: Sprite;
        protected _physics2DManager: Physics2DWorldManager;
        protected _box2DJointDef: any;
        /**
         * @en [read-only] Native joint object.
         * @zh [只读]原生关节对象。
         */
        get joint(): any;
        constructor();
        getJointRecationForce(): Vector2;
        getJointRecationTorque(): number;
        isValid(): boolean;
        /**@internal */
        protected getBodyAnchor(body: ColliderBase, anchorx: number, anchory: number): Point;
        protected _onAdded(): void;
        /**@internal */
        protected _onEnable(): void;
        /**@internal */
        protected _onAwake(): void;
        /**@internal */
        protected _createJoint(): void;
        /**@internal */
        protected _onDisable(): void;
    }
    /**
     * @en Motor Joint: Allows specifying the relative position and angle between two rigid bodies, and then attempts to achieve these targets by applying forces and torques, striving to maintain this configuration.
     * @zh 马达关节：允许指定两个刚体间的相对位置和角度，然后尝试通过施加力和扭矩来达到这些目标，并会尽力维持这样的配置。
     */
    class MotorJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 基于otherBody坐标位置的偏移量，也是selfBody的目标位置*/
        private _linearOffset;
        /**@internal 基于otherBody的角度偏移量，也是selfBody的目标角度*/
        private _angularOffset;
        /**@internal 当selfBody偏离目标位置时，为使其恢复到目标位置，马达关节所施加的最大作用力*/
        private _maxForce;
        /**@internal 当selfBody角度与目标角度不同时，为使其达到目标角度，马达关节施加的最大扭力*/
        private _maxTorque;
        /**@internal selfBody向目标位置移动时的缓动因子，取值0~1，值越大速度越快*/
        private _correctionFactor;
        /**
         * @en The self body of the joint, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The other body connected by the joint, effective only on the first setting.
         * @zh [首次设置有效]关节的连接刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en Specifies whether the two connected bodies should collide with each other. Default is false, effective only on the first setting.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The offset from the other body's coordinates, which is also the target position for the self body.
         * @zh 基于 otherBody 坐标位置的偏移量，也是 selfBody 的目标位置。
         */
        get linearOffset(): any[];
        set linearOffset(value: any[]);
        /**
         * @en The angular offset based on the other body, which is also the target angle for the self body.
         * @zh 基于 otherBody 的角度偏移量，也是 selfBody 的目标角度。
         */
        get angularOffset(): number;
        set angularOffset(value: number);
        /**
         * @en The maximum force applied by the motor joint when the selfBody deviates from the target position. When the force applied by the motor joint exceeds the maximum force, the engine automatically limits the force to ensure it does not exceed the specified maximum value.
         * @zh 当 selfBody 偏离目标位置时，马达关节所施加的最大作用力。当马达关节施加的力超过最大力时，引擎会自动截断力的大小，使其不超过设定的最大值。
         */
        get maxForce(): number;
        set maxForce(value: number);
        /**
         * @en The maximum torque is used to ensure that when the torque applied by the motor joint exceeds the maximum torque value, the engine automatically limits the torque to not exceed the specified maximum value.
         * @zh 最大扭矩用于当马达关节施加的扭矩超过最大扭矩值时，引擎会自动截断扭矩的大小，以确保不超过设定的最大值。
         */
        get maxTorque(): number;
        set maxTorque(value: number);
        /**
         * @en The factor of easing when the self body moves towards the target position, with a value from 0 to 1, the larger the value, the faster the speed.
         * @zh selfBody 向目标位置移动时的缓动因子，取值 0~1，值越大速度越快。
         */
        get correctionFactor(): number;
        set correctionFactor(value: number);
        /**@internal */
        protected _createJoint(): void;
    }
    /**
     * @en Mouse joint: A physics constraint used to simulate the user dragging an object with the mouse. It typically allows a rigid body to follow the mouse cursor's movement while also being influenced by other physics effects such as collisions and gravity.
     * @zh 鼠标关节:一种用来模拟用户用鼠标拖拽物体的物理约束。它通常会使得一个刚体可以跟随鼠标移动，但同时也能受到其他物理效果如碰撞、重力等的影响。
     */
    class MouseJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 鼠标关节在拖曳刚体bodyB时施加的最大作用力*/
        private _maxForce;
        /**@internal 弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**@internal 刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**
         * @en The self rigid body of a joint, effective only on the first setting.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connection point of a joint is offset from the position of the upper left corner of its own rigid body. If not set, it is used as the connection point based on the mouse click point. Effective only on the first setting.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移，如果不设置，则根据鼠标点击点作为连接点。
         */
        anchor: any[];
        /**
         * @en Used to limit the maximum force that the mouse joint can apply when attempting to move an object towards the mouse position, preventing excessive force that could lead to abnormal behavior or unnatural effects.
         * @zh 用于限制鼠标关节试图将物体移向鼠标位置时所能施加的最大力量，避免力过大导致的异常行为或不自然的效果。
         */
        get maxForce(): number;
        set maxForce(value: number);
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient. The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the anchor, with a recommended value between 0 and 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值在 0 到 1 之间。
         */
        get damping(): number;
        set damping(value: number);
        /**@internal */
        protected _onEnable(): void;
        /**@internal */
        protected _createJoint(): void;
        /**@internal */
        private _onMouseDown;
        /**@internal */
        private _onStageMouseUp;
        /**@internal */
        private _onMouseMove;
        /**@internal */
        protected _onDisable(): void;
    }
    /**
     * @en Translation joint: A movement joint allows two objects to move relative to each other along a specified axis, but it prevents relative rotation
     * @zh 平移关节：移动关节允许两个物体沿指定轴相对移动，它会阻止相对旋转
     */
    class PrismaticJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**@internal 启用马达后，在axis坐标轴上移动可以达到的最大速度*/
        private _motorSpeed;
        /**@internal 启用马达后，可以施加的最大作用力*/
        private _maxMotorForce;
        /**@internal 是否对刚体的移动范围加以约束*/
        private _enableLimit;
        /**@internal 启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        private _lowerTranslation;
        /**@internal 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        private _upperTranslation;
        /**
        * @internal
        * @deprecated
        * @en A vector describing the axis of motion. For example, [1, 0] represents movement along the positive X-axis to the right. This setting is effective only on the first assignment.
        * @zh [首次设置有效]一个向量值，描述运动方向，比如1,0是沿X轴向右
        */
        _axis: any[];
        /**
         * @en The rigid body to which the joint is attached. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connected rigid body of the joint. It can be left unspecified, in which case it defaults to an empty rigid body at the top left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en The anchor point of the joint, which is the offset relative to the top-left corner of the own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的控制点，是相对于自身刚体左上角位置的偏移。
         */
        anchor: any[];
        /**
         * @en The angle describing the axis of motion, e.g., 0 degrees represents movement to the right along the X-axis. This setting is effective only on the first assignment.
         * @zh [首次设置有效]描述运动方向的角度，例如 0 度表示沿 X 轴向右移动。
         */
        angle: number;
        /**
         * @en Specifies whether the two connected rigid bodies should collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个刚体是否可以发生碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en Whether the motor is enabled to drive the connected body.
         * @zh 是否开启马达，开启马达可使目标刚体运动。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum speed that the motor can achieve along the axis when the motor is enabled.
         * @zh 启用马达后，在axis坐标轴上移动可以达到的最大速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum force that can be applied by the motor when it is enabled.
         * @zh 启用马达后，可以施加的最大作用力。
         */
        get maxMotorForce(): number;
        set maxMotorForce(value: number);
        /**
         * @en Whether to constrain the movement range of the rigid body.
         * @zh 是否对刚体的移动范围加以约束。
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit of the body's movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用限制后，刚体移动范围的下限，是距离anchor的偏移量。
         */
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**
         * @en The upper limit of the body's movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用限制后，刚体移动范围的上限，是距离anchor的偏移量。
         */
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * @en The axis of motion, which is a vector describing the direction of movement.
         * @zh 启用约束后，刚体移动范围的上限，是距离anchor的偏移量
         */
        get axis(): any;
        set axis(value: any);
        /**@internal */
        protected _createJoint(): void;
    }
    /**
     * @en PulleyJoint class, which connects two bodies to the ground and to each other, when one body rises, the other descends, simulating the behavior of a pulley system.
     * @zh 滑轮关节：它将两个物体接地(ground)并彼此连接，当一个物体上升，另一个物体就会下降
     */
    class PulleyJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**
         * @en The rigid body that is attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节相连的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]连接到关节的另一个刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en The anchor point of the rigid body relative to its top-left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]自身刚体的链接点，是相对于自身刚体左上角位置的偏移。
         */
        selfAnchor: any[];
        /**
         * @en The anchor point of the connected body relative to its top-left corner. This setting is effective only on the first assignment.
         * @zh [首次设置有效]连接刚体的链接点，是相对于otherBody左上角位置的偏移。
         */
        otherAnchor: any[];
        /**
         * @en The point on the pulley connected to the self anchor, relative to the top-left corner of the rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]滑轮上与自身刚体的 selfAnchor 相连的点，是相对于自身刚体左上角位置的偏移。
         */
        selfGroundPoint: any[];
        /**
         * @en The point on the pulley connected to the other anchor, relative to the top-left corner of the connected body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]滑轮上与连接刚体的 otherAnchor 相连的点，是相对于对方刚体左上角位置的偏移。
         */
        otherGroundPoint: any[];
        /**
         * @en The ratio of movement distances between the two connected rigid bodies. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个刚体的移动距离比率。
         */
        ratio: number;
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**@internal */
        protected _createJoint(): void;
    }
    /**
     * @en Rotating joint forces two objects to share an anchor point, and the two objects rotate relative to each other
     * @zh 旋转关节强制两个物体共享一个锚点，两个物体相对旋转
     */
    class RevoluteJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**@internal 启用马达后，可以达到的最大旋转速度*/
        private _motorSpeed;
        /**@internal 启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        private _maxMotorTorque;
        /**@internal 是否对刚体的旋转范围加以约束*/
        private _enableLimit;
        /**@internal 启用约束后，刚体旋转范围的下限角度*/
        private _lowerAngle;
        /**@internal 启用约束后，刚体旋转范围的上限角度*/
        private _upperAngle;
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connected rigid body. It can be optionally not set. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体，可以不设置。
         */
        otherBody: ColliderBase;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en Enables or disables the motor, which when enabled, drives the rotation of the target body.
         * @zh 启用或禁用马达，启用后可以驱动目标刚体的旋转。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum rotational speed that can be achieved when the motor is enabled.
         * @zh 启用马达后可以达到的最大旋转速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum torque that can be applied when the motor is enabled. Insufficient torque may result in no rotation.
         * @zh 启用马达后可以施加的最大扭距。如果最大扭矩太小，可能导致不旋转。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**
         * @en Whether to constrain the rotation range of the rigid body
         * @zh 是否对刚体的旋转范围加以约束
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit angle of the rotation range when the limit is enabled.
         * @zh 启用限制后，刚体旋转范围的下限角度。
         */
        get lowerAngle(): number;
        set lowerAngle(value: number);
        /**
         * @en The upper limit angle of the rotation range when the limit is enabled.
         * @zh 启用限制后，刚体旋转范围的上限角度。
         */
        get upperAngle(): number;
        set upperAngle(value: number);
        /** @internal */
        protected _createJoint(): void;
    }
    /**
     * @en WeldJoint class, used to constrain two bodies together so they cannot move relative to each other. The relative position and angle between the two bodies are fixed, making them appear as a single rigid body.
     * @zh 焊接关节：焊接关节的用途是使两个物体不能相对运动，受到关节的限制，两个刚体的相对位置和角度都保持不变，看上去像一个整体
     */
    class WeldJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**@internal 刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient.The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数。通常频率应该小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio of the body when returning to the anchor point, with a recommended value range of 0 to 1.
         * @zh 刚体在回归到节点过程中受到的阻尼比，建议取值0~1。
         */
        get damping(): number;
        set damping(value: number);
        /**@internal */
        protected _createJoint(): void;
    }
    /**
     * @en WheelJoint: Allows an object to rotate around a fixed axis relative to another object, while also providing spring-like resistance along the axis for bouncing back.
     * @zh 轮子关节：允许一个物体在另一个物体上以固定的轴向转动，同时还能沿着轴向弹簧回弹。
     */
    class WheelJoint extends JointBase {
        /**@internal */
        private static _temp;
        /**@internal 弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**@internal 刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**@internal 是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**@internal 启用马达后，可以达到的最大旋转速度*/
        private _motorSpeed;
        /**@internal 启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        private _maxMotorTorque;
        /**@internal 是否对刚体的移动范围加以约束*/
        private _enableLimit;
        /**@internal 启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        private _lowerTranslation;
        /**@internal 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        private _upperTranslation;
        /**
         * @en The rigid body that is locally attached to the joint. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节直接相连的自身刚体。
         */
        selfBody: ColliderBase;
        /**
         * @en The connected rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]与关节连接的另一个刚体。
         */
        otherBody: ColliderBase;
        /**
         * @en Link points of joints, it is offset from the position of the upper left corner of its own rigid body. This setting is effective only on the first assignment.
         * @zh [首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移。。
         */
        anchor: any[];
        /**
         * @en Specifies whether the two connected rigid bodies can collide with each other. Default is false. This setting is effective only on the first assignment.
         * @zh [首次设置有效]两个连接的刚体是否可以相互碰撞，默认为 false。
         */
        collideConnected: boolean;
        /**
         * @deprecated
         * [首次设置有效]一个向量值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，比如1,0是沿X轴向右，0,1是沿Y轴向下*/
        _axis: any[];
        /**
         * @en An angle value that defines the direction of elastic motion, i.e., the direction in which the wheel can compress and extend like a spring. For example, 0 degrees is along the X-axis to the right, and 90 degrees is along the Y-axis downward. This setting is effective only on the first assignment.
         * @zh [首次设置有效]一个角度值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，例如 0 度表示沿 X 轴正方向，90 度表示沿 Y 轴负方向。
         */
        angle: number;
        /**
         * @en The vibration frequency of the spring system, which can be considered as the spring's elasticity coefficient.The frequency should typically be less than half the time step frequency.
         * @zh 弹簧系统的振动频率，可以视为弹簧的弹性系数。通常频率应小于时间步长频率的一半。
         */
        get frequency(): number;
        set frequency(value: number);
        /**
         * @en The damping ratio that the body experiences when returning to the anchor point, with a recommended value range of 0 to 1.
         * @zh 刚体在回归到锚点过程中受到的阻尼比，建议取值范围为 0 到 1。
         */
        get damping(): number;
        set damping(value: number);
        /**
         * @en Whether the motor is enabled to drive the rotation of the connected body.
         * @zh 是否启用马达以驱动连接刚体的旋转。
         */
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**
         * @en The maximum rotational speed that can be achieved when the motor is enabled.
         * @zh 启用马达后可以达到的最大旋转速度。
         */
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**
         * @en The maximum torque that can be applied when the motor is enabled. Insufficient torque may result in no rotation.
         * @zh 启用马达后可以施加的最大扭距。如果最大扭矩太小，可能导致不旋转。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**
         * @en Whether the movement range of the connected body is limited.
         * @zh 是否对连接刚体的移动范围加以约束。
         */
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**
         * @en The lower limit of the movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用约束后，刚体移动范围的下限，是距离锚点的偏移量。
         */
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**
         * @en The upper limit of the movement range when the limit is enabled, as an offset from the anchor.
         * @zh 启用约束后，刚体移动范围的上限，是距离锚点的偏移量。
         */
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get axis(): any;
        set axis(value: any);
        /**@internal */
        protected _createJoint(): void;
    }
    /**
     * @en 2D Physics Engine
     * @zh 2D物理引擎
     */
    class Physics2D extends EventDispatcher {
        private static _I;
        static Physics2D: any;
        /**
         * @en Gets the global singleton instance of the Physics2D.
         * @zh 获取全局的 Physics2D 单例。
         */
        static get I(): Physics2D;
        /** 是否已经激活*/
        private _enabled;
        /**
         * @internal
         * @en An empty body node for joints that do not require a node.
         * @zh 给不需要节点的关节使用的空的 body 节点。
         */
        _emptyBody: any;
        _factory: IPhysics2DFactory;
        /**
         * @internal
         * @en Need to synchronize and update the data list in real-time.
         * @zh 需要同步实时更新数据列表。
         */
        _rigiBodyList: SingletonList<RigidBody>;
        /**@internal */
        _addRigidBody(body: RigidBody): void;
        /**@internal */
        _removeRigidBody(body: RigidBody): void;
        private _update;
        /**@internal */
        _updatePhysicsTransformToRender(): void;
        /**
         * @en Enables the physics world. This method initializes the physics engine and starts the simulation.
         * @zh 开启物理世界。此方法初始化物理引擎并启动模拟。
         */
        enable(): Promise<void>;
        /**
         * @en Starts the physics world. This method is called after the physics engine is initialized.
         * @zh 开启物理世界。此方法在物理引擎初始化后被调用。
         */
        start(): void;
        /**
         * @en Destroys the current physics world.
         * @zh 销毁当前物理世界。
         */
        destroyWorld(): void;
        /**
         * @en Stops the physics world.
         * @zh 停止物理世界。
         */
        stop(): void;
    }
    /**
     * @ignore
     * @blueprintIgnore
     */
    class Physics2DDebugDraw {
        _scene: Scene;
        _camera: any;
        _lineWidth: number;
        private _matrix;
        /**绘制需要使用的材质 */
        private _material;
        private _cmdBuffer;
        private _cmdDrawLineList;
        private _linePointsList;
        private _cmdDrawMeshList;
        private _meshList;
        constructor();
        setActive(value: boolean): void;
        private render;
        /**
         * 根据多边形顶点生成Mesh2D，不添加中心点
         * @param vertices 多边形顶点数组 [x1, y1, x2, y2, ...]
         * @returns 生成的Mesh2D对象
         */
        createMesh2DByVertices(vertices: any[]): Mesh2D;
        createCircleMeshByVertices(center: {
            x: number;
            y: number;
        }, radius: number, numSegments: number): Mesh2D;
        addMeshDebugDrawCMD(mesh2D: Mesh2D, color: Color, matrix?: Matrix): void;
        addLineDebugDrawCMD(points: any[], color: Color, lineWidth?: number, matrix?: Matrix): void;
        destroy(): void;
    }
    /**
     * @en Physics2DOption is used to configure default parameters for 2D physics
     * @zh Physics2DOption 用于配置2D物理的默认参数
     */
    class Physics2DOption {
        /**
         * @en Sets whether sleeping is allowed. Allowing sleep can improve stability and performance, but it usually comes at the cost of accuracy.The default is false.
         * @zh 设置是否允许休眠。允许休眠可以提高稳定性和性能，但通常会牺牲准确性。默认为否。
         */
        static allowSleeping: boolean;
        /**
         * @en Gravity acceleration, with a default value of 9.8, corresponding to 9.8 meters per second squared (m/s²) in the real world.
         * @zh 重力加速度，默认的重力加速度值为 9.8，对应于现实世界中的 9.8米/秒²（m/s²） 。
         */
        static gravity: {
            x: number;
            y: number;
        };
        /**
         * @en Indicates whether the update is performed externally.The default is false.
         * @zh 表示更新是否由外部执行。默认为否。
         */
        static customUpdate: boolean;
        /**
         * @en The number of velocity iterations. Increasing this number will improve accuracy but reduce performance.The default is 8.
         * @zh 旋转迭代次数。增大此数字会提高精度，但会降低性能。默认为8。
         */
        static velocityIterations: number;
        /**
         * @en The number of position iterations. Increasing this number will improve accuracy but reduce performance.The default is 3.
         * @zh 位置迭代次数。增大此数字会提高精度，但会降低性能。默认为3。
         */
        static positionIterations: number;
        /**
         * @en The conversion ratio between rendering pixels and physical units. By default, 1 length unit in the physics engine corresponds to 50 pixels. Modifying this value changes the number of pixels that correspond to 1 length unit in the physics engine.
         * @zh 渲染像素和物理单位的转换比率，物理引擎中的1长度单位默认转换为50个像素，修改此处可改变物理引擎1长度单位对应的渲染像素值。
         */
        static pixelRatio: number;
        /**
         * @en Whether to enable physics drawing.The default is true.
         * @zh 是否开启物理绘制。默认为是。
         */
        static debugDraw: boolean;
        /**
         * @en Whether to draw shapes.The default is true.
         * @zh 是否绘制形状。默认为是。
         */
        static drawShape: boolean;
        /**
         * @en Whether to draw joints.The default is true.
         * @zh 是否绘制关节。默认为是。
         */
        static drawJoint: boolean;
        /**
         * @en Whether to draw the Bounding Box.The default is false.
         * @zh 是否绘制包围盒。默认为否。
         */
        static drawAABB: boolean;
        /**
         * @en Whether to draw the center of mass.The default is false.
         * @zh 是否绘制质心。默认为否。
         */
        static drawCenterOfMass: boolean;
        static subStep: number;
    }
    /**
     * @en 2D physics world manager class for the scene
     * @zh 场景对应的2D物理管理类
     */
    class Physics2DWorldManager implements IElementComponentManager {
        /**
         * @en 2Dphysics manager class name
         * @zh 2D物理管理类类名
         */
        static __managerName: string;
        name: string;
        private _box2DWorld;
        private _pixelRatio;
        private _RePixelRatio;
        private _scene;
        private _subStep;
        private _velocityIterations;
        private _positionIterations;
        private _gravity;
        private _worldDef;
        private _eventList;
        private _debugDraw;
        private _jsDraw;
        private _contactListener;
        private _JSQuerycallback;
        private _JSRayCastcallback;
        private _allowWorldSleep;
        /**
         * @en Get the box2D world corresponding to the current scene
         * @zh 获取当前场景对应的box2D世界
         */
        get box2DWorld(): any;
        /**
         * @en Get the current gravity value of the physical world
         * @zh 获取当前物理世界的重力值
         */
        get gravity(): Vector2;
        /**
         * @en constructor method
         * @zh 构造方法
         * @param scene
         */
        constructor(scene: Scene | Sprite);
        Init(data: any): void;
        update(dt: number): void;
        /**
         * @zh 设置物理世界绑定的场景或根节点
         * @en Set the physics world bound to the scene or root node
         * @param scene 场景
         * @param scene scene
         */
        private setRootSprite;
        /**
         * @zh 设置重力向量
         * @param gravity 重力
         * @en Set the gravity vector
         * @param gravity gravity
         */
        setGravity(gravity: Vector2): void;
        /**
         * @zh 获取物理世界绑定的场景或根节点
         * @returns 场景或根节点
         * @en Get the physics world bound to the scene or root node
         * @returns Scene | Sprite
         */
        getRootSprite(): Scene | Sprite;
        /**
         * @zh 平移整个物理世界的远点
         * @en Shift the far point of the entire physics world
         * @param newOrigin 新的物理世界原点
         * @en New physics world origin
         */
        shiftOrigin(newOrigin: Vector2): void;
        /**
         * @zh 设置是否开启物理世界的Debug绘制
         * @param enable 是否开启
         * @param bli 绘制模式
         * @en Set whether to enable the debug drawing of the physics world
         * @param enable enable
         * @param bli blit mode
         */
        enableDebugDraw(enable: boolean, bli: EPhycis2DBlit): void;
        /**
         * @zh 设置物理世界像素对照单位
         * @param pixelRatio 设置像素比例
         * @en Set the pixel ratio of the physics world
         * @param pixelRatio The pixel ratio of the physics world
         */
        setPixel_Ratio(pixelRatio: number): void;
        /**
         * @zh 获取物理世界像素对照单位
         * @en Get the pixel ratio of the physics world
         * @returns The pixel ratio of the physics world
         * @returns 获取物理世界像素对照单位
         */
        getPixel_Ratio(): number;
        /**
         * @zh 设置物理世界子步迭代次数
         * @param subStep 设置物理世界子步迭代次数
         * @en Set the number of substeps in the physics world
         * @param subStep The number of substeps in the physics world
         */
        setSubStep(subStep: number): void;
        /**
         * @zh 获取物理世界子步迭代次数
         * @returns 获取物理世界子步迭代次数
         * @en Get the number of substeps in the physics world
         * @returns The number of substeps in the physics world
         */
        getSubStep(): number;
        /**
         * @zh 派发物理世界的事件
         * @en dispath the events of the physics2d world
         */
        sendEvent(): void;
        /**
         * @zh 设置物理世界模拟中速度的迭代次数，迭代次数越多越精确，性能越差.
         * @param velocityIterations 速度迭代次数
         * @en Set the number of iterations of the physics world simulation, the more iterations, the more accurate, but the more performance.
         * @param velocityIterations velocityIterations
         */
        setVelocityIterations(velocityIterations: number): void;
        /**
         * @zh 获取物理世界模拟中速度的迭代次数.
         * @returns 速度迭代次数
         * @en Get the number of iterations of the physics world simulation.
         * @returns velocityIterations
         */
        getVelocityIterations(): number;
        /**
         * @zh 设置物理世界模拟中位置的迭代次数.
         * @en Set the number of iterations of the physics world simulation.
         * @param positionIterations 位置迭代次数
         * @param positionIterations positionIterations
         */
        setPositionIterations(positionIterations: number): void;
        /**
         * @zh 获取物理世界模拟中位置的迭代次数.
         * @returns 位置迭代次数.
         * @en Get the number of iterations of the physics world simulation.
         * @returns positionIterations.
         */
        getPositionIterations(): number;
        /**
         * @zh 获取物理世界中刚体的数量.
         * @returns 刚体的数量.
         * @en Get the number of bodies in the physics world.
         * @returns bodyCount.
         */
        getBodyCount(): number;
        /**
         * @zh 获取物理世界中关节的数量.
         * @returns 关节的数量.
         * @en Get the number of joints in the physics world.
         * @returns jointCount.
         */
        getJointCount(): number;
        /**
         * @zh 获取物理世界中碰撞的数量.
         * @returns 碰撞的数量.
         * @en Get the number of collisions in the physics world.
         * @returns contactCount.
         */
        getContactCount(): number;
        /**
         * @zh 将Laya坐标转换到物理坐标系.
         * @param value Laya坐标.
         * @returns Physics2D坐标.
         * @en Convert Laya coordinates to physics coordinates.
         * @param value Laya coordinates.
         * @returns Physics2D coordinates.
         */
        layaToPhysics2D(value: number): number;
        /**
         * @zh 将物理坐标系转换到Laya坐标.
         * @param value Physics2D坐标.
         * @returns Laya坐标.
         * @en Convert physics coordinates to Laya coordinates.
         * @param value Physics2D coordinates.
         * @returns Laya coordinates.
         */
        physics2DToLaya(value: number): number;
        /**
         * @zh 清除场景中所有的力
         * @en Clear all forces in the scene
         */
        clearAllForces(): void;
        /**
         * @zh 查询物理世界中所有可能与提供的AABB重叠的内容
         * @param res 返回的ColliderBase数组
         * @param bounds 要查询的AABB包围盒
         * @en Query the physical world for all possible overlaps with the provided AABB
         * @param res Returned ColliderBase array
         * @param bounds The AABB bounding box to query
         */
        QueryAABB(res: ColliderBase[], bounds: any): void;
        /**
         * @zh 查询物理世界中对射线路径上的所有形状，可以获取最近点、任意点、还是 n 点。射线投射会忽略包含起点的形状。
         * @param startPos 射线开始位置
         * @param endPos 射线结束位置
         * @en Query the physical world for all shapes on a ray path, either the closest point, any point, or n points. Ray casting ignores shapes that contain the starting point.
         * @param startPos ray start position
         * @param endPos ray end position
         */
        RayCast(res: Physics2DHitResult[], startPos: Vector2, endPos: Vector2): void;
        /**
         * @zh 销毁物理世界。
         * @en Destroy the physics world.
         */
        destroy(): void;
        private _worldBeginContactCallback;
        private _worldEndContactCallback;
        private _worldPreSolveCallback;
        private _worldPostSolveCallback;
        private _worldBeginTriggerCallback;
        private _worldEndTriggerCallback;
        private _worldPreTriggerCallback;
        private _worldPostTriggerCallback;
        private _worldContactCallback;
        private _makeStyleString;
        private _enableBox2DDraw;
        private _debugDrawSegment;
        private _debugDrawPolygon;
        private _debugDrawSolidPolygon;
        private _debugDrawCircle;
        private _debugDrawSolidCircle;
        private _debugDrawTransform;
        private _debugDrawPoint;
        private _debugDrawAABB;
        private _dispatchEvent;
    }
    class PhysicsDrawLine2DCMD extends Command2D {
        private static readonly _pool;
        _renderElements: IRenderElement2D[];
        private _physicsGeometry;
        private _material;
        get physicsGeometry(): PhysicsLineGemetry;
        static create(pointArray: number[], mat: Matrix, color?: Color, lineWidth?: number): PhysicsDrawLine2DCMD;
        private _drawElementData;
        private _needUpdateElement;
        private _matrix;
        private _shaderData;
        private _struct;
        private _renderGeometry;
        constructor();
        set lineWidth(value: number);
        set color(value: Color);
        _setMatrix(value: Matrix): void;
        /**
       * @override
       * @internal
       * @returns
       */
        getRenderCMD(): Draw2DElementCMD;
        /**
         * @en Runs the  command.
         * @zh 运行命令。
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         * @en Recovers the render command for reuse.
         * @zh 回收渲染命令以供重用。
         */
        recover(): void;
    }
    /**
     * @en Physics line geometry class
     * @zh 物理线段几何体类
     */
    class PhysicsLineGemetry {
        private _positions;
        private _needUpdate;
        private _maxLineNumer;
        private _enLarge;
        private _renderGeometry;
        private _positionInstansBufferData;
        private _positionVertexBuffer;
        private _lineLengthBufferData;
        private _lineLengthVertexBuffer;
        /**
         * @en Set the line segment data in the format [beginX, beginY, endX, endY, beginX, beginY, endX, endY, ...]. Data must be in multiples of 4
         * @zh 设置线段数据，格式为[beginX,beginY,endX,endY,beginX,beginY,endX,endY,...]，数据必须是4的倍数
         */
        get positions(): number[];
        set positions(value: number[]);
        /**
         * @en Get the render geometry
         * @zh 获取渲染几何体
         */
        get renderGeometry(): IRenderGeometryElement;
        /**
         * @en Clear all line segments
         * @zh 清空所有线段
         */
        clear(): void;
        /**
         * @en Update geometry data
         * @zh 更新几何体数据
         */
        updateGeometry(): void;
        /**
         * @en Initialize render geometry
         * @zh 初始化渲染几何体
         */
        initRender(): void;
        /**
         * @en Change geometry data
         * @zh 改变几何体数据
         */
        private _changeGeometry;
        /**
         * @en Constructor
         * @zh 构造函数
         */
        constructor();
    }
    class PhysicsLineShader {
        static LINEWIDTH: number;
        static DASHED: number;
        static TILINGOFFSET: number;
        static linePoisitionDesc: VertexDeclaration;
        static lineLengthDesc: VertexDeclaration;
        /**
         * @internal
         */
        static _vbs: IVertexBuffer;
        /**
         * @internal
         */
        static _ibs: IIndexBuffer;
        private static _isInit;
        static __init__(): void;
    }
    /**
     * @en 2D rigidbody, display objects are bound to the physics world through RigidBody to keep the positions of physics and display objects synchronized.
     * Changes in the position of the physics world will be automatically synchronized to the display object, and the displacement and rotation of the display object itself (displacement of the parent object is invalid) will also be automatically synchronized to the physics world.
     * If you want to move the physics world as a whole, you can set Physics2D.I.worldRoot = scene, and then move the scene.
     * @zh 2D刚体，显示对象通过RigidBody和物理世界进行绑定，保持物理和显示对象之间的位置同步。
     * 物理世界的位置变化会自动同步到显示对象，显示对象本身的位移，旋转（父对象位移无效）也会自动同步到物理世界。
     * 如果想整体位移物理世界，可以设置 Physics2D.I.worldRoot = 场景，然后移动场景即可。
     */
    class RigidBody extends ColliderBase {
        /** 是否允许休眠，允许休眠能提高性能*/
        protected _allowSleep: boolean;
        /** 角速度，设置会导致旋转*/
        protected _angularVelocity: number;
        /** 旋转速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        protected _angularDamping: number;
        /** 线性运动速度，比如{x:10,y:10}*/
        protected _linearVelocity: IV2;
        /** 线性速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        protected _linearDamping: number;
        /** 是否高速移动的物体，设置为true，可以防止高速穿透*/
        protected _bullet: boolean;
        /** 是否允许旋转，如果不希望刚体旋转，这设置为false*/
        protected _allowRotation: boolean;
        /** 重力缩放系数，设置为0为没有重力*/
        protected _gravityScale: number;
        /**@deprecated 兼容模式下获取owner的其他collider碰撞形状 */
        private _colliders;
        /**
         * @deprecated is deprecated, use shape's filter instead.
         * @en [Read-only] Specifies the collision group to which the body belongs, default is 0, the collision rules are as follows:
         * 1. If the group values of two objects are equal:
         *    - If the group value is greater than zero, they will always collide.
         *    - If the group value is less than zero, they will never collide.
         *    - If the group value is equal to 0, then rule 3 is used.
         * 2. If the group values are not equal, then rule 3 is used.
         * 3. Each rigidbody has a category, this property receives a bit field, the range is the power of 2 in the range of [1,2^31].
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @deprecated 已废弃，通过设置刚体shape的filter来设置这个参数.
         * @zh [只读] 指定了该主体所属的碰撞组，默认为0，碰撞规则如下：
         * 1. 如果两个对象 group 相等：
         *    - group 值大于零，它们将始终发生碰撞。
         *    - group 值小于零，它们将永远不会发生碰撞。
         *    - group 值等于0，则使用规则3。
         * 2. 如果 group 值不相等，则使用规则3。
         * 3. 每个刚体都有一个 category 类别，此属性接收位字段，范围为 [1,2^31] 范围内的2的幂。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        group: number;
        /**
         * @deprecated is deprecated, please use shape's catalogy instead.
         * @en [Read-only] Collision category, specified using powers of 2, with 32 different collision categories available.
         * @deprecated 已废弃，通过设置刚体shape的filter来设置
         * @zh [只读] 碰撞类别，使用2的幂次方值指定，有32种不同的碰撞类别可用。
         */
        category: number;
        /**
         * @deprecated is deprecated, use shape's filter instead.
         * @en [Read-only] Specifies the category of collision bit mask, the result of category bitwise operation.
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @deprecated 已废弃，通过设置刚体shape的filter来设置
         * @zh [只读] 指定冲突位掩码碰撞的类别，category 位操作的结果。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        mask: number;
        /**
         * @en [Read-only] Custom label.
         * @zh [只读] 自定义标签。
         */
        label: string;
        readonly owner: Sprite;
        /**
         * @zh 碰撞形状，可以是多个
         */
        private _shapes;
        /**
         * @zh 是否兼容Collider组件的方式
         */
        private _applyOwnerColliderComponent;
        /**
         * @en The original body object.
         * @zh 原始body对象。
         */
        get body(): any;
        /**
         * @en The type of the rigid body. Supports two types: dynamic, and kinematic.
         * - dynamic: Dynamic type, affected by gravity.
         * - kinematic: Kinematic type, not affected by gravity, can be moved by applying velocity or force.
         * @zh 刚体类型，支持两种类型：dynamic 和 kinematic。
         * - dynamic：动态类型，受重力影响。
         * - kinematic：运动类型，不受重力影响，可以通过施加速度或者力的方式使其运动。
         */
        get type(): RigidBody2DType;
        set type(value: RigidBody2DType);
        /**
         * @en The gravity scale factor. Set it to 0 for no gravity.
         * @zh 重力缩放系数，设置为 0 表示没有重力。
         */
        get gravityScale(): number;
        set gravityScale(value: number);
        /**
         * @en Allowing rotation means that when a force or impact is applied to the rigid body, it will naturally rotate according to physical rules. If you do not want the rigid body to rotate, set this to false.
         * @zh 允许旋转是指当力或者冲击作用于该刚体时，它会按照物理规则进行自然旋转，如果不希望刚体旋转，请设置为 false。
         */
        get allowRotation(): boolean;
        set allowRotation(value: boolean);
        /**
         * @en Whether to allow sleeping. Allowing sleeping can improve performance but may result in the inability to respond immediately.
         * @zh 是否允许休眠，允许休眠能提高性能，但会导致无法即时响应。
         */
        get allowSleep(): boolean;
        set allowSleep(value: boolean);
        /**
         * @en The angular damping coefficient. It can range from 0 to infinity, where 0 means no damping and infinity means full damping. Normally, the damping value should be between 0 and 0.1.
         * @zh 旋转速度阻尼系数，范围可以在 0 到无穷大之间，0 表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在 0 到 0.1 之间。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * @en The angular velocity. Setting it will cause rotation.
         * @zh 角速度，设置会导致旋转。
         */
        get angularVelocity(): number;
        set angularVelocity(value: number);
        /**
         * @en The linear damping coefficient. It can range from 0 to infinity, where 0 means no damping and infinity means full damping. Normally, the damping value should be between 0 and 0.1.
         * @zh 线性速度阻尼系数，范围可以在 0 到无穷大之间，0 表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在 0 到 0.1 之间。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * @en The linear velocity, such as {x: 5, y: 5}.
         * @zh 线性运动速度，例如 {x: 5, y: 5}。
         */
        get linearVelocity(): IV2;
        set linearVelocity(value: IV2);
        /**
         * @en Whether it is a high-speed moving object. Setting it to true can prevent high-speed penetration.
         * @zh 是否为高速移动的物体，设置为 true 可以防止高速穿透。
         */
        get bullet(): boolean;
        set bullet(value: boolean);
        /**
         * @zh 刚体的碰撞形状
         * @en Collision shape of the rigid body
         */
        get shapes(): Physics2DShapeBase[];
        set shapes(shapes: Physics2DShapeBase[]);
        /**
         * @zh 是否应用旧版的Collider组件的兼容方式
         * @en Whether to use the old version of the Collider component compatibility method
         */
        get applyOwnerColliderComponent(): boolean;
        set applyOwnerColliderComponent(value: boolean);
        /**
         * @zh 强制设置刚体的位置
         * @en Enforce the position of a rigid body
         */
        set position(pos: Point);
        /**
         * @zh 获取当前刚体的位置
         * @en Get the position of the current rigid body
         */
        get position(): Point;
        /**
         * @zh 强制设置刚体的旋转（弧度）
         * @en Force the rotation of the rigidbody (in radians)
         */
        set rotation(number: number);
        /**
         * @zh 获取当前刚体的角度
         * @en Get the angle of the current rigid body
         */
        get rotation(): number;
        constructor();
        /**
         * @internal
         * @en Synchronize the body type.
         * @zh 同步刚体类型。
         */
        _updateBodyType(): void;
        /** @internal */
        _globalChangeHandler(flag: number): void;
        protected _onAwake(): void;
        /**
         * @en Update the body structure data.
         * @zh 更新刚体结构体的数据
         */
        private _setBodyDefValue;
        /** @internal */
        _onEnable(): void;
        /**
         * @en Get the box2DBody of the rigid body
         * @returns box2DBody
         * @zh 获取刚体的box2DBody
         * @returns box2DBody
         */
        getBody(): any;
        /**
         * @internal
         * @en Synchronize physics coordinates to game coordinates. Called by the system.
         * @zh 同步物理坐标到游戏坐标，由系统调用。
         */
        _updatePhysicsTransformToRender(): void;
        private _destroyAllShape;
        /**@internal */
        _onDisable(): void;
        /**@internal */
        _onDestroy(): void;
        /**
         * @zh 获取刚体的自定义数据
         * @returns 自定义数据
         * @en Get custom data of rigid body
         * @returns custom data
         */
        getUserData(): any;
        /**
         * @zh 获取刚体在世界坐标下某一点的线速度，比如刚体边缘的线速度(考虑旋转的影响)
         * @returns 线速度
         * @en Get the linear velocity of a rigid body at a certain point in the world coordinate system, such as the linear velocity of the edge of the rigid body (considering the influence of rotation)
         * @returns linearVelocity
         */
        getLinearVelocityFromWorldPoint(worldPoint: Vector2): Vector2;
        /**
         * @zh 获取刚体在局部坐标下某一点的线速度，比如刚体边缘的线速度(考虑旋转的影响)
         * @returns 线速度
         * @en Get the linear velocity of a point on a rigid body in local coordinates, such as the linear velocity of the edge of the rigid body (considering the influence of rotation)
         * @returns linearVelocity
         */
        getLinearVelocityFromLocalPoint(localPoint: Vector2): Vector2;
        /**
         * @en Apply force to the rigid body.
         * @param position The point where the force is applied, such as {x: 100, y: 100}, in global coordinates.
         * @param force The force to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 对刚体施加力。
         * @param position 施加力的点，如 {x: 100, y: 100}，全局坐标。
         * @param force 施加的力，如 {x: 0.1, y: 0.1}。
         */
        applyForce(position: IV2, force: IV2): void;
        /**
         * @en Apply force to the center of the rigid body to prevent object rotation.
         * @param force The force to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 从中心点对刚体施加力，防止对象旋转。
         * @param force 施加的力，如 {x: 0.1, y: 0.1}。
         */
        applyForceToCenter(force: IV2): void;
        /**
         * @en Apply linear impulse. The added velocity impulse will be combined with the rigid body's original velocity to produce a new velocity.
         * @param position The point where the impulse is applied, such as {x: 100, y: 100}, in global coordinates.
         * @param impulse The velocity impulse to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度。
         * @param position 施加力的点，如 {x: 100, y: 100}，全局坐标。
         * @param impulse 施加的速度冲量，如 {x: 0.1, y: 0.1}。
         */
        applyLinearImpulse(position: IV2, impulse: IV2): void;
        /**
         * @en Apply linear impulse to the center. The added velocity impulse will be combined with the rigid body's original velocity to produce a new velocity.
         * @param impulse The velocity impulse to be applied, such as {x: 0.1, y: 0.1}.
         * @zh 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度。
         * @param impulse 施加的速度冲量，如 {x: 0.1, y: 0.1}。
         */
        applyLinearImpulseToCenter(impulse: IV2): void;
        /**
         * @zh 施加角速度冲量
         * @param impulse 角速度冲量
         * @en Apply angular velocity impulse
         * @param impulse angular impulse
         */
        applyAngularImpulse(impulse: number): void;
        /**
         * @en Apply torque to the rigid body to make it rotate.
         * @param torque The torque to be applied.
         * @zh 对刚体施加扭矩，使其旋转。
         * @param torque 施加的扭矩。
         */
        applyTorque(torque: number): void;
        /**
         * @en Set the velocity, such as {x: 10, y: 10}.
         * @param velocity The velocity to be set.
         * @zh 设置速度，例如 {x: 10, y: 10}。
         * @param velocity 要设置的速度。
         */
        setVelocity(velocity: IV2): void;
        /**
         * @en Set the angle.
         * @param value The angle value in degrees.
         * @zh 设置角度。
         * @param value 角度值，单位为度。
         */
        setAngle(value: number): void;
        /**
         * @en Get the mass of the rigid body.
         * @zh 获得刚体质量。
         */
        getMass(): number;
        /**
         * @en Get the offset of the center of mass relative to the node's (0, 0) point.
         * @zh 获得质心相对于节点 (0, 0) 点的位置偏移。
         */
        getCenter(): IV2;
        /**
         * @en Get the inertia of the rigid body.
         * @zh 获得刚体的惯性张量。
         * @returns
         */
        getInertia(): number;
        /**
         * @en Get the world coordinates of the center of mass, relative to the Physics2D.I.worldRoot node.
         * @zh 获得质心的世界坐标，相对于 Physics2D.I.worldRoot 节点。
         */
        getWorldCenter(): IV2;
        /**
         * @en Get the world coordinates relative to the body.
         * @param x The x-coordinate in pixels.
         * @param y The y-coordinate in pixels.
         * @zh 获得相对于 body 的世界坐标。
         * @param x 像素坐标的 x 值。
         * @param y 像素坐标的 y 值。
         */
        getWorldPoint(x: number, y: number): Readonly<Point>;
        /**
         * @en Get the local coordinates relative to the body.
         * @param x The x-coordinate in pixels.
         * @param y The y-coordinate in pixels.
         * @zh 获得相对于 body 的本地坐标。
         * @param x 像素坐标的 x 值。
         * @param y 像素坐标的 y 值。
         */
        getLocalPoint(x: number, y: number): Readonly<Point>;
    }
    /**
     * @zh 2D物理矩形碰撞形状
     * @en 2D physics box collision shape
     */
    class BoxShape2D extends Physics2DShapeBase {
        private _width;
        private _height;
        /**
         * @en Rectangle height of collision body
         * @zh 2D物理矩形碰撞形状高度
         */
        get height(): number;
        set height(value: number);
        /**
         * @en Rectangle width of collision body
         * @zh 2D物理矩形碰撞形状宽度
         */
        get width(): number;
        set width(value: number);
        /**
        * @en Constructor method
        * @zh 构造方法
        */
        constructor();
        /**
         * @internal
         */
        protected _createShape(): void;
        /**
         * @internal
         */
        protected _updateShapeData(): void;
        clone(): BoxShape2D;
        cloneTo(destObject: BoxShape2D): void;
    }
    /**
     * @en 2Dphysics chain shape
     * @zh 2D物理链形碰撞形状
     */
    class ChainShape2D extends Physics2DShapeBase {
        /**@internal 顶点数据*/
        private _datas;
        /**@internal 是否是闭环，注意不要有自相交的链接形状，它可能不能正常工作*/
        private _loop;
        /**
         * @en Vertex data x,y,x,y ...
         * @zh 顶点数据 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        /**
         * @en Whether it is a closed loop. Ensure there are no self-intersecting link shapes, as they may not function properly.
         * @zh 是否是闭环，注意不要有自相交的链接形状，否则它可能不能正常工作
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
        * @en Constructor method
        * @zh 构造方法
        */
        constructor();
        /**
         * @internal
         * @override
         */
        protected _createShape(): void;
        /**
         * @internal
         * @override
         */
        protected _updateShapeData(): void;
        clone(): ChainShape2D;
        cloneTo(destObject: ChainShape2D): void;
    }
    /**
     * @en 2Dphysics circle shape
     * @zh 2D物理圆形碰撞体
     */
    class CircleShape2D extends Physics2DShapeBase {
        private _radius;
        /**
         * @en Circular radius, must be a positive number
         * @zh 圆形半径，必须为正数
        */
        get radius(): number;
        set radius(value: number);
        constructor();
        protected _createShape(): void;
        protected _updateShapeData(): void;
        clone(): CircleShape2D;
        cloneTo(destObject: CircleShape2D): void;
    }
    /**
     * @en 2Dphysics edge shape.
     * @zh 2D物理边缘碰撞形状。
     */
    class EdgeShape2D extends Physics2DShapeBase {
        /**@internal 顶点数据*/
        private _datas;
        /**
         * @en Vertex data in the format of x,y,x,y ...
         * @zh 顶点数据，格式为 x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
        protected _createShape(): void;
        protected _updateShapeData(): void;
        clone(): EdgeShape2D;
        cloneTo(destObject: EdgeShape2D): void;
    }
    /**
     * @zh 2D物理碰撞形状基类
     * @en Base class of 2D physics collision shapes
     */
    class Physics2DShapeBase implements IClone {
        protected _shapeDef: Box2DShapeDef;
        private _filterData;
        protected _box2DFilter: any;
        private _isSensor;
        private _density;
        private _friction;
        private _restitution;
        protected _box2DBody: any;
        protected _body: ColliderBase;
        private _restitutionThreshold;
        protected _box2DShapeDef: any;
        protected _box2DShape: any;
        protected _physics2DManager: Physics2DWorldManager;
        /**@internal 相对节点的x轴偏移*/
        private _x;
        /**@internal 相对节点的y轴偏移*/
        private _y;
        /**
         * @en The x-axis offset relative to the node.
         * @zh 相对于节点的 x 轴偏移。
         */
        get x(): number;
        set x(value: number);
        /**
         * @en The y-axis offset relative to the node.
         * @zh 相对于节点的 y 轴偏移。
         */
        get y(): number;
        set y(value: number);
        /**
         * @zh 碰撞分组数据，用来设置当前形状碰撞时候的分组数据
         * @en Collision grouping data, used to set the grouping data when the current shape collides
         */
        get filterData(): FilterData;
        set filterData(value: FilterData);
        /**
         * @en The density value. The value can be zero or a positive number. It is recommended to use similar densities to improve stacking stability. The default value is 10.
         * @zh 密度值。值可以为零或者是正数，建议使用相似的密度以改善堆叠稳定性。默认值为 10。
         */
        get density(): number;
        set density(value: number);
        /**
         * @en The restitution coefficient. The value ranges from 0 to 1, the larger the value, the greater the elasticity. The default value is 0.
         * @zh 弹性系数。取值范围0-1，值越大，弹性越大。默认值为0。
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * @en Restitution velocity threshold, usually in meters per second. Collisions above this velocity will have restitution applied (will bounce).
         * @zh 恢复速度阈值，通常以米/秒为单位。高于此速度的碰撞将应用恢复（将反弹）。
         */
        get restitutionThreshold(): number;
        set restitutionThreshold(value: number);
        /**
         * @en The friction coefficient. The value ranges from 0 to 1, the larger the value, the greater the friction. The default value is 0.2.
         * @zh 摩擦力。取值范围0-1，值越大，摩擦越大。默认值为0.2。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @en Whether the object is a sensor. A sensor can trigger collision events but does not produce collision responses.
         * @zh 是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应
         */
        get isSensor(): boolean;
        set isSensor(value: boolean);
        /**
         * @internal
         * 获得节点的全局缩放X
         */
        protected get scaleX(): number;
        /**
         * @internal
         * 获得节点的全局缩放Y
         */
        protected get scaleY(): number;
        /**@internal 创建获得相对于描点x的偏移 */
        protected get pivotoffx(): number;
        /**@internal 创建获得相对于描点y的偏移 */
        protected get pivotoffy(): number;
        /**
         * @en constructor method
         * @zh 构造方法
         */
        constructor();
        /**
         * @zh 更新碰撞分组数据
         * @en Update collision group data
         */
        private _updateFilterData;
        /**
         * @internal
         * @en Set the collision volume to which the shape belongs and initialize the content
         * @param body The collision body
         * @zh 设置形状所属的碰撞体并初始化内容
         * @param body 所属的碰撞体
         */
        setCollider(body: ColliderBase): void;
        private _initShape;
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @override
         */
        protected _updateShapeData(): void;
        /**
         * @en Get the axis-aligned bounding box corresponding to the shape
         * @returns box2D's AABB bounding box
         * @zh 获取形状对应的轴对齐包围盒
         * @returns box2D的AABB包围盒
         */
        getAABB(): any;
        /**
         * @zh 检测射线是否与形状相交
         * @param index index通常用于ChainShape与PolygonShape等多形状的对象，CircleShape、EdgeShape等默认为0
         * @returns 是否相交
         * @en Check if a ray intersects a shape
         * @param index Index is usually used for objects with multiple shapes such as ChainShape and PolygonShape. The default value for CircleShape, EdgeShape, etc. is 0.
         * @returns Whether it intersects
         */
        rayCast(index?: number): boolean;
        /**
         * @en Destroy shape
         * @zh 销毁形状
         */
        destroy(): void;
        clone(): void;
        cloneTo(destObject: Physics2DShapeBase): void;
    }
    /**
     * @en 2Dphysics polygon collider. Concave polygons are currently not supported. If it is a concave polygon, manually split it into multiple convex polygons first.
     * The maximum number of vertices is `b2_maxPolygonVertices`, which defaults to 8. So it is not recommended to exceed 8 points, and it cannot be less than 3.
     * @zh 2D物理多边形碰撞体，暂时不支持凹多边形，如果是凹多边形，先手动拆分为多个凸多边形。
     * 节点个数最多是 `b2_maxPolygonVertices`，这数值默认是8，所以点的数量不建议超过8个，也不能小于3个。
     */
    class PolygonShape2D extends Physics2DShapeBase {
        /**@internal 顶点数据*/
        private _datas;
        /**
         * @en Vertex data in the format: x,y,x,y ...
         * @zh 顶点数据，格式：x,y,x,y ...
         */
        get datas(): number[];
        set datas(value: number[]);
        constructor();
        protected _createShape(): void;
        protected _updateShapeData(): void;
        clone(): PolygonShape2D;
        cloneTo(destObject: PolygonShape2D): void;
    }
    /**
     * @en 2Dphysics Static Collider
     * @zh 2D物理静态碰撞体
     */
    class StaticCollider extends ColliderBase {
        /**
         * @en [Read-only] Custom label.
         * @zh [只读] 自定义标签。
         */
        label: string;
        private _shapes;
        /**
         * @zh 2D物理静态碰撞体类型，只能为"static"类型
         * @en A 2D physics static body must have a type of 'static'.
         */
        get type(): RigidBody2DType;
        set type(value: RigidBody2DType);
        /**
         * @zh 2D物理静态碰撞体的碰撞形状数组
         * @en Array of collision shapes for a 2D physics static body
         */
        get shapes(): Physics2DShapeBase[];
        set shapes(value: Physics2DShapeBase[]);
        constructor();
        private _setBodyDefValue;
        protected _onAwake(): void;
        protected _onEnable(): void;
        _removeShapeAndDestroyData(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
        /**
        * @deprecated 兼容方法
        * @param collider
        */
        createShape(collider: RigidBody): void;
        protected _setShapeData(shape: any): void;
        /**@deprecated 兼容方法 */
        _setRigidbodyValue(collider: RigidBody): void;
    }
    interface IPhyDebugDrawer {
        /**
         * @en Set the color.
         * @param c The color value.
         * @zh 设置颜色。
         * @param c 颜色值。
         */
        color(c: number): void;
        /**
         * @en Draw a line.
         * @param sx Start point x coordinate.
         * @param sy Start point y coordinate.
         * @param sz Start point z coordinate.
         * @param ex End point x coordinate.
         * @param ey End point y coordinate.
         * @param ez End point z coordinate.
         * @zh 绘制线段。
         * @param sx 起点 x 坐标。
         * @param sy 起点 y 坐标。
         * @param sz 起点 z 坐标。
         * @param ex 终点 x 坐标。
         * @param ey 终点 y 坐标。
         * @param ez 终点 z 坐标。
         */
        line(sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): void;
        /**
         * @en Clear drawn lines.
         * @zh 清除画线结果。
         */
        clear(): void;
    }
    /**
     * @internal
     */
    class BulletInteractive {
        mem: WebAssembly.Memory;
        dbgLine: IPhyDebugDrawer;
        /**
         * @ignore
         * @en Creates an instance of BulletInteractive.
         * @param mem WebAssembly memory.
         * @param dbgline If you want to display physical lines, you need to set this.
         * @zh 创建一个 BulletInteractive 的实例。
         * @param mem WebAssembly 内存。
         * @param dbgline 如果要显示物理线框，要设置这个。
         */
        constructor(mem: WebAssembly.Memory, dbgline: IPhyDebugDrawer);
        /**
         * @en Dynamic physical body, called once when initialized, Kinematic physical body, called every physical tick (if not in sleep state), let the physical engine know the position of the body.
         * @param rigidBodyID The ID of the rigid body.
         * @param worldTransPointer Pointer to the world transform data.
         * @zh Dynamic刚体,初始化时调用一次,Kinematic刚体,每次物理tick时调用(如果未进入睡眠状态),让物理引擎知道刚体位置。
         * @param rigidBodyID 刚体的 ID。
         * @param worldTransPointer 世界变换数据的指针。
         */
        getWorldTransform(rigidBodyID: number, worldTransPointer: number): void;
        /**
         * @en Dynamic physical body, the physical engine calls it once every frame, used to update the rendering matrix.
         * @param rigidBodyID The ID of the rigid body.
         * @param worldTransPointer Pointer to the world transform data.
         * @zh Dynamic刚体,物理引擎每帧调用一次,用于更新渲染矩阵。
         * @param rigidBodyID 刚体的 ID。
         * @param worldTransPointer 世界变换数据的指针。
         */
        setWorldTransform(rigidBodyID: number, worldTransPointer: number): void;
        /**
         * @en Draw a debug line.
         * @param sx Start point x coordinate.
         * @param sy Start point y coordinate.
         * @param sz Start point z coordinate.
         * @param ex End point x coordinate.
         * @param ey End point y coordinate.
         * @param ez End point z coordinate.
         * @param color Line color.
         * @zh 绘制调试线段。
         * @param sx 起点 x 坐标。
         * @param sy 起点 y 坐标。
         * @param sz 起点 z 坐标。
         * @param ex 终点 x 坐标。
         * @param ey 终点 y 坐标。
         * @param ez 终点 z 坐标。
         * @param color 线段颜色。
         */
        drawLine: (sx: number, sy: number, sz: number, ex: number, ey: number, ez: number, color: number) => void;
        /**
         * @en Clear all debug lines.
         * @zh 清除所有调试线段。
         */
        clearLine: () => void;
        /**
         * @en Log a message from WebAssembly to console.
         * @param ptr Pointer to the message string in WebAssembly memory.
         * @param len Length of the message string.
         * @zh 将 WebAssembly 中的消息记录到控制台。
         * @param ptr WebAssembly 内存中消息字符串的指针。
         * @param len 消息字符串的长度。
         */
        jslog: (ptr: number, len: number) => void;
    }
    /**
     * @en The `btPhysicsCreateUtil` class is responsible for creating and managing various physics objects and capabilities within the Bullet physics engine.
     * @zh `btPhysicsCreateUtil` 类负责在 Bullet 物理引擎中创建和管理各种物理对象和功能。
     */
    class btPhysicsCreateUtil implements IPhysicsCreateUtil {
        /**
         * @en A map that stores the capabilities of the physics engine.
         * @zh 存储物理引擎功能的映射。
         */
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @en Initializes the physics engine's capabilities, setting up which features are supported.
         * @zh 初始化物理引擎的功能，设置支持的功能项。
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the status of a specific physics capability.
         * @param value The physics capability to query.
         * @returns Whether the capability is available.
         * @zh 获取特定物理能力的状态。
         * @param value 要查询的物理能力。
         * @returns 该能力是否可用。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initializes the Bullet physics engine. This includes setting up the physics memory, creating an instance of the Bullet physics engine, and initializing various physics components.
         * @returns A promise that resolves when initialization is complete.
         * @zh 初始化 Bullet 物理引擎。这包括设置物理内存、创建 Bullet 物理引擎实例以及初始化各种物理组件。
         * @returns 当初始化完成时解析的 Promise。
         */
        initialize(): Promise<void>;
        /**
         * @en Creates a new instance of the physics manager with the specified settings.
         * @param physicsSettings The physics settings.
         * @returns A btPhysicsManager instance.
         * @zh 使用指定的设置创建一个新的物理管理器实例。
         * @param physicsSettings 物理设置。
         * @returns btPhysicsManager 实例。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): btPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @returns A btRigidBodyCollider instance.
         * @zh 创建动态碰撞器。
         * @param manager 物理管理器。
         * @returns btRigidBodyCollider 实例。
         */
        createDynamicCollider(manager: btPhysicsManager): btRigidBodyCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @returns A btStaticCollider instance.
         * @zh 创建静态碰撞器。
         * @param manager 物理管理器。
         * @returns btStaticCollider 实例。
         */
        createStaticCollider(manager: btPhysicsManager): btStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @returns A btCharacterCollider instance.
         * @zh 创建角色控制器。
         * @param manager 物理管理器。
         * @returns btCharacterCollider 实例。
         */
        createCharacterController(manager: btPhysicsManager): btCharacterCollider;
        /**
         * @en Create a fixed joint.
         * @param manager The physics manager.
         * @returns A btFixedJoint instance.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         * @returns btFixedJoint 实例。
         */
        createFixedJoint(manager: btPhysicsManager): btFixedJoint;
        /**
         * @en Create a hinge joint.
         * @param manager The physics manager.
         * @returns A btHingeJoint instance.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         * @returns btHingeJoint 实例。
         */
        createHingeJoint(manager: btPhysicsManager): IHingeJoint;
        /**
         * @en Create a spring joint.
         * @param manager The physics manager.
         * @returns A btSpringJoint instance.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         * @returns btSpringJoint 实例。
         */
        createSpringJoint(manager: btPhysicsManager): btSpringJoint;
        /**
         * @en Create a D6 (6 degrees of freedom) joint.
         * @param manager The physics manager.
         * @returns A btCustomJoint instance.
         * @zh 创建 D6（6 自由度） 关节。
         * @param manager 物理管理器。
         * @returns btCustomJoint 实例。
         */
        createD6Joint(manager: btPhysicsManager): ID6Joint;
        /**
         * @en Create a box collider shape.
         * @returns A btBoxColliderShape instance.
         * @zh 创建盒型碰撞器形状。
         * @returns btBoxColliderShape 实例。
         */
        createBoxColliderShape(): btBoxColliderShape;
        /**
         * @en Create a sphere collider shape.
         * @returns A btSphereColliderShape instance.
         * @zh 创建球形碰撞器形状。
         * @returns btSphereColliderShape 实例。
         */
        createSphereColliderShape(): btSphereColliderShape;
        /**
         * @en Create a capsule collider shape.
         * @returns A btCapsuleColliderShape instance.
         * @zh 创建胶囊碰撞器形状。
         * @returns btCapsuleColliderShape 实例。
         */
        createCapsuleColliderShape(): btCapsuleColliderShape;
        /**
         * @en Create a mesh collider shape.
         * @returns A btMeshColliderShape instance.
         * @zh 创建网格碰撞器形状。
         * @returns btMeshColliderShape 实例。
         */
        createMeshColliderShape(): btMeshColliderShape;
        /**
         * @en Create a plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create a cylinder collider shape.
         * @returns A btCylinderColliderShape instance.
         * @zh 创建圆柱碰撞器形状。
         * @returns btCylinderColliderShape 实例。
         */
        createCylinderColliderShape(): btCylinderColliderShape;
        /**
         * @en Create a cone collider shape.
         * @returns A btConeColliderShape instance.
         * @zh 创建圆锥碰撞器形状。
         * @returns btConeColliderShape 实例。
         */
        createConeColliderShape(): btConeColliderShape;
        /**
         * @en Create a compound collider shape.
         * @returns A btCompoundColliderShape instance.
         * @zh 创建组合碰撞器形状。
         * @returns btCompoundColliderShape 实例。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create a convex mesh from a given mesh.
         * @param mesh The source mesh.
         * @returns The created convex mesh, or null if creation fails.
         * @zh 从给定的网格创建凸包网格。
         * @param mesh 源网格。
         * @returns 创建的凸包网格，如果创建失败则返回 null。
         */
        createCorveMesh(mesh: Mesh): Mesh;
    }
    /**
     * @en The `btPhysicsManager` class is the core class for managing the Bullet physics engine.
     * @zh `btPhysicsManager` 类是用于管理 Bullet 物理引擎的核心类。
     */
    class btPhysicsManager implements IPhysicsManager {
        /** @internal */
        private static _btTempVector30;
        /** @internal */
        private static _btTempVector31;
        /** @internal */
        private static _btTempQuaternion0;
        /** @internal */
        private static _btTempQuaternion1;
        /** @internal */
        private static _btTempTransform0;
        /** @internal */
        private static _btTempTransform1;
        /** @internal */
        private static _tempVector30;
        /**
         * @en Initializes the btPhysicsManager.
         * @zh 初始化 btPhysicsManager。
         */
        static init(): void;
        /**
         * @en The maximum number of sub-steps used by the physics engine in one frame to compensate for deceleration. This is the maximum number of simulations allowed per frame. If the engine runs slowly, this number may need to be increased,otherwise the simulator will lose "time". It's crucial that the engine interval time is less than maxSubSteps * fixedTimeStep.
         * @zh 物理引擎在一帧中用于补偿减速的最大次数：模拟器每帧允许的最大模拟次数，如果引擎运行缓慢,可能需要增加该次数，否则模拟器会丢失“时间",引擎间隔时间小于maxSubSteps*fixedTimeStep非常重要。
         */
        maxSubSteps: number;
        /***/
        /**
         * @en The interval time of the physics simulator frame. Reducing fixedTimeStep can increase simulation precision. The default value is 1.0 / 60.0.
         * @zh 物理模拟器帧的间隔时间:通过减少fixedTimeStep可增加模拟精度，默认是1.0 / 60.0。
         */
        fixedTimeStep: number;
        /**
         * @en Whether to enable continuous collision detection.
         * @zh 是否开启连续碰撞检测。
         */
        enableCCD: boolean;
        /**
         * @en The threshold for continuous collision detection.
         * @zh 连续碰撞检测的阈值。
         */
        ccdThreshold: number;
        /**
         * @en The sphere radius for continuous collision detection.
         * @zh 连续碰撞检测的球体半径。
         */
        ccdSphereRadius: number;
        /**
         * @en The delta time used in physics calculations, default is 1/60 second.
         * @zh 物理计算中使用的时间间隔，默认为 1/60 秒。
         */
        dt: number;
        /** @internal */
        private _btDiscreteDynamicsWorld;
        /** @internal */
        private _btCollisionWorld;
        /** @internal */
        protected _btDispatcher: number;
        /** @internal */
        private _btCollisionConfiguration;
        /** @internal */
        private _btBroadphase;
        /** @internal */
        _btSolverInfo: number;
        /** @internal */
        private _btDispatchInfo;
        /** @internal */
        _gravity: Vector3;
        /** @internal */
        private _btClosestRayResultCallback;
        /** @internal */
        private _btAllHitsRayResultCallback;
        /** @internal */
        private _btClosestConvexResultCallback;
        /** @internal */
        private _btAllConvexResultCallback;
        /** @internal */
        private _btVector3Zero;
        /** @internal */
        private _btDefaultQuaternion;
        /**@internal*/
        _updatedRigidbodies: number;
        protected _updateCount: number;
        /** @internal */
        protected _previousFrameCollisions: Collision[];
        /** @internal */
        protected _currentFrameCollisions: Collision[];
        /** @internal */
        protected _collisionsUtils: CollisionTool;
        /** @internal */
        private _currentConstraint;
        /** @internal */
        _physicsUpdateList: PhysicsUpdateList;
        _characters: btCharacterCollider[];
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @ignore
         * @en Creates an instance of a btPhysicsManager.
         * @param physicsSettings The settings for the physics simulation.
         * @zh 创建一个 btPhysicsManager 的实例。
         * @param physicsSettings 物理模拟的设置。
         */
        constructor(physicsSettings: PhysicsSettings);
        /**
         * @en Sets the active state of a btCollider.
         * @param collider The btCollider to set the active state for.
         * @param value The active state to set (true for active, false for inactive).
         * @zh 设置 btCollider 的激活状态。
         * @param collider 要设置激活状态的 btCollider。
         * @param value 要设置的激活状态（true 表示激活，false 表示不激活）。
         */
        setActiveCollider(collider: btCollider, value: boolean): void;
        /**
         * @en Performs a sphere query to find colliders within a specified radius from a given position.
         * @param pos The center position of the sphere query.
         * @param radius The radius of the sphere query.
         * @param result An array to store the found colliders.
         * @param collisionmask The collision mask to filter the query results.
         * @zh 执行球体查询，查找给定位置指定半径内的碰撞体。
         * @param pos 球体查询的中心位置。
         * @param radius 球体查询的半径。
         * @param result 用于存储找到的碰撞体的数组。
         * @param collisionmask 用于过滤查询结果的碰撞掩码。
         */
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        /**
        * @internal
        */
        private _simulate;
        /**
         * @internal
         * @perfTag PerformanceDefine.T_Physics_UpdateNode
         */
        private _updatePhysicsTransformToRender;
        /**
         * @internal
         */
        _updateCollisions(): void;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderEnter
         * @en Dispatch Collider Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param curFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器进入事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param curFrameCol Current Frame Collision Information
         */
        private _collision_EnterEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderStay
         * @en Dispatch Collider Stay Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param curFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器持续事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param curFrameCol Current Frame Collision Information
         */
        private _collision_StayEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsColliderExit
         * @en Dispatch Collider Exit Event
         * @param preColliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param preColliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @param preFrameCol 当前帧碰撞信息
         * @zh 派发碰撞器离开事件
         * @param preColliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param preColliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         * @param preFrameCol Current Frame Collision Information
         */
        private _collision_ExitEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerEnter
         * @en Dispatch Trigger Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器进入事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_EnterEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerStay
         * @en Dispatch Trigger Enter Event
         * @param colliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param colliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器持续事件
         * @param colliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param colliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_StayEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsTriggerExit
         * @en Dispatch Trigger Exit Event
         * @param preColliderA 碰撞组件A
         * @param ownerA 组件A的所属节点
         * @param preColliderB 碰撞组件B
         * @param ownerB 组件B的所属节点
         * @zh 派发触发器离开事件
         * @param preColliderA Collision Component A
         * @param ownerA The Node to Which Component A Belongs
         * @param preColliderB Collision Component B
         * @param ownerB The Node to Which Component B Belongs
         */
        private _trigger_ExitEvent;
        /**
         * @perfTag PerformanceDefine.T_PhysicsEvent
         * @en This method only sends events to objects, it doesn't call collision functions for each component individually.Components need to listen to events if they want to respond to collisions.
         * @zh 这个只是给对象发送事件，不会挨个组件调用碰撞函数。组件要响应碰撞的话，要通过监听事件。
         */
        dispatchCollideEvent(): void;
        /**
        * @internal
        */
        _updateCharacters(): void;
        /**
         * @en Debugger function to enable or disable the debug drawer.
         * @param value A boolean value to enable (true) or disable (false) the debug drawer.
         * @zh 调试器函数，用于启用或禁用调试绘制器。
         * @param value 布尔值，用于启用（true）或禁用（false）调试绘制器。
         */
        enableDebugDrawer(value: boolean): void;
        /**
         * @en Gets the capability status of a specific physics feature.
         * @param value The physics capability to check.
         * @returns Whether the specified physics capability is supported.
         * @zh 获取特定物理特性的能力状态。
         * @param value 要检查的物理能力。
         * @returns 指定的物理能力是否被支持。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initializes the physics capabilities map.
         * @zh 初始化物理能力映射。
         */
        initPhysicsCapable(): void;
        /**
         * @en Sets the gravity.
         * @param gravity The gravity to be set.
         * @zh 设置重力。
         * @param gravity 要设置的重力。
         */
        setGravity(gravity: Vector3): void;
        /**
         * @en Adds a collider.
         * @param collider The collider to be added.
         * @zh 添加碰撞体。
         * @param collider 要添加的碰撞体。
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Removes a collider.
         * @param collider The collider to be removed.
         * @zh 移除碰撞体。
         * @param collider 要移除的碰撞体。
         */
        removeCollider(collider: ICollider): void;
        /**
         * @en Adds a joint.
         * @param joint The joint to be added.
         * @zh 添加关节。
         * @param joint 要添加的关节。
         */
        addJoint(joint: btJoint): void;
        /**
         * @en Removes a joint.
         * @param joint The joint to be removed.
         * @zh 移除关节。
         * @param joint 要移除的关节。
         */
        removeJoint(joint: btJoint): void;
        /**
         * @perfTag PerformanceDefine.T_Physics_Simulation
         * @en Updates the physics simulation.
         * @param elapsedTime The time elapsed since the last update.
         * @zh 更新物理模拟。
         * @param elapsedTime 自上次更新以来经过的时间。
         */
        update(elapsedTime: number): void;
        /**
         * @en Performs a ray cast in the physics world.Returns the first hit object.
         * @param ray The ray to cast.
         * @param outHitResult The hit result object to store the result.
         * @param distance The maximum distance of the ray cast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the ray hit anything.
         * @zh 执行一次射线检测，返回第一个与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param outHitResult 用于存储结果的命中结果对象。
         * @param distance 射线投射的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a ray cast in the physics world.Returns all hit objects.
         * @param ray The ray to cast.
         * @param out An array to store all hit results.
         * @param distance The maximum distance of the ray cast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the ray hit anything.
         * @zh 执行一次射线检测，返回所有与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param out 用于存储所有命中结果的数组。
         * @param distance 射线投射的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCastAll(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a shape cast. Returns the first hit object.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out The hit result object to store the result.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether hit anything.
         * @zh 执行形状射线检测，返回第一个与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储结果的命中结果对象。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 是否击中了任何物体。
         */
        shapeCast(shape: btColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Performs a shape cast. Returns all hit objects.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out An array to store all hit results.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether hit anything.
         * @zh 执行形状投射，返回所有与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储所有命中结果的数组。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 是否击中了任何物体。
         */
        shapeCastAll(shape: btColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Destroys the physics manager and releases all associated resources.
         * @zh 销毁物理管理器并释放所有相关资源。
         */
        destroy(): void;
        /**
        * @internal
        */
        private _addRigidBody;
        /**
         * @internal
         */
        private _removeRigidBody;
        /**
         * @internal
         */
        private _addCharacter;
        /**
         * @internal
         */
        private _removeCharacter;
    }
    class btStatics {
        static bt: any;
        /**
             * @en Default collision group
             * @zh 默认碰撞组
             */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**
         * @en Static collision group
         * @zh 静态碰撞组
         */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**
         * @en Kinematic rigid body collision group
         * @zh 运动学刚体碰撞组
         */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**
         * @en Debris collision group
         * @zh 碎片碰撞组
         */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**
         * @en Sensor trigger group
         * @zh 传感器触发器组
         */
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**
         * @en Character filter group
         * @zh 角色过滤器组
         */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**
         * @en Custom filter group 1
         * @zh 自定义过滤组 1
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**
         * @en Custom filter group 2
         * @zh 自定义过滤组 2
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**
         * @en Custom filter group 3
         * @zh 自定义过滤组 3
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**
         * @en Custom filter group 4
         * @zh 自定义过滤组 4
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**
         * @en Custom filter group 5
         * @zh 自定义过滤组 5
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**
         * @en Custom filter group 6
         * @zh 自定义过滤组 6
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**
         * @en Custom filter group 7
         * @zh 自定义过滤组 7
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**
         * @en Custom filter group 8
         * @zh 自定义过滤组 8
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**
         * @en Custom filter group 9
         * @zh 自定义过滤组 9
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**
         * @en Custom filter group 10
         * @zh 自定义过滤组 10
         */
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**
         * @en All filter groups
         * @zh 所有过滤组
         */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        /**
         * @internal
         * @en Active tag for activation state
         * @zh 激活状态的标签
         */
        static ACTIVATIONSTATE_ACTIVE_TAG: number;
        /**
         * @internal
         * @en Island sleeping tag for activation state
         * @zh 落地休眠状态的标签
         */
        static ACTIVATIONSTATE_ISLAND_SLEEPING: number;
        /**
         * @internal
         * @en Wants deactivation tag for activation state
         * @zh 希望停用状态的标签
         */
        static ACTIVATIONSTATE_WANTS_DEACTIVATION: number;
        /**
         * @internal
         * @en Disable deactivation tag for activation state
         * @zh 禁用停用状态的标签
         */
        static ACTIVATIONSTATE_DISABLE_DEACTIVATION: number;
        /**
         * @internal
         * @en Disable simulation tag for activation state
         * @zh 禁用模拟状态的标签
         */
        static ACTIVATIONSTATE_DISABLE_SIMULATION: number;
        /**
         * @internal
         * @en Collision flag: Static object
         * @zh 碰撞标志：静态对象
         */
        static COLLISIONFLAGS_STATIC_OBJECT: number;
        /**
         * @internal
         * @en Collision flag: Kinematic object
         * @zh 碰撞标志：运动学对象
         */
        static COLLISIONFLAGS_KINEMATIC_OBJECT: number;
        /**
         * @internal
         * @en Collision flag: No contact response
         * @zh 碰撞标志：无接触响应
         */
        static COLLISIONFLAGS_NO_CONTACT_RESPONSE: number;
        /**
         * @internal
         * @en Collision flag: Custom material callback.This allows per-triangle material (friction/restitution)
         * @zh 碰撞标志：自定义材质回调。这允许每个三角形使用单独的材质（摩擦力/弹性）
         */
        static COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK: number;
        /**
         * @internal
         * @en Collision flag: Character object
         * @zh 碰撞标志：角色对象
         */
        static COLLISIONFLAGS_CHARACTER_OBJECT: number;
        /**
         * @internal
         * @en Collision flag: Disable visualize object.Disables debug drawing
         * @zh 碰撞标志：禁用可视化对象。禁用调试绘制
         */
        static COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT: number;
        /**
         * @internal
         * @en Collision flag: Disable SPU collision processing.Disables parallel/SPU processing
         * @zh 碰撞标志：禁用 SPU 碰撞处理。禁用并行/SPU 处理
         */
        static COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING: number;
        /**
         * @internal
         * @en Physics engine flag: None.Indicates no specific physics engine features are enabled.
         * @zh 物理引擎标志：无。表示没有启用任何特定的物理引擎功能。
         */
        static PHYSICSENGINEFLAGS_NONE: number;
        /**
         * @internal
         * @en Physics engine flag: Collisions only.Enables collision detection without full physics simulation.
         * @zh 物理引擎标志：仅碰撞。启用碰撞检测，但不进行完整的物理模拟。
         */
        static PHYSICSENGINEFLAGS_COLLISIONSONLY: number;
        /**
         * @internal
         * @en Physics engine flag: Soft body support.Enables soft body physics simulation.
         * @zh 物理引擎标志：软体支持。启用软体物理模拟。
         */
        static PHYSICSENGINEFLAGS_SOFTBODYSUPPORT: number;
        /**
         * @internal
         * @en Physics engine flag: Multi-threaded.Enables multi-threaded physics computations.
         * @zh 物理引擎标志：多线程。启用多线程物理计算。
         */
        static PHYSICSENGINEFLAGS_MULTITHREADED: number;
        /**
         * @internal
         * @en Physics engine flag: Use hardware when possible.Enables hardware acceleration for physics calculations when available.
         * @zh 物理引擎标志：尽可能使用硬件加速。在可用时启用硬件加速进行物理计算。
         */
        static PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE: number;
        /**
         * @internal
         * @en Solver mode: Randomize order.Randomizes the order of constraint solving.
         * @zh 求解器模式：随机顺序。随机化约束求解的顺序。
         */
        static SOLVERMODE_RANDMIZE_ORDER: number;
        /**
         * @internal
         * @en Solver mode: Separate friction.Handles friction separately from other constraints.
         * @zh 求解器模式：分离摩擦力。将摩擦力与其他约束分开处理。
         */
        static SOLVERMODE_FRICTION_SEPARATE: number;
        /**
         * @internal
         * @en Solver mode: Use warm starting.Uses previous solution as a starting point for faster convergence.
         * @zh 求解器模式：使用热启动。使用前一次的解作为起点，以加快收敛速度。
         */
        static SOLVERMODE_USE_WARMSTARTING: number;
        /**
         * @internal
         * @en Solver mode: Use 2 friction directions.Applies friction in two orthogonal directions.
         * @zh 求解器模式：使用两个摩擦方向。在两个正交方向上应用摩擦力。
         */
        static SOLVERMODE_USE_2_FRICTION_DIRECTIONS: number;
        /**
         * @internal
         * @en Solver mode: Enable friction direction caching。Caches friction directions for improved performance.
         * @zh 求解器模式：启用摩擦方向缓存。缓存摩擦方向以提高性能。
         */
        static SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING: number;
        /**
         * @internal
         * @en Solver mode: Disable velocity-dependent friction direction.Friction direction does not depend on relative velocity.
         * @zh 求解器模式：禁用速度相关的摩擦方向。摩擦方向不依赖于相对速度。
         */
        static SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION: number;
        /**
         * @internal
         * @en Solver mode: Cache friendly.Optimizes memory access patterns for better cache utilization.
         * @zh 求解器模式：缓存友好。优化内存访问模式以更好地利用缓存。
         */
        static SOLVERMODE_CACHE_FRIENDLY: number;
        /**
         * @internal
         * @en Solver mode: SIMD.Uses SIMD instructions for improved performance.
         * @zh 求解器模式：SIMD。使用 SIMD 指令以提高性能。
         */
        static SOLVERMODE_SIMD: number;
        /**
         * @internal
         * @en Solver mode: Interleave contact and friction constraints.Alternates between contact and friction constraint solving.
         * @zh 求解器模式：交错接触和摩擦约束。在接触约束和摩擦约束求解之间交替进行。
         */
        static SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: number;
        /**
         * @internal
         * @en Solver mode: Allow zero length friction directions.Permits friction calculations even when relative velocity is zero.
         * @zh 求解器模式：允许零长度摩擦方向。即使相对速度为零也允许进行摩擦力计算。
         */
        static SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: number;
        /**
         * @internal
         * @en Ray result callback flag: None.No special flags applied to the ray callback.
         * @zh 射线结果回调标志：无。不应用特殊标志到射线回调。
         */
        static HITSRAYRESULTCALLBACK_FLAG_NONE: number;
        /**
         * @internal
         * @en Ray result callback flag: Ignore back faces.Ray test will ignore back faces of triangles.
         * @zh 射线回调模式：忽略反面。射线检测时，会忽略掉反面的三角形
         */
        static HITSRAYRESULTCALLBACK_FLAG_FILTERBACKFACESS: number;
        /**
         * @internal
         * @en Ray result callback flag: Keep unflipped normal.Maintains the original normal direction of hit surfaces.
         * @zh 射线结果回调标志：保持未翻转的法线。保持命中表面的原始法线方向。
         */
        static HITSRAYRESULTCALLBACK_FLAG_KEEPUNFILIPPEDNORMAL: number;
        /**
         * @internal
         * @en Ray result callback flag: Use sub-simplex convex cast ray test.Employs a sub-simplex algorithm for convex shape ray casting.
         * @zh 射线结果回调标志：使用子单纯形凸体投射射线测试。使用子单纯形算法进行凸形体的射线投射。
         */
        static HITSRAYRESULTCALLBACK_FLAG_USESUBSIMPLEXCONVEXCASTRAYTEST: number;
        /**
         * @internal
         * @en Ray result callback flag: Use GJK convex cast ray test.Utilizes the GJK algorithm for convex shape ray casting.
         * @zh 射线结果回调标志：使用 GJK 凸体投射射线测试。使用 GJK 算法进行凸形体的射线投射。
         */
        static HITSRAYRESULTCALLBACK_FLAG_USEGJKCONVEXCASTRAYTEST: number;
        /**
         * @internal
         * @en Ray result callback flag: Terminator.Indicates the end of ray callback flags.
         * @zh 射线结果回调标志：终止符。表示射线回调标志的结束。
         */
        static HITSRAYRESULTCALLBACK_FLAG_TERMINATOR: number;
    }
    /**
     * @internal
     */
    function convertToBulletVec3(lVector: Vector3, out: number): void;
    /**
     * @en The btCharacterCollider class is used to handle 3D physics character colliders.
     * @zh btCharacterCollider 类用于处理3D物理角色碰撞器。
     */
    class btCharacterCollider extends btCollider implements ICharacterController {
        /** @internal */
        private static _btTempVector30;
        /** @internal */
        private static _btTempVector31;
        /**@internal */
        _btKinematicCharacter: number;
        /** @internal */
        private _stepHeight;
        /** @internal */
        private _upAxis;
        /**@internal */
        private _maxSlope;
        /**@internal */
        private _fallSpeed;
        /**@internal */
        private _jumpSpeed;
        /** @internal */
        private _gravity;
        /**@internal */
        private _pushForce;
        /**@internal */
        static _characterCapableMap: Map<any, any>;
        /**
         * @internal
         * @en Whethe the character is enabled.
         * @zh 是否启用。
         */
        componentEnable: boolean;
        static __init__(): void;
        /**
         * @en Check if the character is capable of a specific action.
         * @param value The capability to check.
         * @returns True if the character is capable, false otherwise.
         * @zh 检查角色是否能够执行特定动作。
         * @param value 要检查的能力。
         * @returns 如果角色具备该能力则返回 true，否则返回 false。
         */
        getCapable(value: number): boolean;
        /**
         * @en Creates an instance of the btCharacterCollider class.
         * @param physicsManager The physics manager instance.
         * @zh 创建一个 btCharacterCollider 类的实例。
         * @param physicsManager 物理管理器实例。
         */
        constructor(physicsManager: btPhysicsManager);
        /**
         * @en Set the local offset of the collider shape.
         * @param value The local offset vector.
         * @zh 设置碰撞器形状的偏移。
         * @param value 偏移向量。
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Set the skin width of the character collider.
         * @param width The skin width value.
         * @zh 设置角色碰撞器的皮肤宽度。
         * @param width 皮肤宽度值。
         */
        setSkinWidth?(width: number): void;
        /**
         * @en Set the position.
         * @param value The position vector.
         * @zh 设置位置。
         * @param value 位置向量。
         */
        setPosition(value: Vector3): void;
        /**
         * @en Get the current position.
         * @returns The position vector.
         * @zh 获取当前位置。
         * @returns 位置向量。
         */
        getPosition(): Vector3;
        /**
         * @en Set the radius of the character collider.
         * @param value The radius value.
         * @zh 设置角色碰撞器的半径。
         * @param value 半径值。
         */
        setRadius?(value: number): void;
        /**
         * @en Set the height of the character collider.
         * @param value The height value.
         * @zh 设置角色碰撞器的高度。
         * @param value 高度值。
         */
        setHeight?(value: number): void;
        /**
         * @en Set the minimum distance for the character collider.
         * @param value The minimum distance value.
         * @zh 设置角色碰撞器的最小距离。
         * @param value 最小距离值。
         */
        setminDistance(value: number): void;
        /**
         * @en Set the dynamic friction of the character collider.
         * @param value The dynamic friction value.
         * @zh 设置角色碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction?(value: number): void;
        /**
         * @en Set the static friction of the character collider.
         * @param value The static friction value.
         * @zh 设置角色碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction?(value: number): void;
        /**
         * @en Set the friction combine mode of the character collider.
         * @param value The friction combine mode.
         * @zh 设置角色碰撞器的摩擦力合并模式。
         * @param value 摩擦力合并模式。
         */
        setFrictionCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Set the bounce combine mode of the character collider.
         * @param value The bounce combine mode.
         * @zh 设置角色碰撞器的弹力合并模式。
         * @param value 弹力合并模式。
         */
        setBounceCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Get the character capability status.
         * @param value The character capability to check.
         * @zh 获取角色能力状态。
         * @param value 要检查的角色能力。
         */
        static getCharacterCapable(value: ECharacterCapable): boolean;
        /**
         * @en Initialize the capabilities of the character collider.
         * @zh 初始化角色碰撞器的能力。
         */
        static initCapable(): void;
        protected getColliderType(): btColliderType;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        /**
         * @en Set the world position of the character.
         * @param value The new world position vector.
         * @zh 设置角色的世界位置。
         * @param value 新的世界位置向量。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Move the character by a displacement vector.
         * @param disp The displacement vector.
         * @zh 通过位移向量移动角色。
         * @param disp 位移向量。
         */
        move(disp: Vector3): void;
        /**
         * @en Make the character jump with a given velocity.
         * @param velocity The jump velocity vector.
         * @zh 使角色以给定的速度跳跃。
         * @param velocity 跳跃速度向量。
         */
        jump(velocity: Vector3): void;
        isGrounded(): boolean;
        /**
         * @en Set the jump speed of the character.
         * @param value The jump speed value.
         * @zh 设置角色的跳跃速度。
         * @param value 跳跃速度值。
         */
        setJumpSpeed(value: number): void;
        /**
         * @en Set the step offset (height) for the character.
         * @param offset The step offset value.
         * @zh 设置角色的步高。
         * @param offset 步高值。
         */
        setStepOffset(offset: number): void;
        /**
         * @en Set the up direction for the character.
         * @param up The up direction vector.
         * @zh 设置角色的向上方向。
         * @param up 向上方向向量。
         */
        setUpDirection(up: Vector3): void;
        /**
         * @en Get the vertical velocity of the character.
         * @zh 获取角色的垂直速度。
         */
        getVerticalVel(): number;
        /**
         * @en Set the slope limit for the character.
         * @param slopeLimit The slope limit in degrees.
         * @zh 设置角色的坡度限制。
         * @param slopeLimit 坡度限制（以度为单位）。
         */
        setSlopeLimit(slopeLimit: number): void;
        /**
         * @en Set the fall speed for the character.
         * @param value The fall speed value.
         * @zh 设置角色的下落速度。
         * @param value 下落速度值。
         */
        setfallSpeed(value: number): void;
        /**
         * @en Set the push force for the character.
         * @param value The push force value.
         * @zh 设置角色的推力。
         * @param value 推力值。
         */
        setPushForce(value: number): void;
        /**
         * @en Set the gravity for the character.
         * @param value The gravity vector.
         * @zh 设置角色的重力。
         * @param value 重力向量。
         */
        setGravity(value: Vector3): void;
        /**
         * @en Get the overlapping objects of the character.
         * @param cb Callback function to handle each overlapping object.
         * @zh 获得角色碰撞的对象。
         * @param cb 处理每个重叠对象的回调函数。
         */
        getOverlappingObj(cb: (body: btCollider) => void): void;
        /**
         * @en Set the collider shape for the character.
         * @param shape The collider shape to set.
         * @zh 设置角色的碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroy CharacterController
         * @zh 销毁角色控制器
         */
        destroy(): void;
    }
    enum btColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    /**
     * @en btCollider class is used to handle 3D physics collisions.
     * @zh btCollider 类用于处理3D物理碰撞。
     */
    class btCollider implements ICollider {
        component: PhysicsColliderComponent;
        static _colliderID: number;
        static _addUpdateList: boolean;
        /**
         * @en Static rigid body type.
         * Set to a rigid body that will never move, and the engine will not automatically update it.
         * If you intend to move physics objects, it is recommended to use TYPE_KINEMATIC.
         * @zh 刚体类型_静态。
         * 设定为永远不会移动刚体,引擎也不会自动更新。
         * 如果你打算移动物理,建议使用TYPE_KINEMATIC。
         */
        static TYPE_STATIC: number;
        /**
         * @en Dynamic rigid body type.
         * The rigid body can be moved through forces and impulses, and there's no need to modify the movement transformation.
         * @zh 刚体类型_动态。
         * 可以通过力和冲量移动刚体，并且不需要修改移动变换。
         */
        static TYPE_DYNAMIC: number;
        /**
         * @en Kinematic rigid body type.
         * The rigid body can be moved, and the physics engine will automatically handle dynamic interactions.
         * Note: It will not produce dynamic interactions with static or other types of rigid bodies.
         * @zh 刚体类型_运动。
         * 可以移动刚体，物理引擎会自动处理动态交互。
         * 注意：和静态或其他类型刚体不会产生动态交互。
         */
        static TYPE_KINEMATIC: number;
        /** @internal */
        static _physicObjectsMap: {
            [key: number]: btCollider;
        };
        protected static _btVector30: number;
        /** @internal */
        protected static _btQuaternion0: number;
        /**
         * @en The underlying Bullet physics collider object.
         * @zh 物理碰撞器对象。
         */
        _btCollider: any;
        /**
         * @en The shape of the Bullet physics collider.
         * @zh 物理碰撞器的形状。
         */
        _btColliderShape: btColliderShape;
        /**
         * @en The collision group that this collider belongs to.
         * @zh 此碰撞器所属的碰撞组。
         */
        _collisionGroup: number;
        /**
         * @en The collision mask determining which groups this collider can collide with.
         * @zh 决定此碰撞器可以与哪些组碰撞的碰撞掩码。
         */
        _canCollideWith: number;
        /**
         * @en The physics manager handling this collider.
         * @zh 处理此碰撞器的物理管理器。
         */
        _physicsManager: btPhysicsManager;
        /**
         * @en Indicates whether the collider is currently simulated in the physics world.
         * @zh 表示碰撞器是否已在物理世界中生效。
         */
        _isSimulate: boolean;
        /**
         * @en The type of the collider (static, dynamic, or kinematic).
         * @zh 碰撞器的类型（静态、动态或运动学）。
         */
        _type: btColliderType;
        /**
         * @en update list index.
         * @zh 更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**
         * @en Unique identifier for the collider.
         * @zh 碰撞器的唯一标识符。
         */
        _id: number;
        /**
         * @en Whether the collider is a trigger.
         * @zh 是否为触发器。
         */
        _isTrigger: boolean;
        /**
         * @en Determines if collision processing is enabled for this collider.
         * @zh 决定是否为此碰撞器启用碰撞处理。
         */
        _enableProcessCollisions: boolean;
        /**
         * @en Indicates whether the collider has been destroyed.
         * @zh 表示碰撞器是否已被销毁。
         */
        _destroyed: boolean;
        /**
         * @en The Sprite3D object that owns this collider.
         * @zh 拥有此碰撞器的Sprite3D对象。
         */
        owner: Sprite3D;
        /**
         * @en The Transform3D component associated with this collider.
         * @zh 与此碰撞器关联的Transform3D组件。
         */
        _transform: Transform3D;
        /**
         * @internal
         * @en Indicates whether the component is enabled.
         * @zh 表示组件是否启用。
         */
        componentEnable: boolean;
        /** @internal */
        protected _restitution: number;
        /** @internal */
        protected _friction: number;
        /** @internal */
        protected _rollingFriction: number;
        /** @internal */
        protected _ccdThreshold: number;
        /** @internal */
        protected _ccdSwapSphereRadius: number;
        /** @internal */
        protected _transformFlag: number;
        /**
        * @internal
        */
        static __init__(): void;
        /**
         * @ignore
         * @en Creates an instance of btCollider.
         * @param physicsManager The physics manager.
         * @zh 创建一个 btCollider 的实例。
         * @param physicsManager 物理管理器。
         */
        constructor(physicsManager: btPhysicsManager);
        active: boolean;
        /**
         * @en Sets the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction?(value: number): void;
        /**
         * @en Sets the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction?(value: number): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦力组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置弹力组合模式。
         * @param value 弹力组合模式。
         */
        setBounceCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Sets the event filter for the collider.
         * @param events Array of event names to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件名称。
         */
        setEventFilter?(events: string[]): void;
        allowSleep(value: boolean): void;
        /**
         * @en Checks if the collider is capable of a certain feature.
         * @param value The capability to check.
         * @returns Whether the collider has the capability.
         * @zh 检查碰撞器是否具有某种能力。
         * @param value 要检查的能力。
         * @returns 碰撞器是否具有该能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Sets the owner of the collider.
         * @param node The Sprite3D node to set as owner.
         * @zh 设置碰撞器的所有者。
         * @param node 所有者节点。
         */
        setOwner(node: Sprite3D): void;
        /**
         * @en Sets the collision group of the collider.
         * @param value The collision group value.
         * @zh 设置碰撞器的碰撞组。
         * @param value 碰撞组的值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Sets which groups this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与哪些组碰撞。
         * @param value 碰撞掩码的值。
         */
        setCanCollideWith(value: number): void;
        protected _initCollider(): void;
        protected getColliderType(): btColliderType;
        /**
         * @internal
         */
        protected _onScaleChange(scale: Vector3): void;
        protected _onShapeChange(): void;
        /**
         * @en Sets the collider shape.
         * @param shape The new collider shape.
         * @zh 设置碰撞器形状。
         * @param shape 新的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroys the collider.
         * @zh 销毁碰撞器。
         */
        destroy(): void;
        /**
         * @internal
         * @en Updates the physics transformation based on the rendering matrix.
         * @param force Whether to force update.
         * @zh 通过渲染矩阵更新物理矩阵。
         * @param force 是否强制更新。
         */
        _derivePhysicsTransformation(force: boolean): void;
        /**
         * @internal
         * @en Updates the physics transformation based on the rendering matrix.
         * @param physicTransformPtr Pointer to the physics transform.
         * @param force Whether to force update.
         * @zh 通过渲染矩阵更新物理矩阵。
         * @param physicTransformPtr 物理变换的指针。
         * @param force 是否强制更新。
         */
        _innerDerivePhysicsTransformation(physicTransformPtr: number, force: boolean): void;
        /**
         * @internal
         * @en Updates the rendering transformation based on the physics matrix.
         * @param physicsTransform The physics transform.
         * @param syncRot Whether to synchronize rotation.
         * @param addmargin Additional margin to add.
         * @zh 通过物理矩阵更新渲染矩阵。
         * @param physicsTransform 物理变换。
         * @param syncRot 是否同步旋转。
         * @param addmargin 要添加的额外边距。
         */
        _updateTransformComponent(physicsTransform: number, syncRot?: boolean, addmargin?: number): void;
        /**
         * @internal
         * @en Checks if a specific transform flag is set.
         * @param type The type of transform flag to check.
         * @returns Whether the flag is set.
         * @zh 检查是否设置了特定的变换标志。
         * @param type 要检查的变换标志类型。
         * @returns 标志是否被设置。
         */
        _getTransformFlag(type: number): boolean;
        /**
         * @internal
         * @en Sets a specific transform flag.
         * @param type The type of transform flag to set.
         * @param value Whether to set or unset the flag.
         * @zh 设置特定的变换标志。
         * @param type 要设置的变换标志类型。
         * @param value 是否设置或取消设置标志。
         */
        _setTransformFlag(type: number, value: boolean): void;
        /**
         * @en Handles transform changes.
         * @param flag The transform flag.
         * @zh 处理变换改变。
         * @param flag 变换标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Sets the bounciness (restitution) of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性（恢复系数）。
         * @param value 弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the friction of the collider.
         * @param value The friction value.
         * @zh 设置碰撞器的摩擦力。
         * @param value 摩擦力值。
         */
        setfriction(value: number): void;
        /**
         * @en Sets the rolling friction of the collider.
         * @param value The rolling friction value.
         * @zh 设置碰撞器的滚动摩擦力。
         * @param value 滚动摩擦力值。
         */
        setRollingFriction(value: number): void;
        /**
         * @en Sets the CCD (Continuous Collision Detection) motion threshold.
         * @param value The CCD motion threshold value.
         * @zh 设置 CCD（连续碰撞检测）运动阈值。
         * @param value CCD 运动阈值。
         */
        setCcdMotionThreshold(value: number): void;
        /**
         * @en Sets the CCD (Continuous Collision Detection) swept sphere radius.
         * @param value The CCD swept sphere radius value.
         * @zh 设置 CCD（连续碰撞检测）扫描球半径。
         * @param value CCD 扫描球半径。
         */
        setCcdSweptSphereRadius(value: number): void;
    }
    /**
     * @en The `btRigidBodyCollider` class is used to implement 3D physics rigid body colliders.
     * @zh `btRigidBodyCollider` 类用于实现3D物理刚体碰撞器。
     */
    class btRigidBodyCollider extends btCollider implements IDynamicCollider {
        /** @internal */
        static _BT_DISABLE_WORLD_GRAVITY: number;
        /** @internal */
        static _BT_ENABLE_GYROPSCOPIC_FORCE: number;
        /** @internal */
        private static _btTempVector30;
        /** @internal */
        private static _btTempVector31;
        /** @internal */
        private static _RBtempVector30;
        /** @internal */
        private static _btVector3Zero;
        /**@internal */
        private static _btTransform0;
        /** @internal */
        private static _btInertia;
        /** @internal */
        private static _btImpulse;
        /** @internal */
        private static _btImpulseOffset;
        /** @internal */
        private static _btGravity;
        /**@internal */
        static _rigidBodyCapableMap: Map<any, any>;
        /**
        * @internal
        */
        static __init__(): void;
        /**@internal */
        componentEnable: boolean;
        /** @internal */
        private _btLayaMotionState;
        /** @internal */
        private _isKinematic;
        /** @internal */
        private _mass;
        /** @internal */
        private _gravity;
        /** @internal */
        private _angularDamping;
        /** @internal */
        private _linearDamping;
        /** @internal */
        private _overrideGravity;
        /** @internal */
        private _totalTorque;
        /** @internal */
        private _totalForce;
        /** @internal */
        private _linearVelocity;
        /** @internal */
        private _angularVelocity;
        /** @internal */
        private _linearFactor;
        /** @internal */
        private _angularFactor;
        /** @internal */
        private _detectCollisions;
        /**@internal TODO*/
        private _allowSleep;
        constructor(manager: btPhysicsManager);
        /**
         * @en Get the capability of the rigid body collider.
         * @param value The capability value to check.
         * @returns Whether the rigid body collider has the specified capability.
         * @zh 获取刚体碰撞器的能力。
         * @param value 要检查的能力值。
         * @returns 刚体碰撞器是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Get the capability of the rigid body.
         * @param value The capability to check.
         * @returns Whether the rigid body has the specified capability.
         * @zh 获取刚体的能力。
         * @param value 要检查的能力。
         * @returns 刚体是否具有指定的能力。
         */
        static getRigidBodyCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities of the rigid body collider.
         * @zh 初始化刚体碰撞器的能力。
         */
        static initCapable(): void;
        /**
         * @en Set the world position of the rigid body.
         * @param value The new world position.
         * @zh 设置刚体的世界坐标位置。
         * @param value 坐标位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Set the world rotation of the rigid body.
         * @param value The new world rotation.
         * @zh 设置刚体在世界坐标系下的旋转。
         * @param value 旋转四元数。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Set the rigid body to sleep state.
         * @zh 设置刚体进入睡眠状态。
         */
        sleep(): void;
        protected getColliderType(): btColliderType;
        /**
         * @en Whether to override gravity.
         * @zh 是否重载重力。
         */
        private _setoverrideGravity;
        /**
        * @internal
        */
        private _updateMass;
        /**
         * @en Whether it is sleeping.
         * @zh 是否处于睡眠状态。
         */
        isSleeping(): boolean;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        /**
         * @en Set the linear damping of the rigid body.
         * @param value The linear damping value.
         * @zh 设置刚体的线性阻尼。
         * @param value 线性阻尼值。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Set the angular damping of the rigid body.
         * @param value The angular damping value.
         * @zh 设置刚体的角速度阻尼。
         * @param value 角速度阻尼值。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Set the linear velocity of the rigid body.
         * @param value The linear velocity vector.
         * @zh 设置刚体的线速度。
         * @param value 线速度向量。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the rigid body.
         * @returns The current linear velocity vector.
         * @zh 获取刚体的线速度。
         * @returns 当前的线速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Set the linear velocity threshold for the rigid body.
         * @param value The linear velocity threshold vector.
         * @zh 设置刚体线速度阈值。
         * @param value 线速度阈值。
         */
        setSleepLinearVelocity(value: Vector3): void;
        /**
         * @en Set the angular velocity of the rigid body.
         * @param value The angular velocity vector.
         * @zh 设置刚体的角速度。
         * @param value 角速度。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Get the angular velocity of the rigid body.
         * @returns The current angular velocity vector.
         * @zh 获取刚体的角速度。
         * @returns 当前的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Set the mass of the rigid body.
         * @param value The mass value.
         * @zh 设置刚体的质量。
         * @param value 质量值。
         */
        setMass(value: number): void;
        /**
         * @en Set the inertia tensor of the rigid body.
         * @param value The inertia tensor vector.
         * @zh 设置刚体的惯性张量。
         * @param value 惯性张量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Set the center of mass of the rigid body.
         * @param value The center of mass vector.
         * @zh 设置刚体的质心。
         * @param value 质心。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Set the maximum angular velocity of the rigid body.
         * @param value The maximum angular velocity.
         * @zh 设置刚体的最大角速度。
         * @param value 角速度。
         */
        setMaxAngularVelocity(value: number): void;
        /**
         * @en Set the maximum depenetration velocity of the rigid body.
         * @param value The maximum depenetration velocity.
         * @zh 设置刚体的最大去穿透速度。
         * @param value 速度。
         */
        setMaxDepenetrationVelocity(value: number): void;
        /**
         * @en Set the linear velocity threshold for the rigid body to sleep.
         * @param value The linear velocity threshold.
         * @zh 设置刚体进入睡眠状态的线速度阈值。
         * @param value 线速度阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the angular velocity threshold for the rigid body to sleep.
         * @param value The angular velocity threshold.
         * @zh 设置刚体进入睡眠状态的角速度阈值。
         * @param value 角速度阈值。
         */
        setSleepAngularThreshold(value: number): void;
        /**
         * @en Set the solver iterations for the rigid body.
         * @param value The number of solver iterations.
         * @zh 设置刚体的求解器迭代次数。
         * @param value 求解器迭代次数。
         */
        setSolverIterations(value: number): void;
        /**
         * @en Set the collision detection mode for the rigid body.
         * @param value The collision detection mode.
         * @zh 设置刚体的碰撞检测模式。
         * @param value 碰撞检测模式。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Set whether the rigid body is kinematic.
         * @param value True if the body should be kinematic, false otherwise.
         * @zh 设置刚体是否为运动学刚体。
         * @param value 如果为true，则设置为运动学刚体；否则为false。
         */
        setIsKinematic(value: boolean): void;
        /**
         * @en Set the linear and angular factor constraints for the rigid body.
         * @param linearFactor The linear factor constraint.
         * @param angularFactor The angular factor constraint.
         * @zh 设置刚体的线性和角度因子约束。
         * @param linearFactor 线性因子约束。
         * @param angularFactor 角度因子约束。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Set whether the rigid body is a trigger.
         * @param value True if the body should be a trigger, false otherwise.
         * @zh 设置刚体是否为触发器。
         * @param value 如果为true，则设置为触发器；否则为false。
         */
        setTrigger(value: boolean): void;
        /**
         * @en Apply a force to the rigid body.
         * @param force The force to be applied.
         * @param localOffset The offset. If null, force is applied at the center.
         * @zh 应用作用力。
         * @param force 要施加的作用力。
         * @param localOffset 偏移量，如果为null则为中心点。
         */
        private _applyForce;
        /**
         * @en Apply a torque to the rigid body.
         * @param torque The torque to be applied.
         * @zh 应用扭转力。
         * @param torque 要施加的扭转力。
         */
        private _applyTorque;
        /**
         * @en Apply an impulse to the rigid body.
         * @param impulse The impulse to be applied.
         * @param localOffset The offset. If null, force is applied at the center.
         * @zh 应用冲量。
         * @param impulse 要施加的冲量。
         * @param localOffset 偏移量，如果为null则为中心点。
         */
        private _applyImpulse;
        /**
         * @en Apply a torque impulse to the rigid body.
         * @param torqueImpulse The torque impulse to be applied.
         * @zh 应用扭转冲量。
         * @param torqueImpulse 要施加的扭转冲量。
         */
        private _applyTorqueImpulse;
        /**
         * @en Add a force to the rigid body.
         * @param force The force to be added.
         * @param mode The force mode.
         * @param localOffset The offset from the center of mass.
         * @zh 向刚体添加力。
         * @param force 要添加的力。
         * @param mode 力的模式。
         * @param localOffset 相对于质心的偏移量。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Add a torque to the rigid body.
         * @param torque The torque to be added.
         * @param mode The force mode.
         * @zh 向刚体添加扭矩。
         * @param torque 要添加的扭矩。
         * @param mode 力的模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Clear all forces applied to the rigid body.
         * @zh 清除应用到刚体上的所有力。
         */
        private clearForces;
        /**
         * @en Wake up the rigid body.
         * @zh 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @internal
         * @en Update the physics transformation based on the render matrix.
         * @param force Whether to force update.
         * @zh 通过渲染矩阵更新物理矩阵。
         * @param force 是否强制更新。
         */
        _derivePhysicsTransformation(force: boolean): void;
        protected _onScaleChange(scale: Vector3): void;
        /**
         * @en Set the collider shape for the rigid body.
         * @param shape The collider shape to be set.
         * @zh 设置刚体的碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: btColliderShape): void;
        /**
         * @en Destroy the rigid body.
         * @zh 销毁刚体。
         */
        destroy(): void;
    }
    /**
     * @en The `btStaticCollider` class is used to create and manage static colliders.
     * @zh `btStaticCollider` 类用于创建和管理静态碰撞体。
     */
    class btStaticCollider extends btCollider implements IStaticCollider {
        /**@internal */
        static _staticCapableMap: Map<any, any>;
        /**@internal */
        componentEnable: boolean;
        /**
         * @internal
         */
        static __init__(): void;
        protected _initCollider(): void;
        /**
         * @en Set whether the collider is a trigger.
         * @param value True if the collider should be a trigger, false otherwise.
         * @zh 设置碰撞体是否为触发器。
         * @param value 如果为true，则设置为触发器；否则为false。
         */
        setTrigger(value: boolean): void;
        allowSleep(value: boolean): void;
        protected getColliderType(): btColliderType;
        /**
         * @en Check if the collider has a specific capability.
         * @param value The capability to check.
         * @returns Whether the collider has the specified capability.
         * @zh 检查碰撞体是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 碰撞体是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @ignore
         * @en Creates an instance of `btStaticCollider`.
         * @param physicsManager The physics manager.
         * @zh 创建一个 `btStaticCollider` 的实例。
         * @param physicsManager 物理管理器。
         */
        constructor(physicsManager: btPhysicsManager);
        /**
         * @en Check if the static collider has a specific capability.
         * @param value The capability to check.
         * @returns Whether the static collider has the specified capability.
         * @zh 检查静态碰撞体是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 静态碰撞体是否具有指定的能力。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities of the static collider.
         * @zh 初始化静态碰撞体的能力。
         */
        static initCapable(): void;
        /**
         * @en Set the world position of the static collider.
         * @param value The world position.
         * @zh 设置静态碰撞体的世界坐标位置。
         * @param value 坐标位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Destroy Static Collider
         * @zh 销毁静态碰撞器
         */
        destroy(): void;
    }
    /**
     * @internal
     * <code>CollisionMap</code> 类用于实现碰撞组合实例图。
     */
    class CollisionTool {
        /**@internal	*/
        private _hitResultsPoolIndex;
        /**@internal	*/
        private _hitResultsPool;
        /**@internal	*/
        private _contactPonintsPoolIndex;
        /**@internal	*/
        private _contactPointsPool;
        /**@internal */
        private _collisionsPool;
        /**@internal */
        private _collisions;
        /**
         * 创建一个 <code>CollisionMap</code> 实例。
         */
        constructor();
        /**
         * @internal
         */
        getHitResult(): HitResult;
        /**
         * @internal
         */
        recoverAllHitResultsPool(): void;
        /**
         * @internal
         */
        getContactPoints(): ContactPoint;
        /**
         * @internal
         */
        recoverAllContactPointsPool(): void;
        /**
         * @internal
         */
        getCollision(physicComponentA: btCollider, physicComponentB: btCollider): Collision;
        /**
         * @internal
         */
        recoverCollision(collision: Collision): void;
        /**
         * @internal
         */
        garbageCollection(): void;
    }
    /**
     * @en The `btCustomJoint` class is used for detailed control of joints.
     * @zh 类`btCustomJoint`用于实现关节的详细控制。
     */
    class btCustomJoint extends btJoint implements ID6Joint {
        /**
         * @internal
         * @en Minimum angular limit for X-axis rotation
         * @zh X轴旋转的最小角度限制
         */
        _minAngularXLimit: number;
        /**
         * @internal
         * @en Maximum angular limit for X-axis rotation
         * @zh X轴旋转的最大角度限制
         */
        _maxAngularXLimit: number;
        /**
         * @internal
         * @en Minimum angular limit for Y-axis rotation
         * @zh Y轴旋转的最小角度限制
         */
        _minAngularYLimit: number;
        /**
         * @internal
         * @en Maximum angular limit for Y-axis rotation
         * @zh Y轴旋转的最大角度限制
         */
        _maxAngularYLimit: number;
        /**
         * @internal
         * @en Minimum angular limit for Z-axis rotation
         * @zh Z轴旋转的最小角度限制
         */
        _minAngularZLimit: number;
        /**
         * @internal
         * @en Maximum angular limit for Z-axis rotation
         * @zh Z轴旋转的最大角度限制
         */
        _maxAngularZLimit: number;
        /**
         * @internal
         * @en Minimum distance limit
         * @zh 最小距离限制
         */
        _minLinearLimit: number;
        /**
         * @internal
         * @en Maximum distance limit
         * @zh 最大距离限制
         */
        _maxLinearLimit: number;
        /**
         * @internal
         * @en Linear motion along X-axis
         * @zh X轴方向的线性运动
         */
        _linearXMotion: D6Axis;
        /**
         * @internal
         * @en Linear motion along Y-axis
         * @zh Y轴方向的线性运动
         */
        _linearYMotion: D6Axis;
        /**
         * @internal
         * @en Linear motion along Z-axis
         * @zh Z轴方向的线性运动
         */
        _linearZMotion: D6Axis;
        /**
         * @internal
         * @en Angular motion around X-axis
         * @zh 绕X轴的角运动
         */
        _angularXMotion: D6Axis;
        /**
         * @internal
         * @en Angular motion around Y-axis
         * @zh 绕Y轴的角运动
         */
        _angularYMotion: D6Axis;
        /**
         * @internal
         * @en Angular motion around Z-axis
         * @zh 绕Z轴的角运动
         */
        _angularZMotion: D6Axis;
        /**
         * @internal
         * @en axis constraint
         * @zh 轴限制
         */
        _axis: Vector3;
        /**
         * @internal
         * @en Secondary axis constraint
         * @zh 副轴限制
         */
        _secondAxis: Vector3;
        /**
         * @internal
         * @en Bullet physics primary axis representation
         * @zh Bullet物理引擎的轴表示
         */
        _btAxis: number;
        /**
         * @internal
         * @en Bullet physics secondary axis representation
         * @zh Bullet物理引擎的副轴表示
         */
        _btsceondAxis: number;
        /**
         * @en Initializes the joint.
         * @zh 初始化关节。
         */
        initJoint(): void;
        protected _createJoint(): void;
        /**
         * @en Initializes all constraint information for the joint.
         * @zh 初始化关节的所有约束信息。
         */
        _initAllConstraintInfo(): void;
        /**
         * @ignore
         * @en Creates an instance of btCustomJoint.
         * @param manager The Bullet physics manager instance used to handle physics simulations.
         * @zh 创建一个btCustomJoint的实例。
         * @param manager 用于处理物理模拟的Bullet物理管理器实例。
         */
        constructor(manager: btPhysicsManager);
        /**
         * TODO
         * @internal
         * @en Sets the equilibrium point for a specific axis of the constraint.
         * @param axis The axis index to set the equilibrium point for.
         * @param equilibriumPoint The equilibrium point value to set.
         * @zh 为约束的特定轴设置平衡点。
         * @param axis 要设置平衡点的轴索引。
         * @param equilibriumPoint 要设置的平衡点值。
         */
        setEquilibriumPoint(axis: number, equilibriumPoint: number): void;
        /**
         * @en Sets the local position of the joint.
         * @param pos The new local position vector.
         * @zh 设置关节的局部位置。
         * @param pos 新的局部位置向量。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The new connected local position vector.
         * @zh 设置关节的连接局部位置。
         * @param pos 新的连接局部位置向量。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the primary and secondary axes for the joint.
         * @param axis The primary axis vector.
         * @param secendary The secondary axis vector.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴向量。
         * @param secendary 次轴向量。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @internal
         * @en Sets the limit values for each axis.
         * @param axis The constraint type.
         * @param motionType The motion type.
         * @param low The lower limit (optional).
         * @param high The upper limit (optional).
         * @zh 设置各个轴限制值。
         * @param axis 限制类型。
         * @param motionType 运动类型。
         * @param low 下限（可选）。
         * @param high 上限（可选）。
         */
        _setLimit(axis: D6Axis, motionType: D6MotionType, low?: number, high?: number): void;
        /**
         * @internal
         * @en Sets the spring properties for each axis.
         * @param axis The constraint type.
         * @param motionType The motion type.
         * @param springValue The spring stiffness value.
         * @param limitIfNeeded Whether to set the limit if needed (default: true).
         * @zh 设置各个轴的弹簧属性值。
         * @param axis 约束类型。
         * @param motionType 运动类型。
         * @param springValue 弹簧刚度值。
         * @param limitIfNeeded 是否在需要时设置限制（默认：true）。
         */
        _setSpring(axis: D6Axis, motionType: D6MotionType, springValue: number, limitIfNeeded?: boolean): void;
        /**
         * @internal
         * @en Sets the bounce value for each axis.
         * @param axis The constraint type.
         * @param motionType The motion type.
         * @param bounce The bounce value.
         * @zh 设置各个轴的弹力值。
         * @param axis 约束类型。
         * @param motionType 运动类型。
         * @param bounce 弹力值。
         */
        _setBounce(axis: D6Axis, motionType: D6MotionType, bounce: number): void;
        /**
         * @internal
         * @en Sets the damping value for each axis of the constraint.
         * @param axis The constraint type.
         * @param motionType The motion type.
         * @param damp The damping value.
         * @param limitIfNeeded Whether to set the limit if needed (default: true).
         * @zh 设置各个轴的阻尼值。
         * @param axis 约束类型。
         * @param motionType 运动类型。
         * @param damp 阻尼值。
         * @param limitIfNeeded 是否在需要时设置限制（默认：true）。
         */
        _setDamp(axis: D6Axis, motionType: D6MotionType, damp: number, limitIfNeeded?: boolean): void;
        /**
         * @en Sets the motion type for a specific axis of the constraint.
         * @param axis The constraint type to set.
         * @param motionType The motion type to apply.
         * @zh 设置约束特定轴的运动类型。
         * @param axis 要设置的约束类型。
         * @param motionType 要应用的运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Sets the distance limit for the constraint.
         * @param limit The distance limit.
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damp The damping value.
         * @zh 设置约束的距离限制。
         * @param limit 距离限制。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damp 阻尼值。
         */
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en Sets the linear limit for a specific axis of the constraint.
         * @param linearAxis The linear axis to set the limit for.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束特定轴的线性限制。
         * @param linearAxis 要设置限制的线性轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the twist limit for the constraint.
         * @param upper The upper twist limit (in radians).
         * @param lower The lower twist limit (in radians).
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束的扭转限制。
         * @param upper 上扭转限制（弧度）。
         * @param lower 下扭转限制（弧度）。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the swing limit for the constraint.
         * @param yAngle The Y-axis swing limit (in radians).
         * @param zAngle The Z-axis swing limit (in radians).
         * @param bounceness The bounciness of the constraint.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring stiffness.
         * @param damping The damping value.
         * @zh 设置约束的摆动限制。
         * @param yAngle Y轴摆动限制（弧度）。
         * @param zAngle Z轴摆动限制（弧度）。
         * @param bounceness 约束的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧刚度。
         * @param damping 阻尼值。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the drive parameters for a specific axis of the constraint.
         * @param index The drive axis index.
         * @param stiffness The drive stiffness.
         * @param damping The drive damping.
         * @param forceLimit The force limit for the drive.
         * @zh 设置约束特定轴的驱动参数。
         * @param index 驱动轴索引。
         * @param stiffness 驱动刚度。
         * @param damping 驱动阻尼。
         * @param forceLimit 驱动力限制。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Sets the drive transform for the constraint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置约束的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Sets the drive velocity for the constraint.
         * @param position The target linear velocity.
         * @param angular The target angular velocity.
         * @zh 设置约束的驱动速度。
         * @param position 目标线性速度。
         * @param angular 目标角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Gets the current twist angle of the constraint.
         * @zh 获取约束当前的扭转角度。
         */
        getTwistAngle(): number;
        /**
         * @en Gets the current swing Y angle of the constraint.
         * @returns The current swing Y angle.
         * @zh 获取约束当前的Y轴摆动角度。
         * @returns 当前Y轴摆动角度。
         */
        getSwingYAngle(): number;
        /**
         * @en Gets the current swing Z angle of the constraint.
         * @returns The current swing Z angle.
         * @zh 获取约束当前的Z轴摆动角度。
         * @returns 当前Z轴摆动角度。
         */
        getSwingZAngle(): number;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en Class `btFixedJoint` is used to create a fixed joint in the physical engine.
     * @zh 类`btFixedJoint`用于在物理引擎中创建固定关节。
     */
    class btFixedJoint extends btJoint implements IFixedJoint {
        /**
         * @en Creates an instance of `btFixedJoint`.
         * @param manager The physics manager that will handle this joint.
         * @zh 创建一个实例`btFixedJoint`。
         * @param manager 将处理这个关节的物理管理器。
         */
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The class `btHingeJoint` represents a hinge joint between two rigid bodies.
     * @zh 类 `btHingeJoint` 表示两个刚体之间的摆动关节。
     */
    class btHingeJoint extends btJoint implements IHingeJoint {
        /**@internal */
        static ANGULAR_X: number;
        /**@internal */
        static ANGULAR_Y: number;
        /**@internal */
        static ANGULAR_Z: number;
        /**@internal */
        _uperLimit: number;
        /**@internal */
        _lowerLimit: number;
        /**@internal */
        _angularAxis: number;
        /**@internal */
        _enableLimit: boolean;
        /**@internal */
        _enableDrive: boolean;
        protected _createJoint(): void;
        /**
         * @internal
         */
        _initJointConstraintInfo(): void;
        /**
         * @ignore
         * @en Creates an instance of btHingeJoint.
         * @param manager The physics manager.
         * @zh 创建 `btHingeJoint` 的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        /**
         * @en Sets the local position of the joint.
         * @param pos The new local position vector.
         * @zh 设置关节的局部位置。
         * @param pos 新的局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The new connected local position vector.
         * @zh 设置关节的连接局部位置。
         * @param pos 新的连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the lower limit of the joint's rotation.
         * @param lowerLimit The new lower limit in radians.
         * @zh 设置关节旋转的下限。
         * @param lowerLimit 新的下限值，单位为弧度。
         */
        setLowerLimit(lowerLimit: number): void;
        /**
         * @en Sets the upper limit of the joint's rotation.
         * @param value The new upper limit in radians.
         * @zh 设置关节旋转的上限。
         * @param value 新的上限值，单位为弧度。
         */
        setUpLimit(value: number): void;
        /**
         * @en Sets the bounciness of the joint.
         * @param value The bounce factor. If less than or equal to 0, it will be set to 0.
         * @zh 设置关节的弹性。
         * @param value 弹跳因子。如果小于或等于0，将被设置为0。
         */
        setBounceness(value: number): void;
        /**
         * @en Sets the minimum velocity for bounce.
         * @param value The minimum velocity value.
         * @zh 设置弹跳的最小速度。
         * @param value 最小速度值。
         */
        setBouncenMinVelocity(value: number): void;
        /**
         * @en Sets the contact distance for the joint.
         * @param value The contact distance value.
         * @zh 设置关节的接触距离。
         * @param value 接触距离值。
         */
        setContactDistance(value: number): void;
        /**
         * @en Enables or disables the joint limit.
         * @param value True to enable the limit, false to disable.
         * @zh 启用或禁用关节限制。
         * @param value 为true时启用限制，为false时禁用。
         */
        enableLimit(value: boolean): void;
        /**
         * @en Enables or disables the joint drive.
         * @param value True to enable the drive, false to disable.
         * @zh 启用或禁用关节驱动。
         * @param value 为true时启用驱动，为false时禁用。
         */
        enableDrive(value: boolean): void;
        /**
         * @en Enables or disables free spin for the joint.
         * @param value True to enable free spin, false to disable.
         * @zh 启用或禁用关节的自由旋转。
         * @param value 为true时启用自由旋转，为false时禁用。
         */
        enableFreeSpin(value: boolean): void;
        /**
         * @en Sets the axis of rotation for the hinge joint.
         * @param value A vector representing the axis of rotation.
         * @zh 设置铰链关节的旋转轴。
         * @param value 表示旋转轴的向量。
         */
        setAxis(value: Vector3): void;
        /**
         * @en Sets the swing offset for the joint.
         * @param value The swing offset vector.
         * @zh 设置关节的摆动偏移。
         * @param value 摆动偏移向量。
         */
        setSwingOffset(value: Vector3): void;
        /**
         * @en Gets the current angle of the joint.
         * @zh 获取关节的当前角度。
         */
        getAngle(): number;
        /**
         * @en Gets the current velocity of the joint.
         * @zh 获取关节的当前速度。
         */
        getVelocity(): Readonly<Vector3>;
        /**
         * @en Sets the hard limit for the joint.
         * @param lowerLimit The lower limit of the joint's movement.
         * @param upperLimit The upper limit of the joint's movement.
         * @param contactDist The contact distance.
         * @zh 设置关节的硬限制。
         * @param lowerLimit 关节运动的下限。
         * @param upperLimit 关节运动的上限。
         * @param contactDist 接触距离。
         */
        setHardLimit(lowerLimit: number, upperLimit: number, contactDist: number): void;
        /**
         * @en Sets the soft limit for the joint.
         * @param lowerLimit The lower limit of the joint's movement.
         * @param upperLimit The upper limit of the joint's movement.
         * @param stiffness The stiffness of the soft limit.
         * @param damping The damping of the soft limit.
         * @zh 设置关节的软限制。
         * @param lowerLimit 关节运动的下限。
         * @param upperLimit 关节运动的上限。
         * @param stiffness 软限制的刚度。
         * @param damping 软限制的阻尼。
         */
        setSoftLimit(lowerLimit: number, upperLimit: number, stiffness: number, damping: number): void;
        /**
         * @en Sets the drive velocity for the joint.
         * @param velocity The target velocity for the joint's motor.
         * @zh 设置关节的驱动速度。
         * @param velocity 关节电机的目标速度。
         */
        setDriveVelocity(velocity: number): void;
        /**
         * @en Sets the drive force limit for the joint.
         * @param limit The maximum force that can be applied by the joint's motor.
         * @zh 设置关节的驱动力限制。
         * @param limit 关节电机可以施加的最大力。
         */
        setDriveForceLimit(limit: number): void;
        /**
         * @en Sets the drive gear ratio for the joint.
         * @param ratio The gear ratio for the joint's motor.
         * @zh 设置关节的驱动齿轮比。
         * @param ratio 关节电机的齿轮比。
         */
        setDriveGearRatio(ratio: number): void;
        /**
         * @en Sets a specific flag for the hinge joint.
         * @param flag The flag to be set.
         * @param value The boolean value to set the flag to.
         * @zh 为铰链关节设置特定标志。
         * @param flag 要设置的标志。
         * @param value 设置标志的布尔值。
         */
        setHingeJointFlag(flag: number, value: boolean): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en Class `btJoint` is the base class for all joints in LayaAir physics engine.
     * @zh 类`btJoint`用于实现物理关节的基类。
     */
    class btJoint implements IJoint {
        /**@internal */
        static _jointCapableMap: Map<any, any>;
        /** @internal TODO*/
        static CONSTRAINT_POINT2POINT_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_HINGE_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_CONETWIST_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_D6_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_SLIDER_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_CONTACT_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_GEAR_CONSTRAINT_TYPE: number;
        /** @internal */
        static CONSTRAINT_FIXED_CONSTRAINT_TYPE: number;
        /** @internal TODO*/
        static CONSTRAINT_MAX_CONSTRAINT_TYPE: number;
        /** @internal error reduction parameter (ERP)*/
        static CONSTRAINT_CONSTRAINT_ERP: number;
        /** @internal*/
        static CONSTRAINT_CONSTRAINT_STOP_ERP: number;
        /** @internal constraint force mixing（CFM）*/
        static CONSTRAINT_CONSTRAINT_CFM: number;
        /** @internal*/
        static CONSTRAINT_CONSTRAINT_STOP_CFM: number;
        /**@internal */
        _connectCollider: ICollider;
        /**@internal */
        _collider: ICollider;
        /**@internal */
        _connectOwner: Sprite3D;
        /**@internal */
        owner: Sprite3D;
        /**@internal */
        _id: number;
        /**@internal */
        _btJoint: any;
        /**@internal 回调参数*/
        _btJointFeedBackObj: number;
        /**@internal */
        private _getJointFeedBack;
        /**@internal */
        _constraintType: number;
        _manager: btPhysicsManager;
        /**
         * @en Whether to perform collision detection between the two connected objects.
         * @zh 连接的两个物体是否进行碰撞检测。
         */
        _disableCollisionsBetweenLinkedBodies: boolean;
        /**@internal */
        _anchor: Vector3;
        /** @internal */
        _connectAnchor: Vector3;
        /**@internal */
        private _currentForce;
        /**@internal */
        private _breakForce;
        /**@internal */
        private _currentTorque;
        /**@internal */
        private _breakTorque;
        /**@internal */
        protected _btTempVector30: number;
        /**@internal */
        protected _btTempVector31: number;
        /**@internal */
        protected _btTempTrans0: number;
        /**@internal */
        protected _btTempTrans1: number;
        static __init__(): void;
        /**
         * @en Initialize the joint capability map.
         * @zh 初始化关节能力映射。
         */
        static initJointCapable(): void;
        /**
         * @en Get the joint capability.
         * @param value The joint capability to check.
         * @returns Whether the joint has the specified capability.
         * @zh 获取关节能力。
         * @param value 要检查的关节能力。
         * @returns 关节是否具有指定的能力。
         */
        static getJointCapable(value: EJointCapable): boolean;
        /**
         * @en Creates an instance of btJoint.
         * @param manager The physics manager.
         * @zh 创建一个 btJoint 的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
        destroy(): void;
        /**
         * @en Set the collider for the joint.
         * @param collider The collider to set.
         * @zh 设置关节的碰撞器。
         * @param collider 要设置的碰撞器。
         */
        setCollider(collider: btCollider): void;
        /**
         * @en Set the connected collider for the joint.
         * @param collider The connected collider to set.
         * @zh 设置关节的连接碰撞器。
         * @param collider 要设置的连接碰撞器。
         */
        setConnectedCollider(collider: btCollider): void;
        /**
         * @en Set the local position of the joint.
         * @param pos The local position to set.
         * @zh 设置关节的局部位置。
         * @param pos 要设置的局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Set the connected local position of the joint.
         * @param pos The connected local position to set.
         * @zh 设置关节的连接局部位置。
         * @param pos 要设置的连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Get the linear force of the joint.
         * @zh 获取关节的线性力。
         */
        getlinearForce(): Vector3;
        /**
         * @en Get the angular force of the joint.
         * @zh 获取关节的角力。
         */
        getAngularForce(): Vector3;
        /**
         * @en Check if the joint is valid.
         * @zh 检查关节是否有效。
         */
        isValid(): boolean;
        /**
         * @en Enable or disable the joint.
         * @param value Whether to enable the joint.
         * @zh 启用或禁用关节。
         * @param value 是否启用关节。
         */
        isEnable(value: boolean): void;
        /**
         * @en Set whether collision is enabled between connected bodies.
         * @param value Whether to enable collision.
         * @zh 设置连接的物体之间是否启用碰撞。
         * @param value 是否启用碰撞。
         */
        isCollision(value: boolean): void;
        protected initJoint(): void;
        /**
         * @en Set the owner of the joint.
         * @param owner The owner to set.
         * @zh 设置关节的所有者。
         * @param owner 要设置的所有者。
         */
        setOwner(owner: Sprite3D): void;
        /**
         * @en Check if the joint is constrained by break force or torque.
         * @zh 检查关节是否受到断裂力或扭矩的约束。
         */
        _isBreakConstrained(): boolean;
        /**
         * @internal
         * @en Get the feedback information from bt.
         * @zh 获取bt回调参数。
         */
        _btFeedBackInfo(): void;
        /**
         * @en Set the mass scale of the connected body.
         * @param value The mass scale to set.
         * @zh 设置连接物体的质量比例。
         * @param value 要设置的质量比例。
         */
        setConnectedMassScale(value: number): void;
        /**
         * @en Set the inertia scale of the connected body.
         * @param value The inertia scale to set.
         * @zh 设置连接物体的惯性比例。
         * @param value 要设置的惯性比例。
         */
        setConnectedInertiaScale(value: number): void;
        /**
         * @en Set the mass scale of the joint.
         * @param value The mass scale to set.
         * @zh 设置关节的质量比例。
         * @param value 要设置的质量比例。
         */
        setMassScale(value: number): void;
        /**
         * @en Set the inertia scale of the joint.
         * @param value The inertia scale to set.
         * @zh 设置关节的惯性比例。
         * @param value 要设置的惯性比例。
         */
        setInertiaScale(value: number): void;
        /**
         * @en Set the break force of the joint.
         * @param value The break force to set.
         * @zh 设置关节的断裂力。
         * @param value 要设置的断裂力。
         */
        setBreakForce(value: number): void;
        /**
         * @en Set the break torque of the joint.
         * @param value The break torque to set.
         * @zh 设置关节的断裂扭矩。
         * @param value 要设置的断裂扭矩。
         */
        setBreakTorque(value: number): void;
    }
    /**
     * @en The `btSpringJoint` class is used to create and manage spring joints in the physics engine.
     * @zh 类`btSpringJoint`用于在物理引擎中创建和管理弹簧关节。
     */
    class btSpringJoint extends btJoint implements ISpringJoint {
        /**@internal */
        static LINEARSPRING_AXIS_X: number;
        /**@internal */
        static LINEARSPRING_AXIS_Y: number;
        /**@internal */
        static LINEARSPRING_AXIS_Z: number;
        /**@internal */
        static ANGULARSPRING_AXIS_X: number;
        /**@internal */
        static ANGULARSPRING_AXIS_Y: number;
        /**@internal */
        static ANGULARSPRING_AXIS_Z: number;
        /**@internal */
        _minDistance: number;
        /**@internal */
        _maxDistance: number;
        protected _createJoint(): void;
        /**
         * @internal
         * @en Initializes the joint constraint information.
         * @zh 初始化关节约束信息。
         */
        _initJointConstraintInfo(): void;
        /**
         * @ignore
         * @en Creates an instance of the `btSpringJoint` class.
         * @param manager The physics manager.
         * @zh 创建一个btSpringJoint类的实例。
         * @param manager 物理管理器。
         */
        constructor(manager: btPhysicsManager);
        /**
         * @en Sets the local position of the joint.
         * @param pos The local position.
         * @zh 设置关节的局部位置。
         * @param pos 局部位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the connected local position of the joint.
         * @param pos The connected local position.
         * @zh 设置关节连接的局部位置。
         * @param pos 连接局部位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Sets the swing offset of the joint.
         * @param value The swing offset.
         * @zh 设置关节的摆动偏移量。
         * @param value 摆动偏移量。
         */
        setSwingOffset(value: Vector3): void;
        /**
         * @en Sets the minimum distance of the spring joint.
         * @param distance The minimum distance value.
         * @zh 设置弹簧关节的最小距离。
         * @param distance 最小距离值。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Sets the maximum distance of the spring joint.
         * @param distance The maximum distance value.
         * @zh 设置弹簧关节的最大距离。
         * @param distance 最大距离值。
         */
        setMaxDistance(distance: number): void;
        /**
         * @ignore
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Sets the stiffness of the spring joint.
         * @param stiffness The stiffness value.
         * @zh 设置弹簧关节的刚度。
         * @param stiffness 刚度值。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Sets the damping of the spring joint.
         * @param damping The damping value.
         * @zh 设置弹簧关节的阻尼。
         * @param damping 阻尼值。
         */
        setDamping(damping: number): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The `btBoxColliderShape` class is used to create and manage box collision shapes for the physics engine.
     * @zh 类`btBoxColliderShape` 用于创建和管理物理引擎的盒子碰撞形状。
     */
    class btBoxColliderShape extends btColliderShape implements IBoxColliderShape {
        /** @internal */
        private _btSize;
        /** @internal */
        private _size;
        constructor();
        private changeBoxShape;
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the size of the box collider shape.
         * @param size The new size of the box.
         * @zh 设置盒子碰撞器形状的大小。
         * @param size 盒子的新大小。
         */
        setSize(size: Vector3): void;
        /**
         * @en Destroys the box collider shape and releases resources.
         * @zh 销毁盒子碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btCapsuleColliderShape` class is used to create and manage capsule-shaped colliders.
     * @zh 类 `btCapsuleColliderShape` 用于创建和管理胶囊形状的碰撞体。
     */
    class btCapsuleColliderShape extends btColliderShape implements ICapsuleColliderShape {
        private static _tempVector30;
        /**@internal */
        private _radius;
        /**@internal */
        private _length;
        /**@internal */
        private _orientation;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the capsule.
         * @param radius The radius of the capsule.
         * @zh 设置胶囊体的半径。
         * @param radius 胶囊体的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the capsule.
         * @param height The height of the capsule.
         * @zh 设置胶囊体的高度。
         * @param height 胶囊体的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the capsule.
         * @param upAxis The up axis of the capsule.
         * @zh 设置胶囊体的朝向轴。
         * @param upAxis 胶囊体的朝向轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Sets the world scale of the capsule collider shape.
         * @param scale The scale of the capsule collider shape.
         * @zh 设置胶囊碰撞器形状的世界缩放。
         * @param scale 缩放比例。
         */
        setWorldScale(scale: Vector3): void;
        /**
         * @en Destroys the capsule collider shape and releases resources.
         * @zh 销毁胶囊碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btColliderShape` class is the base class for defining and managing physics collision shapes.
     * @zh 类`btColliderShape` 用于定义和管理物理碰撞形状的基类。
     */
    class btColliderShape implements IColliderShape {
        /**
         * @en Shape orientation along positive X-axis
         * @zh 形状方向沿 X 轴正向
         */
        static SHAPEORIENTATION_UPX: number;
        /**
         * @en Shape orientation along positive Y-axis
         * @zh 形状方向沿 Y 轴正向
         */
        static SHAPEORIENTATION_UPY: number;
        /**
         * @en Shape orientation along positive Z-axis
         * @zh 形状方向沿 Z 轴正向
         */
        static SHAPEORIENTATION_UPZ: number;
        /** @internal */
        static SHAPETYPES_BOX: number;
        /** @internal */
        static SHAPETYPES_SPHERE: number;
        /** @internal */
        static SHAPETYPES_CYLINDER: number;
        /** @internal */
        static SHAPETYPES_CAPSULE: number;
        /** @internal */
        static SHAPETYPES_CONVEXHULL: number;
        /** @internal */
        static SHAPETYPES_COMPOUND: number;
        /** @internal */
        static SHAPETYPES_STATICPLANE: number;
        /** @internal */
        static SHAPETYPES_CONE: number;
        /** @internal */
        static SHAPETYPES_HEIGHTFIELDTERRAIN: number;
        _type: number;
        _btShape: any;
        _btScale: any;
        _localOffset: Vector3;
        _worldScale: Vector3;
        _btCollider: btCollider;
        _destroyed: boolean;
        constructor();
        getOffset(): Vector3;
        getPhysicsShape(): any;
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @override
         */
        protected _getType(): number;
        /**
         * @en Sets the local offset of the shape.
         * @param value The offset value.
         * @zh 设置形状的局部偏移。
         * @param value 偏移量。
         */
        setOffset(value: Vector3): void;
        /**
         * @en Sets the world scale of the shape.
         * @param scale The scale value.
         * @zh 设置形状的世界缩放。
         * @param scale 缩放比例。
         */
        setWorldScale(scale: Vector3): void;
        /**
         * @en Destroys the collider shape and releases resources.
         * @zh 销毁碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en use to create compound collider.
     * @zh 用于创建组合碰撞器。
     */
    class btCompoundColliderShape extends btColliderShape implements ICompoundColliderShape {
        /**@internal */
        private _physicsComponent;
        /**@internal */
        private _btVector3One;
        /**@internal */
        private _btTransform;
        /**@internal */
        private _btOffset;
        /**@internal */
        private _btRotation;
        /**@internal */
        private _childColliderShapes;
        /**
         * @en create a new instance of btCompoundColliderShape.
         * @zh 创建一个新的组合碰撞形状实例。
         */
        constructor();
        clearChildShape(): void;
        protected _getType(): number;
        addChildShape(shape: btColliderShape): void;
        removeChildShape(shape: btColliderShape, index: number): void;
        setShapeData(component: PhysicsColliderComponent): void;
        getChildShapeCount(): number;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    /**
     * @en The `btConeColliderShape` class creates a cone shape, which is a cylinder with a conical top.
     * @zh 类 `btConeColliderShape` 用于创建和管理物理引擎中圆锥碰撞器形状。
     */
    class btConeColliderShape extends btColliderShape implements IConeColliderShape {
        /**@internal */
        private _radius;
        /**@internal */
        private _length;
        /**@internal */
        private _orientation;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the cone.
         * @param radius The radius to set.
         * @zh 设置圆锥的半径。
         * @param radius 圆锥的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the cone.
         * @param height The height to set.
         * @zh 设置圆锥的高度。
         * @param height 圆锥的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the cone.
         * @param upAxis The up axis to set.
         * @zh 设置圆锥的朝向轴。
         * @param upAxis 圆锥的朝向轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Destroys the cone collider shape and releases resources.
         * @zh 销毁圆锥碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btCylinderColliderShape` class is used to create and manage cylinder collision shapes.
     * @zh `btCylinderColliderShape` 类用于创建和管理圆柱体碰撞形状。
     */
    class btCylinderColliderShape extends btColliderShape implements ICylinderColliderShape {
        private static _tempVector30;
        /**@internal */
        private _radius;
        /**@internal */
        private _length;
        /**@internal */
        private _orientation;
        private _btSize;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        /**
         * @en Sets the radius of the cylinder.
         * @param radius The radius of the cylinder.
         * @zh 设置圆柱体的半径。
         * @param radius 圆柱体的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the cylinder.
         * @param height The height of the cylinder.
         * @zh 设置圆柱体的高度。
         * @param height 圆柱体的高度。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the cylinder.
         * @param upAxis The up axis of the cylinder.
         * @zh 设置圆柱体的朝上轴。
         * @param upAxis 圆柱体的朝上轴。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Destroys the cylinder collider shape and releases resources.
         * @zh 销毁圆柱体碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en The `btMeshColliderShape` class is used to create and manage mesh-based collision shapes.
     * @zh `btMeshColliderShape` 类用于创建和管理基于网格的碰撞形状。
     */
    class btMeshColliderShape extends btColliderShape implements IMeshColliderShape {
        /**@internal */
        private _mesh;
        /**@internal */
        private _physicMesh;
        /**@internal */
        static _btTempVector30: number;
        /**@internal */
        static _btTempVector31: number;
        /**@internal */
        static _btTempVector32: number;
        private _limitvertex;
        private _convex;
        /**
         * @en The mesh of the collider shape.
         * @zh 碰撞器形状的网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        static __init__(): void;
        /** @ignore */
        constructor();
        /**
         * @en Set the physics mesh from a given mesh.
         * @param value The mesh to set.
         * @zh 从给定的网格设置物理网格。
         * @param value 网格。
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Set the convex mesh.
         * @param value The mesh to set.
         * @zh 设置凸包网格。
         * @param value 网格。
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Set the limit of vertices.
         * @param limit The limit value.
         * @zh 设置顶点限制。
         * @param limit 限制值。
         */
        setLimitVertex(limit: number): void;
        /**
         * @internal
         * @en Whether the shape is convex.
         * @zh 形状是否为凸包。
         */
        get convex(): boolean;
        private _createPhysicsMeshFromMesh;
        private _createConvexMeshFromMesh;
        protected _createTrianggleMeshGeometry(): void;
        protected _createConvexMeshGeometry(): void;
        /**
         * @en Set the world scale of the collider shape.
         * @param value The scale vector to set.
         * @zh 设置碰撞器形状的世界缩放。
         * @param value 缩放向量。
         */
        setWorldScale(value: Vector3): void;
    }
    /**
     * @en The `btSphereColliderShape` class is used to create and manage spherical collision shapes.
     * @zh `btSphereColliderShape` 类用于创建和管理球形碰撞体形状。
     */
    class btSphereColliderShape extends btColliderShape implements ISphereColliderShape {
        /**@internal */
        private _radius;
        /** @ignore */
        constructor();
        protected _getType(): number;
        protected _createShape(): void;
        /**
         * @en Sets the radius of the sphere.
         * @param radius The radius to set.
         * @zh 设置球体的半径。
         * @param radius 要设置的半径。
         */
        setRadius(radius: number): void;
        /**
         * @en Destroys the sphere collider shape and cleans up resources.
         * @zh 销毁球形碰撞体形状并清理资源。
         */
        destroy(): void;
    }
    /**
     * @en Interface for character controllers.
     * @zh 角色控制器的接口。
     */
    interface ICharacterController extends ICollider {
        /**
         * @en Moves the character using a "collide-and-slide" algorithm.
         * @param disp Displacement vector
         * @zh 使用"碰撞并滑动"算法移动角色。
         * @param disp 位移向量
         */
        move(disp: Vector3): void;
        /**
         * @en Make the character jump.
         * @param velocity Jump velocity
         * @zh 使角色跳跃。
         * @param velocity 跳跃速度
         */
        jump?(velocity: Vector3): void;
        /**
         * @en Set position of CharacterController.
         * @param value New position
         * @zh 设置角色控制器的位置。
         * @param value 位置
         */
        setPosition(value: Vector3): void;
        /**
         * @en Get current position of characterController.
         * @returns Current position
         * @zh 获取角色控制器的当前位置。
         * @returns 当前位置
         */
        getPosition?(): Vector3;
        /**
         * @en Set the step height for the characterController.
         * @param offset The new step offset
         * @zh 设置角色控制器的步高。
         * @param offset 步高偏移量
         */
        setStepOffset?(offset: number): void;
        /**
         * @en Set skin width for the characterController.
         * @param width The new skin width
         * @zh 设置角色控制器的皮肤宽度。
         * @param width 皮肤宽度
         */
        setSkinWidth?(width: number): void;
        /**
         * @en Set the 'up' direction for the characterController.
         * @param up The up direction
         * @zh 设置角色控制器的"向上"方向。
         * @param up 向上方向
         */
        setUpDirection?(up: Vector3): void;
        /**
         * @en Get the vertical velocity of the characterController.
         * @returns Vertical velocity
         * @zh 获取角色控制器的垂直速度。
         * @returns 垂直速度
         */
        getVerticalVel?(): number;
        /**
         * @en Set the slope limit for the characterController.
         * @param slopeLimit The new slope limit
         * @zh 设置角色控制器的斜坡限制。
         * @param slopeLimit 斜坡限制
         */
        setSlopeLimit?(slopeLimit: number): void;
        /**
         * @en Set the gravity for the characterController.
         * @param value Gravity vector
         * @zh 设置角色控制器的重力。
         * @param value 重力
         */
        setGravity?(value: Vector3): void;
        /**
         * @en Set the radius of the characterController.
         * @param value The new radius
         * @zh 设置角色的半径。
         * @param value 半径
         */
        setRadius?(value: number): void;
        /**
         * @en Set the height of the characterController.
         * @param value The height
         * @zh 设置角色的高度。
         * @param value 高度
         */
        setHeight?(value: number): void;
        /**
         * @en Set the minimum distance for the characterController.
         * @param value The minimum distance
         * @zh 设置角色控制器的最小距离。
         * @param value 最小距离
         */
        setminDistance(value: number): void;
        /**
         * @en Set the local offset of the characterController's shape.
         * @param value The local offset
         * @zh 设置角色控制器形状的局部偏移。
         * @param value 局部偏移
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Set the push force for the characterController.
         * @param value The push force
         * @zh 设置角色控制器的推力。
         * @param value 推力
         */
        setPushForce?(value: number): void;
        /**
         * @en Set the jump speed for the characterController.
         * @param value The jump speed
         * @zh 设置角色控制器的跳跃速度。
         * @param value 跳跃速度
         */
        setJumpSpeed?(value: number): void;
        /**
         * @en Whether the character is on the ground.
         * @returns Whether the character is on the ground.
         * @zh 是否在地面上。
         * @returns 是否在地面上。
         */
        isGrounded?(): boolean;
    }
    /**
     * @en Interface for collider.
     * @zh 碰撞器的接口。
     */
    interface ICollider {
        /**
         * @en The owner node of the collider.
         * @zh 碰撞器所属的节点。
         */
        owner: Node;
        /**
         * @en Indicates whether the collider can be enabled. It's true only when placed in the scene and the physics component is effective.
         * @zh 是否可以启用，只有放入scene中且物理组件生效才会为true。
         */
        active: boolean;
        /**
         * @en Index in the physics update list.
         * @zh 在物理更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**
         * @internal
         * @en Indicates whether the component is enabled.
         * @zh 指示组件是否启用。
         */
        componentEnable: boolean;
        /**
         * @en The physics collider component associated with this collider.
         * @zh 与此碰撞器关联的物理碰撞器组件。
         */
        component: PhysicsColliderComponent;
        /**
         * @en Get the capability of the collider.
         * @param value The capability value to check.
         * @zh 获取碰撞器的能力。
         * @param value 要检查的能力值。
         */
        getCapable(value: number): boolean;
        /**
         * @en Set the collider shape.
         * @param shape The collider shape to set.
         * @zh 设置碰撞器形状。
         * @param shape 要设置的碰撞器形状。
         */
        setColliderShape(shape: IColliderShape): void;
        /**
         * @en Destroy the collider.
         * @zh 销毁碰撞器。
         */
        destroy(): void;
        /**
         * @en Set the collision group of the collider.
         * @param value The collision group value.
         * @zh 设置碰撞器的碰撞组。
         * @param value 碰撞组的值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Set the groups that this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与之碰撞的组。
         * @param value 碰撞掩码的值。
         */
        setCanCollideWith(value: number): void;
        /**
         * @en Set the owner node of the collider.
         * @param node The owner node to set.
         * @zh 设置碰撞器的所有者节点。
         * @param node 要设置的所有者节点。
         */
        setOwner(node: Node): void;
        /**
         * @en Handle transform changes of the collider.
         * @param flag The transform change flag.
         * @zh 处理碰撞器的变换改变。
         * @param flag 变换改变标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Set the bounciness of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性。
         * @param value 弹性值。
         */
        setBounciness?(value: number): void;
        /**
         * @en Set the friction of the collider.
         * @param value The friction value.
         * @zh 设置碰撞器的摩擦力。
         * @param value 摩擦力值。
         */
        setfriction?(value: number): void;
        /**
         * @en Set the rolling friction of the collider.
         * @param value The rolling friction value.
         * @zh 设置碰撞器的滚动摩擦力。
         * @param value 滚动摩擦力值。
         */
        setRollingFriction?(value: number): void;
        /**
         * @en Set the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction?(value: number): void;
        /**
         * @en Set the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction?(value: number): void;
        /**
         * @en Set the friction combine mode of the collider.
         * @param value The friction combine mode.
         * @zh 设置碰撞器的摩擦力合并模式。
         * @param value 摩擦力合并模式。
         */
        setFrictionCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Set the bounce combine mode of the collider.
         * @param value The bounce combine mode.
         * @zh 设置碰撞器的弹性合并模式。
         * @param value 弹性合并模式。
         */
        setBounceCombine?(value: PhysicsCombineMode): void;
        /**
         * @en Set the event filter for the collider.
         * @param events An array of event names to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter?(events: string[]): void;
        /**
         * @en Set whether the collider allows sleep.
         * @param value Whether the collider allows sleep.
         * @zh 设置碰撞器是否允许睡眠。
         * @param value 是否允许睡眠。
         */
        allowSleep(value: boolean): void;
    }
    /**
     * @en Interface of physics dynamic collider.
     * @zh 物理动态碰撞器的接口。
     */
    interface IDynamicCollider extends ICollider {
        /**
         * @en Sets the linear damping coefficient.
         * @param value Linear damping coefficient.
         * @zh 设置线性阻尼系数。
         * @param value 线性阻尼系数。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Sets the angular damping coefficient.
         * @param value Angular damping coefficient.
         * @zh 设置角度阻尼系数。
         * @param value 角度阻尼系数。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Sets the linear velocity of the actor.
         * @param value New linear velocity of actor.
         * @zh 设置物体的线性速度。
         * @param value 物体的新线性速度。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the actor.
         * @zh 获取物体的线性速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Sets the angular velocity of the actor.
         * @param value New angular velocity of actor.
         * @zh 设置物体的角速度。
         * @param value 物体的新角速度。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Gets the angular velocity of the actor.
         * @zh 获取物体的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Sets the mass of a dynamic actor.
         * @param value New mass value for the actor.
         * @zh 设置动态物体的质量。
         * @param value 物体的新质量值。
         */
        setMass(value: number): void;
        /**
         * @en Sets the pose of the center of mass relative to the actor.
         * @param value Mass frame offset transform relative to the actor frame.
         * @zh 设置质心相对于物体的位置。
         * @param value 质心相对于物体框架的偏移变换。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Sets the inertia tensor, using a parameter specified in mass space coordinates.
         * @param value New mass space inertia tensor for the actor.
         * @zh 设置惯性张量，使用质量空间坐标中指定的参数。
         * @param value 物体的新质量空间惯性张量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.
         * @param value Energy below which an actor may go to sleep.
         * @zh 设置物体可能进入睡眠状态的质量归一化动能阈值。
         * @param value 物体可能进入睡眠状态的能量阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the angular velocity threshold for the rigid body to sleep.
         * @param value The angular velocity threshold.
         * @zh 设置刚体进入睡眠状态的角速度阈值。
         * @param value 角速度阈值。
         */
        setSleepAngularThreshold?(value: number): void;
        /**
        * @en Whether it is sleeping.
        * @zh 是否处于睡眠状态。
        */
        isSleeping(): boolean;
        /**
         * @en Sets the colliders' collision detection mode.
         * @param value Rigid body flag.
         * @zh 设置碰撞器的碰撞检测模式。
         * @param value 刚体标志。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Controls whether physics affects the dynamic collider.
         * @param value Whether physics affects the dynamic collider.
         * @zh 控制物理是否影响动态碰撞器。
         * @param value 物理是否影响动态碰撞器。
         */
        setIsKinematic(value: boolean): void;
        /**
         * @en Raises or clears a particular rigid dynamic lock flag.
         * @param linearFactor Linear constraint factor.
         * @param angularFactor Angular constraint factor.
         * @zh 设置或清除特定的刚体动态锁定标志。
         * @param linearFactor 线性约束因子。
         * @param angularFactor 角度约束因子。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Apply a force to the dynamic collider.
         * @param force The force to make the collider move.
         * @param mode The mode of applying the force.
         * @param localOffset The local offset where the force is applied.
         * @zh 对动态碰撞器施加力。
         * @param force 使碰撞器移动的力。
         * @param mode 施加力的模式。
         * @param localOffset 力施加的局部偏移。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Apply a torque to the dynamic collider.
         * @param torque The torque to make the collider rotate.
         * @param mode The mode of applying the torque.
         * @zh 对动态碰撞器施加扭矩。
         * @param torque 使碰撞器旋转的扭矩。
         * @param mode 施加扭矩的模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Forces a collider to sleep at least one frame.
         * @zh 强制碰撞器至少休眠一帧。
         */
        sleep?(): void;
        /**
         * @en Forces a collider to wake up.
         * @zh 强制唤醒碰撞器。
         */
        wakeUp(): void;
        /**
         * @en Sets the world position of the collider.
         * @param value The new world position.
         * @zh 设置碰撞器的世界位置。
         * @param value 位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Sets the world rotation of the collider.
         * @param value The new world rotation.
         * @zh 设置碰撞器的世界旋转。
         * @param value 旋转四元数。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Sets whether the collider is a trigger.
         * @param value Whether the collider is a trigger.
         * @zh 设置碰撞器是否为触发器。
         * @param value 碰撞器是否为触发器。
         */
        setTrigger(value: boolean): void;
    }
    /**
     * @en Interface for physics creation utility.
     * @zh 物理创建工具接口。
     */
    interface IPhysicsCreateUtil {
        /**
         * @en Initialize the physics system.
         * @zh 初始化物理。
         */
        initialize(): Promise<void>;
        /**
         * @en Set the physics engine capabilities.
         * @zh 设置物理引擎能力。
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the physics engine capability.
         * @param value The capability to check.
         * @zh 获取物理引擎能力。
         * @param value 要检查的能力。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Create a physics manager.
         * @param physicsSettings The physics settings.
         * @zh 创建物理管理器。
         * @param physicsSettings 物理设置。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): IPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @zh 创建动态碰撞体。
         * @param manager 物理管理器。
         */
        createDynamicCollider(manager: IPhysicsManager): IDynamicCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @zh 创建静态碰撞体。
         * @param manager 物理管理器。
         */
        createStaticCollider(manager: IPhysicsManager): IStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @zh 创建角色碰撞器。
         * @param manager 物理管理器。
         */
        createCharacterController(manager: IPhysicsManager): ICharacterController;
        /**
         * @en Create fixed joint.
         * @param manager The physics manager.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         */
        createFixedJoint(manager: IPhysicsManager): IFixedJoint;
        /**
         * @en Create hinge joint.
         * @param manager The physics manager.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         */
        createHingeJoint(manager: IPhysicsManager): IHingeJoint;
        /**
         * @en Create spring joint.
         * @param manager The physics manager.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         */
        createSpringJoint(manager: IPhysicsManager): ISpringJoint;
        /**
         * @en Create Custom Joint.
         * @param manager The physics manager.
         * @zh 创建自定义关节。
         * @param manager 物理管理器。
         */
        createD6Joint(manager: IPhysicsManager): ID6Joint;
        /**
         * @en Create box collider shape.
         * @zh 创建盒形碰撞器形状。
         */
        createBoxColliderShape(): IBoxColliderShape;
        /**
         * @en Create sphere collider shape.
         * @zh 创建球形碰撞器形状。
         */
        createSphereColliderShape(): ISphereColliderShape;
        /**
         * @en Create plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create capsule collider shape.
         * @zh 创建胶囊碰撞器形状。
         */
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        /**
         * @en Create mesh collider shape.
         * @zh 创建网格碰撞器形状。
         */
        createMeshColliderShape?(): IMeshColliderShape;
        /**
         * @en Create cylinder collider shape.
         * @zh 创建圆柱碰撞器形状。
         */
        createCylinderColliderShape?(): ICylinderColliderShape;
        /**
         * @en Create cone collider shape.
         * @zh 创建圆锥碰撞器形状。
         */
        createConeColliderShape?(): IConeColliderShape;
        /**
         * @en Create height field shape.
         * @zh 创建高度场形状。
         */
        createHeightFieldShape?(): IHeightFieldShape;
        /**
         * @en Create compound collider shape.
         * @zh 创建组合碰撞形状。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create curve mesh.
         * @param mesh The input mesh.
         * @zh 创建曲线网格。
         * @param mesh 输入的网格。
         */
        createCorveMesh?(mesh: Mesh): Mesh;
    }
    /**
     * @en Interface for physics manager.
     * @zh 物理管理器的接口。
     */
    interface IPhysicsManager {
        /**
         * @en Set gravity for the physics world.
         * @param gravity Physics gravity vector.
         * @zh 设置物理世界的重力。
         * @param gravity 物理重力向量。
         */
        setGravity(gravity: Vector3): void;
        /**
         * @en Add ICollider into the manager.
         * @param collider StaticCollider or DynamicCollider to be added.
         * @zh 向物理管理器添加碰撞器。
         * @param collider 要添加的静态碰撞器或动态碰撞器。
         * @blueprintIgnore
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Set whether the collider is active.
         * @param collider The collider to set active state.
         * @param value Whether the collider is active.
         * @zh 是否启用碰撞器。
         * @param collider 要设置启用状态的碰撞器。
         * @param value 碰撞器是否处于启用状态。
         * @blueprintIgnore
         */
        setActiveCollider(collider: ICollider, value: boolean): void;
        /**
         * @en Remove ICollider from the physics manager.
         * @param collider StaticCollider or DynamicCollider to be removed.
         * @zh 从物理管理器中移除碰撞器。
         * @param collider 要移除的静态碰撞器或动态碰撞器。
         * @blueprintIgnore
         */
        removeCollider(collider: ICollider): void;
        /**
         * @en Update the physics world, called on every frame to update object poses.
         * @param elapsedTime Step time for the update.
         * @zh 更新物理世界，每帧调用以更新对象姿态。
         * @param elapsedTime 更新的步进时间。
         * @blueprintIgnore
         */
        update(elapsedTime: number): void;
        /**
         * @en Perform a raycast to find the first collision.
         * @param ray The ray to cast.
         * @param outHitResult The result of the raycast.
         * @param distance Maximum distance of the raycast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @zh 执行射线检测以找到第一个碰撞。
         * @param ray 要投射的射线。
         * @param outHitResult 射线检测的结果。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         */
        rayCast?(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Perform a raycast to find all collisions.
         * @param ray The ray to cast.
         * @param out Array to store all hit results.
         * @param distance Maximum distance of the raycast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @zh 执行射线检测以找到所有碰撞。
         * @param ray 要投射的射线。
         * @param out 用于存储所有命中结果的数组。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         */
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Enable or disable the debug drawer.
         * @param value Whether to enable the debug drawer.
         * @zh 启用或禁用调试器。
         * @param value 是否启用调试器。
         */
        enableDebugDrawer?(value: boolean): void;
        /**
         * @en Destroy the physics manager.
         * @zh 销毁物理管理器。
         * @blueprintIgnore
         */
        destroy(): void;
        /**
         * @en Perform a shape cast to find the first collision.
         * @param shape The shape to cast.
         * @param fromPosition Start position of the cast.
         * @param toPosition End position of the cast.
         * @param out The result of the shape cast.
         * @param fromRotation Start rotation of the cast.
         * @param toRotation End rotation of the cast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @param allowedCcdPenetration Allowed continuous collision detection penetration.
         * @zh 执行形状投射以找到第一个碰撞。
         * @param shape 要投射的形状。
         * @param fromPosition 投射的起始位置。
         * @param toPosition 投射的结束位置。
         * @param out 形状投射的结果。
         * @param fromRotation 投射的起始旋转。
         * @param toRotation 投射的结束旋转。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         */
        shapeCast(shape: IColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Perform a shape cast to find all collisions.
         * @param shape The shape to cast.
         * @param fromPosition Start position of the cast.
         * @param toPosition End position of the cast.
         * @param out Array to store all hit results.
         * @param fromRotation Start rotation of the cast.
         * @param toRotation End rotation of the cast.
         * @param collisonGroup Collision group for filtering.
         * @param collisionMask Collision mask for filtering.
         * @param allowedCcdPenetration Allowed continuous collision detection penetration.
         * @zh 执行形状投射以找到所有碰撞。
         * @param shape 要投射的形状。
         * @param fromPosition 投射的起始位置。
         * @param toPosition 投射的结束位置。
         * @param out 用于存储所有命中结果的数组。
         * @param fromRotation 投射的起始旋转。
         * @param toRotation 投射的结束旋转。
         * @param collisonGroup 用于过滤的碰撞组。
         * @param collisionMask 用于过滤的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         */
        shapeCastAll(shape: IColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
    }
    /**
     * @en Interface for physics material.
     * @zh 物理材质的接口。
     */
    interface IPhysicsMaterial {
        /**
         * @en Sets the bounciness.
         * @param value The bounciness value.
         * @zh 设置弹力。
         * @param value 弹力值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction.
         * @param value The dynamic friction.
         * @zh 设置动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction.
         * @param value The static friction.
         * @zh 设置静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置弹性组合模式。
         * @param value 弹力组合模式。
         */
        setBounceCombine(value: number): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine(value: number): void;
        /**
         * @en Decrements the reference count of a material and releases it if the new reference count is zero.
         * @zh 减少材质的引用计数，如果新的引用计数为零则释放它。
         */
        destroy(): void;
    }
    /**
     * @en Interface for static physics collider.
     * @zh 静态物理碰撞器的接口。
     */
    interface IStaticCollider extends ICollider {
        /**
         * @en Sets whether the collider is a trigger.
         * @param value Whether the collider is a trigger.
         * @zh 设置碰撞器是否为触发器。
         * @param value 碰撞器是否为触发器。
         */
        setTrigger(value: boolean): void;
    }
    /**
     * @en Interface for custom joints in the physics system.
     * @zh 用于物理系统中自定义关节的接口。
     */
    interface ICustomJoint extends IJoint {
    }
    /**
     * @en Enumeration of motion types for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的运动类型枚举。
     */
    enum D6MotionType {
        /**
         * @en Motion along the X axis
         * @zh X轴方向的运动
         */
        eX = 0,
        /**
         * @en Motion along the Y axis
         * @zh Y轴方向的运动
         */
        eY = 1,
        /**
         * @en Motion along the Z axis
         * @zh Z轴方向的运动
         */
        eZ = 2,
        /**
         * @en Motion around the X axis
         * @zh 绕X轴的运动
         */
        eTWIST = 3,
        /**
         * @en Motion around the Y axis
         * @zh 绕Y轴的运动
         */
        eSWING1 = 4,
        /**
         * @en Motion around the Z axis
         * @zh 绕Z轴的运动
         */
        eSWING2 = 5
    }
    /**
     * @en Enumeration of axis states for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的轴状态枚举。
     */
    enum D6Axis {
        /**
         * @en The degree of freedom is locked, not allowing relative motion.
         * @zh 自由度被锁定，不允许相对运动。
         */
        eLOCKED = 0,
        /**
         * @en The degree of freedom is limited, only allowing motion within a specific range.
         * @zh 自由度受限，只允许在特定范围内运动。
         */
        eLIMITED = 1,
        /**
         * @en The degree of freedom is free, allowing its full range of motion.
         * @zh 自由度是自由的，允许其全范围运动。
         */
        eFREE = 2
    }
    /**
     * @en Enumeration of drive types for a 6-degree-of-freedom joint.
     * @zh 6自由度关节的驱动类型枚举。
     */
    enum D6Drive {
        /**
         * @en Drive along the X-axis
         * @zh 沿X轴驱动
         */
        eX = 0,
        /**
         * @en Drive along the Y-axis
         * @zh 沿Y轴驱动
         */
        eY = 1,
        /**
         * @en Drive along the Z-axis
         * @zh 沿Z轴驱动
         */
        eZ = 2,
        /**
         * @en Drive of displacement from the X-axis
         * @zh 相对于X轴的位移驱动
         */
        eSWING = 3,
        /**
         * @en Drive of the displacement around the X-axis
         * @zh 绕X轴的位移驱动
         */
        eTWIST = 4,
        /**
         * @en Drive of all three angular degrees along a SLERP-path
         * @zh 沿SLERP路径的三个角度自由度的驱动
         */
        eSLERP = 5
    }
    /**
     * @en Interface for a 6-degree-of-freedom joint in the physics system.
     * @zh 物理系统中6自由度关节的接口。
     */
    interface ID6Joint extends IJoint {
        /**
         * @en Set the primary and secondary axes for the joint.
         * @param axis The primary axis.
         * @param secendary The secondary axis.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴。
         * @param secendary 次轴。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @en Set the motion type around the specified axis.
         * @param axis The axis to set.
         * @param motionType The type of motion to set.
         * @zh 设置指定轴的运动类型。
         * @param axis 轴。
         * @param motionType 运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Set Distance limit Params
         * @param limit The distance limit.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damp The damping coefficient.
         * @zh 设置关节的距离限制参数。
         * @param limit 距离限制。
         * @param bounciness 限制的弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damp 阻尼系数。
         */
        setDistanceLimit(limit: number, bounciness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en x,y,z linear Limit.
         * @param linearAxis The axis to set the limit for.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置x,y,z轴的线性限制。
         * @param linearAxis 轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en The twist limit controls the range of motion around the twist axis.
         * @param upper The upper limit of the twist.
         * @param lower The lower limit of the twist.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 扭转限制控制绕扭转轴的运动范围。
         * @param upper 扭转轴的上限。
         * @param lower 扭转轴的下限。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setTwistLimit(upper: number, lower: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Set the cone-like swing limit for the joint.
         * @param yAngle The angle limit around the Y axis.
         * @param zAngle The angle limit around the Z axis.
         * @param bounciness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的锥形摆动限制。
         * @param yAngle Y轴的角度限制。
         * @param zAngle Z轴的角度限制。
         * @param bounciness 弹性。
         * @param bounceThreshold 弹跳阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounciness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Set the drive parameters for a specific drive type.
         * @param index The drive type to set.
         * @param stiffness The stiffness of the drive.
         * @param damping The damping of the drive.
         * @param forceLimit The force limit of the drive.
         * @zh 设置特定驱动类型的驱动参数。
         * @param index 驱动类型。
         * @param stiffness 刚度。
         * @param damping 阻尼。
         * @param forceLimit 力限。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Set the drive transform for the joint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置关节的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Set the drive velocity for the joint.
         * @param position The linear velocity.
         * @param angular The angular velocity.
         * @zh 设置关节的驱动速度。
         * @param position 线速度。
         * @param angular 角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Get the twist angle of the joint, in the range (-2*Pi, 2*Pi].
         * @zh 获取关节的扭转角度，范围为(-2*Pi, 2*Pi]。
         */
        getTwistAngle(): number;
        /**
         * @en Get the swing angle of the joint from the Y axis.
         * @zh 获取关节相对于Y轴的摆动角度。
         */
        getSwingYAngle(): number;
        /**
         * @en Get the swing angle of the joint from the Z axis.
         * @zh 获取关节相对于Z轴的摆动角度。
         */
        getSwingZAngle(): number;
    }
    /**
     * @en Interface for a fixed joint in the physics system.
     * @zh 物理系统中固定关节的接口。
     */
    interface IFixedJoint extends IJoint {
    }
    /**
     * @en Interface for a hinge joint.
     * @zh 铰链关节接口。
     */
    interface IHingeJoint extends IJoint {
        /**
         * @en Sets the axis of rotation for the hinge joint.
         * @param value The axis vector to set.
         * @zh 设置铰链关节的旋转轴。
         * @param value 要设置的轴向量。
         */
        setAxis(value: Vector3): void;
        /**
         * @en The current angle in degrees of the joint relative to its rest position.
         * @zh 当前关节相对于其静止位置的角度。
         */
        getAngle(): number;
        /**
         * @en The angular velocity of the joint in degrees per second.
         * @zh 关节的角速度（以度/秒为单位）。
         */
        getVelocity(): Readonly<Vector3>;
        /**
         * @en Sets the lower limit of the joint's rotation.
         * @param lowerLimit The lower limit value in degrees.
         * @zh 设置关节旋转的下限。
         * @param lowerLimit 下限值（以度为单位）。
         */
        setLowerLimit(lowerLimit: number): void;
        /**
         * @en Sets the upper limit of the joint's rotation.
         * @param value The upper limit value in degrees.
         * @zh 设置关节旋转的上限。
         * @param value 上限值（以度为单位）。
         */
        setUpLimit(value: number): void;
        /**
         * @en Sets the bounciness of the joint.
         * @param value The bounciness value.
         * @zh 设置关节的反弹性。
         * @param value 反弹性值。
         */
        setBounceness(value: number): void;
        /**
         * @en Sets the minimum velocity required for the joint to bounce.
         * @param value The minimum bounce velocity.
         * @zh 设置关节反弹所需的最小速度。
         * @param value 最小反弹速度。
         */
        setBouncenMinVelocity(value: number): void;
        /**
         * @en Sets the contact distance for the joint.
         * @param value The contact distance value.
         * @zh 设置关节的接触距离。
         * @param value 接触距离值。
         */
        setContactDistance(value: number): void;
        /**
         * @en Enables or disables the joint's rotation limit.
         * @param value True to enable the limit, false to disable.
         * @zh 启用或禁用关节的旋转限制。
         * @param value 为true时启用限制，为false时禁用。
         */
        enableLimit(value: boolean): void;
        /**
         * @en Enables or disables the joint's drive.
         * @param value True to enable the drive, false to disable.
         * @zh 启用或禁用关节的驱动。
         * @param value 为true时启用驱动，为false时禁用。
         */
        enableDrive(value: boolean): void;
        /**
         * @en Enables or disables free spin for the joint.
         * @param value True to enable free spin, false to disable.
         * @zh 启用或禁用关节的自由旋转。
         * @param value 为true时启用自由旋转，为false时禁用。
         */
        enableFreeSpin(value: boolean): void;
        /**
         * @en Sets the target velocity for the drive model.
         * @param velocity The drive target velocity.
         * @zh 设置驱动模型的目标速度。
         * @param velocity 驱动目标速度。
         */
        setDriveVelocity(velocity: number): void;
        /**
         * @en Sets the maximum torque the drive can exert.
         * @param limit The maximum torque value.
         * @zh 设置驱动可施加的最大扭矩。
         * @param limit 最大扭矩值。
         */
        setDriveForceLimit(limit: number): void;
    }
    /**
     * @en Interface for a joint in a physics system.
     * @zh 物理系统中关节的接口。
     */
    interface IJoint {
        /**
         * @en Sets the owner node of the joint.
         * @param value The node to set as the owner.
         * @zh 设置关节的所有者节点。
         * @param value 要设置为所有者的节点。
         */
        setOwner(value: Node): void;
        /**
         * @en Sets the collider for this joint.
         * @param owner The collider to set.
         * @zh 设置此关节的碰撞体。
         * @param owner 要设置的碰撞体。
         */
        setCollider(owner: ICollider): void;
        /**
         * @en Sets the connected collider for this joint.
         * @param owner The collider to connect to.
         * @zh 设置此关节连接的碰撞体。
         * @param owner 要连接的碰撞体。
         */
        setConnectedCollider(owner: ICollider): void;
        /**
         * @en The scale to apply to the inverse mass of collider 0 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于连接碰撞体逆质量的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setConnectedMassScale(value: number): void;
        /**
         * @en The scale to apply to the inverse inertia of collider0 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于连接碰撞体逆惯性的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setConnectedInertiaScale(value: number): void;
        /**
         * @en The scale to apply to the inverse mass of collider 1 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于主碰撞体逆质量的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setMassScale(value: number): void;
        /**
         * @en The scale to apply to the inverse inertia of collider1 for resolving this constraint.
         * @param value The scale value to set.
         * @zh 设置应用于主碰撞体逆惯性的缩放比例，用于解析此约束。
         * @param value 要设置的缩放值。
         */
        setInertiaScale(value: number): void;
        /**
         * @en The maximum force the joint can apply before breaking.
         * @param value The maximum force value.
         * @zh 设置关节在断裂前可施加的最大力。
         * @param value 最大力值。
         */
        setBreakForce(value: number): void;
        /**
         * @en The maximum torque the joint can apply before breaking.
         * @param value The maximum torque value.
         * @zh 设置关节在断裂前可施加的最大扭矩。
         * @param value 最大扭矩值。
         */
        setBreakTorque(value: number): void;
        /**
         * @en Sets the local anchor/frame position for the main actor.
         * @param pos The local position to set.
         * @zh 设置主执行体的本地锚点/框架位置。
         * @param pos 要设置的本地位置。
         */
        setLocalPos(pos: Vector3): void;
        /**
         * @en Sets the local anchor/frame position for the connected actor.
         * @param pos The local position to set.
         * @zh 设置连接执行体的本地锚点/框架位置。
         * @param pos 要设置的本地位置。
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * @en Gets the linear force applied by the joint.
         * @zh 获取关节施加的线性力。
         */
        getlinearForce(): Vector3;
        /**
         * @en Gets the angular force applied by the joint.
         * @zh 获取关节施加的角力。
         */
        getAngularForce(): Vector3;
        /**
         * @en Checks if the joint is still valid (not broken).
         * @zh 检查关节是否仍然有效（未断裂）。
         */
        isValid(): boolean;
        /**
         * @en Enables or disables the joint.
         * @param value True to enable, false to disable.
         * @zh 启用或禁用关节。
         * @param value 为true时启用，为false时禁用。
         */
        isEnable(value: boolean): void;
        /**
         * @en Sets whether collision is enabled between the connected bodies.
         * @param value True to enable collision, false to disable.
         * @zh 设置是否启用连接体之间的碰撞。
         * @param value 为true时启用碰撞，为false时禁用。
         */
        isCollision(value: boolean): void;
        /**
         * @en Destroy the joint.
         * @zh 销毁关节。
         */
        destroy(): void;
    }
    /**
     * @en Interface for a spring joint.
     * @zh 弹簧关节接口。
     */
    interface ISpringJoint extends IJoint {
        /**
         * @en Set the allowed minimum distance for the joint.
         * @param distance The minimum distance.
         * @zh 设置关节允许的最小距离。
         * @param distance 最小距离。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Set the allowed maximum distance for the joint.
         * @param distance The maximum distance.
         * @zh 设置关节允许的最大距离。
         * @param distance 最大距离。
         */
        setMaxDistance(distance: number): void;
        /**
         * @en Set the error tolerance of the joint.
         * @param tolerance The distance beyond the allowed range at which the joint becomes active.
         * @zh 设置关节的误差容限。
         * @param tolerance 超出允许范围时关节变为活动状态的距离。
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Set the strength of the joint spring.
         * @param stiffness The spring strength of the joint.
         * @zh 设置关节弹簧的强度。
         * @param stiffness 关节弹簧的强度。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Set the damping of the joint spring.
         * @param damping The degree of damping of the joint spring.
         * @zh 设置关节弹簧的阻尼。
         * @param damping 关节弹簧的阻尼程度。
         */
        setDamping(damping: number): void;
    }
    class Physics3DStatInfo {
        private static _PhysicsStatisticsInfo;
        /**
         * @en enable Physics Statistics
         * @zh 启动物理统计信息
         */
        static enableStatistics: boolean;
        /**
         * @en enable Frame ClearData
         * @zh 是否每帧自动清理
         */
        static autoFrameClear: boolean;
        /**
         * @en Initialize Physical Statistics Map
         * @zh 初始化物理统计信息表
         */
        static initStatisticsInfo(): void;
        /**
         * @en Set Physical Statistics Values
         * @param info Physical Statistics Enumeration
         * @param value value
         * @zh 设置物理统计信息值
         * @param info 物理统计信息枚举
         * @param value 值
         */
        static addStatisticsInfo(info: EPhysicsStatisticsInfo, value: number): void;
        /**
         * @en Get Physical Statistics Values
         * @param info Physical Statistics Enumeration
         * @returns Physical Statistics value
         * @zh 获取物理统计信息值
         * @param info 物理统计信息枚举
         * @returns 物理统计信息值
         */
        static getStatisticsInfo(info: EPhysicsStatisticsInfo): number;
        /**
         * @en Per Frame Cleanup of Physical Statistics
         * @zh 每帧清理物理统计信息
         */
        static clearStatisticsInfo(): void;
        /**
         * @en Stop Statistics
         * @zh 停止统计信息
         */
        static stopAndClearAllStatisticsInfo(): void;
    }
    /**
     * @en Interface for box collider shape.
     * @zh 盒形碰撞器的接口。
     */
    interface IBoxColliderShape extends IColliderShape {
        /**
         * @en Set size of Box Shape.
         * @param size The size of the box
         * @zh 设置盒子形状的大小。
         * @param size 盒子的大小
         */
        setSize(size: Vector3): void;
    }
    /**
     * @en Interface for capsule collider shape.
     * @zh 胶囊体碰撞器的接口。
     */
    interface ICapsuleColliderShape extends IColliderShape {
        /**
         * @en Set radius of capsule.
         * @param radius The radius of the capsule
         * @zh 设置胶囊体的半径。
         * @param radius 胶囊体的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of capsule.
         * @param height The height of the capsule
         * @zh 设置胶囊体的高度。
         * @param height 胶囊体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of capsule.
         * @param upAxis The up axis of the capsule
         * @zh 设置胶囊体的朝上轴。
         * @param upAxis 胶囊体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for collider shape.
     * @zh 碰撞器形状的接口。
     */
    interface IColliderShape {
        /**
         * @en Set local position of the collider shape.
         * @param position The local position to set
         * @zh 设置碰撞器形状的局部位置。
         * @param position 要设置的局部位置
         */
        setOffset(position: Vector3): void;
        /**
         * @en Gets the local offset of the shape.
         * @returns The local offset of the shape.
         * @zh 获取形状的局部偏移。
         * @returns 局部偏移量。
         */
        getOffset(): Vector3;
        /**
         * @en Decrements the reference count of a shape and releases it if the new reference count is zero.
         * @zh 减少形状的引用计数，如果新的引用计数为零则释放它。
         */
        destroy(): void;
        /**
         * @en Gets the physics shape.
         * @returns The physics shape.
         * @zh 获取物理形状。
         * @returns 物理形状。
         */
        getPhysicsShape(): any;
    }
    /**
     * @en The `ICompoundColliderShape` interface defines the methods for managing compound collider shapes.
     * @zh `ICompoundColliderShape` 接口定义了用于管理组合碰撞器形状的方法。
     */
    interface ICompoundColliderShape extends IColliderShape {
        /**
         * @en Adds a child shape to the compound collider shape.
         * @param shape The child shape to add.
         * @zh 添加一个子形状到组合碰撞器形状。
         * @param shape 要添加的子形状。
         */
        addChildShape(shape: IColliderShape): void;
        /**
         * @en Removes a child shape from the compound collider shape.
         * @param shape The child shape to remove.
         * @param index The index of the child shape to remove.
         * @zh 从组合碰撞器形状中移除一个子形状。
         * @param shape 要移除的子形状。
         * @param index 要移除的子形状的索引。
         */
        removeChildShape(shape: IColliderShape, index: number): void;
        /**
         * @en Sets the data of the shape.
         * @param component The component to set the data.
         * @zh 设置形状的数据。
         * @param component 要设置数据的组件。
         */
        setShapeData?(component: PhysicsColliderComponent): void;
    }
    /**
     * @en Interface for cone collider shape.
     * @zh 锥体碰撞器的接口。
     */
    interface IConeColliderShape extends IColliderShape {
        /**
         * @en Set radius of the cone.
         * @param radius The radius of the cone base
         * @zh 设置锥体的半径。
         * @param radius 锥体底部的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of the cone.
         * @param height The height of the cone
         * @zh 设置锥体的高度。
         * @param height 锥体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of the cone.
         * @param upAxis The up axis of the cone
         * @zh 设置锥体的朝上轴。
         * @param upAxis 锥体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for cylinder collider shape.
     * @zh 圆柱体碰撞器的接口。
     */
    interface ICylinderColliderShape extends IColliderShape {
        /**
         * @en Set radius of the cylinder.
         * @param radius The radius of the cylinder base
         * @zh 设置圆柱体的半径。
         * @param radius 圆柱体底面的半径
         */
        setRadius(radius: number): void;
        /**
         * @en Set height of the cylinder.
         * @param height The height of the cylinder
         * @zh 设置圆柱体的高度。
         * @param height 圆柱体的高度
         */
        setHeight(height: number): void;
        /**
         * @en Set up axis of the cylinder.
         * @param upAxis The up axis of the cylinder
         * @zh 设置圆柱体的朝上轴。
         * @param upAxis 圆柱体的朝上轴
         */
        setUpAxis(upAxis: number): void;
    }
    /**
     * @en Interface for height field shape.
     * @zh 高度场的接口。
     */
    interface IHeightFieldShape extends IColliderShape {
        /**
         * @en Set height field data.
         * @param numRows Number of rows in the height field
         * @param numCols Number of columns in the height field
         * @param heightData Array of height values
         * @param flag Array of flags for each cell
         * @param scale Scale of the height field
         * @zh 设置高度数据。
         * @param numRows 高度场的行数
         * @param numCols 高度场的列数
         * @param heightData 高度值数组
         * @param flag 每个单元格的标志数组
         * @param scale 高度场的缩放
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * @en Get the number of rows in the height field.
         * @zh 获取高度场的行数。
         */
        getNbRows(): number;
        /**
         * @en Get the number of columns in the height field.
         * @zh 获取高度场的列数。
         */
        getNbColumns(): number;
        /**
         * @en Get the height at a specific row and column.
         * @param rows Row index
         * @param cols Column index
         * @returns The height at the specified position
         * @zh 获取指定行列位置的高度。
         * @param rows 行索引
         * @param cols 列索引
         * @returns 指定位置的高度
         */
        getHeight(rows: number, cols: number): number;
    }
    /**
     * @en Interface for mesh collider shape.
     * @zh 网格碰撞器的接口。
     */
    interface IMeshColliderShape extends IColliderShape {
        /**
         * @en Create physics mesh from regular Mesh.
         * @param value The source Mesh to create physics mesh from
         * @zh 从常规网格创建物理网格。
         * @param value 用于创建物理网格的源网格
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Set convex mesh for the collider shape.
         * @param value The convex Mesh to set
         * @zh 为碰撞器形状设置凸多边形网格。
         * @param value 要设置的凸多边形网格
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Set the vertex limit for mesh simplification.
         * @param limit The maximum number of vertices allowed
         * @zh 设置网格简化的顶点限制。
         * @param limit 允许的最大顶点数
         */
        setLimitVertex(limit: number): void;
    }
    interface IPlaneColliderShape extends IColliderShape {
    }
    /**
     * @en Interface for sphere collider shape.
     * @zh 球形碰撞器的接口。
     */
    interface ISphereColliderShape extends IColliderShape {
        /**
         * @en Set the radius of the sphere.
         * @param radius The radius of the sphere
         * @zh 设置球体的半径。
         * @param radius 球体的半径
         */
        setRadius(radius: number): void;
    }
    enum ECharacterCapable {
        /**
         * @en Gravity applied to the character.
         * @zh 应用于角色的重力。
         */
        Charcater_Gravity = 0,
        /**
         * @en Collision group for the character.
         * @zh 角色的碰撞分组。
         */
        Charcater_CollisionGroup = 1,
        /**
         * @en World position of the character.
         * @zh 角色在世界坐标中的位置。
         */
        Charcater_WorldPosition = 2,
        /**
         * @en Directional movement of the character.
         * @zh 角色的方向移动。
         */
        Charcater_Move = 3,
        /**
         * @en Jump capability of the character.
         * @zh 角色的跳跃能力。
         */
        Charcater_Jump = 4,
        /**
         * @en Step offset for the character.
         * @zh 角色的步幅偏移。
         */
        Charcater_StepOffset = 5,
        /**
         * @en Up direction of the character.
         * @zh 角色的向上方向。
         */
        Character_UpDirection = 6,
        /**
         * @en Fall speed of the character.
         * @zh 角色的下落速度。
         */
        Character_FallSpeed = 7,
        /**
         * @en Slope limit for the character.
         * @zh 角色的坡度限制。
         */
        Character_SlopeLimit = 8,
        /**
         * @en Force when character collides with other objects.
         * @zh 角色碰撞其他物体的力。
         */
        Character_PushForce = 9,
        /**
         * @en Radius of the character.
         * @zh 角色的半径。
         */
        Character_Radius = 10,
        /**
         * @en Height of the character.
         * @zh 角色的高度。
         */
        Character_Height = 11,
        /**
         * @en Offset of the character.
         * @zh 角色的偏移。
         */
        Character_offset = 12,
        /**
         * @en Skin of the character.
         * @zh 角色的皮肤。
         */
        Character_Skin = 13,
        /**
         * @en Minimum distance for the character.
         * @zh 角色的最小距离。
         */
        Character_minDistance = 14,
        /**
         * @en Event filter for the character controller.
         * @zh 角色控制器的事件过滤器。
         */
        Character_EventFilter = 15,
        /**
         * @en Simulate gravity for the character controller.
         * @zh 模拟角色控制器的重力。
         */
        Character_SimulateGravity = 16,
        /**
         * @en Whether the character is on the ground.
         * @zh 是否在地面上。
         */
        Character_IsOnGround = 17
    }
    enum EColliderCapable {
        /**
         * @en Collision group for the collider.
         * @zh 碰撞体的碰撞分组。
         */
        Collider_CollisionGroup = 0,
        /**
         * @en Friction of the collider.
         * @zh 碰撞体的摩擦力。
         */
        Collider_Friction = 1,
        /**
         * @en Rolling friction of the collider.
         * @zh 碰撞体的滚动摩擦力。
         */
        Collider_RollingFriction = 2,
        /**
         * @en Restitution (bounciness) of the collider.
         * @zh 碰撞体的弹力。
         */
        Collider_Restitution = 3,
        /**
         * @en Whether the collider supports triggers.
         * @zh 碰撞体是否支持触发器。
         */
        Collider_AllowTrigger = 4,
        /**
         * @en Dynamic friction of the collider.
         * @zh 碰撞体的动态摩擦力。
         */
        Collider_DynamicFriction = 5,
        /**
         * @en Static friction of the collider.
         * @zh 碰撞体的静态摩擦力。
         */
        Collider_StaticFriction = 6,
        /**
         * @en Bounce combine mode of the collider.
         * @zh 碰撞体的弹力组合模式。
         */
        Collider_BounceCombine = 7,
        /**
         * @en Friction combine mode of the collider.
         * @zh 碰撞体的摩擦力组合模式。
         */
        Collider_FrictionCombine = 8,
        /**
         * @en Event filter for the collider.
         * @zh 碰撞体的事件过滤器。
         */
        Collider_EventFilter = 9,
        /**
         * @en Collision detection mode for the collider.
         * @zh 碰撞体的碰撞检测模式。
         */
        Collider_CollisionDetectionMode = 10,
        /**
         * @en Whether the rigid body supports kinematic mode.
         * @zh 刚体是否支持运动学模式。
         */
        RigidBody_CanKinematic = 11,
        /**
         * @en Whether the rigid body supports sleeping.
         * @zh 刚体是否支持睡眠。
         */
        RigidBody_AllowSleep = 12,
        /**
         * @en Gravity applied to the rigid body.
         * @zh 应用于刚体的重力。
         */
        RigidBody_Gravity = 13,
        /**
         * @en Linear damping of the rigid body.
         * @zh 刚体的线性阻尼。
         */
        RigidBody_LinearDamp = 14,
        /**
         * @en Angular damping of the rigid body.
         * @zh 刚体的角度阻尼。
         */
        RigidBody_AngularDamp = 15,
        /**
         * @en Linear velocity of the rigid body.
         * @zh 刚体的线速度。
         */
        RigidBody_LinearVelocity = 16,
        /**
         * @en Angular velocity of the rigid body.
         * @zh 刚体的角速度。
         */
        RigidBody_AngularVelocity = 17,
        /**
         * @en Mass of the rigid body.
         * @zh 刚体的质量。
         */
        RigidBody_Mass = 18,
        /**
         * @en World position of the rigid body.
         * @zh 刚体在世界坐标中的位置。
         */
        RigidBody_WorldPosition = 19,
        /**
         * @en World orientation of the rigid body.
         * @zh 刚体在世界坐标中的旋转。
         */
        RigidBody_WorldOrientation = 20,
        /**
         * @en Inertia tensor of the rigid body.
         * @zh 刚体的惯性张量。
         */
        RigidBody_InertiaTensor = 21,
        /**
         * @en Center of mass of the rigid body.
         * @zh 刚体的重心。
         */
        RigidBody_MassCenter = 22,
        /**
         * @en Maximum angular velocity of the rigid body.
         * @zh 刚体的最大角速度。
         */
        RigidBody_MaxAngularVelocity = 23,
        /**
         * @en Maximum depenetration velocity of the rigid body.
         * @zh 刚体的最大侵入速度。
         */
        RigidBody_MaxDepenetrationVelocity = 24,
        /**
         * @en Sleep threshold of the rigid body.
         * @zh 刚体的睡眠阈值。
         */
        RigidBody_SleepThreshold = 25,
        /**
         * @en Sleep angular velocity of the rigid body.
         * @zh 刚体的睡眠角速度。
         */
        RigidBody_SleepAngularVelocity = 26,
        /**
         * @en Number of physics iterations for the rigid body.
         * @zh 刚体的物理迭代次数。
         */
        RigidBody_SolverIterations = 27,
        /**
         * @en Whether the rigid body supports dynamic switching of object types.
         * @zh 刚体是否支持动态切换物体类型。
         */
        RigidBody_AllowDetectionMode = 28,
        /**
         * @en Whether the rigid body supports kinematic mode.
         * @zh 刚体是否支持运动学模式。
         */
        RigidBody_AllowKinematic = 29,
        /**
         * @en Whether the rigid body supports character mode.
         * @zh 刚体是否支持角色模式。
         */
        RigidBody_AllowCharacter = 30,
        /**
         * @en Linear velocity scale factor of the rigid body.
         * @zh 刚体的线速度缩放因子。
         */
        RigidBody_LinearFactor = 31,
        /**
         * @en Angular velocity scale factor of the rigid body.
         * @zh 刚体的角速度缩放因子。
         */
        RigidBody_AngularFactor = 32,
        /**
         * @en Apply force to the rigid body.
         * @zh 对刚体施加力。
         */
        RigidBody_ApplyForce = 33,
        /**
         * @en Clear forces applied to the rigid body.
         * @zh 清除施加在刚体上的力。
         */
        RigidBody_ClearForce = 34,
        /**
         * @en Apply force at an offset position to the rigid body.
         * @zh 对刚体施加偏移位置的力。
         */
        RigidBody_ApplyForceWithOffset = 35,
        /**
         * @en Apply torque to the rigid body.
         * @zh 对刚体施加扭力。
         */
        RigidBody_ApplyTorque = 36,
        /**
         * @en Apply impulse to the rigid body.
         * @zh 对刚体施加冲量。
         */
        RigidBody_ApplyImpulse = 37,
        /**
         * @en Apply torque impulse to the rigid body.
         * @zh 对刚体施加扭力冲量。
         */
        RigidBody_ApplyTorqueImpulse = 38
    }
    enum EJointCapable {
        /**
         * @en The anchor point of the joint.
         * @zh 关节的锚点。
         */
        Joint_Anchor = 0,
        /**
         * @en The connected anchor point of the joint.
         * @zh 关节的连接锚点。
         */
        Joint_ConnectAnchor = 1
    }
    enum EPhysicsCapable {
        /**
         * @en Gravity in the physics system.
         * @zh 物理系统中的重力。
         */
        Physics_Gravity = 0,
        /**
         * @en Support for static collider mode.
         * @zh 是否支持静态碰撞体模式。
         */
        Physics_StaticCollider = 1,
        /**
         * @en Support for dynamic collider mode.
         * @zh 是否支持动态碰撞体模式。
         */
        Physics_DynamicCollider = 2,
        /**
         * @en Support for character collider mode.
         * @zh 是否支持角色碰撞体模式。
         */
        Physics_CharacterCollider = 3,
        /**
         * @en Box-shaped collider shape.
         * @zh 盒状碰撞形状。
         */
        Physics_BoxColliderShape = 4,
        /**
         * @en Sphere-shaped collider shape.
         * @zh 球状碰撞形状。
         */
        Physics_SphereColliderShape = 5,
        /**
         * @en Capsule-shaped collider shape.
         * @zh 胶囊碰撞形状。
         */
        Physics_CapsuleColliderShape = 6,
        /**
         * @en Cylinder-shaped collider shape.
         * @zh 圆柱碰撞形状。
         */
        Physics_CylinderColliderShape = 7,
        /**
         * @en Cone-shaped collider shape.
         * @zh 圆锥碰撞形状。
         */
        Physics_ConeColliderShape = 8,
        /**
         * @en Mesh collider shape.
         * @zh 网格碰撞形状。
         */
        Physics_MeshColliderShape = 9,
        /**
         * @en Compound collider shape.
         * @zh 组合碰撞形状。
         */
        Physics_CompoundColliderShape = 10,
        /**
         * @en Support for creating curve mesh.
         * @zh 支持创建曲线网格。
         */
        Physics_CreateCorveMesh = 11,
        /**
         * @en Height field collider shape.
         * @zh 高度场碰撞形状。
         */
        physics_heightFieldColliderShape = 12,
        /**
         * @en General joint capability.
         * @zh 常规关节能力。
         */
        Physics_Joint = 13,
        /**
         * @en Fixed joint capability.
         * @zh 固定关节能力。
         */
        Physics_FixedJoint = 14,
        /**
         * @en Spring joint capability.
         * @zh 弹簧关节能力。
         */
        Physics_SpringJoint = 15,
        /**
         * @en Hinge joint capability.
         * @zh 铰链关节能力。
         */
        Physics_HingeJoint = 16,
        /**
         * @en 6 Degrees of Freedom (D6) joint capability.
         * @zh 6自由度（D6）关节能力。
         */
        Physics_D6Joint = 17
    }
    /**
     * @en Physical Statistics Data
     * @zh 物理统计数据
     */
    enum EPhysicsStatisticsInfo {
        /**
         * @en Physical Event Count Enumeration
         * @zh 物理事件计数枚举
         */
        C_PhysicsEventCount = 0,
        /**
         * @en Cleanup Count Per Frame
         * @zh 每帧清理个数
         */
        FrameClearCount = 1,
        /**
         * @en Physical Dynamics Rigid Body Count Enumeration
         * @zh 物理动力学刚体计数枚举
         */
        C_PhysicaDynamicRigidBody = 2,
        /**
         * @en Physical Static Rigid Body Count Enumeration
         * @zh 物理静态刚体计数枚举
         */
        C_PhysicaStaticRigidBody = 3,
        /**
         * @en Physical Kinematic Rigid Body Count Enumeration
         * @zh 物理运动学刚体计数枚举
         */
        C_PhysicaKinematicRigidBody = 4,
        /**
         * @en Physical Character Controller Count Enumeration
         * @zh 物理角色控制器计数枚举
         */
        C_PhysicaCharacterController = 5,
        /**
         * @en Physical Joint Count Enumeration
         * @zh 物理关节计数枚举
         */
        C_PhysicsJoint = 6,
        /**
         * @en Enumeration Count
         * @zh 枚举个数
         */
        Count = 7
    }
    enum ControllerNonWalkableMode {
        /**
         * @en Stops character from climbing up non-walkable slopes, but doesn't move it otherwise.
         * @zh 阻止角色爬上不可行走的斜坡，但不会对其他情况进行移动。
         */
        ePREVENT_CLIMBING = 0,
        /**
         * @en Stops character from climbing up non-walkable slopes, and forces it to slide down those slopes.
         * @zh 阻止角色爬上不可行走的斜坡，并强制其沿这些斜坡滑下。
         */
        ePREVENT_CLIMBING_AND_FORCE_SLIDING = 1
    }
    enum ECharacterCollisionFlag {
        /**
         * @en Character is colliding to the sides.
         * @zh 角色与侧面发生碰撞。
         */
        eCOLLISION_SIDES = 1,
        /**
         * @en Character has collision above.
         * @zh 角色上方发生碰撞。
         */
        eCOLLISION_UP = 2,
        /**
         * @en Character has collision below.
         * @zh 角色下方发生碰撞。
         */
        eCOLLISION_DOWN = 4
    }
    /**
     * @en The `pxCharactorCollider` class implements character controller functionality in the physics engine.
     * @zh `pxCharactorCollider` 类用于在物理引擎中实现角色控制器的功能。
     */
    class pxCharactorCollider extends pxCollider implements ICharacterController {
        static tempV3: Vector3;
        _shapeID: number;
        /** @internal */
        _id: number;
        /** @internal */
        _pxController: any;
        /** @internal */
        _pxNullShape: pxCapsuleColliderShape;
        /**@internal */
        _radius: number;
        /**@internal */
        _height: number;
        /**@internal */
        _localOffset: Vector3;
        /**@internal */
        _upDirection: Vector3;
        /**@internal */
        private _stepOffset;
        /**@internal */
        private _slopeLimit;
        /**@internal */
        private _contactOffset;
        /**@internal */
        private _minDistance;
        private _nonWalkableMode;
        private _gravity;
        private _characterCollisionFlags;
        /**@internal */
        static _characterCapableMap: Map<any, any>;
        /**@internal */
        private _pushForce;
        /**@internal */
        private _characterEvents;
        /**
         * @en Creates a instance of pxCharactorCollider.
         * @param manager The physics manager responsible for this collider.
         * @zh 创建一个 pxCharactorCollider 实例。
         * @param manager 负责管理此碰撞器的物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        setColliderShape(shape: pxColliderShape): void;
        private _getNodeScale;
        protected _initCollider(): void;
        /**
         * @en Gets the capability of the character controller.
         * @param value The capability to check.
         * @returns Whether the capability is supported.
         * @zh 获取角色控制器的能力。
         * @param value 要检查的能力。
         * @returns 是否支持该能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Gets the character capability.
         * @param value The character capability to check.
         * @returns Whether the capability is supported.
         * @zh 获取角色能力。
         * @param value 要检查的角色能力。
         * @returns 是否支持该能力。
         */
        static getCharacterCapable(value: ECharacterCapable): boolean;
        /**
         * @en Initializes the character capabilities.
         * @zh 初始化角色能力。
         */
        static initCapable(): void;
        /**
         * @en Creates the character controller in the physics engine.
         * @zh 在物理引擎中创建角色控制器。
         */
        _createController(): void;
        /**
         * @en Sets the collision flag for the character controller.
         * @param value The collision flag to set.
         * @zh 设置角色控制器的碰撞标志。
         * @param value 要设置的碰撞标志。
         */
        _setCharacterCollisonFlag(value: ECharacterCollisionFlag): void;
        /**
         * @en Releases the character controller from the physics engine.
         * @zh 从物理引擎中释放角色控制器。
         */
        _releaseController(): void;
        /**
         * @en Moves the character controller.
         * @param disp The displacement vector.
         * @zh 移动角色控制器。
         * @param disp 位移向量。
         */
        move(disp: Vector3): void;
        /**
         * @en Makes the character jump.
         * @param velocity The jump velocity.
         * @zh 使角色跳跃。
         * @param velocity 跳跃速度。
         */
        jump?(velocity: Vector3): void;
        isGrounded(): boolean;
        /**
         * @en Sets the step offset for the character controller.
         * @param offset The step offset value.
         * @zh 设置角色控制器的台阶偏移。
         * @param offset 台阶偏移值。
         */
        setStepOffset(offset: number): void;
        /**
         * @en Sets the up direction for the character controller.
         * @param up The up direction vector.
         * @zh 设置角色控制器的向上方向。
         * @param up 向上方向向量。
         */
        setUpDirection(up: Vector3): void;
        /**
         * @en Sets the slope limit for the character controller.
         * @param value The slope limit value in radians.
         * @zh 设置角色控制器的坡度限制。
         * @param value 坡度限制值（弧度）。
         */
        setSlopeLimit(value: number): void;
        /**
         * @en Sets the gravity for the character controller.
         * @param value The gravity vector.
         * @zh 设置角色控制器的重力。
         * @param value 重力向量。
         */
        setGravity(value: Vector3): void;
        /**
         * @en Sets the push force for the character controller.
         * @param value The push force value.
         * @zh 设置角色控制器的推力。
         * @param value 推力值。
         */
        setPushForce(value: number): void;
        /**
         * @en Updates the character's world transform from the physics engine.
         * @zh 从物理引擎更新角色的世界变换。
         */
        getWorldTransform(): void;
        /**
         * @en Sets the skin width for the character controller.
         * @param width The skin width value.
         * @zh 设置角色控制器的皮肤宽度。
         * @param width 皮肤宽度值。
         */
        setSkinWidth(width: number): void;
        /**
         * @en Destroys the character controller.
         * @zh 销毁角色控制器。
         */
        destroy(): void;
        /**
         * @en Sets the position of the character controller.
         * @param value The position vector.
         * @zh 设置角色控制器的位置。
         * @param value 位置向量。
         */
        setPosition(value: Vector3): void;
        /**
         * @en Gets the position of the character controller.
         * @returns The position vector.
         * @zh 获取角色控制器的位置。
         * @returns 位置向量。
         */
        getPosition(): Vector3;
        /**
         * @en Sets the local offset of the character's shape.
         * @param value The local offset vector.
         * @zh 设置角色形状的局部偏移。
         * @param value 局部偏移向量。
         */
        setShapelocalOffset(value: Vector3): void;
        /**
         * @en Sets the height of the character controller.
         * @param value The height value.
         * @zh 设置角色控制器的高度。
         * @param value 高度值。
         */
        setHeight(value: number): void;
        /**
         * @en Sets the radius of the character controller.
         * @param value The radius value.
         * @zh 设置角色控制器的半径。
         * @param value 半径值。
         */
        setRadius(value: number): void;
        /**
         * @en Sets the minimum distance for the character controller.
         * @param value The minimum distance value.
         * @zh 设置角色控制器的最小距离。
         * @param value 最小距离值。
         */
        setminDistance(value: number): void;
        /**
         * @en Sets the non-walkable mode for the character controller.
         * @param value The non-walkable mode.
         * @zh 设置角色控制器的不可行走模式。
         * @param value 不可行走模式。
         */
        setNonWalkableMode(value: ControllerNonWalkableMode): void;
        /**
         * @en Sets the event filter for the character controller.
         * @param events An array of events to filter.
         * @zh 设置角色控制器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter(events: [
        ]): void;
        /**
         * @en Releases the character controller resources.
         * @zh 释放角色控制器资源。
         */
        release(): void;
    }
    /**
     * @en Enumeration of collider types.
     * @zh 碰撞器类型枚举。
     */
    enum pxColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    /**
     * @en PhysX actor flags.
     * @zh PhysX 执行器标志。
     */
    enum pxActorFlag {
        /**
         * @en Enable debug renderer for this actor.
         * @zh 为此执行器启用调试渲染器。
         */
        eVISUALIZATION = 1,
        /**
         * @en Disables scene gravity for this actor.
         * @zh 禁用此执行器的场景重力。
         */
        eDISABLE_GRAVITY = 2,
        /**
         * @en Enables the sending of PxSimulationEventCallback::onWake() and PxSimulationEventCallback::onSleep() notify events.
         * @zh 启用 PxSimulationEventCallback::onWake() 和 PxSimulationEventCallback::onSleep() 通知事件的发送。
         */
        eSEND_SLEEP_NOTIFIES = 4,
        /**
         * @en Disables simulation for the actor.
         * @zh 禁用执行器的模拟。
         */
        eDISABLE_SIMULATION = 8
    }
    /**
     * @en The `pxCollider` class is used to handle physics colliders.
     * @zh `pxCollider` 类用于处理物理碰撞器。
     */
    class pxCollider implements ICollider {
        /**@internal pool of Actor */
        static _ActorPool: Map<number, pxCollider>;
        /**@internal UUid of pxActor */
        static _pxActorID: number;
        /**temp tranform object */
        private static _tempTransform;
        /**@internal */
        owner: Sprite3D;
        /**@internal */
        componentEnable: boolean;
        /**@internal */
        component: PhysicsColliderComponent;
        /**actor */
        _pxActor: any;
        /**owner transform */
        _transform: Transform3D;
        /**type data */
        _type: pxColliderType;
        /**触发器 */
        _isTrigger: boolean;
        /**@internal */
        _isSimulate: boolean;
        /**can collision Group*/
        _canCollisionWith: number;
        /**collision group */
        _collisionGroup: number;
        /**pxshape */
        _shape: pxColliderShape;
        /**manager */
        _physicsManager: pxPhysicsManager;
        /**check destroy */
        _destroyed: boolean;
        /**
         * @en The index of this collider in the physics update list.
         * @zh 此碰撞器在物理更新列表中的索引。
         */
        inPhysicUpdateListIndex: number;
        /**@internal */
        _enableProcessCollisions: boolean;
        /**id */
        _id: number;
        /** @internal */
        protected _transformFlag: number;
        private _bounciness;
        /** @internal */
        private _dynamicFriction;
        /** @internal */
        private _staticFriction;
        /** @internal */
        private _bounceCombine;
        /** @internal */
        private _frictionCombine;
        /**
         * @en Creates a instance of pxCollider.
         * @param manager The physics manager responsible for this collider.
         * @zh 创建一个 pxCollider 实例。
         * @param manager 负责管理此碰撞器的物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Indicates whether the collider is active.
         * @zh 表示碰撞器是否处于激活状态。
         */
        active: boolean;
        /**
         * @en Sets the friction value for the collider.
         * @param value The friction value to set.
         * @zh 设置碰撞器的摩擦力值。
         * @param value 要设置的摩擦力值。
         */
        setfriction?(value: number): void;
        /**
         * @en Sets the rolling friction value for the collider.
         * @param value The rolling friction value to set.
         * @zh 设置碰撞器的滚动摩擦力值。
         * @param value 要设置的滚动摩擦力值。
         */
        setRollingFriction?(value: number): void;
        protected setActorFlag(flag: pxActorFlag, value: boolean): void;
        /**
         * @en Gets the capability of the collider.
         * @param value The capability to check.
         * @zh 获取碰撞器的能力。
         * @param value 要检查的能力。
         */
        getCapable(value: number): boolean;
        /**
         * @en Sets the collider shape for this collider.
         * @param shape The collider shape to set.
         * @zh 为此碰撞器设置碰撞形状。
         * @param shape 要设置的碰撞形状。
         */
        setColliderShape(shape: pxColliderShape): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Destroys the collider and releases its resources.
         * @zh 销毁碰撞器并释放其资源。
         */
        destroy(): void;
        /**
         * @en Sets the collision group for this collider.
         * @param value The collision group value.
         * @zh 设置此碰撞器的碰撞组。
         * @param value 碰撞组值。
         */
        setCollisionGroup(value: number): void;
        /**
         * @en Sets which groups this collider can collide with.
         * @param value The collision mask value.
         * @zh 设置此碰撞器可以与哪些组碰撞。
         * @param value 碰撞掩码值。
         */
        setCanCollideWith(value: number): void;
        /**
         * @en Sets the event filter for the collider.
         * @param events An array of events to filter.
         * @zh 设置碰撞器的事件过滤器。
         * @param events 要过滤的事件数组。
         */
        setEventFilter(events: [
        ]): void;
        allowSleep(value: boolean): void;
        /**
         * @en Sets the owner node for this collider.
         * @param node The Sprite3D node that owns this collider.
         * @zh 设置此碰撞器的所有者节点。
         * @param node 拥有此碰撞器的 Sprite3D 节点。
         */
        setOwner(node: Sprite3D): void;
        protected _initCollider(): void;
        /**
         * @en Notifies that the transform has changed.
         * @param flag The transform change flag.
         * @zh 通知变换已更改。
         * @param flag 变换更改标志。
         */
        transformChanged(flag: number): void;
        /**
         * @en Sets the world transform of the collider.
         * @param focus Whether to force update even if no change is detected.
         * @zh 设置碰撞器的世界变换。
         * @param focus 是否强制更新，即使未检测到变化。
         */
        setWorldTransform(focus: boolean): void;
        /**
         * @en Sets the bounciness (restitution) of the collider.
         * @param value The bounciness value.
         * @zh 设置碰撞器的弹性（恢复）。
         * @param value 弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction of the collider.
         * @param value The dynamic friction value.
         * @zh 设置碰撞器的动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction of the collider.
         * @param value The static friction value.
         * @zh 设置碰撞器的静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the friction combine mode of the collider.
         * @param value The friction combine mode.
         * @zh 设置碰撞器的摩擦力合并模式。
         * @param value 摩擦力合并模式。
         */
        setFrictionCombine(value: PhysicsCombineMode): void;
        /**
         * @en Sets the bounce combine mode of the collider.
         * @param value The bounce combine mode.
         * @zh 设置碰撞器的弹性合并模式。
         * @param value 弹性合并模式。
         */
        setBounceCombine(value: PhysicsCombineMode): void;
        /**
       * @internal
       */
        _getTransformFlag(type: number): boolean;
        /**
         * @internal
         */
        _setTransformFlag(type: number, value: boolean): void;
        /**
         * @internal
         */
        _transformTo(pos: Vector3, rot: Quaternion): {
            translation: Vector3;
            rotation: Quaternion;
        };
    }
    /**
     * @en The collision detection mode constants.
     * @zh 碰撞检测模式常量。
     */
    enum CollisionDetectionMode {
        /**
         * @en Continuous collision detection is off for this dynamic collider.
         * @zh 对于这个动态碰撞体，连续碰撞检测是关闭的。
         */
        Discrete = 0,
        /**
         * @en Continuous collision detection is on for colliding with static mesh geometry.
         * @zh 对于与静态网格几何体的碰撞，连续碰撞检测是开启的。
         */
        Continuous = 1,
        /**
         * @en Continuous collision detection is on for colliding with static and dynamic geometry.
         * @zh 对于与静态和动态几何体的碰撞，连续碰撞检测是开启的。
         */
        ContinuousDynamic = 2,
        /**
         * @en Speculative continuous collision detection is on for static and dynamic geometries.
         * @zh 对于静态和动态几何体，推测性连续碰撞检测是开启的。
         */
        ContinuousSpeculative = 3
    }
    /**
     * @en Use these flags to constrain motion of dynamic collider.
     * @zh 使用这些标志来限制动态碰撞体的运动。
     */
    enum DynamicColliderConstraints {
        /**
         * @en Not Freeze.
         * @zh 不冻结任何运动。
         */
        None = 0,
        /**
         * @en Freeze motion along the X-axis.
         * @zh 冻结沿 X 轴的运动。
         */
        FreezePositionX = 1,
        /**
         * @en Freeze motion along the Y-axis.
         * @zh 冻结沿 Y 轴的运动。
         */
        FreezePositionY = 2,
        /**
         * @en Freeze motion along the Z-axis.
         * @zh 冻结沿 Z 轴的运动。
         */
        FreezePositionZ = 4,
        /**
         * @en Freeze rotation along the X-axis.
         * @zh 冻结绕 X 轴的旋转。
         */
        FreezeRotationX = 8,
        /**
         * @en Freeze rotation along the Y-axis.
         * @zh 冻结绕 Y 轴的旋转。
         */
        FreezeRotationY = 16,
        /**
         * @en Freeze rotation along the Z-axis.
         * @zh 冻结绕 Z 轴的旋转。
         */
        FreezeRotationZ = 32
    }
    /**
     * @en The `pxDynamicCollider` class is used to manage dynamic colliders in the physics engine.
     * @zh `pxDynamicCollider` 类用于在物理引擎中管理动态碰撞体。
     */
    class pxDynamicCollider extends pxCollider implements IDynamicCollider {
        /**@internal */
        static _dynamicCapableMap: Map<any, any>;
        /**
         * @en Get the static collider capability for a given value.
         * @param value The collider capability to check.
         * @returns Whether the static collider has the specified capability.
         * @zh 获取指定值的静态碰撞体能力。
         * @param value 要检查的碰撞体能力。
         * @returns 静态碰撞体是否具有指定的能力。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities map for dynamic colliders.
         * @zh 初始化动态碰撞体的能力映射。
         */
        static initCapable(): void;
        /**
         * @en Indicates whether the collider is kinematic.
         * @zh 表示碰撞体是否是运动学的。
         */
        IsKinematic: boolean;
        private _mass;
        private _linearDamping;
        private _angularDamping;
        private _linearVelocity;
        private _angularVelocity;
        private _centerOfMass;
        private _inertiaTensor;
        private _sleepThreshold;
        private _collisionDetectionMode;
        private _solverIterations;
        /**
         * @en Create a pxDynamicCollider instance.
         * @param manager The physics manager instance.
         * @zh 创建 pxDynamicCollider 类的实例。
         * @param manager 物理管理器实例。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Get the capability of the collider for a given value.
         * @param value The capability value to check.
         * @returns Whether the collider has the specified capability.
         * @zh 获取碰撞体对于给定值的能力。
         * @param value 要检查的能力值。
         * @returns 碰撞体是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Set the world position of the dynamic collider.
         * @param value The new world position.
         * @zh 设置动态碰撞体的世界位置。
         * @param value 新的世界位置。
         */
        setWorldPosition(value: Vector3): void;
        /**
         * @en Set the world rotation of the dynamic collider.
         * @param value The new world rotation.
         * @zh 设置动态碰撞体的世界旋转。
         * @param value 新的世界旋转。
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * @en Get the world transform of the dynamic collider.
         * @zh 获取动态碰撞体的世界变换。
         */
        getWorldTransform(): void;
        /**
         * @en Set the trigger state of the collider.
         * @param value True to set as trigger, false otherwise.
         * @zh 设置碰撞体的触发器状态。
         * @param value 为 true 时设置为触发器，否则为 false。
         */
        setTrigger(value: boolean): void;
        /**
         * @en Set the linear damping of the dynamic collider.
         * @param value The linear damping value.
         * @zh 设置动态碰撞体的线性阻尼。
         * @param value 线性阻尼值。
         */
        setLinearDamping(value: number): void;
        /**
         * @en Set the angular damping of the dynamic collider.
         * @param value The angular damping value.
         * @zh 设置动态碰撞体的角度阻尼。
         * @param value 角度阻尼值。
         */
        setAngularDamping(value: number): void;
        /**
         * @en Set the linear velocity of the dynamic collider.
         * @param value The linear velocity vector.
         * @zh 设置动态碰撞体的线性速度。
         * @param value 线性速度向量。
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * @en Get the linear velocity of the dynamic collider.
         * @returns The current linear velocity.
         * @zh 获取动态碰撞体的线性速度。
         * @returns 当前的线性速度。
         */
        getLinearVelocity(): Vector3;
        /**
         * @en Set the angular velocity of the dynamic collider.
         * @param value The angular velocity vector.
         * @zh 设置动态碰撞体的角速度。
         * @param value 角速度向量。
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * @en Get the angular velocity of the dynamic collider.
         * @returns The current angular velocity.
         * @zh 获取动态碰撞体的角速度。
         * @returns 当前的角速度。
         */
        getAngularVelocity(): Vector3;
        /**
         * @en Set the mass of the dynamic collider.
         * @param value The mass value.
         * @zh 设置动态碰撞体的质量。
         * @param value 质量值。
         */
        setMass(value: number): void;
        /**
         * @en Set the center of mass of the dynamic collider.
         * @param value The center of mass vector.
         * @zh 设置动态碰撞体的质心。
         * @param value 质心向量。
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * @en Set the inertia tensor of the dynamic collider.
         * @param value The inertia tensor vector.
         * @zh 设置动态碰撞体的惯性张量。
         * @param value 惯性张量向量。
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * @en Whether it is sleeping.
         * @zh 是否处于睡眠状态。
         */
        isSleeping(): boolean;
        /**
         * @en Set the sleep threshold of the dynamic collider.
         * @param value The sleep threshold value.
         * @zh 设置动态碰撞体的睡眠阈值。
         * @param value 睡眠阈值。
         */
        setSleepThreshold(value: number): void;
        /**
         * @en Set the collision detection mode of the dynamic collider.
         * @param value The collision detection mode.
         * @zh 设置动态碰撞体的碰撞检测模式。
         * @param value 碰撞检测模式。
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * @en Set the solver iterations of the dynamic collider.
         * @param value The number of solver iterations.
         * @zh 设置动态碰撞体的求解器迭代次数。
         * @param value 求解器迭代次数。
         */
        setSolverIterations(value: number): void;
        /**
         * @en Set whether the dynamic collider is kinematic.
         * @param value True if kinematic, false otherwise.
         * @zh 设置动态碰撞体是否为运动学的。
         * @param value 为 true 时设置为运动学，否则为 false。
         */
        setIsKinematic(value: boolean): void;
        allowSleep(value: boolean): void;
        /**
         * @en Set the constraints of the dynamic collider.
         * @param linearFactor The linear factor vector.
         * @param angularFactor The angular factor vector.
         * @zh 设置动态碰撞体的约束。
         * @param linearFactor 线性因子向量。
         * @param angularFactor 角度因子向量。
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * @en Add force to the dynamic collider.
         * @param force The force vector to add.
         * @param mode The physics force mode.
         * @param localOffset The local offset vector.
         * @zh 为动态碰撞体添加力。
         * @param force 要添加的力向量。
         * @param mode 物理力模式。
         * @param localOffset 局部偏移向量。
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * @en Add torque to the dynamic collider.
         * @param torque The torque vector to add.
         * @param mode The physics force mode.
         * @zh 为动态碰撞体添加扭矩。
         * @param torque 要添加的扭矩向量。
         * @param mode 物理力模式。
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * @en Put the dynamic collider to sleep.
         * @zh 使动态碰撞体进入睡眠状态。
         */
        sleep(): void;
        /**
         * @en Wake up the dynamic collider.
         * @zh 唤醒动态碰撞体。
         */
        wakeUp(): void;
        /**
         * @en Move the kinematic actor to a new pose.
         * @param positionOrRotation The new position or rotation.
         * @param rotation The new rotation (optional).
         * @zh 将运动学角色移动到新的姿态。
         * @param positionOrRotation 新的位置或旋转。
         * @param rotation 新的旋转（可选）。
         */
        move(positionOrRotation: Vector3 | Quaternion, rotation?: Quaternion): void;
        /**
         * @en Destroy Rigidbody
         * @zh 销毁刚体
         */
        destroy(): void;
    }
    /**
     * @en Class representing a static collider in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的静态碰撞器的类。
     */
    class pxStaticCollider extends pxCollider implements IStaticCollider {
        /**@internal */
        static _staticCapableMap: Map<any, any>;
        /**
         * @en Get the capability of a static collider for a specific collider capable.
         * @param value The collider capable to check.
         * @returns Whether the static collider is capable of the specified feature.
         * @zh 获取静态碰撞器对特定碰撞器能力的支持状态。
         * @param value 要检查的碰撞器能力。
         * @returns 静态碰撞器是否支持指定的特性。
         */
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        /**
         * @en Initialize the capabilities map for static colliders.
         * @zh 初始化静态碰撞器的能力映射表。
         */
        static initCapable(): void;
        /**
         * @en Creates an instance of pxStaticCollider.
         * @param manager The physics manager.
         * @zh 创建一个 pxStaticCollider 实例。
         * @param manager 物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        /**
         * @en Check if the static collider is capable of a specific feature.
         * @param value The capability to check.
         * @returns Whether the static collider is capable of the specified feature.
         * @zh 检查静态碰撞器是否具有特定能力。
         * @param value 要检查的能力。
         * @returns 静态碰撞器是否具有指定的能力。
         */
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        /**
         * @en Set the trigger state of the collider.
         * @param value Whether the collider should act as a trigger.
         * @zh 设置碰撞器的触发器状态。
         * @param value 碰撞器是否应该作为触发器。
         */
        setTrigger(value: boolean): void;
        protected _initColliderShapeByCollider(): void;
        /**
         * @en Destroy Static Collider
         * @zh 销毁静态碰撞器
         */
        destroy(): void;
    }
    enum PxD6JointDriveFlag {
        /**
         * @en drive spring is for the acceleration at the joint (rather than the force).
         * @zh 表示驱动弹簧用于关节的加速度，而不是力。
         */
        eACCELERATION = 1
    }
    /**
     * @en The `pxD6Joint` class is used to create and manage D6 joints (6 degrees of freedom joints) in the PhysX physics engine.
     * @zh `pxD6Joint` 类用于创建和管理 PhysX 物理引擎中的 D6 关节（6 自由度关节）。
     */
    class pxD6Joint extends pxJoint implements ID6Joint {
        /**@internal temp V3 */
        static tempV3: Vector3;
        /**@internal axis */
        private _axis;
        /**@internal */
        private _SecondaryAxis;
        /**@internal */
        private _axisRotationQuaternion;
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @internal
         */
        _initAllConstrainInfo(): void;
        /**
         * set local Pose
         * @param actor
         * @param position
         */
        protected _setLocalPose(actor: number, position: Vector3): void;
        /**
         * @en Sets the joint's primary and secondary axes.
         * @param axis The primary axis.
         * @param secendary The secondary axis.
         * @zh 设置关节的主轴和次轴。
         * @param axis 主轴。
         * @param secendary 次轴。
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * @en Sets the motion type for a specific axis.
         * @param axis The axis to set.
         * @param motionType The motion type to apply.
         * @zh 设置特定轴的运动类型。
         * @param axis 要设置的轴。
         * @param motionType 要应用的运动类型。
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * @en Sets the distance limit for the joint.
         * @param limit The distance limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damp The damping coefficient.
         * @zh 设置关节的距离限制。
         * @param limit 距离限制。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damp 阻尼系数。
         */
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         * @en Sets the linear limit for a specific axis.
         * @param linearAxis The linear axis to set.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置特定轴的线性限制。
         * @param linearAxis 要设置的线性轴。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the twist limit for the joint.
         * @param upper The upper limit.
         * @param lower The lower limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的扭转限制。
         * @param upper 上限。
         * @param lower 下限。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the swing limit for the joint.
         * @param yAngle The Y angle limit.
         * @param zAngle The Z angle limit.
         * @param bounceness The bounciness of the limit.
         * @param bounceThreshold The bounce threshold.
         * @param spring The spring coefficient.
         * @param damping The damping coefficient.
         * @zh 设置关节的摆动限制。
         * @param yAngle Y 角度限制。
         * @param zAngle Z 角度限制。
         * @param bounceness 限制的弹性。
         * @param bounceThreshold 反弹阈值。
         * @param spring 弹簧系数。
         * @param damping 阻尼系数。
         */
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         * @en Sets the drive parameters for a specific drive index.
         * @param index The drive index.
         * @param stiffness The stiffness of the drive.
         * @param damping The damping of the drive.
         * @param forceLimit The force limit of the drive.
         * @zh 设置特定驱动索引的驱动参数。
         * @param index 驱动索引。
         * @param stiffness 驱动的刚度。
         * @param damping 驱动的阻尼。
         * @param forceLimit 驱动的力限制。
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         * @en Sets the drive transform for the joint.
         * @param position The target position.
         * @param rotate The target rotation.
         * @zh 设置关节的驱动变换。
         * @param position 目标位置。
         * @param rotate 目标旋转。
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         * @en Sets the drive velocity for the joint.
         * @param position The linear velocity.
         * @param angular The angular velocity.
         * @zh 设置关节的驱动速度。
         * @param position 线性速度。
         * @param angular 角速度。
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         * @en Gets the current twist angle of the joint.
         * @returns The twist angle in radians.
         * @zh 获取关节当前的扭转角度。
         * @returns 扭转角度（弧度）。
         */
        getTwistAngle(): number;
        /**
         * @en Gets the current swing Y angle of the joint.
         * @returns The swing Y angle in radians.
         * @zh 获取关节当前的 Y 轴摆动角度。
         * @returns Y 轴摆动角度（弧度）。
         */
        getSwingYAngle(): number;
        /**
         * @en Gets the current swing Z angle of the joint.
         * @returns The swing Z angle in radians.
         * @zh 获取关节当前的 Z 轴摆动角度。
         * @returns Z 轴摆动角度（弧度）。
         */
        getSwingZAngle(): number;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The pxDistanceJoint class represents a distance joint in the PhysX physics engine.
     * @zh pxDistanceJoint 类表示 PhysX 物理引擎中的距离关节。
     */
    class pxDistanceJoint extends pxJoint implements ISpringJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @en Sets the minimum distance for the joint.
         * @param distance The minimum distance value.
         * @zh 设置关节的最小距离。
         * @param distance 最小距离值。
         */
        setMinDistance(distance: number): void;
        /**
         * @en Sets the maximum distance for the joint.
         * @param distance The maximum distance value.
         * @zh 设置关节的最大距离。
         * @param distance 最大距离值。
         */
        setMaxDistance(distance: number): void;
        /**
         * @en Sets the connect distance for the joint.
         * @param distance The connect distance value.
         * @zh 设置关节的连接距离。
         * @param distance 连接距离值。
         */
        setConnectDistance(distance: number): void;
        /**
         * @en Allows the spring to have a different rest length.
         * @param tolerance The tolerance value for the spring rest length.
         * @zh 允许弹簧具有不同的静止长度。
         * @param tolerance 弹簧静止长度的容差值。
         */
        setTolerance(tolerance: number): void;
        /**
         * @en Sets the stiffness of the joint spring.
         * @param stiffness The stiffness value.
         * @zh 设置关节弹簧的刚度。
         * @param stiffness 刚度值。
         */
        setStiffness(stiffness: number): void;
        /**
         * @en Sets the damping of the joint spring.
         * @param damping The damping value.
         * @zh 设置关节弹簧的阻尼。
         * @param damping 阻尼值。
         */
        setDamping(damping: number): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * @en The pxFixedJoint class represents a fixed joint in the PhysX physics engine.
     * @zh pxFixedJoint 类表示 PhysX 物理引擎中的固定关节。
     */
    class pxFixedJoint extends pxJoint implements IFixedJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    /**
     * joint flag
     */
    enum PxConstraintFlag {
        eBROKEN = 1,
        ePROJECT_TO_ACTOR0 = 2,
        ePROJECT_TO_ACTOR1 = 4,
        ePROJECTION = 6,
        eCOLLISION_ENABLED = 8,
        eVISUALIZATION = 16,
        eDRIVE_LIMITS_ARE_FORCES = 32,
        eIMPROVED_SLERP = 128,
        eDISABLE_PREPROCESSING = 256,
        eENABLE_EXTENDED_LIMITS = 512,
        eGPU_COMPATIBLE = 1024,
        eALWAYS_UPDATE = 2048,
        eDISABLE_CONSTRAINT = 4096
    }
    /**
     * @en The `pxJoint` class is used to implement joint functionality in the physical engine.
     * @zh `pxJoint`类用于在物理引擎中实现关节功能。
     */
    class pxJoint implements IJoint {
        /**@internal */
        static _ActorPool: Map<number, pxJoint>;
        /**@internal */
        static _pxJointID: number;
        /**@internal */
        static _tempTransform0: {
            translation: Vector3;
            rotation: Quaternion;
        };
        /**@internal */
        static _tempTransform1: {
            translation: Vector3;
            rotation: Quaternion;
        };
        /**@internal */
        protected _pxJoint: any;
        /**@internal */
        protected _collider: pxCollider;
        /**@internal */
        protected _localPos: Vector3;
        /**@internal */
        protected _connectCollider: pxCollider;
        /**@internal */
        protected _connectlocalPos: Vector3;
        /**@internal */
        protected _breakForce: number;
        /**@internal */
        protected _breakTorque: number;
        /**@internal */
        protected _id: number;
        /**@internal */
        protected _linearForce: Vector3;
        /**@internal */
        protected _angularForce: Vector3;
        /**
         * @internal
         */
        owner: Sprite3D;
        /**@internal */
        _physicsManager: pxPhysicsManager;
        /**
         * @en Create an instance of the pxJoint class.
         * @param manager The physics manager.
         * @zh 创建pxJoint类的shape实例。
         * @param manager 物理管理器。
         */
        constructor(manager: pxPhysicsManager);
        /**@internal */
        isEnable(value: boolean): void;
        /**@internal */
        isCollision(value: boolean): void;
        /**@internal */
        isPreprocessiong(value: boolean): void;
        /**@internal */
        protected _createJoint(): void;
        destroy(): void;
        /**@internal */
        setOwner(value: Sprite3D): void;
        /**@internal */
        protected _setActor(): void;
        /**@internal */
        setCollider(owner: pxCollider): void;
        /**@internal */
        setConnectedCollider(owner: pxCollider): void;
        /**@internal */
        protected _setLocalPose(actor: number, position: Vector3): void;
        /**@internal */
        setLocalPos(value: Vector3): void;
        /**@internal */
        setConnectLocalPos(value: Vector3): void;
        /**@internal */
        setConnectedMassScale(value: number): void;
        /**@internal */
        setConnectedInertiaScale(value: number): void;
        /**@internal */
        setMassScale(value: number): void;
        /**@internal */
        setInertiaScale(value: number): void;
        /**@internal */
        setBreakForce(value: number): void;
        /**@internal */
        setBreakTorque(value: number): void;
        /**@internal */
        getlinearForce(): Vector3;
        /**@internal */
        getAngularForce(): Vector3;
        /**@internal */
        isValid(): boolean;
        /**@internal */
        release(): void;
    }
    enum PxRevoluteJointFlag {
        eLIMIT_ENABLED = 1,
        eDRIVE_ENABLED = 2,
        eDRIVE_FREESPIN = 4
    }
    /**
     * @en `pxRevoluteJoint` is a joint that allows rotation around an axis.
     * @zh `pxRevoluteJoint`类用于在物理引擎中创建和管理旋转关节（铰链关节）
     */
    class pxRevoluteJoint extends pxJoint implements IHingeJoint {
        /**@internal */
        protected static _xAxis: Vector3;
        /**@internal */
        private _axisRotationQuaternion;
        /**@internal */
        private _velocity;
        /**@internal */
        private _lowerLimit;
        /**@internal */
        private _uperLimit;
        /**@internal */
        private _bouncenciness;
        /**@internal */
        private _bouncenMinVelocity;
        /**@internal */
        private _contactDistance;
        /**@internal */
        private _enableLimit;
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**@internal */
        protected _setLocalPose(actor: number, position: Vector3): void;
        /**@internal */
        private _setRevoluteJointFlag;
        /**@internal */
        private _setLimit;
        /**@internal */
        setLowerLimit(lowerLimit: number): void;
        /**@internal */
        setUpLimit(value: number): void;
        /**@internal */
        setBounceness(value: number): void;
        /**@internal */
        setBouncenMinVelocity(value: number): void;
        /**@internal */
        setContactDistance(value: number): void;
        /**@internal */
        enableLimit(value: boolean): void;
        /**@internal */
        enableDrive(value: boolean): void;
        /**@internal */
        enableFreeSpin(value: boolean): void;
        /**@internal */
        setAxis(value: Vector3): void;
        /**@internal */
        getAngle(): number;
        /**@internal */
        getVelocity(): Readonly<Vector3>;
        /**@internal */
        setDriveVelocity(velocity: number): void;
        /**@internal */
        setDriveForceLimit(limit: number): void;
        /**
         * @en Destroy joint
         * @zh 销毁关节
         */
        destroy(): void;
    }
    class pxSphereJoint extends pxJoint {
    }
    /**
     * @en Implements PhysX collision data content
     * @zh 实现PhysX碰撞数据内容
     */
    class pxCollisionTool {
        /**@internal */
        static _collisionPool: Collision[];
        /**@internal */
        static _hitPool: HitResult[];
        /**@internal */
        static _tempV3: Vector3;
        /**@internal */
        static _contactPoint: ContactPoint;
        /**@ignore */
        constructor();
        /**
         * @internal
         */
        static getCollision(pxCollsionData: any, isTrigger: boolean): Collision;
        /**
         * @en Convert PhysX LayaQuaryResult to HitResult type
         * @param out The HitResult object to store the result
         * @param quaryResult The PhysX query result
         * @returns The converted HitResult
         * @zh 转换PhysX的LayaQuaryResult到HitResult类型
         * @param out 用于存储结果的HitResult对象
         * @param quaryResult PhysX查询结果
         * @returns 转换后的HitResult
         */
        static getRayCastResult(out: HitResult, quaryResult: any): HitResult;
        /**
         * @en Convert all PhysX LayaQuaryResults to HitResult type
         * @param out The array to store the converted HitResults
         * @param quaryResults The PhysX query results
         * @returns The array of converted HitResults
         * @zh 转换所有PhysX的LayaQuaryResult到HitResult类型
         * @param out 用于存储转换后HitResult的数组
         * @param quaryResults PhysX查询结果
         * @returns 转换后的HitResult数组
         */
        static getRayCastResults(out: HitResult[], quaryResults: any): HitResult[];
        /**
         * @en Recycle Collision object back to the pool
         * @param value The Collision object to be recycled
         * @zh 回收Collision对象到对象池
         * @param value 要回收的Collision对象
         */
        static reCoverCollision(value: Collision): void;
        /**
         * @en Recycle HitResult object back to the pool
         * @param value The HitResult object to be recycled
         * @zh 回收HitResult对象到对象池
         * @param value 要回收的HitResult对象
         */
        static reCoverHitresults(value: HitResult): void;
    }
    /**
     * @en PhysX physics creation utility class
     * @zh PhysX物理创建工具类
     */
    class pxPhysicsCreateUtil implements IPhysicsCreateUtil {
        protected _physicsEngineCapableMap: Map<any, any>;
        /**
         * @en Initialize physics capabilities
         * @zh 初始化物理能力
         */
        initPhysicsCapable(): void;
        /**
         * @en Get the capability status of a specific physics feature.
         * @param value The physics capability to query.
         * @returns Whether the specified physics capability is available.
         * @zh 获取特定物理功能的能力状态。
         * @param value 要查询的物理能力。
         * @returns 指定的物理能力是否可用。
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * @en Initialize the physics engine.
         * @returns A promise that resolves when initialization is complete.
         * @zh 初始化物理引擎。
         * @returns 当初始化完成时解析的Promise。
         */
        initialize(): Promise<void>;
        /**
         * @en Enable PhysX PVD (PhysX Visual Debugger) using Socket transport.
         * @param physX The PhysX instance.
         * @param pxFoundation The PhysX foundation instance.
         * @zh 使用Socket传输启用PhysX PVD（PhysX可视化调试器）。
         * @param physX PhysX实例。
         * @param pxFoundation PhysX foundation实例。
         */
        _physxPVDSocketConnect(physX: any, pxFoundation: any): any;
        private _init;
        /**
         * @en Create a physics manager.
         * @param physicsSettings The physics settings.
         * @returns A new physics manager instance.
         * @zh 创建物理管理器。
         * @param physicsSettings 物理设置。
         * @returns 新的物理管理器实例。
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): pxPhysicsManager;
        /**
         * @en Create a dynamic collider.
         * @param manager The physics manager.
         * @returns A new dynamic collider instance.
         * @zh 创建动态碰撞器。
         * @param manager 物理管理器。
         * @returns 新的动态碰撞器实例。
         */
        createDynamicCollider(manager: pxPhysicsManager): IDynamicCollider;
        /**
         * @en Create a static collider.
         * @param manager The physics manager.
         * @returns A new static collider instance.
         * @zh 创建静态碰撞器。
         * @param manager 物理管理器。
         * @returns 新的静态碰撞器实例。
         */
        createStaticCollider(manager: pxPhysicsManager): IStaticCollider;
        /**
         * @en Create a character controller.
         * @param manager The physics manager.
         * @returns A new character controller instance.
         * @zh 创建角色控制器。
         * @param manager 物理管理器。
         * @returns 新的角色控制器实例。
         */
        createCharacterController(manager: pxPhysicsManager): ICharacterController;
        /**
         * @en Create a fixed joint.
         * @param manager The physics manager.
         * @returns A new fixed joint instance.
         * @zh 创建固定关节。
         * @param manager 物理管理器。
         * @returns 新的固定关节实例。
         */
        createFixedJoint(manager: pxPhysicsManager): IFixedJoint;
        /**
         * @en Create a hinge joint.
         * @param manager The physics manager.
         * @returns A new hinge joint instance.
         * @zh 创建铰链关节。
         * @param manager 物理管理器。
         * @returns 新的铰链关节实例。
         */
        createHingeJoint(manager: pxPhysicsManager): IHingeJoint;
        /**
         * @en Create a spring joint.
         * @param manager The physics manager.
         * @returns A new spring joint instance.
         * @zh 创建弹簧关节。
         * @param manager 物理管理器。
         * @returns 新的弹簧关节实例。
         */
        createSpringJoint(manager: pxPhysicsManager): ISpringJoint;
        /**
         * @en Create a D6 joint.
         * @param manager The physics manager.
         * @returns A new D6 joint instance.
         * @zh 创建D6关节。
         * @param manager 物理管理器。
         * @returns 新的D6关节实例。
         */
        createD6Joint(manager: pxPhysicsManager): ID6Joint;
        /**
         * @en Create a box collider shape.
         * @returns A new box collider shape instance.
         * @zh 创建盒子碰撞器形状。
         * @returns 新的盒子碰撞器形状实例。
         */
        createBoxColliderShape(): IBoxColliderShape;
        /**
         * @en Create a sphere collider shape.
         * @returns A new sphere collider shape instance.
         * @zh 创建球体碰撞器形状。
         * @returns 新的球体碰撞器形状实例。
         */
        createSphereColliderShape(): ISphereColliderShape;
        /**
         * @en Create a plane collider shape.
         * @zh 创建平面碰撞器形状。
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * @en Create a capsule collider shape.
         * @returns A new capsule collider shape instance.
         * @zh 创建胶囊碰撞器形状。
         * @returns 新的胶囊碰撞器形状实例。
         */
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        /**
         * @en Create a mesh collider shape.
         * @returns A new mesh collider shape instance.
         * @zh 创建网格碰撞器形状。
         * @returns 新的网格碰撞器形状实例。
         */
        createMeshColliderShape?(): IMeshColliderShape;
        /**
         * @en Create a cylinder collider shape.
         * @zh 创建圆柱体碰撞器形状。
         */
        createCylinderColliderShape?(): ICylinderColliderShape;
        /**
         * @en Create a cone collider shape.
         * @zh 创建圆锥体碰撞器形状。
         */
        createConeColliderShape?(): IConeColliderShape;
        /**
         * @en Create a height field shape.
         * @returns A new height field shape instance.
         * @zh 创建高度场形状。
         * @returns 新的高度场形状实例。
         */
        createHeightFieldShape(): pxHeightFieldShape;
        /**
         * @en Create a compound collider shape.
         * @returns A new compound collider shape instance.
         * @zh 创建组合碰撞器形状。
         * @returns 新的组合碰撞器形状实例。
         */
        createCompoundShape(): ICompoundColliderShape;
        /**
         * @en Create a convex mesh from a given mesh.
         * @param mesh The input mesh.
         * @zh 从给定的网格创建凸包网格。
         * @param mesh 输入的网格。
         */
        createCorveMesh(mesh: Mesh): Mesh;
    }
    /**
     * @en The `pxPhysicsManager` class is used to implement physics management.
     * @zh `pxPhysicsManager` 类用于实现物理管理。
     */
    class pxPhysicsManager implements IPhysicsManager {
        /** @internal 引擎更新物理列表*/
        _physicsUpdateList: PhysicsUpdateList;
        _dynamicUpdateList: PhysicsUpdateList;
        /** @internal */
        _pxScene: any;
        /**
         * @en Fixed time step for physics simulation.
         * @zh 物理模拟的固定时间步长。
         */
        fixedTime: number;
        /**
         * @en Whether to enable Continuous Collision Detection (CCD).
         * @zh 是否启用连续碰撞检测(CCD)。
         */
        enableCCD: boolean;
        /**@internal 碰撞开始数据表*/
        _contactCollisionsBegin: Map<number, Collision>;
        /**@internal 碰撞持续数据表*/
        _contactCollisionsPersist: Map<number, Collision>;
        /**@internal 碰撞结束数据表*/
        _contactCollisionsEnd: Map<number, Collision>;
        /**@internal 触发数据开始列表*/
        _triggerCollisionsBegin: Map<number, Collision>;
        /**@internal 触发数据持续列表*/
        _triggerCollisionsPersist: Map<number, Collision>;
        /**@internal 触发数据结束列表*/
        _triggerCollisionsEnd: Map<number, Collision>;
        _pxcontrollerManager: any;
        private _gravity;
        /**temp tranform object */
        private static _tempTransform;
        /**@internal */
        private static _tempVector30;
        /**
         * @en Create a new instance of `pxPhysicsManager`.
         * @param physicsSettings The physics settings to initialize the manager.
         * @zh 创建`pxPhysicsManager`类的新实例。
         * @param physicsSettings 用于初始化管理器的物理设置。
         */
        constructor(physicsSettings: PhysicsSettings);
        /**
         * @en Set the active state of a collider.
         * @param collider The collider to set.
         * @param value The active state to set.
         * @zh 设置碰撞器的活动状态。
         * @param collider 要设置的碰撞器。
         * @param value 要设置的活动状态。
         */
        setActiveCollider(collider: pxCollider, value: boolean): void;
        /**
         * @en Enable or disable the debug drawer.
         * @param value Whether to enable the debug drawer.
         * @zh 启用或禁用调试绘制器。
         * @param value 是否启用调试绘制器。
         */
        enableDebugDrawer?(value: boolean): void;
        /**
         * @en Set collision data to the appropriate map based on the event type.
         * @param dataCallBack The collision data callback.
         * @param eventType The type of collision event.
         * @param isTrigger Whether the collision is a trigger event.
         * @zh 根据事件类型将碰撞数据设置到适当的映射中。
         * @param dataCallBack 碰撞数据回调。
         * @param eventType 碰撞事件的类型。
         * @param isTrigger 碰撞是否为触发器事件。
         */
        setDataToMap(dataCallBack: any, eventType: string, isTrigger?: boolean): void;
        /**
         * @en Set the gravity of the physics world.
         * @param gravity The gravity vector to set.
         * @zh 设置物理世界的重力。
         * @param gravity 要设置的重力向量。
         */
        setGravity(gravity: Vector3): void;
        private _addCharactorCollider;
        private _removeCharactorCollider;
        private addDynamicElementByUUID;
        private removeDynamicElementByUUID;
        /**
         * @en Add a collider to the physics world.
         * @param collider The collider to be added.
         * @zh 将碰撞器添加到物理世界中。
         * @param collider 要添加的碰撞器。
         */
        addCollider(collider: ICollider): void;
        /**
         * @en Remove a collider from the physics world.
         * @param collider The collider to be removed.
         * @zh 从物理世界中移除碰撞器。
         * @param collider 要移除的碰撞器。
         */
        removeCollider(collider: ICollider): void;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsCollider
         */
        private _collision_event;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderEnter
         */
        private _collision_EnterEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderStay
         */
        private _collision_StayEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsColliderExit
         */
        private _collision_ExitEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTrigger
         */
        private _trigger_Event;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerEnter
         */
        private _trigger_EnterEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerStay
         */
        private _trigger_StayEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsTriggerExit
         */
        private _trigger_ExitEvent;
        /**
         * @private
         * @perfTag PerformanceDefine.T_PhysicsEvent
         */
        private _updatePhysicsEvents;
        /**
         * @private
         * @perfTag PerformanceDefine.T_Physics_UpdateNode
         */
        private _updatePhysicsTransformToRender;
        /**
         * @internal
         */
        private _updatePhysicsTransformFromRender;
        /**
         * @perfTag PerformanceDefine.T_Physics_Simulation
         * @en Update the physics simulation.
         * @param elapsedTime The elapsed time since the last update.
         * @zh 更新物理模拟。
         * @param elapsedTime 自上次更新以来经过的时间。
         */
        update(elapsedTime: number): void;
        /**
         * @en Performs a ray cast in the physics world.Returns the first hit object.
         * @param ray The ray to cast.
         * @param outHitResult The result of the raycast.
         * @param distance The maximum distance of the raycast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the raycast hit anything.
         * @zh 执行一次射线检测，返回第一个与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param outHitResult 射线检测的结果。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a ray cast in the physics world.Returns all hit objects.
         * @param ray The ray to cast.
         * @param out An array to store all hit results.
         * @param distance The maximum distance of the raycast.
         * @param collisonGroup The collision group of the ray.
         * @param collisionMask The collision mask of the ray.
         * @returns Whether the raycast hit anything.
         * @zh 执行一次射线检测，返回所有与射线相交的碰撞体信息。
         * @param ray 要投射的射线。
         * @param out 用于存储所有击中结果的数组。
         * @param distance 射线检测的最大距离。
         * @param collisonGroup 射线的碰撞组。
         * @param collisionMask 射线的碰撞掩码。
         * @returns 射线是否击中了任何物体。
         */
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * @en Performs a shape cast. Returns the first hit object.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out The result of the shape cast.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether the shape cast hit anything.
         * @zh 执行形状射线检测，返回第一个与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 形状投射的结果。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 形状投射是否击中了任何物体。
         */
        shapeCast(shape: pxColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult, fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        /**
         * @en Performs a shape cast. Returns all hit objects.
         * @param shape The shape to cast.
         * @param fromPosition The starting position of the shape.
         * @param toPosition The ending position of the shape.
         * @param out An array to store all hit results.
         * @param fromRotation The starting rotation of the shape.
         * @param toRotation The ending rotation of the shape.
         * @param collisonGroup The collision group of the shape.
         * @param collisionMask The collision mask of the shape.
         * @param allowedCcdPenetration The allowed continuous collision detection penetration.
         * @returns Whether the shape cast hit anything.
         * @zh 执行形状投射，返回所有与射线相交的碰撞体信息。
         * @param shape 要投射的形状。
         * @param fromPosition 形状的起始位置。
         * @param toPosition 形状的结束位置。
         * @param out 用于存储所有击中结果的数组。
         * @param fromRotation 形状的起始旋转。
         * @param toRotation 形状的结束旋转。
         * @param collisonGroup 形状的碰撞组。
         * @param collisionMask 形状的碰撞掩码。
         * @param allowedCcdPenetration 允许的连续碰撞检测穿透。
         * @returns 形状投射是否击中了任何物体。
         */
        shapeCastAll(shape: pxColliderShape, fromPosition: Vector3, toPosition: Vector3, out: HitResult[], fromRotation?: Quaternion, toRotation?: Quaternion, collisonGroup?: number, collisionMask?: number, allowedCcdPenetration?: number): boolean;
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        destroy(): void;
    }
    /**
     * @en Represents a physics material in the PhysX engine.
     * @zh 表示PhysX引擎中的物理材质。
     */
    class pxPhysicsMaterial {
        private _bounciness;
        private _dynamicFriction;
        private _staticFriction;
        private _bounceCombine;
        private _frictionCombine;
        /** @internal */
        _pxMaterial: any;
        /**
         * @en Creates a new pxPhysicsMaterial class.
         * @zh 创建一个新的pxPhysicsMaterial类。
         */
        constructor();
        /**
         * @en Sets the bounciness (restitution).
         * @param value The bounciness value.
         * @zh 设置反弹性（恢复系数）。
         * @param value 反弹性值。
         */
        setBounciness(value: number): void;
        /**
         * @en Sets the dynamic friction.
         * @param value The dynamic friction value.
         * @zh 设置动态摩擦力。
         * @param value 动态摩擦力值。
         */
        setDynamicFriction(value: number): void;
        /**
         * @en Sets the static friction.
         * @param value The static friction value.
         * @zh 设置静态摩擦力。
         * @param value 静态摩擦力值。
         */
        setStaticFriction(value: number): void;
        /**
         * @en Sets the bounce combine mode.
         * @param value The bounce combine mode.
         * @zh 设置反弹组合模式。
         * @param value 反弹组合模式。
         */
        setBounceCombine(value: PhysicsCombineMode): void;
        /**
         * @en Sets the friction combine mode.
         * @param value The friction combine mode.
         * @zh 设置摩擦力组合模式。
         * @param value 摩擦力组合模式。
         */
        setFrictionCombine(value: PhysicsCombineMode): void;
        /**
         * @en Destroys the physics material and releases associated resources.
         * @zh 销毁物理材质并释放相关资源。
         */
        destroy(): void;
    }
    /** @internal */
    class pxStatics {
        static _foundation: any;
        static _physX: any;
        static _physics: any;
        static _physXPVD: boolean;
        static _PxPvdPort: any;
        static _pvd: any;
        static _PxPvdTransport: any;
        static _physXSimulationCallbackInstance: any;
        static _sceneDesc: any;
        static _allocator: any;
        static _tolerancesScale: any;
        /**
         * @en Create a Float32Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Float32Array。
         * @param length 数组的长度。
         */
        static createFloat32Array(length: number): {
            ptr: number;
            buffer: Float32Array;
        };
        /**
         * @en Create a Uint32Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint32Array。
         * @param length 数组的长度。
         */
        static createUint32Array(length: number): {
            ptr: number;
            buffer: Uint32Array;
        };
        /**
         * @en Create a Uint16Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint16Array。
         * @param length 数组的长度。
         */
        static createUint16Array(length: number): {
            ptr: number;
            buffer: Uint16Array;
        };
        /**
         * @en Create a Uint8Array with allocated memory.
         * @param length The length of the array.
         * @zh 创建具有分配内存的Uint8Array。
         * @param length 数组的长度。
         */
        static createUint8Array(length: number): {
            ptr: number;
            buffer: Uint8Array;
        };
        /**
         * @en Free the allocated memory for a buffer.
         * @param data The buffer object to free.
         * @zh 释放为缓冲区分配的内存。
         * @param data 要释放的缓冲区对象。
         */
        static freeBuffer(data: any): void;
    }
    enum partFlag {
        eSOLVE_CONTACT = 1,
        eMODIFY_CONTACTS = 2,
        eNOTIFY_TOUCH_FOUND = 4,
        eNOTIFY_TOUCH_PERSISTS = 8,
        eNOTIFY_TOUCH_LOST = 16,
        eNOTIFY_TOUCH_CCD = 32,
        eNOTIFY_THRESHOLD_FORCE_FOUND = 64,
        eNOTIFY_THRESHOLD_FORCE_PERSISTS = 128,
        eNOTIFY_THRESHOLD_FORCE_LOST = 256,
        eNOTIFY_CONTACT_POINTS = 512,
        eDETECT_DISCRETE_CONTACT = 1024,
        eDETECT_CCD_CONTACT = 2048,
        ePRE_SOLVER_VELOCITY = 4096,
        ePOST_SOLVER_VELOCITY = 8192,
        eCONTACT_EVENT_POSE = 16384,
        eNEXT_FREE = 32768,
        eCONTACT_DEFAULT = 1025,
        eTRIGGER_DEFAULT = 1044
    }
    /**
     * @en Represents a box collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的盒状碰撞器形状。
     */
    class pxBoxColliderShape extends pxColliderShape implements IBoxColliderShape {
        private static _tempHalfExtents;
        /** @internal */
        private _size;
        /**
         * @en Creates a new instance of pxBoxColliderShape.
         * @zh 创建 pxBoxColliderShape 的新实例。
         */
        constructor();
        /**
         * @en Sets the size of the box collider.
         * @param size The new size of the box collider.
         * @zh 设置盒状碰撞器的大小。
         * @param size 盒状碰撞器的新大小。
         */
        setSize(size: Vector3): void;
        /**
         * @en Sets the offset of the box collider.
         * @param position The new offset position.
         * @zh 设置盒状碰撞器的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the box collider shape and releases resources.
         * @zh 销毁盒状碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @en Represents a capsule collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的胶囊碰撞器形状。
     */
    class pxCapsuleColliderShape extends pxColliderShape implements ICapsuleColliderShape {
        /** @internal */
        _radius: number;
        /** @internal */
        _halfHeight: number;
        /**@internal in Physx capsule's height is X Axis, need to rotate*/
        _rotation: Quaternion;
        private _upAxis;
        /**
         * @en Creates a new instance of pxCapsuleColliderShape.
         * @zh 创建 pxCapsuleColliderShape 的新实例。
         */
        constructor();
        /**
         * @internal
         * rotate capusle in physx, physx capsule heigth is X axis
         */
        _setCapsuleRotation(): void;
        /**
         * @en Adds the shape to a collider.
         * @param collider The collider to add the shape to.
         * @zh 将形状添加到碰撞器。
         * @param collider 要添加形状的碰撞器。
         */
        addToActor(collider: pxCollider): void;
        /**
         * @en Sets the radius of the capsule.
         * @param radius The new radius value.
         * @zh 设置胶囊体的半径。
         * @param radius 新的半径值。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the height of the capsule.
         * @param height The new height value.
         * @zh 设置胶囊体的高度。
         * @param height 新的高度值。
         */
        setHeight(height: number): void;
        /**
         * @en Sets the up axis of the capsule.
         * @param upAxis The new up axis value.
         * @zh 设置胶囊体的向上轴。
         * @param upAxis 新的向上轴值。
         */
        setUpAxis(upAxis: number): void;
        /**
         * @en Sets the offset of the capsule collider.
         * @param position The new offset position.
         * @zh 设置胶囊碰撞器的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the capsule collider shape and releases resources.
         * @zh 销毁胶囊碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * Flags which affect the behavior of Shapes.
     */
    enum ShapeFlag {
        /** The shape will partake in collision in the physical simulation. */
        SIMULATION_SHAPE = 1,
        /** The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...). */
        SCENE_QUERY_SHAPE = 2,
        /** The shape is a trigger which can send reports whenever other shapes enter/leave its volume. */
        TRIGGER_SHAPE = 4
    }
    interface pxFilterData {
        word0?: number;
        word1?: number;
        word2?: number;
        word3?: number;
    }
    /**
     * @en Represents a collider shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的碰撞器形状。
     */
    class pxColliderShape implements IColliderShape {
        static _shapePool: Map<number, pxColliderShape>;
        static _pxShapeID: number;
        static transform: {
            translation: Vector3;
            rotation: Quaternion;
        };
        _offset: Vector3;
        _scale: Vector3;
        _shapeFlags: ShapeFlag;
        /** @internal */
        _pxCollider: pxCollider;
        _pxShape: any;
        _pxGeometry: any;
        /** @internal */
        _pxMaterials: pxPhysicsMaterial[];
        _destroyed: boolean;
        _id: number;
        /**
         * @en Filter data for collision and query.
         * - 0: group, 1: mask, 2: event
         * @zh 碰撞和查询的过滤数据。
         * - 0]: 组, 1: 掩码, 2: 事件
         */
        filterData: pxFilterData;
        /** @ignore */
        constructor();
        protected _createShape(): void;
        private _modifyFlag;
        getPhysicsShape(): any;
        /**
         * @en Adds the shape to a collider.
         * @param collider The collider to add the shape to.
         * @zh 将形状添加到碰撞器。
         * @param collider 要添加形状的碰撞器。
         */
        addToActor(collider: pxCollider): void;
        /**
         * @en Removes the shape from a collider.
         * @param collider The collider to remove the shape from.
         * @zh 从碰撞器中移除形状。
         * @param collider 要移除形状的碰撞器。
         */
        removeFromActor(collider: pxCollider): void;
        /**
         * @en Sets the offset of the shape.
         * @param position The new offset position.
         * @zh 设置形状的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        getOffset(): Vector3;
        /**
         * @en Sets whether the shape is a trigger.
         * @param value True if the shape should be a trigger, false otherwise.
         * @zh 设置形状是否为触发器。
         * @param value 如果形状应为触发器则为 true，否则为 false。
         */
        setIsTrigger(value: boolean): void;
        _setShapeFlags(flags: ShapeFlag): void;
        /**
         * @en Sets the simulation filter data.
         * @param colliderGroup The collider group.
         * @param colliderMask The collider mask.
         * @zh 设置模拟过滤数据。
         * @param colliderGroup 碰撞器组。
         * @param colliderMask 碰撞器掩码。
         */
        setSimulationFilterData(colliderGroup: number, colliderMask: number): void;
        /**
         * @en Optimizes event return.
         * @param filterWorld2Number The filter data.
         * @zh 优化事件返回。
         * @param filterWorld2Number 过滤数据。
         */
        setEventFilterData(filterWorld2Number: number): void;
        /**
         * @en Destroys the collider shape and releases resources.
         * @zh 销毁碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    class pxCompoundColliderShape extends pxColliderShape implements ICompoundColliderShape {
        private _physicsComponent;
        pxShapes: pxColliderShape[];
        constructor();
        addChildShape(shape: pxColliderShape): void;
        removeChildShape(shape: pxColliderShape, index: number): void;
        setShapeData(component: PhysicsColliderComponent): void;
        refreshShapes(): void;
    }
    /**
     * @en Represents a height field shape in the PhysX physics engine.
     * @zh 表示 PhysX 物理引擎中的高度场形状。
     */
    class pxHeightFieldShape extends pxColliderShape implements IHeightFieldShape {
        /**@internal */
        private _numRows;
        /**@internal */
        private _numCols;
        /**@internal */
        private _heightData;
        /**@internal */
        private _flag;
        /**@internal */
        private _heightFiled;
        /**@internal */
        private _minHeight;
        /**@internal */
        private _maxHeight;
        /**@ignore */
        constructor();
        /**
         * get height data tranform
         * @returns
         */
        private getHeightData;
        /**
         * get flag Data
         * @returns
         */
        private getFlagData;
        /**
         * create HeightField Geometry
         */
        private _createHeightField;
        /**
         * @en Sets the height field data.
         * @param numRows Number of rows.
         * @param numCols Number of columns.
         * @param heightData Height data array.
         * @param flag Flag data array.
         * @param scale Scale of the height field.
         * @zh 设置高度场数据。
         * @param numRows 行数。
         * @param numCols 列数。
         * @param heightData 高度数据数组。
         * @param flag 标志数据数组。
         * @param scale 高度场的缩放。
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * @en Gets the number of rows in the height field.
         * @returns Number of rows.
         * @zh 获取高度场的行数。
         * @returns 行数。
         */
        getNbRows(): number;
        /**
         * @en Gets the number of columns in the height field.
         * @returns Number of columns.
         * @zh 获取高度场的列数。
         * @returns 列数。
         */
        getNbColumns(): number;
        /**
         * @en Gets the height at a specific row and column.
         * @param rows Row index.
         * @param cols Column index.
         * @returns Height value.
         * @zh 获取特定行列的高度值。
         * @param rows 行索引。
         * @param cols 列索引。
         * @returns 高度值。
         */
        getHeight(rows: number, cols: number): number;
    }
    enum PxConvexFlag {
        e16_BIT_INDICES = 1,
        eCOMPUTE_CONVEX = 2,
        eCHECK_ZERO_AREA_TRIANGLES = 4,
        eQUANTIZE_INPUT = 8,
        eDISABLE_MESH_VALIDATION = 16,
        ePLANE_SHIFTING = 32,
        eFAST_INERTIA_COMPUTATION = 64,
        eGPU_COMPATIBLE = 128,
        eSHIFT_VERTICES = 256
    }
    enum PxConvexMeshGeometryFlag {
        eTIGHT_BOUNDS = 1
    }
    enum PxMeshGeometryFlag {
        eTIGHT_BOUNDS = 1,
        eDOUBLE_SIDED = 2
    }
    /**
     * @en Represents a mesh collider shape in the physics engine.
     * @zh 表示物理引擎中的网格碰撞器形状。
     */
    class pxMeshColliderShape extends pxColliderShape implements IMeshColliderShape {
        private _limitvertex;
        private _mesh;
        private _convex;
        private _meshScale;
        /**
         * @en Creates a new instance of pxMeshColliderShape.
         * @zh 创建一个新的 pxMeshColliderShape 实例。
         */
        constructor();
        private _getMeshPosition;
        private _getIndices;
        private _createConvexMeshGeometry;
        private _createTrianggleMeshGeometry;
        /**
         * @override
         */
        protected _createShape(): void;
        private _reConfigShape;
        private _setScale;
        /**
         * @en Sets the offset of the collider shape.
         * @param position The new offset position.
         * @zh 设置碰撞器形状的偏移。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Sets the physics mesh from a given mesh.
         * @param value The mesh to use for physics.
         * @zh 从给定的网格设置物理网格。
         * @param value 用于物理的网格。
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         * @en Sets the convex mesh for the collider.
         * @param value The convex mesh to use.
         * @zh 设置碰撞器的凸面网格。
         * @param value 要使用的凸面网格。
         */
        setConvexMesh(value: Mesh): void;
        /**
         * @en Sets the vertex limit for convex mesh generation.
         * @param limit The maximum number of vertices.
         * @zh 设置凸面网格生成的顶点限制。
         * @param limit 最大顶点数。
         */
        setLimitVertex(limit: number): void;
    }
    /**
     * @en Represents a sphere collider shape in the physics engine.
     * @zh 表示物理引擎中的球体碰撞器形状。
     */
    class pxSphereColliderShape extends pxColliderShape implements ISphereColliderShape {
        /**@internal */
        private _radius;
        /**
         * @en Creates a new instance of pxSphereColliderShape.
         * @zh 创建一个新的 pxSphereColliderShape 实例。
         */
        constructor();
        /**
         * @en Sets the radius of the sphere collider.
         * @param radius The new radius value.
         * @zh 设置球体碰撞器的半径。
         * @param radius 新的半径值。
         */
        setRadius(radius: number): void;
        /**
         * @en Sets the offset position of the sphere collider.
         * @param position The new offset position.
         * @zh 设置球体碰撞器的偏移位置。
         * @param position 新的偏移位置。
         */
        setOffset(position: Vector3): void;
        /**
         * @en Destroys the sphere collider shape and releases resources.
         * @zh 销毁球体碰撞器形状并释放资源。
         */
        destroy(): void;
    }
    /**
     * @ignore
     */
    class BrowserAdapter extends EventDispatcher {
        requestFrame: Function;
        webSocketClass: new () => IWebSocket;
        protected _visibilityStateKey: string;
        protected _pixelRatio: number;
        /** @internal */
        _globalErrorCallback: (e: any) => void;
        constructor();
        protected init(): void;
        protected setPlatform(u: string, platform: string): void;
        protected initRequestFrameFunction(): void;
        start(): Promise<void>;
        onInitRender(): void;
        getScreenOrientation(): OrientationType;
        getPixelRatio(): number;
        getClientWidth(): number;
        getClientHeight(): number;
        getVisibility(): boolean;
        requestFullscreen(): void;
        exitFullscreen(): void;
        createElement<K extends keyof HTMLElementTagNameMap>(tagName: K): HTMLElementTagNameMap[K];
        createMainCanvas(): HTMLCanvasElement;
        setCursor(cursor: string): void;
        get supportArrayBufferURL(): boolean;
        createBufferURL(data: ArrayBuffer): string;
        revokeBufferURL(url: string): void;
        getOpenDataContextCanvas(): HTMLCanvasElement;
        postMessageToOpenDataContext(msg: any): void;
        captureGlobalError(callback: (e: any) => void | null): void;
        protected onCaptureGlobalError(enabled: boolean, func: (e: any) => void): void;
        alert(msg: string): void;
        setStyleTransformOrigin(style: CSSStyleDeclaration, value: string): void;
        setStyleTransform(style: CSSStyleDeclaration, value: string): void;
        createWebSocket(): IWebSocket | null;
    }
    /**
     * @ignore
     */
    class DeviceAdapter extends EventDispatcher {
        get supportedLocation(): boolean;
        get supportedGetUserMedia(): boolean;
        getCurrentPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): void;
        watchPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): number;
        clearWatchPosition(id: number): void;
        getUserMedia(constraints: MediaStreamConstraints, successCallback: (stream: MediaStream) => void, errorCallback?: (err: Error) => void): void;
        protected onStartListeningToType(type: string): this;
        protected startListeningDeviceMotion(): void;
        protected startListeningDeviceOrientation(): void;
    }
    /**
     * @ignore
     */
    class FileSystemAdapter {
        /**
         * @en Reads a file.
         * @param path File path.
         * @param encoding If encoding is not specified, the file will be read as binary data. If encoding is specified, the file will be read as a string.
         * @zh 读取文件。
         * @param path 文件路径。
         * @param encoding 如果没有指定编码，则文件将作为二进制数据读取。如果指定了编码，则文件将作为字符串读取。
         */
        readFile(path: string, encoding?: string): Promise<ArrayBuffer | string>;
        /**
         * @en Writes a file. If encoding is not specified, the file will be written as binary data. If encoding is specified, the file will be written as a string.
         * @param path File path.
         * @param data Data to write.
         * @param encoding Encoding type.
         * @zh 写入文件。如果没有指定编码，则文件将作为二进制数据写入。如果指定了编码，则文件将作为字符串写入。
         * @param path 文件路径。
         * @param data 要写入的数据。
         * @param encoding 编码类型。如果没有指定编码，则文件将作为二进制数据写入。如果指定了编码，则文件将作为字符串写入。
         */
        writeFile(path: string, data: ArrayBuffer | string, encoding?: string): Promise<void>;
        /**
         * @en Deletes a file.
         * @param path File path.
         * @zh 删除文件。
         * @param path 文件路径。
         */
        unlink(path: string): Promise<void>;
        /**
         * @en Copies a file from srcPath to destPath.
         * @param srcPath Source file path.
         * @param destPath Destination file path.
         * @zh 复制文件。
         * @param srcPath 源文件路径。
         * @param destPath 目标文件路径。
         */
        copyFile(srcPath: string, destPath: string): Promise<void>;
        /**
         * @en Checks if a file or directory exists.
         * @param path File or directory path.
         * @zh 检查文件或目录是否存在。
         * @param path 文件或目录路径。
         */
        exists(path: string): Promise<boolean>;
        /**
         * @en Gets the size of a file.
         * @param path File path.
         * @zh 获取文件大小。
         * @param path 文件路径。
         */
        getFileSize(path: string): Promise<number>;
        /**
         * @en Creates a directory.
         * @param path Directory path.
         * @param options Options for creating the directory. If recursive is true, creates the directory recursively.
         * @zh 创建目录。
         * @param path 目录路径。
         * @param options 创建目录的选项。如果recursive为true，则递归创建目录。
         */
        mkdir(path: string, options?: {
            recursive?: boolean;
        }): Promise<void>;
        /**
         * @en Deletes a directory.
         * @param path Directory path.
         * @param options Options for deleting the directory. If recursive is true, deletes the directory recursively.
         * @zh 删除目录。
         * @param path 目录路径。
         * @param options 删除目录的选项。如果recursive为true，则递归删除目录。
         */
        rmdir(path: string, options?: {
            recursive?: boolean;
        }): Promise<void>;
        /**
         * @en Reads the contents of a directory.
         * @param path Directory path.
         * @zh 读取目录的内容。
         * @param path 目录路径。
         */
        readdir(path: string): Promise<string[]>;
        /**
         * @en Unzips a zip file.
         * @param zipFilePath Path to the zip file.
         * @param targetPath Path to the target directory where the files will be extracted.
         * @zh 解压缩zip文件。
         * @param zipFilePath zip文件路径。
         * @param targetPath 目标目录路径，文件将被解压到该目录。
         */
        unzip(zipFilePath: string, targetPath: string): Promise<void>;
    }
    /**
     * @ignore
     */
    class FontAdapter {
        loadFont(task: ILoadTask): Promise<{
            family: string;
        } | null>;
        protected loadByFontFace(task: ILoadTask, url: string, fontName: string): Promise<{
            family: string;
        } | null>;
        protected loadByCSS(task: ILoadTask, url: string, fontName: string): Promise<{
            family: string;
        } | null>;
    }
    /**
     * @ignore
     */
    class MediaAdapter {
        audioDataCache: AudioDataCache;
        audioCtx: AudioContext;
        touchToStart: boolean;
        shortAudioClass: new (url: string) => SoundChannel;
        longAudioClass: new (url: string) => SoundChannel;
        videoTextureClass: new () => VideoTexture;
        videoPlayerClass: new () => VideoPlayer;
        protected suspendedMedias: Set<SoundChannel | VideoTexture | VideoPlayer>;
        private _testElement;
        private _firstTouch;
        constructor();
        protected init(): void;
        createSoundChannel(url: string, longAudioUsage?: boolean): SoundChannel;
        createVideoTexture(): VideoTexture;
        createVideoPlayer(): VideoPlayer;
        decodeAudioData(data: ArrayBuffer): Promise<any>;
        resumeUntilGotFocus(media: SoundChannel | VideoTexture | VideoPlayer): void;
        canPlayType(type: string): CanPlayTypeResult;
        protected onGotFocus(): void;
        protected beforeResumeMedias(medias: ReadonlyArray<SoundChannel | VideoTexture | VideoPlayer>): Promise<void>;
    }
    const PlatformAdapterNames: readonly [
        "browser",
        "fs",
        "storage",
        "font",
        "textInput",
        "media",
        "device"
    ];
    interface IPlatformGlobalType {
        [key: string]: any;
    }
    /**
     * @en Platform Adapter Libraries.
     * @zh 平台适配器库。
     */
    class PAL {
        /**
         * @en The Browser Adapter.
         * @zh 浏览器适配器。
         */
        static readonly browser: BrowserAdapter;
        /**
         * @en The TextInput Adapter.
         * @zh 文本输入适配器。
         */
        static readonly textInput: TextInputAdapter;
        /**
         * @en The Media Adapter.
         * @zh 媒体适配器。
         */
        static readonly media: MediaAdapter;
        /**
         * @en The LocalStorage Adapter.
         * @zh 本地存储适配器。
         */
        static readonly storage: StorageAdapter;
        /**
         * @en The Device Adapter.
         * @zh 设备适配器。
         */
        static readonly device: WebDeviceAdapter;
        /**
         * @en The Font Adapter.
         * @zh 字体适配器。
         */
        static readonly font: FontAdapter;
        /**
         * @en The FileSystem Adapter.
         * @zh 文件系统适配器。
         */
        static readonly fs: FileSystemAdapter;
        /**
         * @en The global object built into the platform. For example, wx in WeChat.
         * @zh 平台内置的全局对象。例如微信中的wx。
         */
        static g: IPlatformGlobalType;
        private static _classes;
        /** @internal */
        static __init__(): void;
        /**
         * @en Register a platform adapter.
         * @param name The name of the adapter.
         * @param cls The class of the adapter.
         * @zh 注册一个平台适配器。
         * @param name 适配器的名称。
         * @param cls 适配器的类。
         */
        static register(name: typeof PlatformAdapterNames[number], cls: any): void;
        /**
         * @en Print a warning message if the specified feature is not supported on the current platform.
         * @param name The name of the feature.
         * @zh 打印一条警告消息，说明当前平台不支持指定的功能。
         * @param name 功能的名称。
         */
        static warnIncompatibility(name: string): void;
        /**
         * @en Check if the specified API is available in the global object.
         * @param name The name of the API to check.
         * @returns `true` if the API is available, otherwise `false`.
         * @zh 检查指定的API是否在全局对象中可用。
         * @param name 要检查的API名称。
         * @returns 如果API可用则返回`true`，否则返回`false`
         */
        static hasAPI(name: string): boolean;
        /**
         * @en Check if the specified API is available in the global object.
         * @param obj The object to check against, defaults to the global object.
         * @param name The name of the API to check.
         * @returns `true` if the API is available, otherwise `false`.
         * @zh 检查指定的API是否在全局对象中可用。
         * @param obj 要检查的对象，默认为全局对象。
         * @param name 要检查的API名称。
         * @returns 如果API可用则返回`true`，否则返回`false`
         */
        static hasAPI(obj: any, name: string): boolean;
    }
    /**
     * @ignore
     */
    class StorageAdapter {
        protected _storage: Storage;
        protected _supported: boolean;
        constructor();
        protected checkSupport(): boolean;
        getItem(key: string): string | null;
        setItem(key: string, value: string): void;
        removeItem(key: string): void;
        clear(): void;
        getCount(): number;
    }
    /**
     * @ignore
     */
    class TextInputAdapter {
        readonly target: Input;
        protected _eInput: HTMLInputElement;
        protected _ePassword: HTMLInputElement;
        protected _eTextArea: HTMLTextAreaElement;
        protected _visEle: HTMLInputElement | HTMLTextAreaElement;
        protected _container: HTMLDivElement;
        protected _promptStyleDOM: HTMLElement;
        protected _restrictPattern: RegExp;
        protected _enterEvent: Event;
        protected _lastTransform: {
            x: number;
            y: number;
            width: number;
            height: number;
            scaleX: number;
            scaleY: number;
        };
        protected _beginFlag: number;
        /**
         * If true, the input box will be displayed inline with the canvas.
         * If false, use a pop-up keyboard to enter text.
         */
        protected _editInline: boolean;
        constructor();
        begin(target: Input, fromTouchBegin?: boolean): Promise<void>;
        end(complete?: boolean, switching?: boolean): Promise<void>;
        protected onBegin(): Promise<void>;
        protected onCanShowKeyboard(): Promise<void>;
        protected onEnd(target: Input, complete: boolean, switching: boolean): Promise<void>;
        syncText(): void;
        setText(value: string): void;
        setSelection(startIndex: number, endIndex: number): void;
        private onTouchBegin;
        private onTouchEnd;
        protected setPromptColor(): void;
        protected updateRestrictPattern(): void;
        protected validateText(str: string): string;
        protected showInputElement(): void;
        protected hideInputElement(): void;
        protected updateTargetText(value: string): boolean;
        protected getTargetTransform(): {
            x: number;
            y: number;
            width: number;
            height: number;
            scaleX: number;
            scaleY: number;
        };
        protected syncTransform(): void;
        protected createElements(): void;
        protected initElement(input: HTMLInputElement | HTMLTextAreaElement): void;
        protected processInputting(ev: globalThis.Event): void;
        protected stopEvent(e: any): void;
        protected onKeyDown(e: KeyboardEvent): void;
    }
    /**
     * 前向渲染流程通用类
     */
    class ForwardAddClusterRP {
        pipelineMode: PipelineMode;
        depthPipelineMode: PipelineMode;
        depthNormalPipelineMode: PipelineMode;
        depthTarget: InternalRenderTarget;
        destTarget: InternalRenderTarget;
        camera: Camera;
        cameraCullInfo: CameraCullInfo;
        depthTextureMode: DepthTextureMode;
        depthNormalTarget: InternalRenderTarget;
        beforeForwardCmds: CommandBuffer[];
        beforeSkyboxCmds: CommandBuffer[];
        beforeTransparentCmds: CommandBuffer[];
        skyRenderNode: WebBaseRenderNode;
        clearColor: Color;
        clearFlag: number;
        enableCMD: boolean;
        enableOpaque: boolean;
        enableTransparent: boolean;
        protected _opaqueList: RenderListQueue;
        protected _transparent: RenderListQueue;
        protected _zBufferParams: Vector4;
        protected _defaultNormalDepthColor: Color;
        protected _viewPort: Viewport;
        setViewPort(value: Viewport): void;
        protected _scissor: Vector4;
        setScissor(value: Vector4): void;
        constructor();
        /**
         * 设置相机裁剪信息
         * @param camera
         */
        setCameraCullInfo(camera: Camera): void;
        /**
         * 设置渲染命令（前向渲染之前）
         * @param value
         */
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        /**
         * 设置渲染命令（天空渲染之前）
         * @param value
         */
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        /**
         * 设置渲染命令（透明物体渲染之前）
         * @param value
         */
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        /**
         * 渲染流程（TODO:其他两个pass合并MulTargetRT）
         * @param context
         * @param list
         * @param count
         */
        render(context: IRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * 清除渲染队列
         */
        protected _clearRenderList(): void;
        /**
         * 缓存视口和裁剪
         */
        protected _cacheViewPortAndScissor(): void;
        /**
         * 渲染深度流程
         * @param context
         */
        protected _renderDepthPass(context: IRenderContext3D): void;
        /**
         * 渲染法线深度流程
         * @param context
         */
        protected _renderDepthNormalPass(context: IRenderContext3D): void;
        /**
         * 主渲染流程
         * @param context
         */
        protected _mainPass(context: IRenderContext3D): void;
        /**
         * 渲染不透明贴图流程
         */
        protected _opaqueTexturePass(): void;
    }
    /**
     * 裁剪通用工具类
     */
    class RenderCullUtil {
        /**
         * 相机裁剪
         * @param cameraCullInfo 相机裁剪信息
         * @param list 渲染节点列表
         * @param count 渲染节点数量（为什么不是list.length?）
         * @param opaqueList 不透明队列
         * @param transparent 透明队列
         * @param context 渲染上下文
         */
        static cullByCameraCullInfo(cameraCullInfo: CameraCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, transparent: RenderListQueue, context: IRenderContext3D): void;
        /**
         * 方向光源裁剪
         * @param shadowCullInfo
         * @param list
         * @param count
         * @param opaqueList
         * @param context
         */
        static cullDirectLightShadow(shadowCullInfo: ShadowCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, context: IRenderContext3D): void;
        /**
         * 聚光灯裁剪
         * @param cameraCullInfo
         * @param list
         * @param count
         * @param opaqueList
         * @param context
         */
        static cullSpotShadow(cameraCullInfo: CameraCullInfo, list: WebBaseRenderNode[], count: number, opaqueList: RenderListQueue, context: IRenderContext3D): void;
    }
    /**
     * 渲染节点队列
     */
    class RenderListQueue {
        private _elements;
        get elements(): FastSinglelist<IRenderElement3D>;
        private _quickSort;
        private _isTransparent;
        _batch: IInstanceRenderBatch;
        constructor(isTransParent: boolean);
        /**
         * 添加渲染元素
         * @param renderelement
         */
        addRenderElement(renderelement: IRenderElement3D): void;
        /**
         * 合并渲染队列
         */
        private _batchQueue;
        /**
         * 渲染队列
         * @param context
         */
        renderQueue(context: IRenderContext3D): void;
        /**
         * 清空队列
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * 渲染流程通用工具类
     */
    class RenderPassUtil {
        static contextViewPortCache: Viewport;
        static contextScissorCache: Vector4;
        /**
         * 执行渲染命令
         * @param cmds
         * @param context
         */
        static renderCmd(cmds: CommandBuffer[], context: IRenderContext3D): void;
        /**
         * 恢复渲染上下文
         * @param context
         * @param renderTarget
         */
        static recoverRenderContext3D(context: IRenderContext3D, renderTarget: InternalRenderTarget): void;
    }
    /**
     * 渲染节点快速排序
     */
    class RenderQuickSort {
        private elementArray;
        private isTransparent;
        /**
         * 快速排序
         * @param elements
         * @param isTransparent
         * @param left
         * @param right
         */
        sort(elements: FastSinglelist<IRenderElement3D>, isTransparent: boolean, left: number, right: number): void;
        /**
         * @internal
         */
        private _quickSort;
        /**
         * @internal
         */
        private _partitionRenderObject;
        /**
         * @internal
         */
        private _compare;
    }
    interface I2DRenderPassFactory {
        createRenderElement2D(): IRenderElement2D;
        createPrimitiveRenderElement2D(): IPrimitiveRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
        createBlit2DQuadCMDData(): Blit2DQuadCMD;
        createDraw2DElementCMDData(): Draw2DElementCMD;
        createSetRendertarget2DCMD(): SetRendertarget2DCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createRender2DPass(): IRender2DPass;
        createRenderStruct2D(): IRenderStruct2D;
        createRender2DPassManager(): IRender2DPassManager;
        createGraphic2DBufferBlock(): IGraphics2DBufferBlock;
        createGraphic2DVertexBlock(): IGraphics2DVertexBlock;
        create2D2DPrimitiveDataHandle(): I2DPrimitiveDataHandle;
        create2DBaseRenderDataHandle(): I2DBaseRenderDataHandle;
        createMesh2DRenderDataHandle(): IMesh2DRenderDataHandle;
        create2DGlobalRenderDataHandle(): I2DGlobalRenderData;
        createSpineRenderDataHandle(): ISpineRenderDataHandle;
        create2DGraphicVertexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementOffset: number, elementSize: number, stride: number): I2DGraphicVertexDataView;
        create2DGraphicIndexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementSize: number): I2DGraphicIndexDataView;
        create2DGraphicVertexBuffer(): I2DGraphicWholeBuffer;
        create2DGraphicIndexBuffer(): I2DGraphicWholeBuffer;
    }
    interface IRender2DCMD extends IRenderCMD {
        apply(context: IRenderContext2D): void;
    }
    class SetRendertarget2DCMD implements IRender2DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearColor: boolean;
        protected _clearColorValue: Color;
        protected _invertY: boolean;
        size: Vector2;
        /**
         * @en Flip Y Rendering
         * @zh 翻转Y轴渲染
         */
        get invertY(): boolean;
        set invertY(value: boolean);
        /**
         * @en clear rt color value
         * @zh RT清理颜色
         */
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        /**
         * @en set render target
         * @zh 设置渲染目标RT
         */
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        /**
         * @en Clean rt or not
         * @zh 是否清理rt
         */
        get clearColor(): boolean;
        set clearColor(value: boolean);
        apply(context: IRenderContext2D): void;
    }
    class Draw2DElementCMD implements IRender2DCMD {
        /**
        * @en render cmd type
        * @zh 渲染指令类型
        */
        type: RenderCMDType;
        setRenderelements(value: IRenderElement2D[]): void;
        apply(context: IRenderContext2D): void;
    }
    class Blit2DQuadCMD implements IRender2DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _dest: InternalRenderTarget;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _offsetScale: Vector4;
        protected _element: IRenderElement2D;
        /**
         * @en render element
         * @zh 渲染元素
         */
        get element(): IRenderElement2D;
        set element(value: IRenderElement2D);
        /**
         * @en render dest
         * @zh 渲染目标
         */
        get dest(): InternalRenderTarget;
        set dest(value: InternalRenderTarget);
        /**
         * @en copy Texture
         * @zh 拷贝纹理
         */
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        apply(context: IRenderContext2D): void;
    }
    /**
     * @blueprintIgnore
     */
    interface IRenderContext2D {
        invertY: boolean;
        pipelineMode: string;
        passData: ShaderData;
        setRenderTarget(value: InternalRenderTarget, clear: boolean, clearColor: Color): void;
        getRenderTarget(): InternalRenderTarget;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: IRenderElement2D): void;
        drawRenderElementList(list: SingletonList<IRenderElement2D>): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IRenderElement2D {
        type: number;
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        value2DShaderData: ShaderData;
        globalShaderData: ShaderData;
        subShader: SubShader;
        renderStateIsBySprite: boolean;
        nodeCommonMap: Array<string>;
        owner: IRenderStruct2D;
        destroy(): void;
        /** 在合批过程中需要收集 */
        _index?: number;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IPrimitiveRenderElement2D extends IRenderElement2D {
        primitiveShaderData: ShaderData;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IRender3DProcess {
        render3DManager: ISceneRenderManager;
        fowardRender(context: IRenderContext3D, camera: Camera): void;
        destroy(): void;
    }
    type PipelineMode = "Forward" | "ShadowCaster" | "DepthNormal" | string;
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IRenderContext3D {
        globalShaderData: ShaderData;
        sceneData: ShaderData;
        sceneModuleData: ISceneNodeData;
        cameraModuleData: ICameraNodeData;
        cameraData: ShaderData;
        sceneUpdataMask: number;
        cameraUpdateMask: number;
        pipelineMode: PipelineMode;
        invertY: boolean;
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, clolor: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<IRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IRenderElement3D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        materialId: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        destroy(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IInstanceRenderBatch {
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IInstanceRenderElement3D extends IRenderElement3D {
        instanceElementList: SingletonList<IRenderElement3D>;
        setGeometry(geometry: IRenderGeometryElement): void;
        clearRenderData(): void;
        recover(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface ISkinRenderElement3D {
        skinnedData: Float32Array[];
    }
    interface I3DRenderPassFactory {
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createRenderElement3D(): IRenderElement3D;
        createInstanceBatch(): IInstanceRenderBatch;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createSkinRenderElement(): ISkinRenderElement3D;
        createSceneRenderManager(): ISceneRenderManager;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createComputeCommandAppatchCMD?(): ComputeCommandAppatchCMD;
    }
    interface IRender3DCMD extends IRenderCMD {
        apply(context: IRenderContext3D): void;
    }
    class DrawNodeCMDData implements IRender3DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _node: IBaseRenderNode;
        protected _destShaderData: ShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        /**
         * @en render node
         * @zh 渲染节点
         */
        get node(): IBaseRenderNode;
        set node(value: IBaseRenderNode);
        get destShaderData(): ShaderData;
        set destShaderData(value: ShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        apply(context: IRenderContext3D): void;
    }
    class BlitQuadCMDData implements IRender3DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _dest: InternalRenderTarget;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        protected _source: InternalTexture;
        protected _offsetScale: Vector4;
        protected _element: IRenderElement3D;
        get element(): IRenderElement3D;
        set element(value: IRenderElement3D);
        get dest(): InternalRenderTarget;
        set dest(value: InternalRenderTarget);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        apply(context: IRenderContext3D): void;
    }
    class DrawElementCMDData implements IRender3DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        setRenderelements(value: IRenderElement3D[]): void;
        apply(context: IRenderContext3D): void;
    }
    class SetViewportCMD implements IRender3DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        apply(context: IRenderContext3D): void;
    }
    class SetRenderTargetCMD implements IRender3DCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        protected _clearColorValue: Color;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        apply(context: IRenderContext3D): void;
    }
    /**
     * @deprecated
     */
    interface IRenderEngine3DOBJFactory {
        /**
         * @deprecated
         */
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead: boolean): VertexBuffer3D;
        /**
         * @deprecated
         */
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage: BufferUsage, canRead: boolean): IndexBuffer3D;
    }
    /**
     * 可替换的SceneManager
     */
    interface ISceneRenderManager {
        list: FastSinglelist<BaseRender>;
        /**
         * add one BaseRender
         * @param object
         */
        addRenderObject(object: BaseRender): void;
        /**
         * remove RenderObject
         * @param object
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * 移除某个动态的渲染节点
         * @param object
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * 增加运动物体
         * @param object
         */
        addMotionObject(object: BaseRender): void;
        /**
         * 更新运动物体
         */
        updateMotionObjects(): void;
        /**
         * release Manager Node
         */
        destroy(): void;
    }
    /**
     * @deprecated
     */
    class LengencyRenderEngine3DFactory implements IRenderEngine3DOBJFactory {
        /**
         * @deprecated use new VertexBuffer3D
         * @param byteLength
         * @param bufferUsage
         * @param canRead
         * @returns
         */
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean): VertexBuffer3D;
        /**
         * @deprecated use new IndexBuffer3D
         * @param indexType
         * @param indexCount
         * @param bufferUsage
         * @param canRead
         * @returns
         */
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean): IndexBuffer3D;
    }
    type UniformProperty = {
        id: number;
        propertyName: string;
        uniformtype: ShaderDataType;
        arrayLength: number;
    };
    /**
     * @blueprintIgnore
     */
    class CommandUniformMap {
        constructor(stateName: string);
        /**
         * 增加一个Uniform参数
         * @param propertyID
         * @param propertyKey
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /**
         * 增加一个UniformArray参数
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number): void;
    }
    class ComputeCommandBuffer {
        private _context;
        constructor();
        /**
         * @internal
         */
        getResource(): IComputeContext;
        /**
            * 清理所有指令
            */
        clearCMDs(): void;
        /**
         * @en Adds a command to run a ComputeShader.
         * @param computeshader The ComputeShader instance to run.
         * @param kernel The name of the kernel in the ComputeShader.
         * @param shaderDefine The shader define data.
         * @param datas The list of ShaderData to pass to the shader.
         * @param dispatchParams The dispatch parameters, typically a Vector3 representing the workgroup size
         * @zh 添加运行ComputeShader的命令
         * @param computeshader 计算着色器实例
         * @param kernel 计算着色器的内核名称
         * @param shaderDefine 着色器定义数据
         * @param datas 需要传递给着色器的数据列表
         * @param dispatchParams 调度参数，通常是一个Vector3，表示计算的工作组大小。
         */
        addDispatchCommand(computeshader: ComputeShader, kernel: string, shaderDefine: IDefineDatas, datas: ShaderData[], dispatchParams: Vector3): void;
        /**
         * 添加修改ShaderData值的命令
         * @param shaderData 要修改的ShaderData
         * @param propertyID 属性名称
         * @param shaderDataType ShaderData的类型
         * @param value 要设置的值
         */
        addSetShaderDataCommand(shaderData: ShaderData, propertyID: number, shaderDataType: ShaderDataType, value: ShaderDataItem): void;
        /**
         * 添加Buffer拷贝到Buffer的命令
         * @param src 源缓冲区
         * @param dest 目标缓冲区
         * @param sourceOffset 源偏移量（字节）
         * @param destinationOffset 目标偏移量（字节）
         * @param size 拷贝大小（字节）
         */
        addBufferToBufferCommand(src: IDeviceBuffer | IVertexBuffer | IIndexBuffer, dest: IDeviceBuffer | IVertexBuffer | IIndexBuffer, sourceOffset?: number, destinationOffset?: number, size?: number): void;
        /**
            * 清理buffer数据
            * @param dest 清理数据的buffer
            * @param destoffset 位置
            * @param destCount 长度
            */
        addClearBufferCommand(dest: IDeviceBuffer, destoffset: number, destCount: number): void;
        /**
         * 添加Buffer拷贝到Texture的命令
         * @param src 源缓冲区
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addBufferToTextureCommand(src: IDeviceBuffer | IVertexBuffer, srcTextureInfo: any, destTextureInfo: any, copySize: any): void;
        /**
         * 添加Texture拷贝到Buffer的命令
         * @param srcTextureInfo 源纹理信息
         * @param rc 目标缓冲区
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addTextureToBufferCommand(srcTextureInfo: any, rc: IDeviceBuffer | IVertexBuffer, destTextureInfo: any, copySize: any): void;
        /**
         * 添加Texture拷贝到Texture的命令
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addTextureToTextureCommand(srcTextureInfo: CopyTextureInfo, destTextureInfo: CopyTextureInfo, copySize: any): void;
        /**
         * 执行所有命令
         */
        executeCMDs(): void;
        /**
         * 销毁计算上下文，清空所有命令
         */
        destroy(): void;
    }
    class ComputeShader {
        /**@internal */
        static _CompileShader: Record<string, ComputeShader>;
        static createComputeShader(name: string, code: string, other: any): ComputeShader;
        /** @internal */
        protected _cacheSharders: any;
        /** @internal */
        protected _cacheShaderHierarchy: number;
        code: string;
        name: string;
        other: any;
        constructor(name: string, code: string, other: any);
        private setCacheShader;
        getCacheShader(compileDefine: IDefineDatas): IComputeShader;
        /**
      * @internal
      */
        _resizeCacheShaderMap(cacheMap: any, hierarchy: number, resizeLength: number): void;
    }
    interface IGPUBuffer {
        getNativeBuffer(): any;
    }
    /**
     * 计算命令枚举
     */
    enum ComputeCommandType {
        DispatchCompute = 0,
        SetRenderData = 1,
        ClearBuffer = 2,
        CopyBufferToBuffer = 3,
        copyBufferToTexture = 4,
        copyTextureToBuffer = 5,
        copyTextureToTexture = 6
    }
    /**
     * 内存操作枚举
     */
    enum EComputeCMDMemoryOperate {
        ClearBuffer = 0,
        BufferToBuffer = 1,
        BufferToTexture = 2,
        TextureToBuffer = 3,
        TextureToTexture = 4
    }
    interface IComputeCMD_Dispatch {
        shader: IComputeShader;
        Kernel: string;
        shaderData: ShaderData[];
        dispatchParams: Vector3;
    }
    class CopyTextureInfo {
        texture: InternalTexture;
        mipLevel: number;
        origin: Vector3;
    }
    interface IComputeContext {
        /**
         * 清理所有指令
         */
        clearCMDs(): void;
        /**
         * 添加运行ComputeShader的命令
         * @param cmd 计算着色器调度命令
         */
        addDispatchCommand(cmd: IComputeCMD_Dispatch): void;
        /**
         * 添加修改ShaderData值的命令
         * @param shaderData 要修改的ShaderData
         * @param propertyID 属性名称
         * @param shaderDataType ShaderData的类型
         * @param value 要设置的值
         */
        addSetShaderDataCommand(shaderData: ShaderData, propertyID: number, shaderDataType: ShaderDataType, value: ShaderDataItem): void;
        /**
         * 添加Buffer拷贝到Buffer的命令
         * @param src 源缓冲区
         * @param dest 目标缓冲区
         * @param sourceOffset 源偏移量（字节）
         * @param destinationOffset 目标偏移量（字节）
         * @param size 拷贝大小（字节）
         */
        addBufferToBufferCommand(src: IGPUBuffer, dest: IGPUBuffer, sourceOffset?: number, destinationOffset?: number, size?: number): void;
        /**
         * 添加Buffer拷贝到Texture的命令
         * @param src 源缓冲区
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addBufferToTextureCommand(src: IGPUBuffer, srcTextureInfo: any, destTextureInfo: any, copySize: any): void;
        /**
         * 添加Texture拷贝到Buffer的命令
         * @param srcTextureInfo 源纹理信息
         * @param dest 目标缓冲区
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addTextureToBufferCommand(srcTextureInfo: any, dest: IGPUBuffer, destTextureInfo: any, copySize: any): void;
        /**
         * 添加Texture拷贝到Texture的命令
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 拷贝大小
         */
        addTextureToTextureCommand(srcTextureInfo: CopyTextureInfo, destTextureInfo: CopyTextureInfo, copySize: Iterable<number>): void;
        /**
         * 清理buffer数据
         * @param dest 清理数据的buffer
         * @param destoffset 位置
         * @param destCount 长度
         */
        addClearBufferCommand(dest: IDeviceBuffer, destoffset: number, destCount: number): void;
        /**
         * 执行所有命令
         */
        executeCMDs(): void;
        /**
         * 销毁计算上下文，清空所有命令
         */
        destroy(): void;
    }
    interface ComputeShaderProcessInfo {
        name: string;
        code: string;
        other: any;
        defineData: IDefineDatas;
    }
    interface IComputeShader {
        name: string;
        HasKernel(kernel: string): boolean;
        compilete: boolean;
    }
    interface IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer | null): void;
        destroy(): void;
    }
    enum EDeviceBufferUsage {
        MAP_READ = 1,
        MAP_WRITE = 2,
        COPY_SRC = 4,
        COPY_DST = 8,
        STORAGE = 16,
        INDIRECT = 32
    }
    /**
     * 存储缓冲区接口,在GPU中创建各种各样的Buffer
     * 用于在GPU上存储和访问大量数据，主要用于计算着色器,间接渲染数据
     * 间接渲染数据中如果是drawIndirect  参数分别为vertexCount,instanceCount,firstVertex,firstInstance
     *  间接渲染数据中如果是drawIndexIndirect indexCount，instanceCount，firstIndex
     * @blueprintIgnore
     */
    interface IDeviceBuffer {
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        copyToBuffer(buffer: IVertexBuffer | IDeviceBuffer, sourceOffset: number, destoffset: number, bytelength: number): void;
        copyToTexture(): void;
        readData(dest: ArrayBuffer, destOffset: number, srcOffset: number, byteLength: number): Promise<void>;
        destroy(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IIndexBuffer {
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        indexType: IndexFormat;
        indexCount: number;
    }
    interface InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _texturesResolve?: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        dispose(): void;
    }
    /**
     * 内部纹理对象
     */
    interface InternalTexture {
        /**
         * gpu texture object
         */
        resource: any;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        filterMode: FilterMode;
        wrapU: WrapMode;
        wrapV: WrapMode;
        wrapW: WrapMode;
        anisoLevel: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        compareMode: TextureCompareMode;
        /**bytelength */
        gpuMemory: number;
        /**
         * 是否使用 sRGB格式 加载图片数据
         */
        useSRGBLoad: boolean;
        /**
         * gamma 矫正值
         */
        gammaCorrection: number;
        dispose(): void;
    }
    enum RenderCMDType {
        DrawNode = 0,
        DrawElement = 1,
        Blit = 2,
        ChangeData = 3,
        ChangeShaderDefine = 4,
        ChangeViewPort = 5,
        ChangeRenderTarget = 6,
        ComputeCommandAppatch = 7
    }
    interface IRenderCMD {
        type: RenderCMDType;
        apply(context: any): void;
    }
    class SetRenderDataCMD implements IRenderCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _value: ShaderDataItem;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: ShaderData;
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): ShaderData;
        set dest(value: ShaderData);
        apply(context: any): void;
    }
    class SetShaderDefineCMD implements IRenderCMD {
        /**
         * @en render cmd type
         * @zh 渲染指令类型
         */
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: ShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): ShaderData;
        set dest(value: ShaderData);
        get add(): boolean;
        set add(value: boolean);
        apply(context: any): void;
    }
    class ComputeCommandAppatchCMD implements IRenderCMD {
        type: RenderCMDType;
        computeContext: IComputeContext;
        apply(context: any): void;
    }
    interface IRenderDeviceFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: HTMLCanvas): Promise<void>;
        createGlobalUniformMap(blockName: string): CommandUniformMap;
        createShaderData(ownerResource?: Resource): ShaderData;
        createComputeShader?(info: ComputeShaderProcessInfo): IComputeShader;
        createComputeContext?(): IComputeContext;
        createDeviceBuffer?(type: EDeviceBufferUsage): IDeviceBuffer;
    }
    interface IRenderEngine {
        _context: any;
        /**@internal */
        _isShaderDebugMode: boolean;
        _framePassCount: number;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        initRenderEngine(canvas: HTMLCanvasElement): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        resizeOffScreen(width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getDefineByName(name: string): ShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        startFrame(): void;
        endFrame(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IRenderGeometryElement {
        bufferState: IBufferState;
        mode: MeshTopology;
        drawType: DrawType;
        instanceCount: number;
        indexFormat: IndexFormat;
        /**
         * 设置顶点的渲染初始开始位置和长度，参数会累加。此参数只在DrawArray为DrawElement和 DrawArrayInstance中有用
         * @param first
         * @param count
         */
        setDrawArrayParams(first: number, count: number): void;
        /**
         * 设置索引渲染数量和偏移，参数会累加，此参数只在DrawType为DrawElement和DrawElementInstance中有用
         * @param count
         * @param offset
         */
        setDrawElemenParams(count: number, offset: number): void;
        /**
         * 设置间接渲染的Buffer和偏移,此参数只在DrawType为DrawArrayIndirect和DrawElementIndirect中有用
         * @param buffer
         * @param offset
         */
        setIndirectDrawBuffer?(buffer: IDeviceBuffer, offset: number): void;
        clearRenderParams(): void;
        destroy(): void;
        /**
         * @en get render params Array
         * @zh 获取渲染参数队列
         */
        getDrawDataParams(out: FastSinglelist<number>): void;
    }
    /** @blueprintIgnore */
    interface IRenderTarget {
        width: number;
        height: number;
        _renderTarget: InternalRenderTarget;
        _isCameraTarget: boolean;
        isCube: boolean;
        samples: number;
        generateMipmap: boolean;
        depthStencilTexture: BaseTexture | null;
    }
    /**
     * @blueprintIgnore
     */
    interface IShaderInstance {
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        _disposeResource(): void;
        _serializeShader(): ArrayBuffer;
        _deserialize(buffer: ArrayBuffer): boolean;
    }
    interface ITextureContext {
        needBitmap: boolean;
        /**
         * 为 Texture 创建 InternalTexture
         * @param width
         * @param height
         * @param format
         * @param generateMipmap
         * @param sRGB
         * @returns
         */
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: InternalTexture, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: InternalTexture): void;
        setTextureSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: InternalTexture, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: InternalTexture, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: InternalTexture, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTargetInternal(width: number, height: number, format: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number, storage: boolean): InternalRenderTarget;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetDepthTexture(renderTarget: InternalRenderTarget, dimension: TextureDimension, width: number, height: number): InternalTexture;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         */
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IVertexBuffer {
        vertexDeclaration: VertexDeclaration;
        instanceBuffer: boolean;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    enum ShaderDataType {
        None = 0,
        Int = 1,
        Bool = 2,
        Float = 3,
        Vector2 = 4,
        Vector3 = 5,
        Vector4 = 6,
        Color = 7,
        Matrix4x4 = 8,
        Buffer = 9,
        Matrix3x3 = 10,
        ReadOnlyDeviceBuffer = 11,
        DeviceBuffer = 12,
        StorageTexture2D = 13,
        Texture2D = 14,
        Texture3D = 15,
        TextureCube = 16,
        Texture2DArray = 17
    }
    type ShaderDataItem = number | boolean | Vector2 | Vector3 | Vector4 | Color | Matrix4x4 | BaseTexture | Float32Array | Matrix3x3 | IDeviceBuffer;
    function isUboBufferShaderType(type: ShaderDataType): boolean;
    function checkShaderDataValueLegal(value: any, shaderType: ShaderDataType): boolean;
    function ShaderDataDefaultValue(type: ShaderDataType): false | Readonly<Vector2> | 0 | Readonly<Matrix3x3> | Readonly<Vector3> | Readonly<Matrix4x4> | Readonly<Vector4> | Readonly<Color>;
    /**
     * 着色器数据类。
     */
    class ShaderData implements IClone {
        /**@internal */
        readonly _ownerResource: Resource;
        /**
         * @internal
         */
        constructor(ownerResource?: Resource);
        getDefineData(): IDefineDatas;
        /**
         * @internal
         */
        getData(): any;
        /**
         * 增加Shader宏定义。
         * @param define 宏定义。
         */
        addDefine(define: ShaderDefine): void;
        addDefines(define: IDefineDatas): void;
        /**
         * 移除Shader宏定义。
         * @param define 宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         * @param define 宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 清空数据 与 宏定义
         */
        clearData(): void;
        /**
         * 获取布尔。
         * @param index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param index shader索引。
         * @param value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param index shader索引。
         * @param value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param index shader索引。
         * @param value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param index shader索引。
         * @param value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param index shader索引。
         * @param value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param index shader索引。
         * @param value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param index shader索引。
         * @param value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param index shader索引。
         * @param value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        setDeviceBuffer(index: number, value: IDeviceBuffer): void;
        getStorageBuffer(index: number): IDeviceBuffer;
        /**
         * 设置纹理。
         * @param index shader索引。
         * @param value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        setShaderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem | Quaternion): void;
        getShaderData(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @private
         */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 克隆。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: ShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): ShaderData;
        destroy(): void;
    }
    interface IUniformBufferUser {
        needUpload: boolean;
        bufferBlock: UniformBufferBlock;
        bufferAlone: UniformBufferAlone;
        manager: UniformBufferManager;
        offset: number;
        notifyGPUBufferChange(info?: string): void;
        updateOver(): void;
    }
    /**
     * 单独的UniformBuffer
     */
    class UniformBufferAlone {
        private _destroyed;
        private _manager;
        buffer: any;
        data: ArrayBuffer;
        uploadNum: number;
        user: IUniformBufferUser;
        protected _size: number;
        protected _alignedSize: number;
        constructor(size: number, manager: UniformBufferManager, user: IUniformBufferUser);
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（小内存块）
     */
    class UniformBufferBlock {
        private static _idCounter;
        private _destroyed;
        /**
         * @internal
         */
        _id: number;
        cluster: UniformBufferCluster;
        index: number;
        offset: number;
        size: number;
        protected _alignedSize: number;
        uploadNum: number;
        moved: boolean;
        user: IUniformBufferUser;
        constructor(cluster: UniformBufferCluster, index: number, size: number, alignedSize: number, user: IUniformBufferUser);
        /**
         * 标记块需要上传
         */
        needUpload(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    /**
     * Uniform内存块（大内存块）
     */
    class UniformBufferCluster {
        static _idCounter: number;
        /**
         * @internal
         */
        _inManagerUpdateArray: boolean;
        /**
         * @internal
         */
        _sn: number;
        /**
         * @internal
         */
        _id: number;
        protected _blockNum: number;
        protected _move: Uint8Array;
        protected _destroyed: boolean;
        protected _totalSize: number;
        protected _blocks: UniformBufferBlock[];
        protected _needUpload: Array<boolean>;
        protected _holeNum: number;
        /**
         * @internal
         */
        _blockSize: number;
        private _expand;
        buffer: any;
        data: ArrayBuffer;
        manager: UniformBufferManager;
        constructor(blockSize: number, blockNum: number, manager: UniformBufferManager);
        /**
         * 小内存块使用量
         */
        get usedNum(): number;
        /**
         * 扩展GPU缓冲区
         */
        protected _expandBuffer(): boolean;
        /**
         * 移动小内存块，后面的块向前移动，填补指定的内存空洞
         * @param index
         */
        protected _moveBlock(index: number): boolean;
        /**
         * 创建小内存块对象
         * @param index
         * @param size
         * @param alignedSize
         * @param user
         */
        protected _createBufferBlock(index: number, size: number, alignedSize: number, user: IUniformBufferUser): UniformBufferBlock;
        /**
         * 获取小内存块
         * @param size 需求尺寸
         * @param user 使用者
         */
        getBlock(size: number, user: IUniformBufferUser): UniformBufferBlock;
        /**
         * 释放小内存块
         */
        freeBlock(bb: UniformBufferBlock): boolean;
        /**
         * 将数据上传到GPU内存，合并相邻块，尽可能减少上传次数
         */
        upload(): void;
        /**
         * 标记块需要上传
         * @param index
         */
        _addUploadBlock(index: number): void;
        /**
         * 优化小内存块顺序，上传频繁的块放前面
         */
        optimize(): boolean;
        /**
         * 移除空洞，使小内存块连续
         */
        removeHole(): boolean;
        /**
         * 清理，释放所有小内存块，回到内存未占用状态
         * @param blockNum 保留多少小块
         */
        clear(blockNum?: number): void;
        /**
         * 获取一个空闲块，如果空间不够，扩大内存块
         */
        private _getBlockWithExpand;
        /**
         * 销毁
         */
        destroy(): boolean;
    }
    type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
    type TypedArrayConstructor = Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
    /**
     * 向上圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundUp(n: number, align: number): number;
    /**
     * 向下圆整到align的整数倍
     * @param n
     * @param align
     */
    function roundDown(n: number, align: number): number;
    /**
     * Uniform内存块管理
     */
    class UniformBufferManager {
        private _clustersAll;
        private _clustersCur;
        private _destroyed;
        private _needUpdateClusters;
        private _removeHoleArray;
        private _optimizeBufferPosArray;
        _useBigBuffer: boolean;
        byteAlign: number;
        clusterMaxBlock: number;
        uploadThreshold: number;
        removeHoleThreshold: number;
        aloneBuffers: UniformBufferAlone[];
        constructor(useBigBuffer: boolean);
        /**
         * 创建大内存块对象
         * @param size 小内存块尺寸
         * @param blockNum 小内存块初始容量
         * @param manager 管理器
         */
        protected _createBufferCluster(size: number, blockNum: number): UniformBufferCluster;
        /**
         * 添加大内存块
         * @param size 小内存块尺寸
         * @param blockNum 小内存块初始容量
         */
        private _addCluster;
        /**
         * 开始一帧
         */
        startFrame(): void;
        /**
         * 结束一帧
         */
        endFrame(): void;
        /**
         * 获取单独的UniformBuffer
         * @param size
         * @param name
         */
        getBufferAlone(size: number, name?: string): any;
        /**
         * 删除大内存块
         * @param size
         * @param sn
         */
        removeCluster(size: number, sn: number): void;
        /**
         * 获取小内存块
         * @param size
         * @param user
         */
        getBlock(size: number, user: IUniformBufferUser): UniformBufferBlock;
        /**
         * 释放小内存块
         * @param bb
         */
        freeBlock(bb: UniformBufferBlock): boolean;
        /**
         * 上传数据
         */
        upload(): void;
        _addUpdateArray(cluster: UniformBufferCluster): void;
        _addRemoveHoleCluster(cluster: UniformBufferCluster): void;
        _addOptimizeBufferPos(cluster: UniformBufferCluster): void;
        /**
         * 清理所有内存
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
        /**
         * 创建GPU内存对象
         * @param size 字节长度
         * @param name 名称
         */
        createGPUBuffer(size: number, name?: string, data?: ArrayBuffer): any;
        /**
         * 将数据写入GPU内存
         * @param buffer GPU内存对象
         * @param data CPU数据对象
         * @param offset 数据在大内存中的偏移量（字节）
         * @param size 写入的数据长度（字节）
         */
        writeBuffer(buffer: any, data: ArrayBuffer, offset: number, size: number): void;
        /**
         * 统计GPU内存使用量
         * @param bytes 字节
         */
        statisGPUMemory(bytes: number): void;
    }
    type ItemType = {
        name: string;
        view: TypedArray;
        type: string;
        align: number;
        size: number;
        elements: number;
        count: number;
    };
    /**
     * UniformBuffer使用者
     */
    class UniformBufferUser implements IUniformBufferUser {
        name: string;
        protected _strId: string;
        protected _size: number;
        protected _items: Map<number, ItemType>;
        protected _itemNum: number;
        private destroyed;
        needUpload: boolean;
        bufferBlock: UniformBufferBlock;
        bufferAlone: UniformBufferAlone;
        manager: UniformBufferManager;
        data: ShaderData;
        offset: number;
        constructor(name: string, size: number, manager: UniformBufferManager, data: ShaderData);
        /**
         * 创建独立内存对象
         * @param size
         * @param manager
         */
        protected _createBufferAlone(size: number, manager: UniformBufferManager): UniformBufferAlone;
        updateOver(): void;
        /**
         * 通知GPUBuffer改变
         */
        notifyGPUBufferChange(): void;
        /**
         * 清除GPUBuffer绑定
         */
        clearGPUBufferBind(): void;
        /**
         * 添加uniform字段
         * @param id
         * @param name
         * @param type
         * @param offset
         * @param align
         * @param size
         * @param elements
         * @param count
         */
        addUniform(id: number, name: string, type: string, offset: number, align: number, size: number, elements: number, count: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setUniformData(id: number, data: any): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBool(id: number, data: boolean): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBoolArray(id: number, data: boolean[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setInt(id: number, data: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setIntArray(id: number, data: number[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setFloat(id: number, data: number): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setFloatArray(id: number, data: number[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector2(id: number, data: Vector2): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector2Array(id: number, data: Vector2[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector3(id: number, data: Vector3): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector3Array(id: number, data: Vector3[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector4(id: number, data: Vector4): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setVector4Array(id: number, data: Vector4[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix3x3(id: number, data: Matrix3x3): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix3x3Array(id: number, data: Matrix3x3[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix4x4(id: number, data: Matrix4x4): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setMatrix4x4Array(id: number, data: Matrix4x4[]): void;
        /**
         * 设置uniform数据
         * @param id
         * @param data
         */
        setBuffer(id: number, data: Float32Array): void;
        /**
         * 获取uniformItem
         * @param id
         */
        getUniform(id: number): ItemType;
        /**
         * 是否存在指定的uniform
         * @param id
         */
        hasUniform(id: number): boolean;
        /**
         * 根据strId判断是否命中
         * @param strId
         */
        isMe(strId: string): boolean;
        /**
         * 上传数据
         */
        upload(): void;
        /**
         * 清除所有uniform
         */
        clear(): void;
        /**
         * 销毁
         */
        destroy(): boolean;
        /**
         * 获取一个unifromItem
         * @param name
         * @param tac
         * @param type
         * @param offset
         * @param align
         * @param size
         * @param elements
         * @param count
         */
        protected _getUniformItem(name: string, tac: TypedArrayConstructor, type: string, offset: number, align: number, size: number, elements: number, count: number): {
            name: string;
            view: TypedArray;
            type: string;
            align: number;
            size: number;
            elements: number;
            count: number;
        };
        /**
         * 根据type获取TypeArray类型
         * @param type
         */
        protected static _typeArray(type: string): Float32ArrayConstructor | Int32ArrayConstructor;
    }
    class NoRender2DProcess implements I2DRenderPassFactory {
        createGraphic2DBufferBlock(): IGraphics2DBufferBlock;
        createGraphic2DVertexBlock(): IGraphics2DVertexBlock;
        create2DGraphicVertexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementOffset: number, elementSize: number, stride: number): I2DGraphicVertexDataView;
        create2DGraphicIndexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementSize: number): I2DGraphicIndexDataView;
        create2DGraphicIndexBuffer(): I2DGraphicWholeBuffer;
        create2DGraphicVertexBuffer(): I2DGraphicWholeBuffer;
        createRender2DPassManager(): IRender2DPassManager;
        create2DGlobalRenderDataHandle(): I2DGlobalRenderData;
        createSpineRenderDataHandle(): ISpineRenderDataHandle;
        createRender2DPass(): IRender2DPass;
        createRenderStruct2D(): IRenderStruct2D;
        createRender2DDataHandle(): IRender2DDataHandle;
        create2D2DPrimitiveDataHandle(): I2DPrimitiveDataHandle;
        create2DBaseRenderDataHandle(): I2DBaseRenderDataHandle;
        createMesh2DRenderDataHandle(): IMesh2DRenderDataHandle;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createBlit2DQuadCMDData(): Blit2DQuadCMD;
        createDraw2DElementCMDData(): Draw2DElementCMD;
        createSetRendertarget2DCMD(): SetRendertarget2DCMD;
        createRenderElement2D(): IRenderElement2D;
        createPrimitiveRenderElement2D(): IPrimitiveRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
    }
    class NoRenderElement2D implements IRenderElement2D {
        type: number;
        owner: IRenderStruct2D;
        nodeCommonMap: string[];
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        value2DShaderData: ShaderData;
        primitiveShaderData: ShaderData;
        subShader: SubShader;
        renderStateIsBySprite: boolean;
        globalShaderData: ShaderData;
        destroy(): void;
    }
    class NoRenderContext2D implements IRenderContext2D {
        passData: ShaderData;
        getRenderTarget(): InternalRenderTarget;
        sceneData: ShaderData;
        invertY: boolean;
        pipelineMode: string;
        setRenderTarget(value: InternalRenderTarget, clear: boolean, clearColor: Color): void;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: IRenderElement2D): void;
        drawRenderElementList(list: SingletonList<IRenderElement2D>): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    class NoRenderBlit2DquadCMD extends Blit2DQuadCMD {
        apply(context: IRenderContext2D): void;
    }
    class NoRenderDraw2DElementCMD extends Draw2DElementCMD {
        setRenderelements(value: IRenderElement2D[]): void;
        apply(context: IRenderContext2D): void;
    }
    class NoRenderSetRendertarget2DCMD extends SetRendertarget2DCMD {
        apply(context: IRenderContext2D): void;
    }
    class NoRender3DRenderPassFactory implements I3DRenderPassFactory {
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createRenderElement3D(): IRenderElement3D;
        createInstanceBatch(): IInstanceRenderBatch;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createSkinRenderElement(): ISkinRenderElement3D;
        createSceneRenderManager(): ISceneRenderManager;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
    }
    class NoRenderRender3DProcess implements IRender3DProcess {
        render3DManager: NoRenderSceneRenderManager;
        destroy(): void;
        fowardRender(context: IRenderContext3D, camera: Camera): void;
    }
    class NoRenderSceneRenderManager implements ISceneRenderManager {
        addRenderObject(object: BaseRender): void;
        removeRenderObject(object: BaseRender): void;
        removeMotionObject(object: BaseRender): void;
        addMotionObject(object: BaseRender): void;
        updateMotionObjects(): void;
        destroy(): void;
        list: FastSinglelist<BaseRender>;
        baseRenderList: FastSinglelist<IBaseRenderNode>;
    }
    class NoRenderRenderContext3D implements IRenderContext3D {
        globalShaderData: ShaderData;
        sceneData: ShaderData;
        sceneModuleData: ISceneNodeData;
        cameraModuleData: ICameraNodeData;
        cameraData: ShaderData;
        sceneUpdataMask: number;
        cameraUpdateMask: number;
        pipelineMode: string;
        invertY: boolean;
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, clolor: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<IRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    class NoRenderRenderElement3D implements IRenderElement3D {
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        materialId: number;
        destroy(): void;
    }
    class NoRenderInstanceRenderBatch implements IInstanceRenderBatch {
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    class NoRenderInstanceRenderElement3D implements IInstanceRenderElement3D {
        instanceElementList: SingletonList<IRenderElement3D>;
        setGeometry(geometry: IRenderGeometryElement): void;
        clearRenderData(): void;
        recover(): void;
        geometry: IRenderGeometryElement;
        materialShaderData: ShaderData;
        materialRenderQueue: number;
        renderShaderData: ShaderData;
        transform: Transform3D;
        canDynamicBatch: boolean;
        isRender: boolean;
        owner: IBaseRenderNode;
        subShader: SubShader;
        materialId: number;
        destroy(): void;
    }
    class NoRenderSkinRenderElement3D implements ISkinRenderElement3D {
        skinnedData: Float32Array[];
    }
    class NoRenderDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: WebBaseRenderNode;
        protected _destShaderData: NoRenderShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): WebBaseRenderNode;
        set node(value: WebBaseRenderNode);
        get destShaderData(): NoRenderShaderData;
        set destShaderData(value: NoRenderShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        private _sourceTexelSize;
        protected _dest: NoInternalRT;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: NoRenderRenderElement3D;
        get dest(): NoInternalRT;
        set dest(value: NoInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): NoRenderRenderElement3D;
        set element(value: NoRenderRenderElement3D);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: NoRenderRenderElement3D[]): void;
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
        apply(context: NoRenderRenderContext3D): void;
    }
    class NoRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: HTMLCanvas): Promise<void>;
        createGlobalUniformMap(blockName: string): CommandUniformMap;
        createShaderData(ownerResource?: Resource): ShaderData;
    }
    class NoRenderCommandUnifojrmMap extends CommandUniformMap {
        constructor(stateName: string);
        /**
         * 增加一个Uniform参数
         * @param propertyID
         * @param propertyKey
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType, block?: string): void;
        /**
         * 增加一个UniformArray参数
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
    }
    class NoRenderShaderInstance implements IShaderInstance {
        _serializeShader(): ArrayBuffer;
        _deserialize(buffer: ArrayBuffer): boolean;
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        _disposeResource(): void;
    }
    class NoRenderIndexBuffer implements IIndexBuffer {
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        indexType: IndexFormat;
        indexCount: number;
    }
    class NoRenderVertexBuffer implements IVertexBuffer {
        vertexDeclaration: VertexDeclaration;
        instanceBuffer: boolean;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    class NoRenderBufferState implements IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer): void;
        destroy(): void;
    }
    class NoRenderGeometryElement implements IRenderGeometryElement {
        getDrawDataParams(out: FastSinglelist<number>): void;
        bufferState: IBufferState;
        mode: MeshTopology;
        drawType: DrawType;
        instanceCount: number;
        indexFormat: IndexFormat;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        clearRenderParams(): void;
        destroy(): void;
    }
    class NoRenderShaderData extends ShaderData {
        /**@internal */
        _data: any;
        /** @internal */
        _defineDatas: WebDefineDatas;
        getDefineData(): WebDefineDatas;
        /**
         * @internal
         */
        getData(): any;
        /**
         * @ignore
         */
        addDefine(define: ShaderDefine): void;
        /**
         * @ignore
         */
        addDefines(define: IDefineDatas): void;
        /**
         * @ignore
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * @ignore
         */
        hasDefine(define: ShaderDefine): boolean;
        clearDefine(): void;
        clearData(): void;
        /**
         * 获取布尔。
         * @param index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param index shader索引。
         * @param value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param index shader索引。
         * @param value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param index shader索引。
         * @param value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param index shader索引。
         * @param value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param index shader索引。
         * @param value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param index shader索引。
         * @param value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param index shader索引。
         * @param value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param index shader索引。
         * @param value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param index shader索引。
         * @param value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        setShaderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem | Quaternion): void;
        getShaderData(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @private
         */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 克隆。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: NoRenderShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): NoRenderShaderData;
        destroy(): void;
    }
    class NoRenderSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: NoRenderShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): NoRenderShaderData;
        set dest(value: NoRenderShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
        apply(context: any): void;
    }
    class NoRenderSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: NoRenderShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): NoRenderShaderData;
        set dest(value: NoRenderShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
        apply(context: any): void;
    }
    class NoRenderEngine implements IRenderEngine {
        _framePassCount: number;
        _context: any;
        _isShaderDebugMode: boolean;
        _enableStatistics: boolean;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        initRenderEngine(canvas: HTMLCanvasElement): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        resizeOffScreen(width: number, height: number): void;
        endFrame(): void;
        startFrame(): void;
        /**@internal */
        private _propertyNameMap;
        /**@internal */
        private _propertyNameCounter;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        /**@internal */
        private static _defineMap;
        /**@internal */
        private static _defineCounter;
        static _maskMap: Array<{
            [key: number]: string;
        }>;
        getDefineByName(name: string): ShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: string[]): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
    }
    class NoInternalTexture implements InternalTexture {
        resource: any;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        filterMode: FilterMode;
        wrapU: WrapMode;
        wrapV: WrapMode;
        wrapW: WrapMode;
        anisoLevel: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        compareMode: TextureCompareMode;
        gpuMemory: number;
        useSRGBLoad: boolean;
        gammaCorrection: number;
        dispose(): void;
    }
    class NoInternalRT implements InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _texturesResolve?: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        dispose(): void;
    }
    class NoTextureContext implements ITextureContext {
        needBitmap: boolean;
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap | ImageData, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap | ImageData, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: InternalTexture, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: InternalTexture): void;
        setTextureSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: InternalTexture, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: InternalTexture, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: InternalTexture, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTargetInternal(width: number, height: number, format: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number, storage: boolean): InternalRenderTarget;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetDepthTexture(renderTarget: InternalRenderTarget, dimension: TextureDimension, width: number, height: number): InternalTexture;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class GLESSetRendertarget2DCMD extends SetRendertarget2DCMD {
        _nativeObj: any;
        protected _rt: GLESInternalRT;
        constructor();
        /**
       * @en Flip Y Rendering
       * @zh 翻转Y轴渲染
       */
        get invertY(): boolean;
        set invertY(value: boolean);
        /**
         * @en clear rt color value
         * @zh RT清理颜色
         */
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        /**
         * @en set render target
         * @zh 设置渲染目标RT
         */
        get rt(): GLESInternalRT;
        set rt(value: GLESInternalRT);
        /**
         * @en Clean rt or not
         * @zh 是否清理rt
         */
        get clearColor(): boolean;
        set clearColor(value: boolean);
    }
    class GLESDraw2DElementCMD extends Draw2DElementCMD {
        private _elemets;
        _nativeObj: any;
        constructor();
        setRenderelements(value: GLESRenderElement2D[]): void;
    }
    class GLESBlit2DQuadCMD extends Blit2DQuadCMD {
        _nativeObj: any;
        protected _dest: GLESInternalRT;
        protected _source: GLESInternalTex;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: GLESRenderElement2D;
        type: RenderCMDType;
        constructor();
        set source(value: GLESInternalTex);
        /**
         * @en copy Texture
         * @zh 拷贝纹理
         */
        get source(): GLESInternalTex;
        /**
       * @en render element
       * @zh 渲染元素
       */
        get element(): GLESRenderElement2D;
        set element(value: GLESRenderElement2D);
        /**
         * @en render dest
         * @zh 渲染目标
         */
        get dest(): GLESInternalRT;
        set dest(value: GLESInternalRT);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
    }
    class GLESPrimitiveRenderElement2D extends GLESRenderElement2D implements IPrimitiveRenderElement2D {
        protected init(): void;
        private _primitiveShaderData;
        get primitiveShaderData(): GLESShaderData;
        set primitiveShaderData(data: GLESShaderData);
    }
    class GLESRender2DProcess implements I2DRenderPassFactory {
        createGraphic2DBufferBlock(): IGraphics2DBufferBlock;
        createGraphic2DVertexBlock(): IGraphics2DVertexBlock;
        create2DGraphicVertexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementOffset: number, elementSize: number, stride: number): I2DGraphicVertexDataView;
        create2DGraphicIndexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementSize: number): I2DGraphicIndexDataView;
        create2DGraphicIndexBuffer(): I2DGraphicWholeBuffer;
        create2DGraphicVertexBuffer(): I2DGraphicWholeBuffer;
        createPrimitiveRenderElement2D(): IPrimitiveRenderElement2D;
        createRender2DPassManager(): IRender2DPassManager;
        create2DGlobalRenderDataHandle(): I2DGlobalRenderData;
        createSpineRenderDataHandle(): ISpineRenderDataHandle;
        create2D2DPrimitiveDataHandle(): I2DPrimitiveDataHandle;
        create2DBaseRenderDataHandle(): I2DBaseRenderDataHandle;
        createMesh2DRenderDataHandle(): IMesh2DRenderDataHandle;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createBlit2DQuadCMDData(): Blit2DQuadCMD;
        createDraw2DElementCMDData(): Draw2DElementCMD;
        createSetRendertarget2DCMD(): SetRendertarget2DCMD;
        createRenderElement2D(): GLESRenderElement2D;
        createRenderContext2D(): GLESRenderContext2D;
        createRender2DPass(): IRender2DPass;
        createRenderStruct2D(): IRenderStruct2D;
    }
    class GLESRenderContext2D implements IRenderContext2D {
        static isCreateBlitScreenELement: boolean;
        static blitScreenElement: GLESRenderElement2D;
        private _tempList;
        /**
         * @internal
         */
        _nativeObj: any;
        private _dist;
        get invertY(): boolean;
        set invertY(value: boolean);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        constructor();
        private _passData;
        private _passDataShell;
        get passData(): GLESShaderData;
        set passData(value: GLESShaderData);
        private setBlitScreenElement;
        drawRenderElementList(list: FastSinglelist<GLESRenderElement2D>): number;
        setRenderTarget(value: GLESInternalRT, clear: boolean, clearColor: Color): void;
        getRenderTarget(): GLESInternalRT;
        setOffscreenView(width: number, height: number): void;
        drawRenderElementOne(node: GLESRenderElement2D): void;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    class GLESRenderElement2D implements IRenderElement2D {
        private _geometry;
        private _materialShaderData;
        private _value2DShaderData;
        private _globalShaderData;
        private _subShader;
        set type(value: number);
        get type(): number;
        set geometry(data: GLESRenderGeometryElement);
        get geometry(): GLESRenderGeometryElement;
        set materialShaderData(data: GLESShaderData);
        get materialShaderData(): GLESShaderData;
        set value2DShaderData(data: GLESShaderData);
        get value2DShaderData(): GLESShaderData;
        set globalShaderData(data: GLESShaderData);
        get globalShaderData(): GLESShaderData;
        get subShader(): SubShader;
        set subShader(value: SubShader);
        /**@internal */
        _nativeObj: any;
        protected init(): void;
        constructor();
        _owner: IRenderStruct2D;
        get owner(): IRenderStruct2D;
        set owner(value: IRenderStruct2D);
        private _nodeCommonMap;
        get nodeCommonMap(): string[];
        set nodeCommonMap(value: string[]);
        private _renderStateIsBySprite;
        get renderStateIsBySprite(): boolean;
        set renderStateIsBySprite(value: boolean);
        destroy(): void;
    }
    class GLES3DRenderPassFactory implements I3DRenderPassFactory {
        createInstanceBatch(): IInstanceRenderBatch;
        createRender3DProcess(): IRender3DProcess;
        createRenderContext3D(): IRenderContext3D;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createDrawNodeCMDData(): DrawNodeCMDData;
        createBlitQuadCMDData(): BlitQuadCMDData;
        createDrawElementCMDData(): DrawElementCMDData;
        createSetViewportCMD(): SetViewportCMD;
        createSetRenderTargetCMD(): SetRenderTargetCMD;
        createSceneRenderManager(): ISceneRenderManager;
        createSkinRenderElement(): GLESSkinRenderElement3D;
        createInstanceRenderElement3D(): IInstanceRenderElement3D;
        createDirectLightShadowRP(): GLESDirectLightShadowRP;
        createSpotLightShadowRP(): GLESSpotLightShadowRP;
        createForwardAddRP(): GLESForwardAddRP;
        createForwardAddCluster(): GLESForwardAddClusterRP;
        createRenderElement3D(): GLESRenderElement3D;
    }
    class GLESDirectLightShadowRP {
        private _light;
        private _camera;
        private _destTarget;
        private _shadowCasterCommanBuffer;
        _nativeObj: any;
        get light(): RTDirectLight;
        set light(value: RTDirectLight);
        get camera(): RTCameraNodeData;
        set camera(value: RTCameraNodeData);
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        constructor();
        destroy(): void;
        get shadowCasterCommanBuffer(): CommandBuffer[];
        set shadowCasterCommanBuffer(value: CommandBuffer[]);
        private _setCmd;
    }
    class GLESForwardAddClusterRP {
        get enableOpaque(): boolean;
        set enableOpaque(value: boolean);
        get enableCMD(): boolean;
        set enableCMD(value: boolean);
        get enableTransparent(): boolean;
        set enableTransparent(value: boolean);
        get enableOpaqueTexture(): boolean;
        set enableOpaqueTexture(value: boolean);
        private _destTarget;
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        private _depthTarget;
        get depthTarget(): GLESInternalRT;
        set depthTarget(value: GLESInternalRT);
        get depthPipelineMode(): string;
        set depthPipelineMode(value: string);
        private _depthNormalTarget;
        get depthNormalTarget(): GLESInternalRT;
        set depthNormalTarget(value: GLESInternalRT);
        get depthNormalPipelineMode(): string;
        set depthNormalPipelineMode(value: string);
        private _skyRenderNode;
        get skyRenderNode(): RTBaseRenderNode;
        set skyRenderNode(value: RTBaseRenderNode);
        get depthTextureMode(): DepthTextureMode;
        set depthTextureMode(value: DepthTextureMode);
        private _opaqueTexture;
        get opaqueTexture(): GLESInternalRT;
        set opaqueTexture(value: GLESInternalRT);
        private _camera;
        get camera(): RTCameraNodeData;
        set camera(value: RTCameraNodeData);
        private _clearColor;
        get clearColor(): Color;
        set clearColor(value: Color);
        get clearFlag(): number;
        set clearFlag(value: number);
        /**@internal */
        _cameraCullInfo: CameraCullInfo;
        setCameraCullInfo(value: Camera): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        private _getRenderCMDArray;
        /**
        * @internal
        * OpaqueTexture CommandBuffer
        */
        private _opaquePassCommandBuffer;
        get opaquePassCommandBuffer(): CommandBuffer;
        set opaquePassCommandBuffer(value: CommandBuffer);
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        _nativeObj: any;
        constructor();
        destroy(): void;
    }
    class GLESForwardAddRP {
        get shadowCastPass(): boolean;
        set shadowCastPass(value: boolean);
        private _directLightShadowPass;
        get directLightShadowPass(): GLESDirectLightShadowRP;
        set directLightShadowPass(value: GLESDirectLightShadowRP);
        get enableDirectLightShadow(): boolean;
        set enableDirectLightShadow(value: boolean);
        private _spotLightShadowPass;
        get spotLightShadowPass(): GLESSpotLightShadowRP;
        set spotLightShadowPass(value: GLESSpotLightShadowRP);
        get enableSpotLightShadowPass(): boolean;
        set enableSpotLightShadowPass(value: boolean);
        private _renderpass;
        get renderpass(): GLESForwardAddClusterRP;
        set renderpass(value: GLESForwardAddClusterRP);
        private _enablePostProcess;
        get enablePostProcess(): boolean;
        set enablePostProcess(value: boolean);
        /**@internal */
        private _postProcess;
        get postProcess(): CommandBuffer;
        set postProcess(value: CommandBuffer);
        /**@internal */
        private _finalize;
        get finalize(): CommandBuffer;
        set finalize(value: CommandBuffer);
        _nativeObj: any;
        constructor();
        private _getRenderCMDArray;
        setAfterEventCmd(value: CommandBuffer[]): void;
        setBeforeImageEffect(value: CommandBuffer[]): void;
        destroy(): void;
    }
    class GLESRender3DProcess implements IRender3DProcess {
        private _nativeObj;
        private _tempList;
        private renderpass;
        constructor();
        private _render3DManager;
        get render3DManager(): RTScene3DRenderManager;
        set render3DManager(value: RTScene3DRenderManager);
        destroy(): void;
        initRenderpass(camera: Camera, context: GLESRenderContext3D): void;
        renderDepth(camera: Camera): void;
        fowardRender(context: GLESRenderContext3D, camera: Camera): void;
        renderFowarAddCameraPass(context: GLESRenderContext3D, renderpass: GLESForwardAddRP): void;
    }
    class GLESDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: RTBaseRenderNode;
        protected _destShaderData: GLESShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        /**@internal */
        _nativeObj: any;
        get node(): RTBaseRenderNode;
        set node(value: RTBaseRenderNode);
        get destShaderData(): GLESShaderData;
        set destShaderData(value: GLESShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
    }
    class GLESBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        protected _dest: GLESInternalRT;
        protected _viewport: Viewport;
        protected _source: GLESInternalTex;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: GLESRenderElement3D;
        /**@internal */
        _nativeObj: any;
        get dest(): GLESInternalRT;
        set dest(value: GLESInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): GLESInternalTex;
        set source(value: GLESInternalTex);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): GLESRenderElement3D;
        set element(value: GLESRenderElement3D);
        constructor();
    }
    class GLESDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        /**@internal */
        _nativeObj: any;
        private _elemets;
        constructor();
        setRenderelements(value: GLESRenderElement3D[]): void;
    }
    class GLESSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        /**@internal */
        _nativeObj: any;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
    }
    class GLESSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        /**@internal */
        _nativeObj: any;
        protected _rt: GLESInternalRT;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): GLESInternalRT;
        set rt(value: GLESInternalRT);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
    }
    class GLESRenderContext3D implements IRenderContext3D {
        private _globalShaderData;
        get globalShaderData(): GLESShaderData;
        set globalShaderData(value: GLESShaderData);
        private _sceneData;
        get sceneData(): GLESShaderData;
        set sceneData(value: GLESShaderData);
        private _sceneModuleData;
        get sceneModuleData(): RTSceneNodeData;
        set sceneModuleData(value: RTSceneNodeData);
        private _cameraModuleData;
        get cameraModuleData(): RTCameraNodeData;
        set cameraModuleData(value: RTCameraNodeData);
        private _cameraData;
        get cameraData(): GLESShaderData;
        set cameraData(value: GLESShaderData);
        get sceneUpdataMask(): number;
        set sceneUpdataMask(value: number);
        get cameraUpdateMask(): number;
        set cameraUpdateMask(value: number);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        get invertY(): boolean;
        set invertY(value: boolean);
        _nativeObj: any;
        constructor();
        setRenderTarget(value: GLESInternalRT, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        setClearData(clearFlag: number, color: Color, depth: number, stencil: number): number;
        private _tempList;
        drawRenderElementList(list: FastSinglelist<GLESRenderElement3D>): number;
        drawRenderElementOne(node: IRenderElement3D): number;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    enum RenderElementType {
        Base = 0,
        Skin = 1,
        Instance = 2
    }
    class GLESRenderElement3D implements IRenderElement3D {
        private _geometry;
        private _materialShaderData;
        private _renderShaderData;
        private _transform;
        set geometry(data: GLESRenderGeometryElement);
        get geometry(): GLESRenderGeometryElement;
        set materialShaderData(data: GLESShaderData);
        get materialShaderData(): GLESShaderData;
        set renderShaderData(data: GLESShaderData);
        get renderShaderData(): GLESShaderData;
        set transform(data: RTTransform3D);
        get transform(): RTTransform3D;
        get isRender(): boolean;
        set isRender(data: boolean);
        get materialRenderQueue(): number;
        set materialRenderQueue(value: number);
        private _owner;
        get owner(): RTBaseRenderNode;
        set owner(value: RTBaseRenderNode);
        private _subShader;
        get subShader(): SubShader;
        set subShader(value: SubShader);
        get canDynamicBatch(): boolean;
        set canDynamicBatch(value: boolean);
        get materialId(): number;
        set materialId(value: number);
        _nativeObj: any;
        constructor();
        destroy(): void;
        protected init(): void;
    }
    class GLESSkinRenderElement3D extends GLESRenderElement3D implements ISkinRenderElement3D {
        _skinnedData: Float32Array[];
        constructor();
        get skinnedData(): Float32Array[];
        set skinnedData(data: Float32Array[]);
        init(): void;
    }
    class GLESSpotLightShadowRP {
        private _light;
        get light(): SpotLightCom;
        set light(value: SpotLightCom);
        private _destTarget;
        get destTarget(): GLESInternalRT;
        set destTarget(value: GLESInternalRT);
        _nativeObj: any;
        constructor();
        destroy(): void;
    }
    /**
     * OpenGL ES计算上下文，用于缓存和管理一系列计算命令
     */
    class GLESComputeContext implements IComputeContext {
        private _nativeObj;
        private commands;
        private _currentShader;
        private _isExecuting;
        constructor();
        /**
         * 清空所有命令
         */
        clearCMDs(): void;
        /**
         * 添加计算调度命令
         * @param cmd 计算调度命令信息
         */
        addDispatchCommand(cmd: IComputeCMD_Dispatch): void;
        /**
         * 添加设置着色器数据命令
         * @param shaderData 着色器数据
         * @param propertyID 属性ID
         * @param shaderDataType 着色器数据类型
         * @param value 数据值
         */
        addSetShaderDataCommand(shaderData: ShaderData, propertyID: number, shaderDataType: ShaderDataType, value: ShaderDataItem): void;
        /**
         * 添加缓冲区到缓冲区的复制命令
         * @param src 源缓冲区
         * @param dest 目标缓冲区
         * @param sourceOffset 源缓冲区偏移量
         * @param destinationOffset 目标缓冲区偏移量
         * @param size 复制大小
         */
        addBufferToBufferCommand(src: IGPUBuffer, dest: IGPUBuffer, sourceOffset?: number, destinationOffset?: number, size?: number): void;
        /**
         * 添加缓冲区到纹理的复制命令
         * @param src 源缓冲区
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 复制大小
         */
        addBufferToTextureCommand(src: IGPUBuffer, srcTextureInfo: any, destTextureInfo: any, copySize: any): void;
        /**
         * 添加纹理到缓冲区的复制命令
         * @param srcTextureInfo 源纹理信息
         * @param dest 目标缓冲区
         * @param destTextureInfo 目标纹理信息
         * @param copySize 复制大小
         */
        addTextureToBufferCommand(srcTextureInfo: any, dest: IGPUBuffer, destTextureInfo: any, copySize: any): void;
        /**
         * 添加纹理到纹理的复制命令
         * @param srcTextureInfo 源纹理信息
         * @param destTextureInfo 目标纹理信息
         * @param copySize 复制大小
         */
        addTextureToTextureCommand(srcTextureInfo: any, destTextureInfo: any, copySize: any): void;
        /**
         * 清理buffer数据
         * @param dest 清理数据的buffer
         * @param destOffset 位置
         * @param destCount 长度
         */
        addClearBufferCommand(dest: GLESDeviceBuffer, destOffset: number, destCount: number): void;
        /**
         * 绑定着色器数据到计算着色器
         * @param shader 计算着色器
         * @param shaderData 着色器数据数组
         */
        private _bindShaderData;
        /**
         * 执行所有缓存的命令
         */
        executeCMDs(): void;
        /**
         * 执行调度命令
         */
        private _executeDispatchCommand;
        /**
         * 执行设置着色器数据命令
         */
        private _executeSetShaderDataCommand;
        /**
         * 执行缓冲区到缓冲区复制命令
         */
        private _executeBufferToBufferCommand;
        /**
         * 执行清理缓冲区命令
         */
        private _executeClearBufferCommand;
        /**
         * 执行缓冲区到纹理复制命令
         */
        private _executeBufferToTextureCommand;
        /**
         * 执行纹理到缓冲区复制命令
         */
        private _executeTextureToBufferCommand;
        /**
         * 执行纹理到纹理复制命令
         */
        private _executeTextureToTextureCommand;
        /**
         * 同步执行命令并等待完成
         */
        executeAndWait(): Promise<void>;
        /**
         * 检查是否正在执行命令
         */
        get isExecuting(): boolean;
        /**
         * 获取当前绑定的着色器
         */
        get currentShader(): GLESComputeShader | null;
        /**
         * 销毁计算上下文，清空所有命令
         */
        destroy(): void;
    }
    /**
     * OpenGL ES计算着色器实现
     * 管理计算着色器的编译、内核函数和uniform映射
     */
    class GLESComputeShader implements IComputeShader {
        /** ID计数器 */
        static idCounter: number;
        /** 着色器唯一ID */
        private _id;
        /** 原生着色器对象 */
        private _nativeObj;
        /** 着色器名称 */
        name: string;
        /** 是否编译完成 */
        compilete: boolean;
        /** 内核函数集合 */
        private _kernels;
        /** uniform命令映射 */
        uniformCommandMap: GLESCommandUniformMap[];
        /** uniform绑定信息映射 */
        uniformBindingMap: Map<number, any>;
        constructor(name: string);
        /**
         * 检查是否包含指定的内核函数
         * @param kernel 内核函数名称
         * @returns 是否包含该内核
         */
        HasKernel(kernel: string): boolean;
        /**
         * 添加内核函数
         * @param kernel 内核函数名称
         */
        addKernel(kernel: string): void;
        /**
         * 移除内核函数
         * @param kernel 内核函数名称
         */
        removeKernel(kernel: string): void;
        /**
         * 获取所有内核函数
         * @returns 内核函数数组
         */
        getKernels(): string[];
        /**
         * 编译计算着色器
         * @param info 着色器编译信息
         */
        compile(info: ComputeShaderProcessInfo): void;
        /**
         * 从着色器代码中提取内核函数
         * @param code 着色器代码
         */
        private _extractKernelsFromShader;
        /**
         * 获取计算着色器程序对象
         * @param kernel 内核函数名称
         * @returns 着色器程序对象
         */
        getProgram(kernel: string): any;
        /**
         * 绑定计算着色器到OpenGL上下文
         * @param kernel 使用的内核函数名称
         */
        bind(kernel?: string): void;
        /**
         * 解绑计算着色器
         */
        unbind(): void;
        /**
         * 设置uniform值
         * @param location uniform位置
         * @param value 值
         */
        setUniform(location: number, value: any): void;
        /**
         * 获取uniform位置
         * @param name uniform名称
         * @returns uniform位置
         */
        getUniformLocation(name: string): number;
        /**
         * 获取着色器ID
         */
        get id(): number;
        /**
         * 获取原生着色器对象
         */
        get nativeObj(): any;
        /**
         * 销毁计算着色器
         */
        destroy(): void;
    }
    /**
     * OpenGL ES设备缓冲区实现
     * 用于在GPU中创建各种各样的Buffer，支持计算着色器和间接渲染
     */
    class GLESDeviceBuffer implements IDeviceBuffer, IGPUBuffer {
        private _nativeObj;
        private _usage;
        private _size;
        private _cacheShaderData;
        private _destroyed;
        constructor(usage: EDeviceBufferUsage);
        /**
         * 将LayaAir的缓冲区用途转换为OpenGL ES的缓冲区用途
         * @param usage LayaAir缓冲区用途
         * @returns OpenGL ES缓冲区用途
         */
        private _convertUsage;
        /**
         * 添加缓存的着色器数据
         * @param shaderData 着色器数据
         * @param propertyID 属性ID
         */
        _addCacheShaderData(shaderData: GLESShaderData, propertyID: number): void;
        /**
         * 移除缓存的着色器数据
         * @param shaderData 着色器数据
         */
        _removeCacheShaderData(shaderData: GLESShaderData): void;
        /**
         * 获取原生缓冲区对象
         * @returns 原生缓冲区对象
         */
        getNativeBuffer(): any;
        /**
         * 获取缓冲区绑定信息
         * @param binding 绑定点
         * @returns 绑定信息
         */
        getBindInfo(binding: number): any;
        /**
         * 设置缓冲区数据
         * @param buffer 源数据缓冲区
         * @param bufferOffset 目标缓冲区偏移量（字节）
         * @param dataStartIndex 源数据起始偏移量（字节）
         * @param dataCount 数据长度（字节）
         */
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        /**
         * 设置缓冲区数据长度
         * @param byteLength 字节长度
         */
        setDataLength(byteLength: number): void;
        /**
         * 复制数据到另一个缓冲区
         * @param buffer 目标缓冲区
         * @param sourceOffset 源偏移量（字节）
         * @param destOffset 目标偏移量（字节）
         * @param byteLength 复制长度（字节）
         */
        copyToBuffer(buffer: IVertexBuffer | IDeviceBuffer, sourceOffset: number, destOffset: number, byteLength: number): void;
        /**
         * 复制数据到纹理（未实现）
         */
        copyToTexture(): void;
        /**
         * 从缓冲区读取数据
         * @param dest 目标缓冲区
         * @param destOffset 目标偏移量（字节）
         * @param srcOffset 源偏移量（字节）
         * @param byteLength 读取长度（字节）
         * @returns Promise，异步读取完成
         */
        readData(dest: ArrayBuffer, destOffset: number, srcOffset: number, byteLength: number): Promise<void>;
        /**
         * 销毁缓冲区
         */
        destroy(): void;
        /**
         * 检查缓冲区是否已销毁
         */
        get destroyed(): boolean;
        /**
         * 获取缓冲区大小
         */
        get size(): number;
        /**
         * 获取缓冲区用途
         */
        get usage(): EDeviceBufferUsage;
    }
    class GLESBufferState implements IBufferState {
        _bindedIndexBuffer: IIndexBuffer;
        _vertexBuffers: IVertexBuffer[];
        _nativeObj: any;
        constructor();
        applyState(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer): void;
        destroy(): void;
    }
    class GLESCommandUniformMap extends CommandUniformMap {
        _nativeObj: any;
        constructor(stateName: string);
        /**
         * 增加一个Uniform参数，如果Uniform属性是Array，请使用addShaderUniformArray
         * @internal
         * @param propertyID
         * @param propertyKey
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /**
         * 增加一个UniformArray参数
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number): void;
    }
    /**
     * WebGL mode.
     */
    enum GLESMode {
        /** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */
        Auto = 0,
        /** WebGL2.0. */
        WebGL2 = 1,
        /** WebGL1.0, */
        WebGL1 = 2
    }
    /**
     * @private 封装Webgl
     */
    class GLESEngine implements IRenderEngine {
        _context: any;
        _isShaderDebugMode: boolean;
        _nativeObj: any;
        private _GLTextureContext;
        constructor(config: WebGLConfig, webglMode?: GLESMode);
        get _framePassCount(): number;
        set _framePassCount(value: number);
        endFrame(): void;
        startFrame(): void;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        resizeOffScreen(width: number, height: number): void;
        getDefineByName(name: string): RTShaderDefine;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        addTexGammaDefine(key: number, value: RTShaderDefine): void;
        initRenderEngine(canvas: HTMLCanvasElement): void;
        copySubFrameBuffertoTex(texture: InternalTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        viewport(x: number, y: number, width: number, height: number): void;
        scissor(x: number, y: number, width: number, height: number): void;
    }
    class GLESIndexBuffer implements IIndexBuffer {
        destroy(): void;
        _setIndexDataLength(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        get indexType(): IndexFormat;
        set indexType(value: IndexFormat);
        get indexCount(): number;
        set indexCount(value: number);
        _nativeObj: any;
        private _bufferRef;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
    }
    class GLESInternalRT implements InternalRenderTarget {
        _texturesRef: InternalTexture[];
        _depthTextureRef: InternalTexture;
        _nativeObj: any;
        constructor(nativeObj: any);
        get _isCube(): boolean;
        set _isCube(value: boolean);
        get _samples(): number;
        set _samples(value: number);
        get _generateMipmap(): boolean;
        set _generateMipmap(value: boolean);
        get colorFormat(): RenderTargetFormat;
        set colorFormat(value: RenderTargetFormat);
        get depthStencilFormat(): RenderTargetFormat;
        set depthStencilFormat(value: RenderTargetFormat);
        get isSRGB(): boolean;
        set isSRGB(value: boolean);
        get gpuMemory(): number;
        set gpuMemory(value: number);
        get _textures(): InternalTexture[];
        get _depthTexture(): InternalTexture;
        dispose(): void;
    }
    /** @internal */
    class GLESInternalTex implements InternalTexture {
        _nativeObj: any;
        constructor(nativeObj: any);
        get wrapU(): WrapMode;
        set wrapU(value: WrapMode);
        get wrapV(): WrapMode;
        set wrapV(value: WrapMode);
        get wrapW(): WrapMode;
        set wrapW(value: WrapMode);
        set baseMipmapLevel(value: number);
        get baseMipmapLevel(): number;
        set maxMipmapLevel(value: number);
        get maxMipmapLevel(): number;
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        get anisoLevel(): number;
        set anisoLevel(value: number);
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        get mipmapCount(): number;
        get mipmap(): boolean;
        get isPotSize(): boolean;
        get useSRGBLoad(): boolean;
        get depth(): number;
        get gammaCorrection(): number;
        set gammaCorrection(value: number);
        get resource(): any;
        get width(): number;
        get height(): number;
        get gpuMemory(): number;
        dispose(): void;
    }
    class GLESSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        /**@internal */
        _nativeObj: any;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: GLESShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): GLESShaderData;
        set dest(value: GLESShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
    }
    class GLESSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        /**@internal */
        _nativeObj: any;
        protected _define: RTShaderDefine;
        protected _dest: GLESShaderData;
        protected _add: boolean;
        get define(): RTShaderDefine;
        set define(value: RTShaderDefine);
        get dest(): GLESShaderData;
        set dest(value: GLESShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
    }
    class GLESRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderData(ownerResource: Resource): ShaderData;
        private globalBlockMap;
        createGlobalUniformMap(blockName: string): GLESCommandUniformMap;
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): IShaderInstance;
        createIndexBuffer(bufferUsage: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        createEngine(config: Config, canvas: HTMLCanvas): Promise<void>;
        afterInit(): void;
        private static _setVertexDec;
    }
    class GLESRenderGeometryElement implements IRenderGeometryElement {
        private _bufferState;
        /**@internal */
        drawParams: FastSinglelist<number>;
        _nativeObj: any;
        /**@internal */
        constructor(mode: MeshTopology, drawType: DrawType);
        getDrawDataParams(out: FastSinglelist<number>): void;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        destroy(): void;
        clearRenderParams(): void;
        set bufferState(value: IBufferState);
        get bufferState(): IBufferState;
        set mode(value: MeshTopology);
        get mode(): MeshTopology;
        set drawType(value: DrawType);
        get drawType(): DrawType;
        set instanceCount(value: number);
        get instanceCount(): number;
        set indexFormat(value: IndexFormat);
        get indexFormat(): IndexFormat;
    }
    class GLESShaderData extends ShaderData {
        nativeObjID: number;
        _nativeObj: any;
        _defineDatas: RTDefineDatas;
        _textureData: {
            [key: number]: BaseTexture;
        };
        _bufferData: {
            [key: number]: Float32Array;
        };
        /**
         * @internal
         */
        constructor(ownerResource?: Resource, createNativeObj?: boolean);
        getDefineData(): RTDefineDatas;
        /**
         * @internal
         */
        getData(): any;
        clearData(): void;
        /**
         * @ignore
         */
        addDefine(define: RTShaderDefine): void;
        /**
         * @ignore
         */
        addDefines(define: RTDefineDatas): void;
        /**
         * @ignore
         */
        removeDefine(define: RTShaderDefine): void;
        /**
         * @ignore
         */
        hasDefine(define: RTShaderDefine): boolean;
        /**
         * @ignore
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param index shader索引。
         * @param value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param index shader索引。
         * @param value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param index shader索引。
         * @param value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param index shader索引。
         * @param value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param index shader索引。
         * @param value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param index shader索引。
         * @param value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param index shader索引。
         * @param value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param index shader索引。
         * @param value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param index shader索引。
         * @param value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**@internal */
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 获取纹理。
         * @param index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        cloneTo(destObject: GLESShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): GLESShaderData;
        destroy(): void;
    }
    /**
     * @internal
     * <code>ShaderInstance</code> 类用于实现ShaderInstance。
     */
    class GLESShaderInstance implements IShaderInstance {
        _nativeObj: any;
        /**@internal */
        private _shaderPass;
        /**@internal */
        private _attributeMapTemp;
        constructor();
        _serializeShader(): ArrayBuffer;
        _deserialize(buffer: ArrayBuffer): boolean;
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        /**
         * @inheritDoc
         * @override
         */
        _disposeResource(): void;
    }
    class GLESTextureContext implements ITextureContext {
        needBitmap: boolean;
        protected _native: any;
        constructor(native: any);
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): GLESInternalTex;
        setTextureImageData(texture: GLESInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: GLESInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: GLESInternalTex): void;
        setTextureSubPixelsData(texture: GLESInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: GLESInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DImageData(texture: GLESInternalTex, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): GLESInternalTex;
        setTexture3DPixelsData(texture: GLESInternalTex, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: GLESInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureHDRData(texture: GLESInternalTex, hdrInfo: HDRTextureInfo): void;
        setTextureDDSData(texture: GLESInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: GLESInternalTex, ktxInfo: KTXTextureInfo): void;
        setCubeImageData(texture: GLESInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: GLESInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: GLESInternalTex, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: GLESInternalTex, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: GLESInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: GLESInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        bindRenderTarget(renderTarget: GLESInternalRT, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: GLESInternalRT): void;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number, storage: boolean): GLESInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): GLESInternalRT;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): GLESInternalTex;
        createRenderTargetDepthTexture(renderTarget: GLESInternalRT, dimension: TextureDimension, width: number, height: number): GLESInternalTex;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         * @returns
         */
        readRenderTargetPixelData(renderTarget: GLESInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: GLESInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: GLESInternalTex, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class GLESVertexBuffer implements IVertexBuffer {
        _instanceBuffer: boolean;
        _nativeObj: any;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _vertexDeclaration;
        /**@internal */
        _shaderValues: {
            [key: number]: VertexStateContext;
        };
        /**@internal */
        private _attributeMapTemp;
        /**@internal */
        private _bufferRef;
        get vertexDeclaration(): VertexDeclaration;
        set vertexDeclaration(value: VertexDeclaration);
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        setDataLength(byteLength: number): void;
        destroy(): void;
    }
    /**
     * 渲染处理数据
     * @blueprintIgnore
     */
    interface IRender2DDataHandle {
        needUseMatrix: boolean;
        inheriteRenderData(context: IRenderContext2D): void;
        destroy(): void;
    }
    /**
     * 全局数据
     * @blueprintIgnore
     */
    interface I2DGlobalRenderData {
        /** minx , maxx , miny , maxy */
        cullRect: Vector4;
        renderLayerMask: number;
        globalShaderData: ShaderData;
    }
    /** @blueprintIgnore */
    interface I2DGraphicBufferDataView {
        setData(data: ArrayLike<number>): void;
    }
    /** @blueprintIgnore */
    interface I2DGraphicVertexDataView extends I2DGraphicBufferDataView {
        length: number;
        start: number;
        stride: number;
    }
    interface I2DGraphicIndexDataView extends I2DGraphicBufferDataView {
        length: number;
        setGeometry(value: IRenderGeometryElement): void;
        destroy(): void;
    }
    /** @blueprintIgnore */
    interface I2DGraphicWholeBuffer {
        buffer: IVertexBuffer | IIndexBuffer;
        resetData(byteLength: number): void;
        addDataView?(dataView: I2DGraphicBufferDataView): void;
        removeDataView(dataView: I2DGraphicBufferDataView): void;
        destroy(): void;
    }
    /** @blueprintIgnore */
    interface IGraphics2DVertexBlock {
        positions: number[];
        vertexViews: I2DGraphicVertexDataView[];
    }
    /** @blueprintIgnore */
    interface IGraphics2DBufferBlock {
        vertexs: IGraphics2DVertexBlock[];
        indexView: I2DGraphicIndexDataView;
        vertexBuffer: IVertexBuffer;
    }
    /**
     * primitive渲染数据处理
     * @blueprintIgnore
     */
    interface I2DPrimitiveDataHandle extends IRender2DDataHandle {
        mask: IRenderStruct2D | null;
        applyVertexBufferBlock(views: IGraphics2DBufferBlock[]): void;
    }
    /**
     * 基础组件数据处理
     * @blueprintIgnore
     */
    interface I2DBaseRenderDataHandle extends IRender2DDataHandle {
        lightReceive: boolean;
    }
    /**
     * mesh2D数据处理类
     * @blueprintIgnore
     */
    interface IMesh2DRenderDataHandle extends I2DBaseRenderDataHandle {
        baseColor: Color;
        baseTexture: BaseTexture;
        normal2DTexture: BaseTexture;
        normal2DStrength: number;
    }
    /**
     * spine数据处理类
     * @blueprintIgnore
     */
    interface ISpineRenderDataHandle extends I2DBaseRenderDataHandle {
        baseColor: Color;
        skeleton: spine.Skeleton;
        offset: Vector2;
    }
    /** @ignore @blueprintIgnore */
    interface IRender2DPass {
        enable: boolean;
        enableBatch: boolean;
        isSupport: boolean;
        root: IRenderStruct2D;
        doClearColor: boolean;
        postProcess: PostProcess2D;
        mask: IRenderStruct2D;
        repaint: boolean;
        renderTexture: RenderTexture2D;
        priority: number;
        shaderData: ShaderData;
        offsetMatrix: Matrix;
        needRender(): boolean;
        setClearColor(r: number, g: number, b: number, a: number): void;
        fowardRender(context: IRenderContext2D): void;
        destroy(): void;
    }
    /** @ignore @blueprintIgnore */
    interface IRender2DPassManager {
        addPass(pass: IRender2DPass): void;
        removePass(pass: IRender2DPass): void;
        apply(context: IRenderContext2D): void;
        clear(): void;
    }
    /** @ignore @blueprintIgnore */
    interface IClipInfo {
        clipMatDir: Vector4;
        clipMatPos: Vector4;
        clipMatrix: Matrix;
        _updateFrame: number;
    }
    /**
     * @ignore @blueprintIgnore
     * 需要传递的属性 get 效率慢
     */
    interface IRenderStruct2D {
        subStruct: IRenderStruct2D;
        owner: Sprite;
        zIndex: number;
        stackingRoot: boolean;
        enableCulling: boolean;
        readonly inheritedEnableCulling: boolean;
        rect: Rectangle;
        renderLayer: number;
        parent: IRenderStruct2D | null;
        children: IRenderStruct2D[];
        /** 按标记来 */
        renderType: number;
        renderUpdateMask: number;
        renderMatrix: Matrix;
        /** 非即时数据 */
        globalAlpha: number;
        alpha: number;
        blendMode: BlendMode;
        /** 是否启动 */
        enabled: boolean;
        dcOptimize: boolean;
        readonly inheritedDcOptimize: boolean;
        isRenderStruct: boolean;
        renderElements: IRenderElement2D[];
        spriteShaderData: ShaderData;
        renderDataHandler: IRender2DDataHandle;
        globalRenderData: I2DGlobalRenderData;
        pass: IRender2DPass;
        setRepaint(): void;
        addChild(child: IRenderStruct2D, index: number): void;
        updateChildIndex(child: IRenderStruct2D, oldIndex: number, index: number): void;
        removeChild(child: IRenderStruct2D): void;
        setClipRect(rect: Rectangle): void;
        setRenderUpdateCallback(func: Function): void;
        destroy(): void;
    }
    enum BaseRenderType {
        BaseRender = 0,
        MeshRender = 1,
        ParticleRender = 2,
        TrailRender = 3,
        LineRender = 4,
        TerrainRender = 5,
        SkyRender = 7,
        SimpleSkinRender = 8,
        SkinnedMeshRender = 9
    }
    enum ENodeCustomData {
        custom_0 = 0,
        custom_1 = 1,
        custom_2 = 2
    }
    /**
     * 3D Render Node
     * @ignore
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IBaseRenderNode {
        renderNodeType: number;
        transform: Transform3D;
        distanceForSort: number;
        sortingFudge: number;
        castShadow: boolean;
        receiveShadow: boolean;
        enable: boolean;
        renderbitFlag: number;
        layer: number;
        bounds: Bounds;
        baseGeometryBounds: Bounds;
        boundsChange: boolean;
        staticMask: number;
        shaderData: ShaderData;
        additionShaderData: Map<string, ShaderData>;
        lightmapIndex: number;
        lightmap: ILightMapData;
        probeReflection: IReflectionProbeData;
        reflectionMode: number;
        volumetricGI: IVolumetricGIData;
        lightProbUpdateMark: number;
        irradientMode: IrradianceMode;
        ismoved: Vector2;
        set_renderUpdatePreCall(call: any, fun: any): void;
        set_caculateBoundingBox(call: any, fun: any): void;
        /**
         * @param value
         */
        setRenderelements(value: IRenderElement3D[]): void;
        /**
         * @internal
         * @param value
         */
        setLightmapScaleOffset(value: Vector4): void;
        /**
         * @internal
         * @param value
         */
        setCommonUniformMap(value: string[]): void;
        /**
         * 设置基于RenderNode的渲染数据
         * @param dataSlot
         * @param data
         */
        setNodeCustomData(dataSlot: ENodeCustomData, data: number): void;
        /**
         * @override
         * @internal
         */
        destroy(): void;
        _applyLightProb(): void;
        _applyReflection(): void;
    }
    interface IMeshRenderNode extends IBaseRenderNode {
    }
    interface ISkinRenderNode extends IMeshRenderNode {
        computeSkinnedData(): void;
        setRootBoneTransfom(value: Sprite3D): void;
        setOwnerTransform(value: Sprite3D): void;
        setCacheMesh(cacheMesh: Mesh): void;
        setBones(value: Sprite3D[]): void;
        setSkinnedData(value: any[]): void;
    }
    interface ISimpleSkinRenderNode extends IBaseRenderNode {
        setSimpleAnimatorParams(value: Vector4): void;
    }
    interface IDirectLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        shadowCascadesMode: ShadowCascadesMode;
        shadowTwoCascadeSplits: number;
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
    }
    interface ISpotLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        spotRange: number;
        spotAngle: number;
        setDirection(value: Vector3): void;
    }
    interface IPointLightData {
        transform: Transform3D;
        range: number;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
    }
    interface ILightMapData {
        /**@internal */
        lightmapColor: InternalTexture;
        /**@internal */
        lightmapDirection: InternalTexture;
        /**@internal */
        destroy(): void;
    }
    interface IReflectionProbeData {
        /** @internal */
        _id: number;
        /**@internal */
        boxProjection: boolean;
        /**@internal */
        bound: Bounds;
        /**@internal */
        ambientMode: AmbientMode;
        /**@internal */
        ambientIntensity: number;
        /**@internal */
        reflectionIntensity: number;
        /**@internal */
        reflectionTexture: InternalTexture;
        /**@internal */
        iblTex: InternalTexture;
        /**@internal */
        updateMark: number;
        /**@internal */
        iblTexRGBD: boolean;
        /**@internal */
        shaderData: ShaderData;
        /**@internal */
        setProbePosition(value: Vector3): void;
        /**@internal */
        setAmbientColor(value: Color): void;
        /**@internal */
        setAmbientSH(value: Float32Array): void;
        /**@internal */
        destroy(): void;
    }
    interface IVolumetricGIData {
        _id: number;
        irradiance: InternalTexture;
        distance: InternalTexture;
        bound: Bounds;
        intensity: number;
        updateMark: number;
        shaderData: ShaderData;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
        setParams(value: Vector4): void;
        destroy(): void;
    }
    interface ICameraNodeData {
        transform: Transform3D;
        farplane: number;
        nearplane: number;
        fieldOfView: number;
        aspectRatio: number;
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    interface ISceneNodeData {
        lightmapDirtyFlag: number;
    }
    interface I3DRenderModuleFactory {
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): any;
        createVolumetricGI(): IVolumetricGIData;
        createReflectionProbe(): IReflectionProbeData;
        createLightmapData(): ILightMapData;
        createDirectLight(): IDirectLightData;
        createSpotLight(): ISpotLightData;
        createPointLight(): IPointLightData;
        createCameraModuleData(): ICameraNodeData;
        createSceneModuleData(): ISceneNodeData;
        createBaseRenderNode(): IBaseRenderNode;
        createMeshRenderNode(): IMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
    }
    /** @ignore */
    interface IDefineDatas {
        /**
         * @internal
         */
        _mask: Array<number>;
        /**
         * @internal
         */
        _length: number;
        /**
         * @internal
         */
        _intersectionDefineDatas(define: IDefineDatas): void;
        add(define: ShaderDefine): void;
        remove(define: ShaderDefine): void;
        addDefineDatas(define: IDefineDatas): void;
        removeDefineDatas(define: IDefineDatas): void;
        has(define: ShaderDefine): boolean;
        clear(): void;
        cloneTo(destObject: IDefineDatas): void;
        clone(): IDefineDatas;
        destroy(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface IShaderPassData {
        is2D: boolean;
        pipelineMode: string;
        statefirst: boolean;
        validDefine: IDefineDatas;
        renderState: RenderState;
        nodeCommonMap: string[];
        additionShaderData: string[];
        attributeLocations?: Set<number>;
        name: string;
        setCacheShader(defines: IDefineDatas, shaderInstance: IShaderInstance): void;
        getCacheShader(defines: IDefineDatas): IShaderInstance;
        destroy(): void;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    interface ISubshaderData {
        addShaderPass(pass: IShaderPassData): void;
        setUniformMap(_uniformMap: Map<number, UniformProperty>): void;
        enableInstance: boolean;
        shaderName: string;
        destroy(): void;
    }
    /** @ignore */
    interface IUnitRenderModuleDataFactory {
        createRenderState(): RenderState;
        createDefineDatas(): IDefineDatas;
        createSubShader(): ISubshaderData;
        createShaderPass(pass: ShaderPass): IShaderPassData;
    }
    /**
     * <code>RenderState</code> 类用于控制渲染状态。
     */
    class RenderState {
        /**剔除枚举_不剔除。*/
        static CULL_NONE: number;
        /**剔除枚举_剔除正面。*/
        static CULL_FRONT: number;
        /**剔除枚举_剔除背面。*/
        static CULL_BACK: number;
        /**混合枚举_禁用。*/
        static BLEND_DISABLE: number;
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        static BLEND_ENABLE_ALL: number;
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        static BLEND_ENABLE_SEPERATE: number;
        /**混合参数枚举_零,例：RGB(0,0,0),Alpha:(1)。*/
        static BLENDPARAM_ZERO: number;
        /**混合参数枚举_一,例：RGB(1,1,1),Alpha:(1)。*/
        static BLENDPARAM_ONE: number;
        /**混合参数枚举_源颜色,例：RGB(Rs, Gs, Bs)，Alpha(As)。*/
        static BLENDPARAM_SRC_COLOR: number;
        /**混合参数枚举_一减源颜色,例：RGB(1-Rs, 1-Gs, 1-Bs)，Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_COLOR: number;
        /**混合参数枚举_目标颜色,例：RGB(Rd, Gd, Bd),Alpha(Ad)。*/
        static BLENDPARAM_DST_COLOR: number;
        /**混合参数枚举_一减目标颜色,例：RGB(1-Rd, 1-Gd, 1-Bd)，Alpha(1-Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_COLOR: number;
        /**混合参数枚举_源透明,例:RGB(As, As, As),Alpha(1-As)。*/
        static BLENDPARAM_SRC_ALPHA: number;
        /**混合参数枚举_一减源阿尔法,例:RGB(1-As, 1-As, 1-As),Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_ALPHA: number;
        /**混合参数枚举_目标阿尔法，例：RGB(Ad, Ad, Ad),Alpha(Ad)。*/
        static BLENDPARAM_DST_ALPHA: number;
        /**混合参数枚举_一减目标阿尔法,例：RGB(1-Ad, 1-Ad, 1-Ad),Alpha(Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_ALPHA: number;
        /**混合参数枚举_阿尔法饱和，例：RGB(min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad)),Alpha(1)。*/
        static BLENDPARAM_SRC_ALPHA_SATURATE: number;
        /**混合参数枚举_混合设置颜色 */
        static BLENDPARAM_BLENDCOLOR: number;
        /**很合参数枚举_混合颜色取反 */
        static BLENDPARAM_BLEND_ONEMINUS_COLOR: number;
        /**混合方程枚举_加法,例：source + destination*/
        static BLENDEQUATION_ADD: number;
        /**混合方程枚举_减法，例：source - destination*/
        static BLENDEQUATION_SUBTRACT: number;
        /**混合方程枚举_反序减法，例：destination - source*/
        static BLENDEQUATION_REVERSE_SUBTRACT: number;
        /**混合方程枚举_取最小 TODO */
        static BLENDEQUATION_MIN: number;
        /**混合方程枚举_取最大 TODO*/
        static BLENDEQUATION_MAX: number;
        /**深度测试函数枚举_关闭深度测试。*/
        static DEPTHTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static DEPTHTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static DEPTHTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static DEPTHTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static DEPTHTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static DEPTHTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static DEPTHTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static DEPTHTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static DEPTHTEST_ALWAYS: number;
        static STENCILTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static STENCILTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static STENCILTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static STENCILTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static STENCILTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static STENCILTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static STENCILTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static STENCILTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static STENCILTEST_ALWAYS: number;
        /**保持当前值*/
        static STENCILOP_KEEP: number;
        /**将模板缓冲区值设置为0*/
        static STENCILOP_ZERO: number;
        /**将模具缓冲区值设置为指定的参考值*/
        static STENCILOP_REPLACE: number;
        /**增加当前模具缓冲区值+1 */
        static STENCILOP_INCR: number;
        /**增加当前模具缓冲区值,超过最大值的时候循环*/
        static STENCILOP_INCR_WRAP: number;
        /**递减当前模板缓冲区的值*/
        static STENCILOP_DECR: number;
        /**递减当前模板缓冲去的值，小于0时会循环*/
        static STENCILOP_DECR_WRAP: number;
        /**按位反转当前的模板缓冲区的值*/
        static STENCILOP_INVERT: number;
        /** @internal */
        static readonly Default: Readonly<RenderState>;
        /**渲染剔除状态。*/
        private _cull;
        get cull(): number;
        set cull(value: number);
        /**透明混合。*/
        private _blend;
        get blend(): number;
        set blend(value: number);
        /**源混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        private _srcBlend;
        get srcBlend(): number;
        set srcBlend(value: number);
        /**目标混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        private _dstBlend;
        get dstBlend(): number;
        set dstBlend(value: number);
        /**RGB源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _srcBlendRGB;
        get srcBlendRGB(): number;
        set srcBlendRGB(value: number);
        /**RGB目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _dstBlendRGB;
        get dstBlendRGB(): number;
        set dstBlendRGB(value: number);
        /**Alpha源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _srcBlendAlpha;
        get srcBlendAlpha(): number;
        set srcBlendAlpha(value: number);
        /**Alpha目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        private _dstBlendAlpha;
        get dstBlendAlpha(): number;
        set dstBlendAlpha(value: number);
        /**混合方程。*/
        private _blendEquation;
        get blendEquation(): number;
        set blendEquation(value: number);
        /**RGB混合方程。*/
        private _blendEquationRGB;
        get blendEquationRGB(): number;
        set blendEquationRGB(value: number);
        /**Alpha混合方程。*/
        private _blendEquationAlpha;
        get blendEquationAlpha(): number;
        set blendEquationAlpha(value: number);
        /**深度测试函数。*/
        private _depthTest;
        get depthTest(): number;
        set depthTest(value: number);
        /**是否深度测试。*/
        private _depthWrite;
        get depthWrite(): boolean;
        set depthWrite(value: boolean);
        /**是否模板写入 */
        private _stencilWrite;
        get stencilWrite(): boolean;
        set stencilWrite(value: boolean);
        /**是否开启模板测试 */
        private _stencilTest;
        get stencilTest(): number;
        set stencilTest(value: number);
        /** 模板写入掩码 */
        protected _stencilWriteMask: number;
        get stencilWriteMask(): number;
        set stencilWriteMask(value: number);
        /** 模板读取掩码 */
        protected _stencilReadMask: number;
        get stencilReadMask(): number;
        set stencilReadMask(value: number);
        /**模板值 一般会在0-255*/
        protected _stencilRef: number;
        get stencilRef(): number;
        set stencilRef(value: number);
        /**模板设置值 */
        protected _stencilOp: Vector3;
        get stencilOp(): Vector3;
        set stencilOp(value: Vector3);
        /** 是否开启深度偏移 */
        protected _depthBias: boolean;
        get depthBias(): boolean;
        set depthBias(value: boolean);
        /** 深度偏移常量 */
        protected _depthBiasConstant: number;
        get depthBiasConstant(): number;
        set depthBiasConstant(value: number);
        /** 深度偏移斜率缩放 */
        protected _depthBiasSlopeScale: number;
        get depthBiasSlopeScale(): number;
        set depthBiasSlopeScale(value: number);
        /** 深度偏移限制值 */
        protected _depthBiasClamp: number;
        get depthBiasClamp(): number;
        set depthBiasClamp(value: number);
        protected createObj(): void;
        /**
         * 创建一个 <code>RenderState</code> 实例。
         */
        constructor();
        /**
         * @internal
         */
        setNull(): void;
        /**
         * 克隆
         * @param dest
         */
        cloneTo(dest: RenderState): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): RenderState;
    }
    /**
     * @en ShaderDefine class is used to define macro data.
     * @zh ShaderDefine类用于定义宏数据。
     */
    class ShaderDefine {
        /**
         * @en The macro index.
         * @zh 宏索引。
         */
        _index: number;
        /**
         * @en The macro value.
         * @zh 宏值。
         */
        _value: number;
        /**
         * @en Creates an instance of the macro definition.
         * @zh 创建一个宏定义的实例。
         * @param index 宏索引
         * @param value 宏值
         */
        constructor(index: number, value: number);
    }
    class RT2DGraphicVertexBuffer implements I2DGraphicWholeBuffer {
        private _buffer;
        private _nativeMemory;
        private _views;
        _nativeObj: any;
        get buffer(): IVertexBuffer;
        set buffer(value: IVertexBuffer);
        constructor();
        /**
         * @internal
         */
        _setData(data: ArrayLike<number>, view: RT2DGraphic2DVertexDataView): void;
        _addDataView(dataView: I2DGraphicBufferDataView): void;
        removeDataView(dataView: I2DGraphicBufferDataView): void;
        destroy(): void;
        resetData(byteLength: number): void;
    }
    class RT2DGraphicIndexBuffer implements I2DGraphicWholeBuffer {
        private _buffer;
        private _views;
        _nativeObj: any;
        get buffer(): IIndexBuffer;
        set buffer(value: IIndexBuffer);
        constructor();
        resetData(byteLength: number): void;
        _addDataView(dataView: RT2DGraphic2DIndexDataView): void;
        removeDataView(dataView: RT2DGraphic2DIndexDataView): void;
        destroy(): void;
    }
    class RT2DGraphic2DVertexDataView implements I2DGraphicVertexDataView {
        private _owner;
        private _start;
        private _length;
        private _stride;
        _nativeObj: any;
        get start(): number;
        get length(): number;
        get stride(): number;
        constructor(owner: RT2DGraphicVertexBuffer, start: number, length: number, stride: number);
        setData(data: ArrayLike<number>): void;
    }
    class RT2DGraphic2DIndexDataView implements I2DGraphicIndexDataView {
        private _geometry;
        _owner: RT2DGraphicIndexBuffer;
        private _length;
        private _memoryData;
        _nativeObj: any;
        get length(): number;
        constructor(owner: RT2DGraphicIndexBuffer, length: number);
        setData(data: ArrayLike<number>): void;
        setGeometry(value: IRenderGeometryElement): void;
        destroy(): void;
    }
    class RTRender2DPass implements IRender2DPass {
        _nativeObj: any;
        private _enable;
        get enable(): boolean;
        set enable(value: boolean);
        private _enableBatch;
        get enableBatch(): boolean;
        set enableBatch(value: boolean);
        private _isSupport;
        get isSupport(): boolean;
        set isSupport(value: boolean);
        private _root;
        get root(): RTRenderStruct2D;
        set root(value: RTRenderStruct2D);
        private _doClearColor;
        set doClearColor(value: boolean);
        get doClearColor(): boolean;
        postProcess: PostProcess2D;
        private _mask;
        set mask(value: RTRenderStruct2D);
        get mask(): RTRenderStruct2D;
        private _repaint;
        get repaint(): boolean;
        set repaint(value: boolean);
        private _renderTexture;
        get renderTexture(): RenderTexture2D;
        set renderTexture(value: RenderTexture2D);
        private _priority;
        get priority(): number;
        set priority(value: number);
        private _shaderData;
        set shaderData(value: GLESShaderData);
        get shaderData(): GLESShaderData;
        private _renderOffset;
        set offsetMatrix(value: Matrix);
        get offsetMatrix(): Matrix;
        needRender(): boolean;
        setClearColor(r: number, g: number, b: number, a: number): void;
        constructor();
        /**
         * pass 2D 渲染
         * @param context
         */
        fowardRender(context: GLESRenderContext2D): void;
        private renderCallBack;
        destroy(): void;
    }
    class RTRender2DPassManager implements IRender2DPassManager {
        _nativeObj: any;
        constructor();
        removePass(pass: RTRender2DPass): void;
        apply(context: GLESRenderContext2D): void;
        clear(): void;
        addPass(pass: RTRender2DPass): void;
    }
    abstract class RTRender2DDataHandle implements IRender2DDataHandle {
        _nativeObj: any;
        constructor(nativeObj: any);
        protected _owner: RTRenderStruct2D;
        get owner(): RTRenderStruct2D;
        set owner(value: RTRenderStruct2D);
        private _needUseMatrix;
        get needUseMatrix(): boolean;
        set needUseMatrix(value: boolean);
        destroy(): void;
        inheriteRenderData(context: GLESRenderContext2D): void;
    }
    class RTGraphics2DBufferBlock implements IGraphics2DBufferBlock {
        private _vertexs;
        get vertexs(): RTGraphics2DVertexBlock[];
        set vertexs(value: RTGraphics2DVertexBlock[]);
        private _indexView;
        get indexView(): RT2DGraphic2DIndexDataView;
        set indexView(value: RT2DGraphic2DIndexDataView);
        private _vertexBuffer;
        get vertexBuffer(): IVertexBuffer;
        set vertexBuffer(value: IVertexBuffer);
        _nativeObj: any;
        constructor();
    }
    class RTGraphics2DVertexBlock implements IGraphics2DVertexBlock {
        private _positions;
        get positions(): number[];
        set positions(value: number[]);
        private _vertexViews;
        get vertexViews(): RT2DGraphic2DVertexDataView[];
        set vertexViews(value: RT2DGraphic2DVertexDataView[]);
        _nativeObj: any;
        constructor();
    }
    class RTPrimitiveDataHandle extends RTRender2DDataHandle implements I2DPrimitiveDataHandle {
        constructor();
        _mask: RTRenderStruct2D | null;
        get mask(): RTRenderStruct2D | null;
        set mask(value: RTRenderStruct2D | null);
        private _blocks;
        applyVertexBufferBlock(blocks: RTGraphics2DBufferBlock[]): void;
        inheriteRenderData(context: GLESRenderContext2D): void;
    }
    class RTBaseRenderDataHandle extends RTRender2DDataHandle implements I2DBaseRenderDataHandle {
        constructor(nativeObj?: any);
        private _lightReceive;
        get lightReceive(): boolean;
        set lightReceive(value: boolean);
        get owner(): RTRenderStruct2D;
        set owner(value: RTRenderStruct2D);
    }
    class RTMesh2DRenderDataHandle extends RTBaseRenderDataHandle implements IMesh2DRenderDataHandle {
        constructor();
        private _baseColor;
        private _baseTexture;
        private _normal2DTexture;
        get baseColor(): Color;
        set baseColor(value: Color);
        get baseTexture(): BaseTexture;
        set baseTexture(value: BaseTexture);
        get normal2DTexture(): BaseTexture;
        set normal2DTexture(value: BaseTexture);
        private _normal2DStrength;
        get normal2DStrength(): number;
        set normal2DStrength(value: number);
    }
    class RTSpineRenderDataHandle extends RTBaseRenderDataHandle implements ISpineRenderDataHandle {
        private _offset;
        skeleton: spine.Skeleton;
        private _baseColor;
        get baseColor(): Color;
        set baseColor(value: Color);
        constructor();
        get owner(): RTRenderStruct2D;
        set owner(value: RTRenderStruct2D);
        get offset(): Vector2;
        set offset(value: Vector2);
    }
    class RTGlobalRenderData implements I2DGlobalRenderData {
        _nativeObj: any;
        constructor();
        private _cullRect;
        get cullRect(): Vector4;
        set cullRect(value: Vector4);
        private _renderLayerMask;
        get renderLayerMask(): number;
        set renderLayerMask(value: number);
        private _globalShaderData;
        get globalShaderData(): GLESShaderData;
        set globalShaderData(value: GLESShaderData);
    }
    class RTRenderStruct2D implements IRenderStruct2D {
        _nativeObj: any;
        owner: Sprite;
        private _dcOptimize;
        get dcOptimize(): boolean;
        set dcOptimize(value: boolean);
        get inheritedDcOptimize(): boolean;
        private _zIndex;
        set zIndex(value: number);
        get zIndex(): number;
        private _stackingRoot;
        set stackingRoot(value: boolean);
        get stackingRoot(): boolean;
        private _enableCulling;
        get enableCulling(): boolean;
        set enableCulling(value: boolean);
        get inheritedEnableCulling(): boolean;
        private _rect;
        set rect(value: Rectangle);
        get rect(): Rectangle;
        private _renderLayer;
        set renderLayer(value: number);
        get renderLayer(): number;
        private _subStruct;
        get subStruct(): RTRenderStruct2D;
        set subStruct(value: RTRenderStruct2D);
        private _parent;
        set parent(value: RTRenderStruct2D);
        get parent(): RTRenderStruct2D | null;
        private _children;
        get children(): RTRenderStruct2D[];
        set children(value: RTRenderStruct2D[]);
        private _renderType;
        set renderType(value: number);
        get renderType(): number;
        private _renderUpdateMask;
        set renderUpdateMask(value: number);
        get renderUpdateMask(): number;
        private _renderMatrix;
        set renderMatrix(value: Matrix);
        get renderMatrix(): Matrix;
        private _globalAlpha;
        set globalAlpha(value: number);
        get globalAlpha(): number;
        private _alpha;
        get alpha(): number;
        set alpha(value: number);
        private _blendMode;
        get blendMode(): BlendMode;
        set blendMode(value: BlendMode);
        private _enabled;
        get enabled(): boolean;
        set enabled(value: boolean);
        private _isRenderStruct;
        get isRenderStruct(): boolean;
        set isRenderStruct(value: boolean);
        private _renderElements;
        set renderElements(value: IRenderElement2D[]);
        get renderElements(): IRenderElement2D[];
        private _spriteShaderData;
        set spriteShaderData(value: GLESShaderData);
        get spriteShaderData(): GLESShaderData;
        private _renderDataHandler;
        get renderDataHandler(): RTRender2DDataHandle;
        set renderDataHandler(value: RTRender2DDataHandle);
        private _globalRenderData;
        set globalRenderData(value: RTGlobalRenderData);
        get globalRenderData(): RTGlobalRenderData;
        private _pass;
        get pass(): RTRender2DPass;
        set pass(value: RTRender2DPass);
        constructor();
        setRenderUpdateCallback(func: Function): void;
        setClipRect(rect: Rectangle): void;
        setRepaint(): void;
        addChild(child: RTRenderStruct2D, index: number): void;
        updateChildIndex(child: RTRenderStruct2D, oldIndex: number, index: number): void;
        removeChild(child: RTRenderStruct2D): void;
        destroy(): void;
    }
    class NativeBounds implements IClone {
        /**native Share Memory */
        static MemoryBlock_size: number;
        /**@internal	*/
        nativeMemory: NativeMemory;
        /**@internal	*/
        float32Array: Float32Array;
        /**@internal	*/
        _nativeObj: any;
        /**@internal	*/
        _center: Vector3;
        /**@internal	*/
        _extent: Vector3;
        /**@internal */
        private _boundBox;
        get min(): Vector3;
        set min(value: Vector3);
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * 设置包围盒的最小点。
         * @param value	包围盒的最小点。
         */
        setMin(value: Vector3): void;
        /**
         * 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * 设置包围盒的最大点。
         * @param value	包围盒的最大点。
         */
        setMax(value: Vector3): void;
        /**
         * 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * 设置包围盒的中心点。
         * @param value	包围盒的中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * 设置包围盒的范围。
         * @param value	包围盒的范围。
         */
        setExtent(value: Vector3): void;
        /**
         * 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * 创建一个 <code>Bounds</code> 实例。
         * @param min  min 最小坐标
         * @param max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        /**
         * @internal
         */
        _tranform(matrix: Matrix4x4, out: NativeBounds): void;
        _getBoundBox(): BoundBox;
        /**
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: Bounds): number;
        /**
         * 克隆。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: NativeBounds): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): NativeBounds;
    }
    class RTCameraNodeData implements ICameraNodeData {
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get farplane(): number;
        set farplane(value: number);
        get nearplane(): number;
        set nearplane(value: number);
        get fieldOfView(): number;
        set fieldOfView(value: number);
        get aspectRatio(): number;
        set aspectRatio(value: number);
        _nativeObj: any;
        constructor();
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    class RTSceneNodeData implements ISceneNodeData {
        get lightmapDirtyFlag(): number;
        set lightmapDirtyFlag(value: number);
        _nativeObj: any;
        constructor();
    }
    class RT3DRenderModuleFactory implements I3DRenderModuleFactory {
        createTransform(owner: Sprite3D): RTTransform3D;
        createBounds(min: Vector3, max: Vector3): NativeBounds;
        createVolumetricGI(): RTVolumetricGI;
        createReflectionProbe(): RTReflectionProb;
        createLightmapData(): RTLightmapData;
        createDirectLight(): RTDirectLight;
        createSpotLight(): RTSpotLight;
        createPointLight(): IPointLightData;
        createCameraModuleData(): RTCameraNodeData;
        createSceneModuleData(): RTSceneNodeData;
        createBaseRenderNode(): RTBaseRenderNode;
        createMeshRenderNode(): RTMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
    }
    class RTBaseRenderNode implements IBaseRenderNode {
        renderelements: IRenderElement3D[];
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get distanceForSort(): number;
        set distanceForSort(value: number);
        get sortingFudge(): number;
        set sortingFudge(value: number);
        get castShadow(): boolean;
        set castShadow(value: boolean);
        get enable(): boolean;
        set enable(value: boolean);
        get renderbitFlag(): number;
        set renderbitFlag(value: number);
        get layer(): number;
        set layer(value: number);
        private _bounds;
        get bounds(): Bounds;
        set bounds(value: Bounds);
        private _baseGeometryBounds;
        get baseGeometryBounds(): Bounds;
        set baseGeometryBounds(value: Bounds);
        get boundsChange(): boolean;
        set boundsChange(value: boolean);
        get customCull(): boolean;
        set customCull(value: boolean);
        get customCullResoult(): boolean;
        set customCullResoult(value: boolean);
        get staticMask(): number;
        set staticMask(value: number);
        private _shaderData;
        get shaderData(): ShaderData;
        set shaderData(value: ShaderData);
        get lightmapIndex(): number;
        set lightmapIndex(value: number);
        private _lightmap;
        get lightmap(): RTLightmapData;
        set lightmap(value: RTLightmapData);
        private _probeReflection;
        get probeReflection(): RTReflectionProb;
        set probeReflection(value: RTReflectionProb);
        get reflectionMode(): number;
        set reflectionMode(value: number);
        private _volumetricGI;
        get volumetricGI(): RTVolumetricGI;
        set volumetricGI(value: RTVolumetricGI);
        get lightProbUpdateMark(): number;
        set lightProbUpdateMark(value: number);
        private _irradientMode;
        get irradientMode(): IrradianceMode;
        set irradientMode(value: IrradianceMode);
        private _caculateBoundingBoxbindFun;
        private _renderUpdatePrebindFun;
        /**
         * 设置更新数据
         * @param call
         * @param fun
         */
        set_renderUpdatePreCall(call: any, fun: any): void;
        /**
         * 设置更新包围盒方法
         * @param call
         * @param fun
         */
        set_caculateBoundingBox(call: any, fun: any): void;
        _nativeObj: any;
        /**@internal */
        _defaultBaseGeometryBounds: Bounds;
        protected _getNativeObj(): void;
        private _additionShaderData;
        get additionShaderData(): Map<string, ShaderData>;
        set additionShaderData(value: Map<string, ShaderData>);
        constructor();
        ismoved: Vector2;
        private _worldParams;
        setNodeCustomData(dataSlot: ENodeCustomData, data: number): void;
        get renderNodeType(): number;
        set renderNodeType(value: number);
        get receiveShadow(): boolean;
        set receiveShadow(value: boolean);
        _applyLightProb(): void;
        _applyReflection(): void;
        setRenderelements(value: IRenderElement3D[]): void;
        setLightmapScaleOffset(value: Vector4): void;
        setCommonUniformMap(value: string[]): void;
        setOneMaterial(index: number, mat: Material): void;
        destroy(): void;
    }
    class RTDirectLight implements IDirectLightData {
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
        _nativeObj: any;
        constructor();
    }
    class RTLightmapData implements ILightMapData {
        /**@internal */
        _lightmapColor: InternalTexture;
        /**@internal */
        _lightmapDirection: InternalTexture;
        _nativeObj: any;
        constructor();
        get lightmapColor(): InternalTexture;
        set lightmapColor(value: InternalTexture);
        get lightmapDirection(): InternalTexture;
        set lightmapDirection(value: InternalTexture);
        destroy(): void;
    }
    class RTMeshRenderNode extends RTBaseRenderNode implements RTMeshRenderNode {
    }
    class RTPointLight implements IPointLightData {
        _nativeObj: any;
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get range(): number;
        set range(value: number);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        constructor();
    }
    class RTReflectionProb implements IReflectionProbeData {
        private static _idCounter;
        /** @internal */
        _id: number;
        get boxProjection(): boolean;
        set boxProjection(value: boolean);
        private _bound;
        get bound(): Bounds;
        set bound(value: Bounds);
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        private _reflectionTexture;
        get reflectionTexture(): InternalTexture;
        set reflectionTexture(value: InternalTexture);
        private _iblTex;
        get iblTex(): InternalTexture;
        set iblTex(value: InternalTexture);
        get updateMark(): number;
        set updateMark(value: number);
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        setProbePosition(value: Vector3): void;
        setAmbientColor(value: Color): void;
        /**@internal */
        private _ambientSH;
        setAmbientSH(value: Float32Array): void;
        _nativeObj: any;
        constructor();
        private _shaderData;
        get shaderData(): ShaderData;
        set shaderData(value: ShaderData);
        destroy(): void;
    }
    class RTScene3DRenderManager implements ISceneRenderManager {
        _nativeObj: any;
        /** @internal */
        _list: SingletonList<BaseRender>;
        /**
        * @en The list of render objects.
        * @zh 渲染对象列表。
        */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        private _addBaseRenderNode;
        private _removeBaseRenderNode;
        private _clearBaseRenderNode;
        addRenderObject(object: BaseRender): void;
        removeRenderObject(object: BaseRender): void;
        removeMotionObject(object: BaseRender): void;
        addMotionObject(object: BaseRender): void;
        updateMotionObjects(): void;
        destroy(): void;
        constructor();
    }
    class RTSimpleSkinRenderNode extends RTBaseRenderNode implements ISimpleSkinRenderNode {
        private _nativeMemory;
        private _float32Array;
        setSimpleAnimatorParams(value: Vector4): void;
        protected _getNativeObj(): void;
        constructor();
    }
    /**
     * 骨骼动画渲染节点，包含骨骼数据计算
     */
    class RTSkinRenderNode extends RTBaseRenderNode implements ISkinRenderNode {
        private boneNums;
        protected _getNativeObj(): void;
        constructor();
        computeSkinnedData(): void;
        setRootBoneTransfom(value: Sprite3D): void;
        setOwnerTransform(value: Sprite3D): void;
        setCacheMesh(cacheMesh: Mesh): void;
        setBones(value: Sprite3D[]): void;
        setSkinnedData(value: Array<Float32Array[]>): void;
    }
    class RTSpotLight implements ISpotLightData {
        private _transform;
        get transform(): RTTransform3D;
        set transform(value: RTTransform3D);
        get shadowResolution(): number;
        set shadowResolution(value: number);
        get shadowDistance(): number;
        set shadowDistance(value: number);
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        get shadowStrength(): number;
        set shadowStrength(value: number);
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        get spotRange(): number;
        set spotRange(value: number);
        get spotAngle(): number;
        set spotAngle(value: number);
        _nativeObj: any;
        constructor();
        setDirection(value: Vector3): void;
    }
    class RTTransform3D extends Transform3D {
        /**@internal */
        static TRANSFORM_LOCALQUATERNION_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_LOCALEULER_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_LOCALPOS_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_LOCALSCALE_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_LOCALMATRIX_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_WORLDQUATERNION_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_WORLDEULER_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_WORLDPOS_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_WORLDSCALE_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_WORLDMATRIX_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_CHANGEFLAG_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_RT_SYNC_FLAG_DATAOFFSET: number;
        /**@internal */
        static TRANSFORM_SHARE_MEMORY_SIZE: number;
        /** @internal */
        protected _owner: Sprite3D;
        /** @internal */
        protected _localPosition: Vector3;
        /** @internal */
        protected _localRotation: Quaternion;
        /** @internal */
        protected _localScale: Vector3;
        /**@internal */
        protected _localRotationEuler: Vector3;
        /** @internal */
        protected _localMatrix: Matrix4x4;
        /** @internal */
        protected _position: Vector3;
        /** @internal */
        protected _rotation: Quaternion;
        /** @internal */
        protected _scale: Vector3;
        /**@internal */
        protected _rotationEuler: Vector3;
        /** @internal */
        protected _worldMatrix: Matrix4x4;
        /**@internal runtime同步标记*/
        _rtSyncFlag: number;
        /**@internal 如果为true 表示自身相对于父节点并无任何改变，将通过这个参数忽略计算*/
        protected _isDefaultMatrix: boolean;
        /**@internal */
        protected _faceInvert: boolean;
        /**@internal */
        protected _frontFaceValue: number;
        /**native Share Memory */
        private _nativeMemory;
        private _nativeFloat32Buffer;
        private _nativeUInt32Buffer;
        _nativeObj: any;
        constructor(owner: Sprite3D);
        protected _initProperty(): void;
        /**
         * 是否未DefaultMatrix
         */
        get isDefaultMatrix(): boolean;
        /**
         * @internal
         */
        protected _setTransformFlag(type: number, value: boolean): void;
        /**
         * @internal
         */
        protected _getTransformFlag(type: number): boolean;
        /**
         * @internal
         */
        protected _getRTSyncFlag(type: number): boolean;
        protected _setRTSyncFlag(type: number, value: boolean): void;
        get _RTtransformFlag(): number;
        /**
         * 局部位置X轴分量。
         */
        get localPositionX(): number;
        set localPositionX(x: number);
        /**
         * 局部位置Y轴分量。
         */
        get localPositionY(): number;
        set localPositionY(y: number);
        /**
         * 局部位置Z轴分量。
         */
        get localPositionZ(): number;
        set localPositionZ(z: number);
        /**
         * 局部位置。
         */
        get localPosition(): Vector3;
        set localPosition(value: Vector3);
        /**
         * 局部旋转。
         */
        get localRotation(): Quaternion;
        set localRotation(value: Quaternion);
        /**
         * 局部缩放X。
         */
        get localScaleX(): number;
        set localScaleX(value: number);
        /**
         * 局部缩放Y。
         */
        get localScaleY(): number;
        set localScaleY(value: number);
        /**
         * 局部缩放Z。
         */
        get localScaleZ(): number;
        set localScaleZ(value: number);
        /**
         * 局部缩放。
         */
        get localScale(): Vector3;
        set localScale(value: Vector3);
        /**
         * 局部空间欧拉角。
         */
        get localRotationEuler(): Vector3;
        set localRotationEuler(value: Vector3);
        /**
         * 局部矩阵。
         */
        get localMatrix(): Matrix4x4;
        set localMatrix(value: Matrix4x4);
        /**
         * 世界位置。
         */
        get position(): Vector3;
        set position(value: Vector3);
        /**
         * 世界旋转。
         */
        get rotation(): Quaternion;
        set rotation(value: Quaternion);
        /**
         * 世界空间的旋转角度，顺序为x、y、z。
         */
        get rotationEuler(): Vector3;
        set rotationEuler(value: Vector3);
        /**
         * 世界矩阵。
         */
        get worldMatrix(): Matrix4x4;
        set worldMatrix(value: Matrix4x4);
        /**
         * @internal
         */
        _setParent(value: Transform3D): void;
        /**
         * @internal
         */
        protected _onWorldPositionRotationTransform(): void;
        /**
         * @internal
         */
        protected _onWorldPositionScaleTransform(): void;
        /**
         * @internal
         */
        protected _onWorldPositionTransform(): void;
        /**
         * @internal
         */
        protected _onWorldRotationTransform(): void;
        /**
         * @internal
         */
        protected _onWorldScaleTransform(): void;
        /**
         * @internal
         */
        _onWorldTransform(): void;
        /**
         * 平移变换。
         * @param translation 移动距离。
         * @param isLocal 是否局部空间。
         */
        translate(translation: Vector3, isLocal?: boolean): void;
        /**
         * 旋转变换。
         * @param rotation 旋转幅度。
         * @param isLocal 是否局部空间。
         * @param isRadian 是否弧度制。
         */
        rotate(rotation: Vector3, isLocal?: boolean, isRadian?: boolean): void;
        getWorldLossyScale(): Vector3;
        setWorldLossyScale(value: Vector3): void;
    }
    class RTVolumetricGI implements IVolumetricGIData {
        private static _idCounter;
        _id: number;
        private _irradiance;
        get irradiance(): InternalTexture;
        set irradiance(value: InternalTexture);
        private _distance;
        get distance(): InternalTexture;
        set distance(value: InternalTexture);
        private _bound;
        get bound(): Bounds;
        set bound(value: Bounds);
        get intensity(): number;
        set intensity(value: number);
        get updateMark(): number;
        set updateMark(value: number);
        /**@internal */
        _nativeObj: any;
        /**@internal */
        _defaultBounds: Bounds;
        _shaderData: ShaderData;
        set shaderData(value: ShaderData);
        get shaderData(): ShaderData;
        constructor();
        setParams(value: Vector4): void;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
        destroy(): void;
    }
    /**
     * 共享内存分配,并且绑定Native共享Buffer
     */
    class CommonMemoryAllocater {
        /**
         * 创建内存，并绑定为共享内存
         * @param size
         * @returns
         */
        static creatBlock(size: number): ArrayBuffer;
        /**
         * 释放共享内存
         * @param buffer
         */
        static freeMemoryBlock(buffer: ArrayBuffer): void;
    }
    class NativeMemory {
        static NativeSourceID: number;
        /**@internal 共享内存数据 */
        _buffer: ArrayBuffer;
        /**@internal 显示数据 */
        static _sharedBuffer: ArrayBuffer;
        /**@internal 显示数据 */
        protected _idata: Int32Array;
        protected _uidata: Uint32Array;
        protected _uint16data: Uint16Array;
        protected _fdata: Float32Array;
        protected _byteArray: Uint8Array;
        /**数据长度 */
        protected _byteLength: number;
        /**销毁标记 */
        protected _destroyed: boolean;
        /**数据资源 */
        protected _id: number;
        /**
         * 实例化一个共享内存
         * @param size byteLength
         */
        constructor(size: number, shared: boolean);
        /**
         * Float32Array Data
         */
        get float32Array(): Float32Array;
        /**
         * Uint8Array Data
         */
        get uint8Array(): Uint8Array;
        /**
         * Int32Array Data
         */
        get int32Array(): Int32Array;
        get Uint32Array(): Uint32Array;
        /**
         * Int32Array Data
         */
        get Uint16Array(): Uint16Array;
        /**
         * 删除
         * @returns
         */
        destroy(): void;
        /**
         * 清楚
         */
        clear(): void;
    }
    class RTDefineDatas implements IDefineDatas {
        _nativeObj: any;
        constructor();
        get _length(): number;
        set _length(value: number);
        get _mask(): number[];
        set _mask(value: number[]);
        /**
         * @internal
         */
        _intersectionDefineDatas(define: RTDefineDatas): void;
        add(define: RTShaderDefine): void;
        remove(define: RTShaderDefine): void;
        addDefineDatas(define: RTDefineDatas): void;
        removeDefineDatas(define: RTDefineDatas): void;
        has(define: RTShaderDefine): boolean;
        clear(): void;
        cloneTo(destObject: RTDefineDatas): void;
        clone(): RTDefineDatas;
        destroy(): void;
    }
    class RTRenderState extends RenderState {
        _nativeObj: any;
        set cull(value: number);
        get cull(): number;
        set blend(value: number);
        get blend(): number;
        set srcBlend(value: number);
        get srcBlend(): number;
        set dstBlend(value: number);
        get dstBlend(): number;
        set srcBlendRGB(value: number);
        get srcBlendRGB(): number;
        set dstBlendRGB(value: number);
        get dstBlendRGB(): number;
        set srcBlendAlpha(value: number);
        get srcBlendAlpha(): number;
        set dstBlendAlpha(value: number);
        get dstBlendAlpha(): number;
        set blendEquation(value: number);
        get blendEquation(): number;
        set blendEquationRGB(value: number);
        get blendEquationRGB(): number;
        set blendEquationAlpha(value: number);
        get blendEquationAlpha(): number;
        set depthTest(value: number);
        get depthTest(): number;
        set depthWrite(value: boolean);
        get depthWrite(): boolean;
        set stencilWrite(value: boolean);
        get stencilWrite(): boolean;
        set stencilTest(value: number);
        get stencilTest(): number;
        set stencilRef(value: number);
        get stencilRef(): number;
        set stencilOp(value: Vector3);
        get stencilOp(): Vector3;
        /** 模板写入掩码 */
        get stencilWriteMask(): number;
        set stencilWriteMask(value: number);
        /** 模板读取掩码 */
        get stencilReadMask(): number;
        set stencilReadMask(value: number);
        /** 是否开启深度偏移 */
        get depthBias(): boolean;
        set depthBias(value: boolean);
        /** 深度偏移常量 */
        get depthBiasConstant(): number;
        set depthBiasConstant(value: number);
        /** 深度偏移斜率缩放 */
        get depthBiasSlopeScale(): number;
        set depthBiasSlopeScale(value: number);
        /** 深度偏移限制值 */
        get depthBiasClamp(): number;
        set depthBiasClamp(value: number);
        setNull(): void;
        protected createObj(): void;
        constructor();
        cloneTo(dest: RTRenderState): void;
        clone(): RenderState;
    }
    class RTShaderDefine extends ShaderDefine {
        constructor(index: number, value: number);
    }
    class RTShaderPass implements IShaderPassData {
        private _validDefine;
        private _createShaderInstanceFun;
        _nativeObj: any;
        static _globalCompileDefine: RTDefineDatas;
        is2D: boolean;
        private _pass;
        constructor(pass: ShaderPass);
        name: string;
        private _additionShaderData;
        get additionShaderData(): string[];
        set additionShaderData(value: string[]);
        private _nodeCommonMap;
        get nodeCommonMap(): string[];
        set nodeCommonMap(value: string[]);
        attributeLocations: Set<number>;
        /** @internal */
        static getGlobalCompileDefine(): RTDefineDatas;
        get statefirst(): boolean;
        set statefirst(value: boolean);
        private _renderState;
        get renderState(): RenderState;
        set renderState(value: RenderState);
        get pipelineMode(): string;
        set pipelineMode(value: string);
        get validDefine(): RTDefineDatas;
        set validDefine(value: RTDefineDatas);
        nativeCreateShaderInstance(): any;
        destroy(): void;
        setCacheShader(defines: IDefineDatas, shaderInstance: IShaderInstance): void;
        getCacheShader(defines: IDefineDatas): IShaderInstance;
    }
    class RTStatisContext extends DefaultStaticsContext {
        private _nativeObj;
        protected _stateArrayMemory: NativeMemory;
        protected _timeArrayMemory: NativeMemory;
        constructor();
        protected _createStatBuffer(): void;
    }
    class RTSubShader implements ISubshaderData {
        _nativeObj: any;
        constructor();
        private _shaderName;
        get shaderName(): string;
        set shaderName(value: string);
        setUniformMap(_uniformMap: Map<number, UniformProperty>): void;
        get enableInstance(): boolean;
        set enableInstance(value: boolean);
        destroy(): void;
        addShaderPass(pass: RTShaderPass): void;
    }
    class RTUintRenderModuleDataFactory implements IUnitRenderModuleDataFactory {
        createSubShader(): RTSubShader;
        createShaderPass(pass: ShaderPass): RTShaderPass;
        createRenderState(): RTRenderState;
        createDefineDatas(): RTDefineDatas;
    }
    /**
     * @ignore
     */
    interface IBatch2DProvider {
        /**合批范围，合批的RenderElement2D直接add进list中 */
        batch(list: FastSinglelist<IRenderElement2D>, start: number, end: number, allowReorder?: boolean): void;
        reset(): void;
        destroy(): void;
    }
    /**
     * @ignore
     * 合批管理
     */
    class BatchManager {
        /**
         *
         */
        static readonly registry: Record<number, new () => IBatch2DProvider>;
        /**
         * 注册渲染节点之间的合批。根据不同的RenderNode注册合批方式，来优化性能
         * @param renderElementType
         * @param batch
         */
        static registerProvider(renderType: number, cls: new () => IBatch2DProvider): void;
        static createProvider(renderType: number): IBatch2DProvider;
    }
    abstract class Web2DGraphicWholeBuffer implements I2DGraphicWholeBuffer {
        buffer: IIndexBuffer | IVertexBuffer;
        _dataView: Float32Array | Uint16Array;
        arrayBuffer: ArrayBuffer;
        _needResetData: boolean;
        _inPass: boolean;
        protected _num: number;
        /** @internal */
        _first: Web2DGraphicsBufferDataView;
        /** @internal */
        _last: Web2DGraphicsBufferDataView;
        /** @internal */
        _updateRange: Vector2;
        abstract resetData(byteLength: number): void;
        abstract _upload(): void;
        _modifyOneView(view: Web2DGraphicsBufferDataView): void;
        addDataView(view: Web2DGraphicsBufferDataView): void;
        removeDataView(view: Web2DGraphicsBufferDataView): void;
        destroy(): void;
    }
    class Web2DGraphicsVertexBuffer extends Web2DGraphicWholeBuffer {
        buffer: IVertexBuffer;
        _dataView: Float32Array;
        /** @internal */
        _first: Web2DGraphic2DVertexDataView;
        /** @internal */
        _last: Web2DGraphic2DVertexDataView;
        resetData(byteLength: number): void;
        _upload(): void;
    }
    class Web2DGraphicsIndexBuffer extends Web2DGraphicWholeBuffer {
        buffer: IIndexBuffer;
        _dataView: Uint16Array;
        /** @internal */
        _first: Web2DGraphic2DIndexDataView;
        /** @internal */
        _last: Web2DGraphic2DIndexDataView;
        resetData(byteLength: number): void;
        _upload(): void;
        _modifyOneView(view: Web2DGraphic2DIndexDataView): void;
    }
    class Web2DGraphicsIndexBatchBuffer extends Web2DGraphicsIndexBuffer {
        _first: Web2DGraphic2DIndexCloneDataView;
        _last: Web2DGraphic2DIndexCloneDataView;
        /** @internal */
        _upload(): void;
        _modifyOneView(view: Web2DGraphic2DIndexCloneDataView): void;
        clearBufferViews(): void;
        _resetData(byteLength: number): void;
    }
    abstract class Web2DGraphicsBufferDataView implements I2DGraphicBufferDataView {
        abstract setData(data: ArrayLike<number>): void;
        /** IB 的 start 不可信，只有在提交时百分百正确 */
        start: number;
        length: number;
        owner: Web2DGraphicWholeBuffer;
        /** @internal */
        _next: Web2DGraphicsBufferDataView;
        /** @internal */
        _prev: Web2DGraphicsBufferDataView;
    }
    class Web2DGraphic2DVertexDataView extends Web2DGraphicsBufferDataView implements I2DGraphicVertexDataView {
        private _view;
        stride: number;
        owner: Web2DGraphicsVertexBuffer;
        /** @internal */
        _next: Web2DGraphic2DVertexDataView;
        /** @internal */
        _prev: Web2DGraphic2DVertexDataView;
        /**
         * @internal
         * @returns
         */
        _getData(): Float32Array;
        /** @private */
        _modify(): void;
        _updateView(wholeData: Float32Array): void;
        setData(data: ArrayLike<number>): void;
        constructor(owner: Web2DGraphicsVertexBuffer, start: number, length: number, stride?: number);
    }
    class Web2DGraphic2DIndexDataView extends Web2DGraphicsBufferDataView implements I2DGraphicIndexDataView {
        protected _view: Uint16Array;
        owner: Web2DGraphicsIndexBuffer;
        _geometry: IRenderGeometryElement;
        setGeometry(value: IRenderGeometryElement): void;
        /** @internal */
        _next: Web2DGraphic2DIndexDataView;
        /** @internal */
        _prev: Web2DGraphic2DIndexDataView;
        setData(data: Float32Array | Uint16Array): void;
        constructor(owner: Web2DGraphicsIndexBuffer, length: number, create?: boolean);
        _updateView(wholeData: Uint16Array): void;
        /** @private */
        _modify(): void;
        /**
         * 只有 IB 的能clone
         * @param cloneOwner
         * @param create
         * @returns
         */
        _clone(cloneOwner?: boolean, create?: boolean): Web2DGraphic2DIndexCloneDataView;
        /**
         * 克隆视图
         * @param view
         */
        _cloneView(view: Web2DGraphic2DIndexDataView): void;
        destroy(): void;
    }
    class Web2DGraphic2DIndexCloneDataView extends Web2DGraphic2DIndexDataView {
        /** @internal */
        owner: Web2DGraphicsIndexBatchBuffer;
        _next: Web2DGraphic2DIndexCloneDataView;
        _prev: Web2DGraphic2DIndexCloneDataView;
        /** @internal */
        destroy(): void;
    }
    class BatchBuffer {
        indexBuffer: IIndexBuffer;
        wholeBuffer: Web2DGraphicsIndexBatchBuffer;
        indexCount: number;
        maxIndexCount: number;
        bufferStates: Map<IVertexBuffer, IBufferState>;
        constructor();
        _addWebgl(element: IPrimitiveRenderElement2D): IRenderGeometryElement;
        _addWebgpu(element: IPrimitiveRenderElement2D): IRenderGeometryElement;
        add(element: IPrimitiveRenderElement2D): IRenderGeometryElement;
        updateBufLength(): void;
        bindBuffer(buffer: IVertexBuffer): IBufferState;
        clear(): void;
        destroy(): void;
    }
    class BatchContext {
        /** 批次使用的贴图ID */
        textureId: number;
        /** 批次的透明度 */
        globalAlpha: number;
        /** 批次的clip信息 */
        clipInfo: any;
        /** 批次的shader */
        subShader: any;
        /** 批次的bufferState */
        bufferState: any;
        primitiveShaderData: any;
        materialShaderData: any;
        type: number;
        lowType: number;
        globalRenderData: any;
        fillTexture: boolean;
        texRange: Vector4;
        constructor();
        _setHeadWebgl(element: IPrimitiveRenderElement2D): void;
        _setHeadWebgpu(element: IPrimitiveRenderElement2D): void;
        /**
         * 从渲染元素初始化批次上下文
         */
        setHead(element: IPrimitiveRenderElement2D): void;
        /**
         * @internal WebGL 检查元素是否与批次兼容
         */
        _isCompatibleWebgl(element: IPrimitiveRenderElement2D): boolean;
        /**
         * @internal WebGPU 检查元素是否与批次兼容
         */
        _isCompatibleWebgpu(element: IPrimitiveRenderElement2D): boolean;
        /**
         * 检查元素是否与批次兼容
         */
        isCompatible(element: IPrimitiveRenderElement2D): boolean;
    }
    /**
     * @ignore
     */
    class WebGraphicsBatch implements IBatch2DProvider {
        _buffer: BatchBuffer;
        _merged: Array<IPrimitiveRenderElement2D>;
        _context: BatchContext;
        static readonly _pool: IPool<IPrimitiveRenderElement2D>;
        constructor();
        reset(): void;
        destroy(): void;
        batch(list: FastSinglelist<IPrimitiveRenderElement2D>, start: number, end: number, allowReorder?: boolean): void;
        private addSingle;
        private merge;
    }
    /**
     * @ignore
     */
    class WebRender2DPass implements IRender2DPass {
        static buffers: Set<Web2DGraphicWholeBuffer>;
        private _renderElements;
        private _elementGroups;
        private _structs;
        private _structsPool;
        private _pStructs;
        private _batchProviders;
        _priority: number;
        get priority(): number;
        set priority(value: number);
        enable: boolean;
        isSupport: boolean;
        renderTexture: RenderTexture2D;
        postProcess: PostProcess2D;
        repaint: boolean;
        _clearColor: Color;
        doClearColor: boolean;
        finalize: CommandBuffer2D;
        private _mask;
        get mask(): WebRenderStruct2D;
        set mask(value: WebRenderStruct2D);
        private _enableBatch;
        /** 需要挪出去? */
        get enableBatch(): boolean;
        set enableBatch(value: boolean);
        setClearColor(r: number, g: number, b: number, a: number): void;
        private _rtsize;
        root: WebRenderStruct2D;
        /**
         * rt渲染偏移
         **/
        offsetMatrix: Matrix;
        private _invertMat_0;
        private _invertMat_1;
        shaderData: ShaderData;
        destroyed: boolean;
        constructor();
        /**
          * 判断是否需要更新渲染
          * @returns 是否需要更新
          */
        needRender(): boolean;
        cullAndSort(context2D: IRenderContext2D, struct: WebRenderStruct2D): void;
        private _isRectIntersect;
        /**
         * pass 2D 渲染
         * @param context
         */
        fowardRender(context: IRenderContext2D): void;
        private fillRenderElements;
        private batch;
        private getBatchProvider;
        private _initRenderProcess;
        static setBuffer(buffer: Web2DGraphicWholeBuffer): void;
        static uploadBuffer(): void;
        private _updateInvertMatrix;
        private _setInvertMatrix;
        destroy(): void;
    }
    class WebRender2DPassManager implements IRender2DPassManager {
        private _modify;
        private _passes;
        removePass(pass: WebRender2DPass): void;
        apply(context: IRenderContext2D): void;
        clear(): void;
        addPass(pass: WebRender2DPass): void;
    }
    abstract class WebRender2DDataHandle implements IRender2DDataHandle {
        protected _owner: WebRenderStruct2D;
        get owner(): WebRenderStruct2D;
        set owner(value: WebRenderStruct2D);
        protected _nMatrix_0: Vector3;
        protected _nMatrix_1: Vector3;
        constructor();
        private _needUseMatrix;
        get needUseMatrix(): boolean;
        set needUseMatrix(value: boolean);
        destroy(): void;
        inheriteRenderData(context: IRenderContext2D): void;
    }
    class WebGraphics2DBufferBlock implements IGraphics2DBufferBlock {
        vertexs: IGraphics2DVertexBlock[];
        indexView: I2DGraphicIndexDataView;
        vertexBuffer: IVertexBuffer;
    }
    class WebGraphics2DVertexBlock implements IGraphics2DVertexBlock {
        positions: number[];
        vertexViews: I2DGraphicVertexDataView[];
    }
    class WebPrimitiveDataHandle extends WebRender2DDataHandle implements I2DPrimitiveDataHandle {
        mask: WebRenderStruct2D | null;
        private _bufferBlocks;
        private _needUpdateBuffer;
        private _modifiedFrame;
        private _clonesViews;
        applyVertexBufferBlock(blocks: IGraphics2DBufferBlock[]): void;
        /** @internal */
        _getBlocks(): IGraphics2DBufferBlock[];
        inheriteRenderData(context: IRenderContext2D): void;
        getCloneViews(): Web2DGraphic2DIndexCloneDataView[];
        updateCloneView(): void;
        private _cloneView;
        destroy(): void;
    }
    class Web2DBaseRenderDataHandle extends WebRender2DDataHandle implements I2DBaseRenderDataHandle {
        private _lightReceive;
        get lightReceive(): boolean;
        set lightReceive(value: boolean);
        get owner(): WebRenderStruct2D;
        set owner(value: WebRenderStruct2D);
    }
    class WebMesh2DRenderDataHandle extends Web2DBaseRenderDataHandle implements IMesh2DRenderDataHandle {
        private _baseColor;
        private _baseTexture;
        private _normal2DTexture;
        private _renderAlpha;
        get baseColor(): Color;
        set baseColor(value: Color);
        get baseTexture(): BaseTexture;
        set baseTexture(value: BaseTexture);
        get normal2DTexture(): BaseTexture;
        set normal2DTexture(value: BaseTexture);
        private _normal2DStrength;
        get normal2DStrength(): number;
        set normal2DStrength(value: number);
        inheriteRenderData(context: IRenderContext2D): void;
    }
    class WebSpineRenderDataHandle extends Web2DBaseRenderDataHandle implements ISpineRenderDataHandle {
        private _renderAlpha;
        private _baseColor;
        get baseColor(): Color;
        set baseColor(value: Color);
        skeleton: spine.Skeleton;
        private _offset;
        get owner(): WebRenderStruct2D;
        set owner(value: WebRenderStruct2D);
        get offset(): Vector2;
        set offset(value: Vector2);
        inheriteRenderData(context: IRenderContext2D): void;
    }
    class WebGlobalRenderData implements I2DGlobalRenderData {
        cullRect: Vector4;
        renderLayerMask: number;
        globalShaderData: ShaderData;
    }
    interface StructTransform {
        matrix: Matrix;
        modifiedFrame: number;
    }
    class WebRenderStruct2D implements IRenderStruct2D {
        owner: Sprite;
        zIndex: number;
        _effectZ: number;
        stackingRoot: boolean;
        rect: Rectangle;
        private _enableCulling;
        private _parentEnableCulling;
        get enableCulling(): boolean;
        set enableCulling(value: boolean);
        get inheritedEnableCulling(): boolean;
        renderLayer: number;
        parent: WebRenderStruct2D | null;
        children: WebRenderStruct2D[];
        /** 按标记来 */
        renderType: number;
        renderUpdateMask: number;
        /** @internal */
        _dcOptimize: boolean;
        private _parentDcOptimize;
        get dcOptimize(): boolean;
        set dcOptimize(value: boolean);
        get inheritedDcOptimize(): boolean;
        dcOptimizeEnd: WebRenderStruct2D;
        get renderMatrix(): Matrix;
        set renderMatrix(value: Matrix);
        trans: StructTransform;
        globalAlpha: number;
        private _alpha;
        get alpha(): number;
        set alpha(value: number);
        private _blendMode;
        private _parentBlendMode;
        get blendMode(): BlendMode;
        set blendMode(value: BlendMode);
        /** @internal */
        needUploadClip: number;
        /** @internal */
        needUploadAlpha: boolean;
        /** 是否启动 */
        enabled: boolean;
        isRenderStruct: boolean;
        renderElements: IRenderElement2D[];
        spriteShaderData: ShaderData;
        private _renderDataHandler;
        get renderDataHandler(): WebRender2DDataHandle;
        set renderDataHandler(value: WebRender2DDataHandle);
        /** @internal */
        _globalShaderData: ShaderData;
        /** @internal */
        private _globalRenderData;
        /** @internal */
        _parentGlobalRenderData: WebGlobalRenderData;
        get globalRenderData(): WebGlobalRenderData;
        set globalRenderData(value: WebGlobalRenderData);
        /** @internal */
        _pass: WebRender2DPass;
        private _parentPass;
        get pass(): WebRender2DPass;
        set pass(value: WebRender2DPass);
        private _subStruct;
        get subStruct(): WebRenderStruct2D;
        set subStruct(value: WebRenderStruct2D);
        constructor();
        /** @internal */
        _clipRect: Rectangle;
        /** @internal */
        _parentClipInfo: IClipInfo;
        /** @internal */
        _clipInfo: IClipInfo;
        private _rnUpdateFun;
        setRenderUpdateCallback(func: Function): void;
        _handleInterData(): void;
        private _setBlendMode;
        setClipRect(rect: Rectangle): void;
        private _initClipInfo;
        /**
         *  @internal
         * 父节点的裁剪影响substruct
         */
        private _updateParentClipInfo;
        /**
         *  @internal
         * 父节点的全局渲染数据影响substruct
         */
        private _updateParentGlobalRenderData;
        private _updateParentBlendMode;
        private _updateBlendMode;
        getClipInfo(): IClipInfo;
        private updateChildren;
        setRepaint(): void;
        addChild(child: WebRenderStruct2D, index: number): void;
        updateChildIndex(child: WebRenderStruct2D, oldIndex: number, index: number): void;
        removeChild(child: WebRenderStruct2D): void;
        renderUpdate(context: IRenderContext2D): void;
        destroy(): void;
    }
    class Web3DRenderModuleFactory implements I3DRenderModuleFactory {
        createSimpleSkinRenderNode(): ISimpleSkinRenderNode;
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): BoundsImpl;
        createVolumetricGI(): WebVolumetricGI;
        createReflectionProbe(): WebReflectionProbe;
        createLightmapData(): WebLightmap;
        createDirectLight(): WebDirectLight;
        createSpotLight(): WebSpotLight;
        createPointLight(): IPointLightData;
        createCameraModuleData(): WebCameraNodeData;
        createSceneModuleData(): WebSceneNodeData;
        createBaseRenderNode(): WebBaseRenderNode;
        createMeshRenderNode(): IMeshRenderNode;
        createSkinRenderNode(): ISkinRenderNode;
    }
    interface DynamicBaseRenderClass {
        new (): WebBaseRenderNode;
        readonly prototype: WebBaseRenderNode;
    }
    class WebBaseRenderNode implements IBaseRenderNode {
        static BaseRenderNodeClass: DynamicBaseRenderClass;
        renderNodeType: number;
        boundsChange: boolean;
        distanceForSort: number;
        sortingFudge: number;
        castShadow: boolean;
        receiveShadow: boolean;
        enable: boolean;
        renderbitFlag: number;
        layer: number;
        customCull: boolean;
        customCullResoult: boolean;
        staticMask: number;
        lightmapIndex: number;
        lightmapDirtyFlag: number;
        reflectionMode: number;
        lightProbUpdateMark: number;
        irradientMode: IrradianceMode;
        renderelements: IRenderElement3D[];
        lightmapScaleOffset: Vector4;
        lightmap: WebLightmap;
        probeReflection: WebReflectionProbe;
        volumetricGI: WebVolumetricGI;
        baseGeometryBounds: Bounds;
        transform: Transform3D;
        _worldParams: Vector4;
        _commonUniformMap: string[];
        _additionShaderDataKeys: string[];
        ismoved: Vector2;
        private _bounds;
        private _caculateBoundingBoxCall;
        private _caculateBoundingBoxFun;
        private _renderUpdatePreCall;
        private _renderUpdatePreFun;
        private _updateMark;
        protected _additionShaderData: Map<string, ShaderData>;
        protected _shaderData: ShaderData;
        get shaderData(): ShaderData;
        set shaderData(value: ShaderData);
        /**
         * context3D:GLESRenderContext3D
         * @internal
         */
        _renderUpdatePre(context3D: IRenderContext3D): void;
        _calculateBoundingBox(): void;
        /**
         * get bounds
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        get additionShaderData(): Map<string, ShaderData>;
        set additionShaderData(value: Map<string, ShaderData>);
        constructor();
        setNodeCustomData(dataSlot: ENodeCustomData, data: number): void;
        /**
         * 设置更新数据
         * @param call
         * @param fun
         */
        set_renderUpdatePreCall(call: any, fun: any): void;
        /**
         * 设置更新包围盒方法
         * @param call
         * @param fun
         */
        set_caculateBoundingBox(call: any, fun: any): void;
        /**
         * 视锥检测包围盒
         * @param boundFrustum
         * @returns
         */
        _needRender(boundFrustum: BoundFrustum): boolean;
        /**
         * @param value :RenderElementObj
         */
        setRenderelements(value: IRenderElement3D[]): void;
        /**
         * @internal
         * @param index
         * @param mat
         * @returns
         */
        setOneMaterial(index: number, mat: Material): void;
        /**
         * @internal
         * @param value
         */
        setLightmapScaleOffset(value: Vector4): void;
        /**@internal */
        setCommonUniformMap(value: string[]): void;
        /**
         * @internal
         * @returns
         */
        shadowCullPass(): boolean;
        /**
         * @internal
         */
        _ownerCalculateBoundingBox(): void;
        /**
         * @internal
         * 全局贴图
         */
        _applyLightMapParams(): void;
        /**
        * apply lightProb
        * @returns
        */
        _applyLightProb(): void;
        /**
         * apply reflection
         * @returns
         */
        _applyReflection(): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    class WebDirectLight implements IDirectLightData {
        shadowNearPlane: number;
        shadowCascadesMode: ShadowCascadesMode;
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowTwoCascadeSplits: number;
        _shadowFourCascadeSplits: Vector3;
        _direction: Vector3;
        constructor();
        setShadowFourCascadeSplits(value: Vector3): void;
        setDirection(value: Vector3): void;
    }
    class WebLightmap implements ILightMapData {
        /**@internal */
        lightmapColor: InternalTexture;
        /**@internal */
        lightmapDirection: InternalTexture;
        /**@internal */
        destroy(): void;
    }
    function WebMeshRenderNode(): any;
    class WebCameraNodeData implements ICameraNodeData {
        transform: Transform3D;
        farplane: number;
        nearplane: number;
        fieldOfView: number;
        aspectRatio: number;
        _projectViewMatrix: Matrix4x4;
        constructor();
        setProjectionViewMatrix(value: Matrix4x4): void;
    }
    class WebSceneNodeData implements ISceneNodeData {
        lightmapDirtyFlag: number;
    }
    class WebPointLight implements IPointLightData {
        transform: Transform3D;
        range: number;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
    }
    class WebReflectionProbe implements IReflectionProbeData {
        private static _idCounter;
        /** @internal */
        _id: number;
        /**@internal */
        boxProjection: boolean;
        /**@internal */
        bound: Bounds;
        /**@internal */
        ambientMode: AmbientMode;
        /**@internal */
        ambientIntensity: number;
        /**@internal */
        reflectionIntensity: number;
        /**@internal */
        reflectionTexture: InternalTexture;
        /**@internal */
        iblTex: InternalTexture;
        /**@internal */
        updateMark: number;
        /**@internal */
        iblTexRGBD: boolean;
        /**@internal */
        shaderData: ShaderData;
        /**@internal */
        private _reflectionHDRParams;
        /**@internal */
        private _shCoefficients;
        /**@internal */
        private _probePosition;
        /**@internal */
        private _ambientColor;
        /**@internal */
        private _ambientSH;
        private _updateMaskFlag;
        /**@internal */
        constructor();
        /**
         * @internal
         */
        needUpdate(): boolean;
        /**
         * @internal
         */
        destroy(): void;
        /**@internal */
        setAmbientSH(value: Float32Array): void;
        /**@internal */
        setShCoefficients(value: Vector4[]): void;
        /**@internal */
        setProbePosition(value: Vector3): void;
        /**@internal */
        setreflectionHDRParams(value: Vector4): void;
        /**@internal */
        setAmbientColor(value: Color): void;
        /**@internal */
        applyRenderData(): void;
    }
    /**
     * @en The `SceneRenderManagerOBJ` class is used to manage the rendering nodes of a scene.
     * @zh `SceneRenderManagerOBJ` 类用于管理场景的渲染节点。
     */
    class WebSceneRenderManager implements ISceneRenderManager {
        /** @internal */
        _list: SingletonList<BaseRender>;
        /** @ignore */
        constructor();
        /**
         * @en The base render list.
         * @zh 基础渲染节点列表。
         */
        baseRenderList: SingletonList<WebBaseRenderNode>;
        /**
         * @en The list of render objects.
         * @zh 渲染对象列表。
         */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        /**
         * @en Adds a render object to the render list.
         * @param object The render object to add.
         * @zh 向渲染列表添加渲染对象。
         * @param object 要添加的渲染对象。
         */
        addRenderObject(object: BaseRender): void;
        /**
         * @en Removes a render object from the render list and the base render list.
         * @param object The render object to remove.
         * @zh 从渲染列表和基础渲染列表中移除渲染对象。
         * @param object 要移除的渲染对象。
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * @en Removes a motion render object.
         * @param object The motion render object to remove.
         * @zh 移除运动渲染对象。
         * @param object  要移除的运动渲染对象。
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * @en Updates all motion render objects.
         * @zh 更新所有运动渲染对象。
         */
        updateMotionObjects(): void;
        /**
         * @en Adds a motion render object.
         * @param object The motion render object to add.
         * @zh 向管理器添加运动渲染对象。
         * @param object 要添加的运动渲染对象。
         */
        addMotionObject(object: BaseRender): void;
        /**
         * @en Destroys the render objects and cleans up resources.
         * @zh 销毁渲染对象并清理资源。
         */
        destroy(): void;
    }
    function WebSimpleSkinRenderNode(): any;
    function WebSkinRenderNode(): any;
    class WebSpotLight implements ISpotLightData {
        transform: Transform3D;
        shadowResolution: number;
        shadowDistance: number;
        shadowMode: ShadowMode;
        shadowStrength: number;
        shadowDepthBias: number;
        shadowNormalBias: number;
        shadowNearPlane: number;
        spotRange: number;
        spotAngle: number;
        _direction: Vector3;
        setDirection(value: Vector3): void;
        getWorldMatrix(out: Matrix4x4): Matrix4x4;
    }
    class WebVolumetricGI implements IVolumetricGIData {
        private static _idCounter;
        _id: number;
        private _probeCounts;
        private _probeStep;
        irradiance: InternalTexture;
        distance: InternalTexture;
        bound: Bounds;
        intensity: number;
        updateMark: number;
        shaderData: ShaderData;
        /**
         * @internal
         * x: irradiance probe texel size
         * y: distance probe texel size
         * z: normalBias
         * w: viewBias
         */
        private _params;
        constructor();
        setParams(value: Vector4): void;
        setProbeCounts(value: Vector3): void;
        setProbeStep(value: Vector3): void;
        applyRenderData(): void;
        destroy(): void;
    }
    /**
     * <code>DefineDatas</code> 类用于创建宏定义数据集合。
     */
    class WebDefineDatas implements IDefineDatas {
        private _changeFlags;
        /**
         * @internal
         */
        _mask: Array<number>;
        /**
         * @internal
         */
        _length: number;
        /**
         * 创建一个 <code>DefineDatas</code> 实例。
         */
        constructor();
        /**
         * @internal
         */
        _intersectionDefineDatas(define: WebDefineDatas): void;
        /**
         * 添加宏定义值。
         * @param define 宏定义值。
         */
        add(define: ShaderDefine): boolean;
        /**
         * 移除宏定义。
         * @param define 宏定义。
         */
        remove(define: ShaderDefine): boolean;
        /**
         * 添加宏定义集合。
         * @param define 宏定义集合。
         */
        addDefineDatas(define: WebDefineDatas): void;
        /**
         * 移除宏定义集合。
         * @param define 宏定义集合。
         */
        removeDefineDatas(define: WebDefineDatas): void;
        /**
         * 是否有宏定义。
         * @param define 宏定义。
         */
        has(define: ShaderDefine): boolean;
        private _notifyChangeFlag;
        addChangeFlagInfo(flag: Vector2): void;
        removeChangeFlagInfo(flag: Vector2): void;
        /**
         * 清空宏定义。
         */
        clear(): void;
        /**
         * 克隆。
         * @param destObject 克隆源。
         */
        cloneTo(destObject: WebDefineDatas): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): WebDefineDatas;
        destroy(): void;
        isEual(other: WebDefineDatas): boolean;
    }
    /**
     * 着色器数据类。
     */
    class WebGLShaderData extends ShaderData {
        /**@internal */
        protected _gammaColorMap: Map<number, Color>;
        /**@internal */
        _data: any;
        /** @internal */
        _defineDatas: WebDefineDatas;
        /** @internal */
        private _uniformBuffers;
        /** @internal */
        private _subUniformBuffers;
        /** @internal */
        private _uniformBuffersPropertyMap;
        private _needCacheData;
        private _updateCacheArray;
        private _subUboBufferNumber;
        /**
         * @internal
         */
        constructor(ownerResource?: Resource);
        /**
         * @internal
         */
        _initData(): void;
        /**
         * @param name
         * @param uniformMap
         * @returns
         */
        createUniformBuffer(name: string, uniformMap: Map<number, UniformProperty>): WebGLUniformBuffer;
        updateUBOBuffer(name: string): void;
        createSubUniformBuffer(name: string, cacheName: string, uniformMap: Map<number, UniformProperty>): WebGLSubUniformBuffer;
        /**
         * 注意!!!!!! 不要获得data之后直接设置值，设置值请使用set函数
         * @internal
         */
        getData(): any;
        /**
         * @ignore
         */
        addDefine(define: ShaderDefine): void;
        addDefines(define: WebDefineDatas): void;
        /**
         * @ignore
         */
        removeDefine(define: ShaderDefine): void;
        removeDefines(defines: WebDefineDatas): void;
        /**
         * @ignore
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * @ignore
         */
        clearDefine(): void;
        clearData(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         * @param	value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * @internal
         * @param index
         */
        getLinearColor(index: number): Vector4;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        _setInternalTexture(index: number, value: InternalTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        getSourceIndex(value: any): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: WebGLShaderData): void;
        getDefineData(): WebDefineDatas;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): WebGLShaderData;
        destroy(): void;
    }
    class WebShaderPass implements IShaderPassData {
        is2D: boolean;
        pipelineMode: string;
        statefirst: boolean;
        private _validDefine;
        private _renderState;
        get renderState(): RenderState;
        set renderState(value: RenderState);
        /** @internal */
        protected _cacheShaderHierarchy: number;
        get validDefine(): WebDefineDatas;
        set validDefine(value: WebDefineDatas);
        /** @internal */
        protected _cacheSharders: {
            [key: number]: {
                [key: number]: {
                    [key: number]: IShaderInstance;
                };
            };
        };
        constructor(pass: ShaderPass);
        name: string;
        additionShaderData: string[];
        nodeCommonMap: string[];
        attributeLocations: Set<number>;
        /**
        * @internal
        */
        _resizeCacheShaderMap(cacheMap: any, hierarchy: number, resizeLength: number): void;
        setCacheShader(compileDefine: WebDefineDatas, shader: IShaderInstance): void;
        getCacheShader(compileDefine: WebDefineDatas): IShaderInstance;
        destroy(): void;
    }
    class WebSubShader implements ISubshaderData {
        shaderName: string;
        enableInstance: boolean;
        setUniformMap(_uniformMap: Map<number, UniformProperty>): void;
        destroy(): void;
        addShaderPass(pass: WebShaderPass): void;
    }
    class WebUnitRenderModuleDataFactory implements IUnitRenderModuleDataFactory {
        createSubShader(): WebSubShader;
        createShaderPass(pass: ShaderPass): IShaderPassData;
        createRenderState(): RenderState;
        createDefineDatas(): WebDefineDatas;
    }
    class WebGLSetRendertarget2DCMD extends SetRendertarget2DCMD {
        constructor();
        apply(context: IRenderContext2D): void;
    }
    class WebGLDraw2DElementCMD extends Draw2DElementCMD {
        private _elements;
        constructor();
        setRenderelements(value: WebGLRenderElement2D[]): void;
        apply(context: IRenderContext2D): void;
    }
    class WebGLBlit2DQuadCMD extends Blit2DQuadCMD {
        static SCREENTEXTURE_ID: number;
        static SCREENTEXTUREOFFSETSCALE_ID: number;
        static MAINTEXTURE_TEXELSIZE_ID: number;
        static GammaCorrect: ShaderDefine;
        static _init_(): void;
        private _sourceTexelSize;
        type: RenderCMDType;
        constructor();
        set source(value: InternalTexture);
        apply(context: WebglRenderContext2D): void;
    }
    class WebGLPrimitiveRenderElement2D extends WebGLRenderElement2D implements IPrimitiveRenderElement2D {
        primitiveShaderData: WebGLShaderData;
        protected _compileShader(context: WebglRenderContext2D): void;
        renderByShaderInstance(shader: WebGLShaderInstance, context: WebglRenderContext2D): void;
    }
    class WebGLRender2DProcess implements I2DRenderPassFactory {
        constructor();
        createGraphic2DBufferBlock(): IGraphics2DBufferBlock;
        createGraphic2DVertexBlock(): IGraphics2DVertexBlock;
        create2DGraphicVertexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementOffset: number, elementSize: number, stride: number): I2DGraphicVertexDataView;
        create2DGraphicIndexDataView(wholeBuffer: I2DGraphicWholeBuffer, elementSize: number): I2DGraphicIndexDataView;
        create2DGraphicIndexBuffer(): I2DGraphicWholeBuffer;
        createPrimitiveRenderElement2D(): IPrimitiveRenderElement2D;
        create2DGraphicVertexBuffer(): I2DGraphicWholeBuffer;
        createRender2DPassManager(): IRender2DPassManager;
        create2DGlobalRenderDataHandle(): I2DGlobalRenderData;
        createSpineRenderDataHandle(): ISpineRenderDataHandle;
        create2D2DPrimitiveDataHandle(): I2DPrimitiveDataHandle;
        create2DBaseRenderDataHandle(): I2DBaseRenderDataHandle;
        createMesh2DRenderDataHandle(): IMesh2DRenderDataHandle;
        createSetRenderDataCMD(): SetRenderDataCMD;
        createSetShaderDefineCMD(): SetShaderDefineCMD;
        createBlit2DQuadCMDData(): WebGLBlit2DQuadCMD;
        createDraw2DElementCMDData(): Draw2DElementCMD;
        createSetRendertarget2DCMD(): SetRendertarget2DCMD;
        createRenderElement2D(): IRenderElement2D;
        createRenderContext2D(): IRenderContext2D;
        createRender2DPass(): IRender2DPass;
        createRenderStruct2D(): any;
    }
    class WebglRenderContext2D implements IRenderContext2D {
        static isCreateBlitScreenELement: boolean;
        static blitScreenElement: WebGLRenderElement2D;
        static blitContext: WebglRenderContext2D;
        private _clearColor;
        _destRT: WebGLInternalRT;
        invertY: boolean;
        pipelineMode: string;
        passData: WebGLShaderData;
        _globalConfigShaderData: WebDefineDatas;
        private _offscreenWidth;
        private _offscreenHeight;
        constructor();
        /**
         * 兼容ConchWebGL
         */
        private setBlitScreenElement;
        drawRenderElementList(list: FastSinglelist<WebGLRenderElement2D>): number;
        setOffscreenView(width: number, height: number): void;
        setRenderTarget(value: WebGLInternalRT, clear: boolean, clearColor: Color): void;
        getRenderTarget(): WebGLInternalRT;
        drawRenderElementOne(node: WebGLRenderElement2D): void;
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
    }
    class WebGLRenderElement2D implements IRenderElement2D {
        owner: WebRenderStruct2D;
        nodeCommonMap: string[];
        renderStateIsBySprite: boolean;
        type: number;
        /** @internal */
        static _compileDefine: WebDefineDatas;
        protected _shaderInstances: FastSinglelist<WebGLShaderInstance>;
        geometry: WebGLRenderGeometryElement;
        materialShaderData: WebGLShaderData;
        value2DShaderData: WebGLShaderData;
        /** @internal */
        globalShaderData: WebGLShaderData;
        subShader: SubShader;
        protected _compileShader(context: WebglRenderContext2D): void;
        _prepare(context: WebglRenderContext2D): void;
        _render(context: WebglRenderContext2D): void;
        protected _uploadGlobalAndPass(shader: WebGLShaderInstance, context: WebglRenderContext2D): void;
        renderByShaderInstance(shader: WebGLShaderInstance, context: WebglRenderContext2D): void;
        destroy(): void;
    }
    class WebGL3DRenderPassFactory implements I3DRenderPassFactory {
        createInstanceBatch(): IInstanceRenderBatch;
        createSetRenderDataCMD(): WebGLSetRenderData;
        createSetShaderDefineCMD(): WebGLSetShaderDefine;
        createDrawNodeCMDData(): WebGLDrawNodeCMDData;
        createBlitQuadCMDData(): WebGLBlitQuadCMDData;
        createDrawElementCMDData(): WebGLDrawElementCMDData;
        createSetViewportCMD(): WebGLSetViewportCMD;
        createSetRenderTargetCMD(): WebGLSetRenderTargetCMD;
        createSceneRenderManager(): WebSceneRenderManager;
        createSkinRenderElement(): WebGLSkinRenderElement3D;
        createRenderContext3D(): WebGLRenderContext3D;
        createRenderElement3D(): WebGLRenderElement3D;
        createInstanceRenderElement3D(): WebGLInstanceRenderElement3D;
        createRender3DProcess(): WebGLRender3DProcess;
    }
    class WebGLDirectLightShadowRP {
        /** @internal 最大cascade*/
        private static _maxCascades;
        /**@internal */
        shadowCastMode: ShadowCascadesMode;
        camera: WebCameraNodeData;
        destTarget: WebGLInternalRT;
        private _shadowCasterCommanBuffer;
        get shadowCasterCommanBuffer(): CommandBuffer[];
        set shadowCasterCommanBuffer(value: CommandBuffer[]);
        /**light */
        private _light;
        /**@internal */
        private _lightup;
        /**@internal */
        private _lightSide;
        /**@internal */
        private _lightForward;
        /**@internal 分割distance*/
        private _cascadesSplitDistance;
        /** @internal */
        private _frustumPlanes;
        /** @internal */
        private _shadowMatrices;
        /**@internal */
        private _splitBoundSpheres;
        /** @internal */
        private _shadowSliceDatas;
        /** @internal */
        private _shadowMapSize;
        /** @internal */
        private _shadowBias;
        /** @internal */
        private _cascadeCount;
        /** @internal */
        private _shadowMapWidth;
        /** @internal */
        private _shadowMapHeight;
        /** @internal */
        private _shadowTileResolution;
        /** @internal */
        private _shadowCullInfo;
        /**@internal */
        private _renderQueue;
        set light(value: WebDirectLight);
        get light(): WebDirectLight;
        constructor();
        /**
         * @param context
         */
        update(context: WebGLRenderContext3D): void;
        /**
         * @param context
         * @param list
         * @param count
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * set shaderData after Render shadow
         * @param scene
         * @param camera
         */
        private _applyRenderData;
        /**
         * apply shadowCast cmd array
         */
        private _applyCasterPassCommandBuffer;
        private getShadowBias;
        /**
        * 设置阴影级联数据模式
        * @internal
        */
        private _setupShadowCasterShaderValues;
        destroy(): void;
    }
    class WebGLForwardAddClusterRP {
        /** @internal*/
        static _context3DViewPortCatch: Viewport;
        /** @internal*/
        static _contextScissorPortCatch: Vector4;
        /**@internal */
        cameraCullInfo: CameraCullInfo;
        /**@internal */
        beforeForwardCmds: Array<CommandBuffer>;
        /**@internal */
        beforeSkyboxCmds: Array<CommandBuffer>;
        /**@internal */
        beforeTransparentCmds: Array<CommandBuffer>;
        /**enable */
        enableOpaque: boolean;
        enableCMD: boolean;
        enableTransparent: boolean;
        /**@internal */
        destTarget: InternalRenderTarget;
        /**@internal */
        pipelineMode: PipelineMode;
        /**@internal */
        depthTarget: InternalRenderTarget;
        /**@internal */
        depthPipelineMode: PipelineMode;
        /**@internal */
        depthNormalTarget: InternalRenderTarget;
        /**@internal */
        depthNormalPipelineMode: PipelineMode;
        /**@internal sky TODO*/
        skyRenderNode: WebBaseRenderNode;
        /**@internal */
        depthTextureMode: DepthTextureMode;
        opaqueTexture: InternalRenderTarget;
        blitOpaqueBuffer: CommandBuffer;
        private _enableOpaqueTexture;
        get enableOpaqueTexture(): boolean;
        set enableOpaqueTexture(value: boolean);
        clearColor: Color;
        clearFlag: number;
        /**@internal */
        camera: WebCameraNodeData;
        private _viewPort;
        setViewPort(value: Viewport): void;
        private _scissor;
        setScissor(value: Vector4): void;
        private opaqueList;
        private transparent;
        private _zBufferParams;
        private _defaultNormalDepthColor;
        constructor();
        setCameraCullInfo(value: Camera): void;
        setBeforeForwardCmds(value: CommandBuffer[]): void;
        setBeforeSkyboxCmds(value: CommandBuffer[]): void;
        setBeforeTransparentCmds(value: CommandBuffer[]): void;
        /**
         * 渲染主流程（TODO:其他两个pass合并MulTargetRT）
         * @param context
         * @param list
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
         * 渲染深度Pass
         * @param context
         * @param list
         */
        private _renderDepthPass;
        /**
         * @param context
         * @private
         */
        private _transparentListRender;
        /**
         * 渲染非透明物体Pass
         * @param context
         * @param list
         */
        private _opaqueListRender;
        /**
         * 渲染法线深度Pass
         * @param context
         * @param list
         */
        private _renderDepthNormalPass;
        private opaqueTexturePass;
        private _mainPass;
        /**
         * @param cmds
         * @param context
         * @private
         */
        private _rendercmd;
        private _recoverRenderContext3D;
        destroy(): void;
    }
    class WebGLForwardAddRP {
        /**是否开启阴影 */
        shadowCastPass: boolean;
        /**directlight shadow */
        directLightShadowPass: WebGLDirectLightShadowRP;
        /**enable directlight */
        enableDirectLightShadow: boolean;
        /**spot shadow */
        spotLightShadowPass: WebGLSpotLightShadowRP;
        /**enable spot */
        enableSpotLightShadowPass: boolean;
        shadowParams: Vector4;
        /**Render end commanbuffer */
        /**@internal */
        _afterAllRenderCMDS: Array<CommandBuffer>;
        /**@internal */
        _beforeImageEffectCMDS: Array<CommandBuffer>;
        enablePostProcess: boolean;
        /**@internal */
        postProcess: CommandBuffer;
        /**main pass */
        renderpass: WebGLForwardAddClusterRP;
        finalize: CommandBuffer;
        constructor();
        setBeforeImageEffect(value: CommandBuffer[]): void;
        setAfterEventCmd(value: CommandBuffer[]): void;
        destroy(): void;
    }
    /**
     * 动态合批通用类（目前由WebGPU专用）
     */
    class WebGLInstanceRenderBatch {
        static MaxInstanceCount: number;
        private recoverList;
        private _batchOpaqueMarks;
        private _updateCountMark;
        constructor();
        getBatchMark(element: IRenderElement3D): any;
        batch(elements: SingletonList<IRenderElement3D>): void;
        clearRenderData(): void;
        recoverData(): void;
    }
    interface WebGLInstanceStateInfo {
        state: WebGLBufferState;
        worldInstanceVB?: WebGLVertexBuffer;
        lightmapScaleOffsetVB?: WebGLVertexBuffer;
        simpleAnimatorVB?: WebGLVertexBuffer;
    }
    class WebGLInstanceRenderElement3D extends WebGLRenderElement3D implements IInstanceRenderElement3D {
        /**
         * get Instance BufferState
         */
        private static _instanceBufferStateMap;
        static getInstanceBufferState(geometry: WebGLRenderGeometryElement, renderType: number, spriteDefine: WebDefineDatas): WebGLInstanceStateInfo;
        /**
         * max instance count
         */
        static readonly MaxInstanceCount: number;
        /**
         * @internal
         */
        private static _pool;
        static create(): WebGLInstanceRenderElement3D;
        /**
         * pool of Buffer
         * @internal
         */
        private static _bufferPool;
        static _instanceBufferCreate(length: number): Float32Array;
        instanceElementList: FastSinglelist<WebGLRenderElement3D>;
        private _vertexBuffers;
        private _updateData;
        private _updateDataNum;
        private _instanceStateInfo;
        drawCount: number;
        updateNums: number;
        constructor();
        addUpdateData(vb: WebGLVertexBuffer, elementLength: number, maxInstanceCount: number): Float32Array;
        protected _compileShader(context: WebGLRenderContext3D): void;
        private _updateInstanceData;
        /**
         * get correct geometry
         * @param geometry
         */
        setGeometry(geometry: WebGLRenderGeometryElement): void;
        /**
        * render RenderElement
        * context:GLESRenderContext3D
        * @param context
        */
        _render(context: WebGLRenderContext3D): void;
        /**
         * 清理单次渲染生成的数据
         */
        clearRenderData(): void;
        /**
         * 回收
         */
        recover(): void;
        destroy(): void;
    }
    class WebGLRender3DProcess implements IRender3DProcess {
        render3DManager: WebSceneRenderManager;
        private renderpass;
        initRenderpass(camera: Camera, context: WebGLRenderContext3D): void;
        renderDepth(camera: Camera): void;
        fowardRender(context: WebGLRenderContext3D, camera: Camera): void;
        renderFowarAddCameraPass(context: WebGLRenderContext3D, renderpass: WebGLForwardAddRP, list: WebBaseRenderNode[], count: number): void;
        /**
         * @param cmds
         * @param context
         * @private
         */
        private _rendercmd;
        /**
         * @param postprocessCMD
         * @param context
         * @private
         */
        private _renderPostProcess;
        destroy(): void;
    }
    class WebGLDrawNodeCMDData extends DrawNodeCMDData {
        type: RenderCMDType;
        protected _node: WebBaseRenderNode;
        protected _destShaderData: WebGLShaderData;
        protected _destSubShader: SubShader;
        protected _subMeshIndex: number;
        get node(): WebBaseRenderNode;
        set node(value: WebBaseRenderNode);
        get destShaderData(): WebGLShaderData;
        set destShaderData(value: WebGLShaderData);
        get destSubShader(): SubShader;
        set destSubShader(value: SubShader);
        get subMeshIndex(): number;
        set subMeshIndex(value: number);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLBlitQuadCMDData extends BlitQuadCMDData {
        type: RenderCMDType;
        private _sourceTexelSize;
        protected _dest: WebGLInternalRT;
        protected _viewport: Viewport;
        protected _source: InternalTexture;
        protected _scissor: Vector4;
        protected _offsetScale: Vector4;
        protected _element: WebGLRenderElement3D;
        get dest(): WebGLInternalRT;
        set dest(value: WebGLInternalRT);
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        get source(): InternalTexture;
        set source(value: InternalTexture);
        get offsetScale(): Vector4;
        set offsetScale(value: Vector4);
        get element(): WebGLRenderElement3D;
        set element(value: WebGLRenderElement3D);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLDrawElementCMDData extends DrawElementCMDData {
        type: RenderCMDType;
        private _elemets;
        constructor();
        setRenderelements(value: WebGLRenderElement3D[]): void;
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetViewportCMD extends SetViewportCMD {
        type: RenderCMDType;
        protected _viewport: Viewport;
        protected _scissor: Vector4;
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get scissor(): Vector4;
        set scissor(value: Vector4);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLSetRenderTargetCMD extends SetRenderTargetCMD {
        type: RenderCMDType;
        protected _rt: InternalRenderTarget;
        protected _clearFlag: number;
        protected _clearColorValue: Color;
        protected _clearDepthValue: number;
        protected _clearStencilValue: number;
        get rt(): InternalRenderTarget;
        set rt(value: InternalRenderTarget);
        get clearFlag(): number;
        set clearFlag(value: number);
        get clearColorValue(): Color;
        set clearColorValue(value: Color);
        get clearDepthValue(): number;
        set clearDepthValue(value: number);
        get clearStencilValue(): number;
        set clearStencilValue(value: number);
        constructor();
        apply(context: WebGLRenderContext3D): void;
    }
    class WebGLRenderContext3D implements IRenderContext3D {
        static _instance: WebGLRenderContext3D;
        /**
         * @internal
        */
        _preDrawUniformMaps: Set<string>;
        /** @internal */
        _cacheGlobalDefines: WebDefineDatas;
        _globalConfigShaderData: WebDefineDatas;
        private _globalShaderData;
        /**@internal */
        private _sceneData;
        /**@internal */
        private _sceneModuleData;
        private _cameraModuleData;
        /**@internal */
        private _cameraData;
        /**@internal */
        private _renderTarget;
        /**@internal */
        private _viewPort;
        /**@internal */
        private _scissor;
        /**@internal */
        private _sceneUpdataMask;
        /**@internal */
        private _cameraUpdateMask;
        /**@internal */
        private _pipelineMode;
        /**@internal */
        private _invertY;
        /**@internal */
        private _clearFlag;
        /**@internal */
        private _clearColor;
        /**@internal */
        private _clearDepth;
        /**@internal */
        private _clearStencil;
        /**@internal */
        private _needStart;
        get sceneData(): WebGLShaderData;
        set sceneData(value: WebGLShaderData);
        get cameraData(): WebGLShaderData;
        set cameraData(value: WebGLShaderData);
        get sceneModuleData(): WebSceneNodeData;
        set sceneModuleData(value: WebSceneNodeData);
        get cameraModuleData(): WebCameraNodeData;
        set cameraModuleData(value: WebCameraNodeData);
        get globalShaderData(): WebGLShaderData;
        set globalShaderData(value: WebGLShaderData);
        /**
         * @internal
         * @returns
         */
        _getContextShaderDefines(): WebDefineDatas;
        /**
         * @internal
         * 1. 更新 context shader defines string
         * 2. upload context shader data
         */
        _prepareContext(): void;
        setRenderTarget(value: InternalRenderTarget, clearFlag: RenderClearFlag): void;
        setViewPort(value: Viewport): void;
        setScissor(value: Vector4): void;
        get sceneUpdataMask(): number;
        set sceneUpdataMask(value: number);
        get cameraUpdateMask(): number;
        set cameraUpdateMask(value: number);
        get pipelineMode(): PipelineMode;
        set pipelineMode(value: PipelineMode);
        get invertY(): boolean;
        set invertY(value: boolean);
        /**
         * <code>GLESRenderContext3D<code/>
         */
        constructor();
        runOneCMD(cmd: IRenderCMD): void;
        runCMDList(cmds: IRenderCMD[]): void;
        setClearData(clearFlag: number, color: Color, depth: number, stencil: number): number;
        drawRenderElementList(list: FastSinglelist<WebGLRenderElement3D>): number;
        drawRenderElementOne(node: WebGLRenderElement3D): number;
        private _bindRenderTarget;
        private _start;
    }
    class WebGLRenderElement3D implements IRenderElement3D {
        /** @internal */
        static _compileDefine: WebDefineDatas;
        protected _shaderInstances: FastSinglelist<WebGLShaderInstance>;
        geometry: WebGLRenderGeometryElement;
        subShader: SubShader;
        materialId: number;
        canDynamicBatch: boolean;
        materialShaderData: WebGLShaderData;
        materialRenderQueue: number;
        renderShaderData: WebGLShaderData;
        transform: Transform3D;
        isRender: boolean;
        owner: WebBaseRenderNode;
        protected _invertFront: boolean;
        constructor();
        _addShaderInstance(shader: WebGLShaderInstance): void;
        _clearShaderInstance(): void;
        _preUpdatePre(context: WebGLRenderContext3D): void;
        protected _getInvertFront(): boolean;
        /**
         * render RenderElement
         * context:GLESRenderContext3D
         * @param context
         */
        _render(context: WebGLRenderContext3D): void;
        protected _getShaderInstanceDefines(context: WebGLRenderContext3D): WebDefineDatas;
        protected _compileShader(context: WebGLRenderContext3D): void;
        drawGeometry(shaderIns: WebGLShaderInstance): void;
        destroy(): void;
    }
    class WebGLSkinRenderElement3D extends WebGLRenderElement3D implements ISkinRenderElement3D {
        skinnedData: Float32Array[];
        constructor();
        /** 更新数据并且 */
        drawGeometry(shaderIns: WebGLShaderInstance): void;
    }
    class WebGLSpotLightShadowRP {
        destTarget: InternalRenderTarget;
        /**@internal */
        shadowCasterCommanBuffer: CommandBuffer[];
        /**light */
        /**@internal */
        private _light;
        /**@internal */
        private _lightPos;
        /**@internal */
        private _lightWorldMatrix;
        /**@internal */
        private _shadowResolution;
        /**@internal */
        private _spotAngle;
        /**@internal */
        private _spotRange;
        /**@internal */
        private _shadowMode;
        /** @internal */
        private _shadowSpotData;
        /** @internal */
        private _shadowSpotMapSize;
        /** @internal */
        private _shadowSpotMatrices;
        /**@internal */
        private _shadowBias;
        private _renderQueue;
        set light(value: WebSpotLight);
        get light(): WebSpotLight;
        constructor();
        /**
        * 更新阴影数据
        */
        update(context: WebGLRenderContext3D): void;
        /**
         * render
         * @param context
         * @param list
         */
        render(context: WebGLRenderContext3D, list: WebBaseRenderNode[], count: number): void;
        /**
        * @internal
        */
        private _getSpotLightShadowData;
        /**
         * get shadow bias
         * @param shadowResolution
         * @param out
         */
        private _getShadowBias;
        private _setupShadowCasterShaderValues;
        /**
         * apply shadowCast cmd array
         */
        private _applyCasterPassCommandBuffer;
        /**
         * 设置聚光接受阴影的模式
         * @internal
         * @param shaderValues 渲染数据
         */
        private _applyRenderData;
        destroy(): void;
    }
    /**
     * 将继承修改为类似 WebGLRenderingContextBase, WebGLRenderingContextOverloads 多继承 ?
     */
    class GL2TextureContext extends GLTextureContext implements ITextureContext {
        protected _gl: WebGL2RenderingContext;
        constructor(engine: WebGLEngine);
        protected getTarget(dimension: TextureDimension): number;
        glTextureParam(format: TextureFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderBufferParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            attachment: number;
        };
        glRenderTextureParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        getGLtexMemory(tex: WebGLInternalTex, depth?: number): number;
        supportSRGB(format: TextureFormat | RenderTargetFormat, mipmap: boolean): boolean;
        setTextureImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: WebGLInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: WebGLInternalTex, sources: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureHDRData(texture: WebGLInternalTex, hdrInfo: HDRTextureInfo): void;
        setTextureKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setCubeImageData(texture: WebGLInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: WebGLInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        getCubeKTXRGBMData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: WebGLInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderbuffer(width: number, height: number, internalFormat: number, samples: number): WebGLRenderbuffer;
        protected createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number, storage: boolean): WebGLInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        bindRenderTarget(renderTarget: WebGLInternalRT, faceIndex?: number): void;
        unbindRenderTarget(renderTarget: WebGLInternalRT): void;
    }
    class GLTextureContext extends GLObject implements ITextureContext {
        protected _sRGB: any;
        protected _oesTextureHalfFloat: any;
        protected _compressdTextureS3tc_srgb: any;
        protected _compressedTextureEtc1: any;
        protected _compressedTextureS3tc: any;
        protected _compressedTextureETC: any;
        protected _compressedTextureASTC: any;
        protected _webgl_depth_texture: any;
        needBitmap: boolean;
        constructor(engine: WebGLEngine);
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        _glParam: {
            internalFormat: number;
            format: number;
            type: number;
        };
        glTextureParam(format: TextureFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderTextureParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            format: number;
            type: number;
        };
        glRenderBufferParam(format: RenderTargetFormat, useSRGB: boolean): {
            internalFormat: number;
            attachment: number;
        };
        glRenderTargetAttachment(format: RenderTargetFormat): 36096 | 33306 | 36128 | 36064;
        protected getTarget(dimension: TextureDimension): number;
        getFormatPixelsParams(format: TextureFormat): {
            channels: number;
            bytesPerPixel: number;
            dataTypedCons: any;
            typedSize: number;
        };
        /**
         * caculate texture memory
         * @param tex
         * @returns
         */
        getGLtexMemory(tex: WebGLInternalTex, depth?: number): number;
        getGLRTTexMemory(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, multiSamples: number, cube: boolean): number;
        /**
         * 根据 format 判断是否支持 SRGBload
         * @param format
         * @returns
         */
        supportSRGB(format: TextureFormat | RenderTargetFormat, mipmap: boolean): boolean;
        supportGenerateMipmap(format: TextureFormat | RenderTargetFormat): boolean;
        /**
         * 判断 纹理格式 本身是否是 SRGB格式
         * @param format
         * @returns
         */
        isSRGBFormat(format: TextureFormat | RenderTargetFormat): boolean;
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: WebGLInternalTex, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: WebGLInternalTex): void;
        setTexturePixelsData(texture: WebGLInternalTex, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubPixelsData(texture: WebGLInternalTex, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: WebGLInternalTex, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: WebGLInternalTex, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: WebGLInternalTex, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: WebGLInternalTex, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: WebGLInternalTex, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: WebGLInternalTex, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: WebGLInternalTex, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: WebGLInternalTex, compareMode: TextureCompareMode): TextureCompareMode;
        currentActiveRT: WebGLInternalRT;
        bindRenderTarget(renderTarget: WebGLInternalRT, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: WebGLInternalRT): void;
        createRenderTextureCubeInternal(dimension: TextureDimension, size: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetInternal(width: number, height: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number, storage: boolean): WebGLInternalRT;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): WebGLInternalRT;
        createRenderbuffer(width: number, height: number, internalFormat: number, samples: number): WebGLRenderbuffer;
        protected createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): WebGLInternalTex;
        createRenderTargetDepthTexture(renderTarget: WebGLInternalRT, dimension: TextureDimension, width: number, height: number): WebGLInternalTex;
        /**
         * @deprecated 请使用readRenderTargetPixelDataAsync函数代替
         * @param renderTarget
         * @param xOffset
         * @param yOffset
         * @param width
         * @param height
         * @param out
         * @returns
         */
        readRenderTargetPixelData(renderTarget: WebGLInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        readRenderTargetPixelDataAsync(renderTarget: WebGLInternalRT, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): Promise<ArrayBufferView>;
        updateVideoTexture(texture: WebGLInternalTex, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    class WebGLBufferState implements IBufferState {
        static _curBindedBufferState: WebGLBufferState;
        _glVertexState: GLVertexState;
        _bindedIndexBuffer: WebGLIndexBuffer;
        _vertexBuffers: WebGLVertexBuffer[];
        constructor();
        private applyVertexBuffers;
        protected applyIndexBuffers(): void;
        applyState(vertexBuffers: WebGLVertexBuffer[], indexBuffer: WebGLIndexBuffer): void;
        /**
         * @private
         */
        bind(): void;
        /**
         * @private
         */
        unBind(): void;
        isBind(): boolean;
        destroy(): void;
    }
    class WebGLCommandUniformMap extends CommandUniformMap {
        /**@internal */
        _idata: Map<number, UniformProperty>;
        _stateName: string;
        _stateID: number;
        constructor(stateName: string);
        hasPtrID(propertyID: number): boolean;
        /**
         * 增加一个Uniform参数，如果Uniform属性是Array，请使用addShaderUniformArray
         * @internal
         * @param propertyID
         * @param propertyKey
         */
        addShaderUniform(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /**
         * 增加一个UniformArray参数
         * @internal
         */
        addShaderUniformArray(propertyID: number, propertyName: string, uniformtype: ShaderDataType, arrayLength: number, block?: string): void;
    }
    /**
     * 封装Webgl
     */
    class WebGLEngine extends EventDispatcher implements IRenderEngine {
        /**
         * @internal
         * 存储 texture uniform gamma define
         */
        static _texGammaDefine: {
            [key: number]: ShaderDefine;
        };
        static _lastFrameBuffer: WebGLInternalRT;
        static _lastFrameBuffer_WebGLOBJ: WebGLFramebuffer;
        static _lastShaderError: string;
        _context: WebGLRenderingContext | WebGL2RenderingContext;
        _framePassCount: number;
        private _lost;
        get lost(): boolean;
        private _config;
        private _isWebGL2;
        private _webglMode;
        private _propertyNameMap;
        private _propertyNameCounter;
        /**@internal */
        _IDCounter: number;
        /**@internal ShaderDebugMode*/
        _isShaderDebugMode: boolean;
        /**@internal gl.TextureID*/
        _glTextureIDParams: Array<number>;
        /**@internal bind active Texture*/
        _activedTextureID: number;
        /**@internal bindTexture */
        _activeTextures: WebGLTexture[];
        /**
        * @internal
        * bind GLVertexArray
        */
        _GLBindVertexArray: GLVertexState;
        /**
        * @internal
        * 支持功能
        */
        _supportCapatable: GlCapable;
        /**
         * @internal
         * bind Program
         */
        _glUseProgram: GLShaderInstance;
        private _GLBufferBindMap;
        private _lastViewport;
        private _lastScissor;
        private _scissorState;
        private _lastClearColor;
        private _lastClearDepth;
        private _globalWidth;
        private _globalHeight;
        private _GLParams;
        private _GLTextureContext;
        private _GLRenderDrawContext;
        _remapZ: boolean;
        _screenInvertY: boolean;
        _lodTextureSample: boolean;
        _breakTextureSample: boolean;
        _GLRenderState: GLRenderState;
        private static _defineMap;
        private static _defineCounter;
        /**@internal */
        static _maskMap: Array<{
            [key: number]: string;
        }>;
        /** @internal */
        bufferMgr: WebGLUniformBufferManager;
        _uboBindingMap: {
            buffer: WebGLBuffer;
            offset: number;
            size: number;
        }[];
        static instance: WebGLEngine;
        /** @ignore */
        constructor(config: WebGLConfig, webglMode?: WebGLMode);
        startFrame(): void;
        endFrame(): void;
        getInnerWidth(): any;
        getInnerHeight(): any;
        resizeOffScreen(width: number, height: number): void;
        addTexGammaDefine(key: number, value: ShaderDefine): void;
        /**
         * @en webGL rendering context
         * @zh 获取 webGL 渲染上下文
         */
        get gl(): WebGLRenderingContext | WebGL2RenderingContext;
        get isWebGL2(): boolean;
        get webglConfig(): WebGLConfig;
        /**
         * create GL
         * @param canvas
         */
        initRenderEngine(canvas: HTMLCanvasElement): void;
        private _initBufferBlock;
        webglContextLost(e: any): void;
        private _initBindBufferMap;
        _getbindBuffer(target: BufferTargetType): GLBuffer;
        _setbindBuffer(target: BufferTargetType, buffer: GLBuffer | null): void;
        /**
         * @internal
         * @param target
         * @param texture
         */
        _bindTexture(target: number, texture: WebGLTexture): void;
        getCapable(capatableType: RenderCapable): boolean;
        viewport(x: number, y: number, width: number, height: number): void;
        scissor(x: number, y: number, width: number, height: number): void;
        scissorTest(value: boolean): void;
        clearRenderTexture(clearFlag: RenderClearFlag, clearcolor?: Color, clearDepth?: number, clearStencilValue?: number): void;
        copySubFrameBuffertoTex(texture: WebGLInternalTex, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        colorMask(r: boolean, g: boolean, b: boolean, a: boolean): void;
        getParams(params: RenderParams): number;
        createBuffer(targetType: BufferTargetType, bufferUsageType: BufferUsage): GLBuffer;
        createShaderInstance(vs: string, ps: string, attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }): GLShaderInstance;
        createVertexState(): GLVertexState;
        getTextureContext(): ITextureContext;
        getDrawContext(): GLRenderDrawContext;
        /**
       * 通过Shader属性名称获得唯一ID。
       * @param name Shader属性名称。
       * @return 唯一ID。
       */
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): void;
        /**
        * 注册宏定义。
        * @param name
        */
        getDefineByName(name: string): ShaderDefine;
        /**
         * @internal
         */
        uploadUniforms(shader: GLShaderInstance, commandEncoder: CommandEncoder, shaderData: WebGLShaderData, uploadUnTexture: boolean): number;
        /**
         * @internal
         */
        uploadOneUniforms(shader: GLShaderInstance, shaderVariable: ShaderVariable, data: any): void;
        unbindVertexState(): void;
    }
    class GLBuffer extends GLObject {
        _glBuffer: WebGLBuffer;
        _glTarget: number;
        _glUsage: number;
        _glTargetType: BufferTargetType;
        _glBufferUsageType: BufferUsage;
        private _statistics_M_Buffer;
        private _statistics_RC_Buffer;
        _byteLength: number;
        constructor(engine: WebGLEngine, targetType: BufferTargetType, bufferUsageType: BufferUsage);
        private _getGLUsage;
        private _getGLTarget;
        private _memorychange;
        bindBuffer(): boolean;
        unbindBuffer(): void;
        orphanStorage(): void;
        setDataLength(srcData: number): void;
        setData(srcData: ArrayBuffer, offset: number): void;
        setDataEx(srcData: ArrayBuffer | ArrayBufferView, offset: number, length: number): void;
        bindBufferBase(glPointer: number): void;
        bindBufferRange(glPointer: number, offset: number, byteCount: number): void;
        resizeBuffer(dataLength: number): void;
        destroy(): void;
    }
    class GlCapable {
        private _gl;
        private _extensionMap;
        private _capabilityMap;
        constructor(glEngine: WebGLEngine);
        private initCapable;
        private initExtension;
        getCapable(type: RenderCapable): boolean;
        getExtension(type: WebGLExtension): any;
        turnOffSRGB(): void;
    }
    enum WebGLExtension {
        OES_vertex_array_object = 0,
        ANGLE_instanced_arrays = 1,
        OES_texture_half_float = 2,
        OES_texture_half_float_linear = 3,
        OES_texture_float = 4,
        OES_element_index_uint = 5,
        OES_texture_float_linear = 6,
        EXT_color_buffer_half_float = 7,
        EXT_shader_texture_lod = 8,
        WEBGL_depth_texture = 9,
        EXT_sRGB = 10,
        EXT_color_buffer_float = 11,
        EXT_texture_filter_anisotropic = 12,
        WEBGL_compressed_texture_s3tc = 13,
        WEBGL_compressed_texture_s3tc_srgb = 14,
        WEBGL_compressed_texture_pvrtc = 15,
        WEBGL_compressed_texture_etc1 = 16,
        WEBGL_compressed_texture_etc = 17,
        WEBGL_compressed_texture_astc = 18,
        OES_standard_derivatives = 19
    }
    /**
     * WebGL mode.
     */
    enum WebGLMode {
        /** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */
        Auto = 0,
        /** WebGL2.0. */
        WebGL2 = 1,
        /** WebGL1.0, */
        WebGL1 = 2
    }
    /**
     * WebglObject 基类
     */
    class GLObject {
        protected _engine: WebGLEngine;
        protected _gl: WebGLRenderingContext | WebGL2RenderingContext;
        protected _id: number;
        protected _destroyed: boolean;
        constructor(engine: WebGLEngine);
        get destroyed(): boolean;
        /**
         * destroy
         * @override
         * @returns
         */
        destroy(): void;
    }
    /**
     *
     */
    class GLParams {
        _engine: WebGLEngine;
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        _glParamsData: Map<RenderParams, number>;
        constructor(engine: WebGLEngine);
        private _initParams;
        getParams(params: RenderParams): number;
    }
    class GLRenderDrawContext extends GLObject {
        /**@internal */
        private _angleInstancedArrays;
        constructor(engine: WebGLEngine);
        /**
         * @internal
         * @param mode
         * @returns
         */
        getMeshTopology(mode: MeshTopology): number;
        /**
         * @internal
         * @param type
         * @returns
         */
        getIndexType(type: IndexFormat): number;
        /**
         * @internal
         */
        drawElementsInstanced(mode: number, count: number, type: IndexFormat, offset: number, instanceCount: number): void;
        /**
         * @internal
         */
        drawArraysInstanced(mode: number, first: number, count: number, instanceCount: number): void;
        /**
         * @internal
         * @param mode
         * @param first
         * @param count
         */
        drawArrays(mode: number, first: number, count: number): void;
        /**
         * @internal
         * @param mode
         * @param count
         * @param type
         * @param offset
         */
        drawElements(mode: number, count: number, type: IndexFormat, offset: number): void;
        /**
         * @internal
         * @param geometryElement
         */
        drawGeometryElement(geometryElement: WebGLRenderGeometryElement): void;
    }
    class GLRenderState {
        /**@internal */
        private _depthTest;
        /**@internal */
        private _depthMask;
        /**@internal */
        private _depthFunc;
        /**@internal */
        private _stencilTest;
        /** @internal */
        private _stencilWrite;
        /**@internal */
        private _stencilFunc;
        /**@internal */
        private _stencilWriteMask;
        /** @internal */
        private _stencilReadMask;
        /**@internal */
        private _stencilRef;
        /**@internal */
        private _stencilOp_fail;
        /**@internal */
        private _stencilOp_zfail;
        /**@internal */
        private _stencilOp_zpass;
        private _depthBias;
        private _depthBiasConstant;
        private _depthBiasSlope;
        private _depthBiasClamp;
        /**@internal */
        private _blend;
        /**@internal */
        private _blendEquation;
        /**@internal */
        private _blendEquationRGB;
        /**@internal */
        private _blendEquationAlpha;
        /**@internal */
        private _sFactor;
        /**@internal */
        private _dFactor;
        /**@internal */
        private _sFactorRGB;
        /**@internal */
        private _dFactorRGB;
        /**@internal */
        private _sFactorAlpha;
        /**@internal */
        private _dFactorAlpha;
        /**@internal */
        private _cullFace;
        /**@internal */
        private _frontFace;
        /**@internal */
        _engine: WebGLEngine;
        /**@internal */
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        /**
         * intance glRenderState
         * @param engine
         */
        constructor(engine: WebGLEngine);
        /**
         * init
         */
        private _initState;
        /**
         * get gl blend factor
         * @param factor
         * @returns
         */
        _getBlendFactor(factor: BlendFactor): 0 | 1 | 768 | 769 | 774 | 775 | 770 | 771 | 772 | 773 | 776 | 32769 | 32770;
        /**
         * get gl blend operation
         * @param factor
         * @returns
         */
        _getBlendOperation(factor: BlendEquationSeparate): 32774 | 32778 | 32779;
        /**
         * get gl compare fun factor
         * @param compareFunction
         * @returns
         */
        _getGLCompareFunction(compareFunction: CompareFunction): number;
        /**
         * get gl stencil operation
         * @param compareFunction
         * @returns
         */
        _getGLStencilOperation(compareFunction: StencilOperation): number;
        /**
         * get gl frontface factor
         * @param cullmode
         * @returns
         */
        _getGLFrontfaceFactor(cullmode: CullMode): 2305 | 2304;
        /**
         * @internal
         */
        setDepthTest(value: boolean): void;
        /**
         * @internal
         */
        setDepthMask(value: boolean): void;
        /**
         * @internal
         * value {CompareType}
         */
        setDepthFunc(value: number): void;
        /**
         * @internal
         */
        setStencilTest(value: boolean): void;
        /**
         * @internal
         * 模板写入开关
         * @param value
         */
        setStencilWrite(value: boolean): void;
        /**
         * @internal
         * 模板写入掩码
         */
        setStencilWriteMask(mask: number): void;
        /**
         * @internal
         */
        setStencilFunc(fun: number, ref: number, mask: number): void;
        /**
        * @internal
        */
        setstencilOp(fail: number, zfail: number, zpass: number): void;
        /**
         * @internal
         * 设置深度偏移
         * @param value
         */
        setDepthBias(value: boolean): void;
        /**
         * @internal
         * 设置深度偏移因子
         * @param constantFactor
         * @param slopeFactor
         * @param clamp
         */
        setDepthBiasFactor(constantFactor: number, slopeFactor: number, clamp?: number): void;
        /**
         * @internal
         */
        setBlend(value: boolean): void;
        /**
         * @internal
         */
        setBlendEquation(blendEquation: number): void;
        /**
         * @internal
         */
        setBlendEquationSeparate(blendEquationRGB: number, blendEquationAlpha: number): void;
        /**
         * @internal
         */
        setBlendFunc(sFactor: number, dFactor: number, force?: boolean): void;
        /**
         * @internal
         */
        setBlendFuncSeperate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;
        /**
         * @internal
         */
        setCullFace(value: boolean): void;
        /**
         * @internal
         */
        setFrontFace(value: number): void;
    }
    class GLShaderInstance extends GLObject {
        _engine: WebGLEngine;
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        /**@internal */
        private _vs;
        /**@internal */
        private _ps;
        /**@internal TextureId*/
        private _curActTexIndex;
        /**@internal */
        private _vshader;
        /**@internal */
        private _pshader;
        /**@internal */
        private _program;
        /**@internal */
        private _attributeMap;
        /**@internal */
        private _uniformMap;
        /**@internal */
        private _uniformObjectMap;
        /**@internal */
        _complete: boolean;
        constructor(engine: WebGLEngine, vs: string, ps: string, attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        });
        private _create;
        /**
        * @internal
        */
        private _createShader;
        /**
         * @internal
         */
        private _addShaderUnifiormFun;
        getUniformMap(): ShaderVariable[];
        /**
         * @internal
         * @returns
         */
        bind(): boolean;
        /**
         * @internal
         */
        useProgram(): boolean;
        /**
        * @internal
        */
        _uniform1f(one: any, value: any): number;
        /**
        * @internal
        */
        _uniform1fv(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_vec2(one: any, v: Vector2): number;
        /**
         * @internal
         */
        _uniform_vec2v(one: any, value: Float32Array): number;
        /**
         * @internal
         */
        _uniform_vec3(one: any, v: Vector3): number;
        /**
         * @internal
         */
        _uniform_vec3v(one: any, v: Float32Array): number;
        /**
         * @internal
         */
        _uniform_vec4(one: any, v: Vector4): number;
        /**
         * @internal
         */
        _uniform_vec4v(one: any, v: Float32Array): number;
        /**
         * @internal
         */
        _uniformMatrix2fv(one: any, value: any): number;
        /** @internal */
        _uniformMatrix3f(one: any, value: Matrix3x3): number;
        /**
         * @internal
         */
        _uniformMatrix3fv(one: any, value: Float32Array): number;
        /**
         * @internal
         */
        _uniformMatrix4f(one: any, m: Matrix4x4): number;
        /**
         * @internal
         */
        _uniformMatrix4fv(one: any, m: Float32Array): number;
        /**
         * @internal
         */
        _uniform1i(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform1iv(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_ivec2(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_ivec2v(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_vec3i(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_vec3vi(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_vec4i(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_vec4vi(one: any, value: any): number;
        /**
         * @internal
         */
        _uniform_sampler2D(one: any, texture: BaseTexture): number;
        _uniform_sampler2DArray(one: any, texture: BaseTexture): number;
        _uniform_sampler3D(one: any, texture: BaseTexture): number;
        /**
         * @internal
         */
        _uniform_samplerCube(one: any, texture: BaseTexture): number;
        _uniform_UniformBuffer(one: ShaderVariable, value: WebGLUniformBufferBase): number;
        /**
         * @internal
         */
        _bindTexture(textureID: number, target: number, texture: WebGLTexture): void;
        destroy(): void;
    }
    class GLVertexState extends GLObject {
        private _angleInstancedArrays;
        private _vaoExt;
        private _vao;
        _vertexDeclaration: {
            [key: number]: VertexStateContext;
        }[];
        _bindedIndexBuffer: WebGLIndexBuffer;
        _vertexBuffers: WebGLVertexBuffer[];
        constructor(engine: WebGLEngine);
        /**
         * @internal
         */
        private createVertexArray;
        /**
         * @internal
         */
        private deleteVertexArray;
        /**
         * @internal
         */
        bindVertexArray(): void;
        /**
         * @internal
         */
        unbindVertexArray(): void;
        /**
         * @internal
         */
        isVertexArray(): void;
        applyVertexBuffer(vertexBuffer: WebGLVertexBuffer[]): void;
        clearVAO(): void;
        applyIndexBuffer(indexBuffer: WebGLIndexBuffer | null): void;
        /**
             * @internal
             */
        vertexAttribDivisor(index: number, divisor: number): void;
        /**
         * @internal
         */
        destroy(): void;
    }
    class VertexArrayObject {
        constructor();
    }
    /**
     * init Webgl option
     */
    class WebGLConfig {
        stencil: boolean;
        alpha: boolean;
        depth: boolean;
        antialias: boolean;
        failIfMajorPerformanceCaveat: boolean;
        premultipliedAlpha: boolean;
        preserveDrawingBuffer: boolean;
        powerPreference: WebGLPowerPreference;
    }
    class WebGLIndexBuffer implements IIndexBuffer {
        _glBuffer: GLBuffer;
        indexType: IndexFormat;
        indexCount: number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        _setIndexDataLength(data: number): void;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
        destroy(): void;
    }
    class WebGLInternalRT extends GLObject implements InternalRenderTarget {
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        _framebuffer: WebGLFramebuffer;
        _depthbuffer: WebGLRenderbuffer;
        _msaaFramebuffer: WebGLFramebuffer;
        _msaaRenderbuffer: WebGLRenderbuffer;
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        /**bytelength */
        _gpuMemory: number;
        get gpuMemory(): number;
        set gpuMemory(value: number);
        private _changeTexMemory;
        constructor(engine: WebGLEngine, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, isCube: boolean, generateMipmap: boolean, samples: number);
        dispose(): void;
    }
    /** @internal */
    class WebGLInternalTex extends GLObject implements InternalTexture {
        _gl: WebGLRenderingContext | WebGL2RenderingContext;
        readonly resource: WebGLTexture;
        _resourceTarget: number;
        readonly width: number;
        readonly height: number;
        readonly depth: number;
        readonly isPotSize: boolean;
        private _mipmap;
        /**
         * 是否存在 mipmap 数据
         */
        get mipmap(): boolean;
        private _mipmapCount;
        get mipmapCount(): number;
        readonly useSRGBLoad: boolean;
        readonly gammaCorrection: number;
        readonly target: number;
        internalFormat: number;
        format: number;
        type: number;
        /**bytelength */
        _gpuMemory: number;
        private _statistics_M_Texture;
        private _statistics_RC_Texture;
        _getSource(): WebGLTexture;
        get gpuMemory(): number;
        set gpuMemory(value: number);
        constructor(engine: WebGLEngine, target: number, width: number, height: number, depth: number, dimension: TextureDimension, mipmap: boolean, useSRGBLoader: boolean, gammaCorrection: number);
        private _filterMode;
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        private _warpU;
        get wrapU(): WrapMode;
        set wrapU(value: WrapMode);
        private _warpV;
        get wrapV(): WrapMode;
        set wrapV(value: WrapMode);
        private _warpW;
        get wrapW(): WrapMode;
        set wrapW(value: WrapMode);
        private _anisoLevel;
        get anisoLevel(): number;
        set anisoLevel(value: number);
        private _baseMipmapLevel;
        set baseMipmapLevel(value: number);
        get baseMipmapLevel(): number;
        private _maxMipmapLevel;
        set maxMipmapLevel(value: number);
        get maxMipmapLevel(): number;
        private _compareMode;
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        _setTexParameteri(pname: number, param: number): void;
        _setTexParametexf(pname: number, param: number): void;
        protected getFilteMinrParam(filterMode: FilterMode, mipmap: boolean): 9984 | 9728 | 9985 | 9729 | 9987;
        protected getFilterMagParam(filterMode: FilterMode): 9728 | 9729;
        protected getWrapParam(wrapMode: WrapMode): 10497 | 33071 | 33648;
        protected _setWrapMode(pname: number, param: number): void;
        private _changeTexMemory;
        dispose(): void;
    }
    class WebGLSetRenderData extends SetRenderDataCMD {
        type: RenderCMDType;
        protected _dataType: ShaderDataType;
        protected _propertyID: number;
        protected _dest: WebGLShaderData;
        protected _value: ShaderDataItem;
        data_v4: Vector4;
        data_v3: Vector3;
        data_v2: Vector2;
        data_mat: Matrix4x4;
        data_number: number;
        data_texture: BaseTexture;
        data_Color: Color;
        data_Buffer: Float32Array;
        get dataType(): ShaderDataType;
        set dataType(value: ShaderDataType);
        get propertyID(): number;
        set propertyID(value: number);
        get dest(): WebGLShaderData;
        set dest(value: WebGLShaderData);
        get value(): ShaderDataItem;
        set value(value: ShaderDataItem);
        constructor();
        apply(context: any): void;
    }
    class WebGLSetShaderDefine extends SetShaderDefineCMD {
        type: RenderCMDType;
        protected _define: ShaderDefine;
        protected _dest: WebGLShaderData;
        protected _add: boolean;
        get define(): ShaderDefine;
        set define(value: ShaderDefine);
        get dest(): WebGLShaderData;
        set dest(value: WebGLShaderData);
        get add(): boolean;
        set add(value: boolean);
        constructor();
        apply(context: any): void;
    }
    class WebGLRenderDeviceFactory implements IRenderDeviceFactory {
        createShaderData(ownerResource?: Resource): ShaderData;
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): IShaderInstance;
        createIndexBuffer(bufferUsageType: BufferUsage): IIndexBuffer;
        createVertexBuffer(bufferUsageType: BufferUsage): IVertexBuffer;
        createBufferState(): IBufferState;
        createRenderGeometryElement(mode: MeshTopology, drawType: DrawType): IRenderGeometryElement;
        private globalBlockMap;
        createGlobalUniformMap(blockName: string): WebGLCommandUniformMap;
        createEngine(config: Config, canvas: HTMLCanvas): Promise<void>;
        /**@private test function*/
        private _replaceWebglcall;
    }
    class WebGLRenderGeometryElement implements IRenderGeometryElement {
        private static _idCounter;
        _id: number;
        bufferState: WebGLBufferState;
        private _mode;
        /**@internal 优化使用*/
        _glmode: number;
        drawType: DrawType;
        drawParams: FastSinglelist<number>;
        instanceCount: number;
        /**@internal 优化*/
        _glindexFormat: number;
        private _indexFormat;
        /**
         * index format
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * Mesh Topology mode
         */
        get mode(): MeshTopology;
        set mode(value: MeshTopology);
        constructor(mode: MeshTopology, drawType: DrawType);
        getDrawDataParams(out: FastSinglelist<number>): void;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        destroy(): void;
        clearRenderParams(): void;
        cloneTo(obj: WebGLRenderGeometryElement): void;
    }
    /**
     * <code>ShaderInstance</code> 类用于实现ShaderInstance。
     */
    class WebGLShaderInstance implements IShaderInstance {
        /**@internal */
        private _shaderPass;
        /**@internal */
        _cacheShaerVariable: {
            [key: number]: ShaderVariable;
        };
        /**@internal */
        _renderShaderInstance: GLShaderInstance;
        /**@internal */
        _sceneUniformParamsMap: CommandEncoder;
        /**@internal */
        _cameraUniformParamsMap: CommandEncoder;
        /**@internal */
        _spriteUniformParamsMap: CommandEncoder;
        /**@internal */
        _materialUniformParamsMap: CommandEncoder;
        /**@internal */
        _sprite2DUniformParamsMap: CommandEncoder;
        _additionUniformParamsMaps: Map<string, CommandEncoder>;
        /**@internal */
        _uploadMark: number;
        /**@internal */
        _uploadMaterial: ShaderData;
        /**@internal RenderIDTODO*/
        _uploadRender: ShaderData;
        /** @internal */
        _uploadRenderType: number;
        /**@internal CamneraTOD*/
        _uploadCameraShaderValue: ShaderData;
        /**@internal SceneIDTODO*/
        _uploadScene: ShaderData;
        /** @internal 缓存数据 用来优化一些*/
        _additionShaderData: Map<string, ShaderData>;
        /**
         * 创建一个 <code>ShaderInstance</code> 实例。
         */
        constructor();
        _serializeShader(): ArrayBuffer;
        _deserialize(buffer: ArrayBuffer): boolean;
        /**
         * get complete
         */
        get complete(): boolean;
        _create(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderPass): void;
        /**
         * @internal
         */
        protected _create3D(): void;
        /**
         * @internal
         */
        protected _create2D(): void;
        private hasSpritePtrID;
        private _hasAdditionShaderData;
        /**
         * @inheritDoc
         * @override
         */
        _disposeResource(): void;
        /**
         * apply shader programe
         * @returns
         */
        bind(): boolean;
        /**
         * upload uniform data
         * @param shaderUniform
         * @param shaderDatas
         * @param uploadUnTexture
         */
        uploadUniforms(shaderUniform: CommandEncoder, shaderDatas: WebGLShaderData, uploadUnTexture: boolean): void;
        /**
         * set blend depth stencil RenderState
         * @param shaderDatas
         */
        uploadRenderStateBlendDepth(shaderDatas: WebGLShaderData): void;
        /**
         * set blend depth stencil RenderState frome Shader
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByShader(shaderDatas: WebGLShaderData): void;
        /**
         * set blend depth stencil RenderState frome Material
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByMaterial(shaderDatas: ShaderData): void;
        /**
         * @internal
         */
        uploadRenderStateFrontFace(shaderDatas: ShaderData, isTarget: boolean, invertFront: boolean): void;
    }
    class WebGLSubUniformBuffer extends WebGLUniformBufferBase implements IUniformBufferUser {
        uniformMap: Map<number, {
            id: number;
            propertyName: string;
            uniformtype: ShaderDataType;
            arrayLength: number;
        }>;
        upload(): void;
        bind(location: number): void;
        bufferBlock: UniformBufferBlock;
        bufferAlone: UniformBufferAlone;
        manager: WebGLUniformBufferManager;
        data: ShaderData;
        offset: number;
        name: string;
        size: number;
        constructor(name: string, uniformMap: Map<number, {
            id: number;
            propertyName: string;
            uniformtype: ShaderDataType;
            arrayLength: number;
        }>, mgr: WebGLUniformBufferManager, data: ShaderData);
        updateOver(): void;
        clearGPUBufferBind(): void;
        notifyGPUBufferChange(info?: string): void;
        destroy(): void;
    }
    class WebGLUniformBuffer extends WebGLUniformBufferBase {
        private _data;
        private _buffer;
        name: string;
        constructor(name: string);
        create(): void;
        /**
         * 添加 uniform
         * @param index
         * @param type
         * @param arraySize
         */
        addUniform(index: number, type: ShaderDataType, arraySize?: number): void;
        upload(): void;
        bind(location: number): void;
        clone(): WebGLUniformBuffer;
        cloneTo(dest: WebGLUniformBuffer): void;
        destroy(): void;
    }
    abstract class WebGLUniformBufferBase {
        descriptor: WebGLUniformBufferDescriptor;
        needUpload: boolean;
        abstract upload(): void;
        abstract bind(location: number): void;
        abstract destroy(): void;
        setInt(index: number, value: number): void;
        setFloat(index: number, value: number): void;
        setVector2(index: number, value: Vector2): void;
        setVector3(index: number, value: Vector3): void;
        setVector4(index: number, value: Vector4): void;
        setMatrix3x3(index: number, value: Matrix3x3): void;
        setMatrix4x4(index: number, value: Matrix4x4): void;
        setBuffer(index: number, value: Float32Array): void;
        setArrayBuffer(index: number, value: Float32Array): void;
        private setMatrix3x3Array;
        setUniformData(index: number, type: ShaderDataType, data: any): void;
    }
    type WebGLUniform = {
        index: number;
        /**
         * byte offset
         */
        offset: number;
        dataView: TypedArrayConstructor;
        view: TypedArrayType;
        /**
         * element size (eg: vec2: 2, vec4: 4, mat4: 16)
         */
        size: number;
        alignStride: number;
        viewByteLength: number;
        /**
         * 0: not array
         */
        arrayLength: number;
    };
    class WebGLUniformBufferDescriptor implements IClone {
        name: string;
        private _currentLength;
        private _byteLength;
        get byteLength(): number;
        private _maxAlignment;
        uniforms: Map<number, WebGLUniform>;
        constructor(name: string);
        /**
         * std 140 字节对齐
         * @param alignment
         */
        private alignmentPadding;
        addUniformItem(index: number, size: number, alignStride: number, arraySize: number, tsc: TypedArrayConstructor): void;
        addUniform(index: number, type: ShaderDataType, arraySize?: number): void;
        /**
         * finish add uniform
         * @param alignment
         */
        finish(alignment?: number): void;
        clone(): WebGLUniformBufferDescriptor;
        cloneTo(destObject: WebGLUniformBufferDescriptor): void;
        destroy(): void;
    }
    class WebGLUniformBufferManager extends UniformBufferManager {
        engine: WebGLEngine;
        constructor(engine: WebGLEngine, offsetAlignment: number);
        createGPUBuffer(size: number, name?: string, data?: ArrayBuffer): GLBuffer;
        writeBuffer(buffer: GLBuffer, data: ArrayBuffer, offset: number, size: number): void;
    }
    class WebGLVertexBuffer implements IVertexBuffer {
        _glBuffer: GLBuffer;
        private _vertexDeclaration;
        /**@internal */
        _shaderValues: {
            [key: number]: VertexStateContext;
        };
        get vertexDeclaration(): VertexDeclaration;
        set vertexDeclaration(value: VertexDeclaration);
        instanceBuffer: boolean;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        setDataLength(byteLength: number): void;
        setData(buffer: ArrayBuffer, bufferOffset: number, dataStartIndex: number, dataCount: number): void;
        /**
         * @private
         */
        bind(): boolean;
        unbind(): void;
        /**
         * 剥离内存块存储。
         */
        orphanStorage(): void;
        destroy(): void;
    }
    class BlendState {
        static _blend_All_pool: any;
        static _blend_seperate_pool: any;
        static create(blendType: number, colorBlendhash: BlendComponent, alphaBlendComponent: BlendComponent): void;
        /** Whether to enable blend. */
        blendType: BlendType;
        colorBlendComponent: BlendComponent;
        alphaBlendComponent: BlendComponent;
        constructor(blendType: number);
    }
    class BlendComponent {
        static _pool: Record<number, BlendComponent>;
        static getHash(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): number;
        static getBlendComponent(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): BlendComponent;
        _blendOperation: BlendEquationSeparate;
        _blendOperationGLData: number;
        _sourceBlendFactor: BlendFactor;
        _sourceBlendFactorGLData: number;
        _destinationFactor: BlendFactor;
        _destinationFactorGLData: number;
        _hashIndex: number;
        constructor(blendOperationGLData: BlendEquationSeparate, sourceBlendFactor: BlendFactor, destinationFactor: BlendFactor, hashindex: number);
    }
    class Buffer {
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        _bufferType: number;
        _bufferUsage: number;
        _byteLength: number;
        get bufferUsage(): number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        /**
         * @private
         */
        destroy(): void;
    }
    /**
     * dds 未存储 color space 需要手动指定
     * @blueprintIgnore
     */
    class DDSTextureInfo {
        width: number;
        height: number;
        mipmapCount: number;
        isCube: boolean;
        bpp: number;
        blockBytes: number;
        format: TextureFormat;
        compressed: boolean;
        dataOffset: number;
        source: ArrayBuffer;
        constructor(width: number, height: number, mipmapCount: number, isCube: boolean, bpp: number, blockBytes: number, dataOffset: number, format: TextureFormat, compressed: boolean, sourceData: ArrayBuffer);
        static getDDSTextureInfo(source: ArrayBuffer): DDSTextureInfo;
    }
    /**
     * https://floyd.lbl.gov/radiance/framer.html
     * @blueprintIgnore
     */
    class HDRTextureInfo {
        source: ArrayBuffer;
        byteOffset: number;
        decreaseX: boolean;
        decreaseY: boolean;
        width: number;
        height: number;
        format: TextureFormat;
        static HDRTEXTURE: string;
        static _parseHDRTexture(data: ArrayBuffer, propertyParams?: any, constructParams?: any[]): Texture2D;
        /**
         *
         * @param source
         */
        static getHDRInfo(source: ArrayBuffer): HDRTextureInfo;
        private static getLineString;
        constructor(source: ArrayBuffer, byteOffset: number, decreaseX: boolean, decreaseY: boolean, width: number, height: number, format: TextureFormat);
        get_32_bit_rle_rgbe(): ArrayBufferView;
        /**
         * https://www.radiance-online.org/archived/radsite/radiance/refer/Notes/picture_format.html
         */
        readScanLine(): ArrayBufferView;
        readcolors(scanlineArray: Uint8Array, getc: () => number, wrong: () => void): void;
        olddreadcolors(scanlineArray: Uint8Array, getc: () => number, r: number, g: number, b: number, e: number): void;
        color_color(col: Vector4, clr: Vector4): void;
    }
    class IndexBuffer extends Buffer {
        /** @internal */
        protected _indexType: IndexFormat;
        /** @internal */
        protected _indexTypeByteCount: number;
        /** @internal */
        protected _indexCount: number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    /**
     * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
     * https://www.khronos.org/registry/KTX/specs/2.0/ktxspec_v2.html
     * @blueprintIgnore
     */
    class KTXTextureInfo {
        source: ArrayBuffer;
        compress: boolean;
        sRGB: boolean;
        dimension: TextureDimension;
        width: number;
        height: number;
        format: TextureFormat;
        mipmapCount: number;
        bytesOfKeyValueData: number;
        headerOffset: number;
        static getLayaFormat(glFormat: number, glInternalFormat: number, glType: number, glTypeSize: number): {
            format: TextureFormat;
            sRGB: boolean;
        };
        static getKTXTextureInfo(source: ArrayBuffer): KTXTextureInfo;
        static createKTX1Info(source: ArrayBuffer): KTXTextureInfo;
        constructor(source: ArrayBuffer, compress: boolean, sRGB: boolean, dimension: TextureDimension, width: number, height: number, format: TextureFormat, mipmapCount: number, bytesOfKeyValueData: number, headerOffset: number);
    }
    enum BlendEquationSeparate {
        ADD = 0,
        SUBTRACT = 1,
        REVERSE_SUBTRACT = 2,
        MIN = 3,
        MAX = 4
    }
    enum BlendFactor {
        /** (0, 0, 0, 0)*/
        Zero = 0,
        /** (1, 1, 1, 1)*/
        One = 1,
        /** (Rs, Gs, Bs, As) */
        SourceColor = 2,
        /** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/
        OneMinusSourceColor = 3,
        /** (Rd, Gd, Bd, Ad)*/
        DestinationColor = 4,
        /** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/
        OneMinusDestinationColor = 5,
        /** (As, As, As, As)*/
        SourceAlpha = 6,
        /** (1 - As, 1 - As, 1 - As, 1 - As)*/
        OneMinusSourceAlpha = 7,
        /** (Ad, Ad, Ad, Ad)*/
        DestinationAlpha = 8,
        /** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/
        OneMinusDestinationAlpha = 9,
        /** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/
        SourceAlphaSaturate = 10,
        /** (Rc, Gc, Bc, Ac)*/
        BlendColor = 11,
        /** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/
        OneMinusBlendColor = 12
    }
    enum BlendType {
        /**混合枚举_禁用。*/
        BLEND_DISABLE = 0,
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        BLEND_ENABLE_ALL = 1,
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        BLEND_ENABLE_SEPERATE = 2
    }
    enum BufferTargetType {
        ARRAY_BUFFER = 0,
        ELEMENT_ARRAY_BUFFER = 1,
        UNIFORM_BUFFER = 2,
        COPY_READ_BUFFER = 3,
        COPY_WRITE_BUFFER = 4,
        TRANSFORM_FEEDBACK_BUFFER = 5
    }
    /**
     * Buffer usage.
     */
    enum BufferUsage {
        /** The buffer content are intended to be specified once, and used many times */
        Static = 0,
        /** The buffer contents are intended to be respecified repeatedly, and used many times */
        Dynamic = 1,
        /** The buffer contents are intended to be specified once, and used at most a few times */
        Stream = 2
    }
    enum CompareFunction {
        /** never pass. */
        Never = 0,
        /** pass if the incoming value is less than the depth/stencil buffer value. */
        Less = 1,
        /** pass if the incoming value equals the depth/stencil buffer value. */
        Equal = 2,
        /** pass if the incoming value is less than or equal to the depth/stencil buffer value. */
        LessEqual = 3,
        /** pass if the incoming value is greater than the depth/stencil buffer value. */
        Greater = 4,
        /** pass if the incoming value is not equal to the depth/stencil buffer value. */
        NotEqual = 5,
        /** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */
        GreaterEqual = 6,
        /** always pass. */
        Always = 7,
        /** off */
        Off = 8
    }
    enum CullMode {
        /** Disable culling. */
        Off = 0,
        /** cut the front-face of the polygons. */
        Front = 1,
        /** cut the back-face of the polygons. */
        Back = 2
    }
    enum FrontFace {
        /** Clockwise front faces. */
        CW = 0,
        /** Counter-clockwise front faces. */
        CCW = 1
    }
    enum DrawType {
        DrawArray = 0,
        DrawArrayInstance = 1,
        DrawArrayIndirect = 2,
        DrawElement = 3,
        DrawElementInstance = 4,
        DrawElementIndirect = 5
    }
    /**
     * 纹理的过滤模式。
     */
    enum FilterMode {
        /**点过滤。*/
        Point = 0,
        /**双线性过滤。*/
        Bilinear = 1,
        /**三线性过滤。*/
        Trilinear = 2
    }
    enum HDREncodeFormat {
        NONE = 0,
        RGBM = 1,
        RGBD = 2
    }
    enum IndexFormat {
        /** 8 位无符号整型索引格式。*/
        UInt8 = 0,
        /** 16 位无符号整型索引格式。*/
        UInt16 = 1,
        /** 32 位无符号整型索引格式。*/
        UInt32 = 2
    }
    enum RenderCapable {
        Element_Index_Uint32 = 0,
        Element_Index_Uint8 = 1,
        TextureFormat_R32G32B32A32 = 2,
        TextureFormat_R16G16B16A16 = 3,
        Texture_anisotropic = 4,
        RenderTextureFormat_R16G16B16A16 = 5,
        RenderTextureFormat_R32G32B32A32 = 6,
        RenderTextureFormat_Depth = 7,
        RenderTextureFormat_ShadowMap = 8,
        Vertex_VAO = 9,
        DrawElement_Instance = 10,
        Shader_TextureLod = 11,
        COMPRESS_TEXTURE_S3TC = 12,
        COMPRESS_TEXTURE_S3TC_SRGB = 13,
        COMPRESS_TEXTURE_PVRTC = 14,
        COMPRESS_TEXTURE_ETC1 = 15,
        COMPRESS_TEXTURE_ETC = 16,
        COMPRESS_TEXTURE_ASTC = 17,
        Texture_SRGB = 18,
        MSAA = 19,
        UnifromBufferObject = 20,
        Texture3D = 21,
        Texture_FloatLinearFiltering = 22,
        Texture_HalfFloatLinearFiltering = 23,
        StorageBuffer = 24,
        ComputeShader = 25,
        IndirectDraw = 26
    }
    enum RenderClearFlag {
        Nothing = 0,
        Color = 1,
        Depth = 2,
        Stencil = 4
    }
    enum RenderDrawMode {
        TRIANGLES = 0,
        POINTS = 1,
        LINES = 2
    }
    enum RenderIndexMode {
        UNSIGNED_BYTE = 0,
        UNSIGNED_SHORT = 1,
        UNSIGNED_INT = 2
    }
    enum RenderParams {
        Max_Active_Texture_Count = 0,
        Max_Uniform_Count = 1,
        Max_AnisoLevel_Count = 2,
        MAX_Texture_Size = 3,
        MAX_Texture_Image_Uint = 4,
        SHADER_CAPAILITY_LEVEL = 5,
        FLOAT = 6,
        UNSIGNED_BYTE = 7,
        BYTE = 8,
        UNSIGNED_SHORT = 9
    }
    /**
     * Mesh topology.
     */
    enum MeshTopology {
        /** Draws a single dot */
        Points = 0,
        /** Draws a line between a pair of vertices */
        Lines = 1,
        /** Draws a straight line to the next vertex, and connects the last vertex back to the first */
        LineLoop = 2,
        /** Draws a straight line to the next vertex. */
        LineStrip = 3,
        /** Draws a triangle for a group of three vertices */
        Triangles = 4,
        /** Draws a triangle strip */
        TriangleStrip = 5,
        /** Draws a triangle fan */
        TriangleFan = 6
    }
    enum RenderStateType {
        DepthTest = 0,
        DepthMask = 1,
        DepthFunc = 2,
        StencilTest = 3,
        StencilMask = 4,
        StencilFunc = 5,
        StencilOp = 6,
        BlendType = 7,
        BlendEquation = 8,
        BlendEquationSeparate = 9,
        BlendFunc = 10,
        BlendFuncSeperate = 11,
        CullFace = 12,
        FrontFace = 13
    }
    enum RenderTargetFormat {
        None = -1,
        /**使用RGB的纹理，不可设置SRGB参数 */
        R8G8B8 = 0,
        R8G8B8A8 = 1,
        R16G16B16A16 = 17,
        R32G32B32 = 30,
        R32G32B32A32 = 15,
        R16G16B16 = 31,
        DEPTH_16 = 35,
        STENCIL_8 = 36,
        DEPTHSTENCIL_24_8 = 37,
        DEPTH_32 = 38,
        DEPTHSTENCIL_24_Plus = 39
    }
    enum StencilOperation {
        /** Keeps the current value. */
        Keep = 0,
        /** Sets the stencil buffer value to 0. */
        Zero = 1,
        /** Sets the stencil buffer value to the reference value. */
        Replace = 2,
        /** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */
        IncrementSaturate = 3,
        /** Decrements the current stencil buffer value. Clamps to 0. */
        DecrementSaturate = 4,
        /** Inverts the current stencil buffer value bitwise. */
        Invert = 5,
        /** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */
        IncrementWrap = 6,
        /** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */
        DecrementWrap = 7
    }
    enum TextureCompareMode {
        None = 0,
        LEQUAL = 1,
        GEQUAL = 2,
        LESS = 3,
        GREATER = 4,
        EQUAL = 5,
        NOTEQUAL = 6,
        ALWAYS = 7,
        NEVER = 8
    }
    /**
     * 纹理解码格式。
     */
    enum TextureDecodeFormat {
        /** 常规解码方式,直接采样纹理颜色。*/
        Normal = 0,
        /** 按照RGBM方式解码并计算最终RGB颜色。 */
        RGBM = 1
    }
    enum TextureDimension {
        Tex2D = 0,
        Cube = 1,
        Tex3D = 2,
        Texture2DArray = 3,
        CubeArray = 4,
        Unkonw = 5,
        None = 6
    }
    /**
     * 纹理格式
     */
    enum TextureFormat {
        /**纹理格式_R8G8B8。*/
        R8G8B8 = 0,
        /**纹理格式_R8G8B8A8。*/
        R8G8B8A8 = 1,
        /**RGB格式纹理,R通道5位，G通道6位，B通道5位。*/
        R5G6B5 = 16,
        /**纹理格式_ALPHA8。*/
        Alpha8 = 2,
        /**纹理格式_DXT1。*/
        DXT1 = 3,
        /**纹理格式_DXT3 */
        DXT3 = 29,
        /**纹理格式_DXT5。*/
        DXT5 = 4,
        /**纹理格式_ETC2RGB。*/
        ETC1RGB = 5,
        ETC2RGB = 6,
        ETC2RGBA = 7,
        /**纹理格式_ETC2RGB_PUNCHTHROUGHALPHA。*/
        /**纹理格式_PVRTCRGB_2BPPV。*/
        ETC2SRGB_Alpha8 = 8,
        /** 纹理格式_ETC2SRGB*/
        ETC2SRGB = 28,
        /** 纹理格式 RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ETC2RGB_Alpha1 = 32,
        /** 纹理格式 SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ETC2SRGB_Alpha1 = 33,
        /** 纹理格式_PVRTCRGB_2BPPV*/
        PVRTCRGB_2BPPV = 9,
        /**纹理格式_PVRTCRGBA_2BPPV。*/
        PVRTCRGBA_2BPPV = 10,
        /**纹理格式_PVRTCRGB_4BPPV。*/
        PVRTCRGB_4BPPV = 11,
        /**纹理格式_PVRTCRGBA_4BPPV。*/
        PVRTCRGBA_4BPPV = 12,
        /**RGBA格式纹理,每个通道32位浮点数。*/
        R32G32B32A32 = 15,
        /**R32G32B32 */
        R32G32B32 = 30,
        /**RGBA格式纹理，每个通道16位浮点数。 */
        R16G16B16A16 = 17,
        /**R16 G16 B6 */
        R16G16B16 = 31,
        /**ASTC 4x4*/
        ASTC4x4 = 18,
        /**ASTC sRGB 4x4 */
        ASTC4x4SRGB = 23,
        /**ASTC 6x6*/
        ASTC6x6 = 19,
        /**ASTC  6x6*/
        ASTC6x6SRGB = 24,
        /**ASTC 8x8 */
        ASTC8x8 = 20,
        /**ASTC srgb 8x8 */
        ASTC8x8SRGB = 25,
        /**ASTC 10x10 */
        ASTC10x10 = 21,
        /**ASTC srgb 10x10 */
        ASTC10x10SRGB = 26,
        /**ASTC 12x12 */
        ASTC12x12 = 22,
        /**ASTC srgb 12x12 */
        ASTC12x12SRGB = 27,
        /**ktx图片 */
        KTXTEXTURE = -1,
        /**pvr图片 */
        PVRTEXTURE = -2
    }
    /** 通过纹理格式获取压缩纹理类型 */
    function getCompressTextureRenderCapable(format: TextureFormat): RenderCapable | null;
    /**
     * 纹理寻址模式。
     */
    enum WrapMode {
        /** 循环平铺。*/
        Repeat = 0,
        /** 超过UV边界后采用最后一个像素。*/
        Clamp = 1,
        /** 镜像采样 */
        Mirrored = 2
    }
    /**
     * @internal
     */
    class GLSLCodeGenerator {
        static glslAttributeString(attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }): string;
        static glslUniformString(uniformsMap: Map<number, UniformProperty>, useUniformBlock: boolean, blockName: string): string;
        static GLShaderLanguageProcess3D(defineString: string[], attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap: Map<number, UniformProperty>, VS: ShaderNode, FS: ShaderNode): {
            vs: string;
            fs: string;
        };
    }
    interface IShaderObjStructor {
        name: string;
        enableInstancing: boolean;
        supportReflectionProbe: boolean;
        supportVolumetricGI: boolean;
        attributeMap: any;
        shaderType: ShaderFeatureType | string;
        uniformMap: any;
        defaultValue: any;
        shaderPass: Array<any>;
    }
    interface IShaderpassStructor {
        VS?: string;
        FS?: string;
        VSPath?: string;
        FSPath?: string;
        pipeline?: string;
        statefirst?: boolean;
        renderState?: Record<string, string | boolean | number | string[]>;
    }
    enum ShaderFeatureType {
        None = -1,
        Default = 0,
        D3 = 1,
        D2_primitive = 2,
        D2_TextureSV = 3,
        D2_BaseRenderNode2D = 4,
        PostProcess = 5,
        Sky = 6,
        Effect = 7
    }
    /**
     * Shader3D类用于创建Shader3D。
     * @blueprintIgnore
     */
    class Shader3D {
        static _configDefineValues: IDefineDatas;
        /**@internal */
        private static _compileDefineDatas;
        /**渲染状态_剔除。*/
        static CULL: number;
        /**渲染状态_混合。*/
        static BLEND: number;
        /**渲染状态_混合源。*/
        static BLEND_SRC: number;
        /**渲染状态_混合目标。*/
        static BLEND_DST: number;
        /**渲染状态_混合源RGB。*/
        static BLEND_SRC_RGB: number;
        /**渲染状态_混合目标RGB。*/
        static BLEND_DST_RGB: number;
        /**渲染状态_混合源ALPHA。*/
        static BLEND_SRC_ALPHA: number;
        /**渲染状态_混合目标ALPHA。*/
        static BLEND_DST_ALPHA: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION_RGB: number;
        /**渲染状态_ALPHA混合方程。*/
        static BLEND_EQUATION_ALPHA: number;
        /**渲染状态_深度测试。*/
        static DEPTH_TEST: number;
        /**渲染状态_深度写入。*/
        static DEPTH_WRITE: number;
        /**渲染状态_模板测试。*/
        static STENCIL_TEST: number;
        /**渲染状态_模板写入 */
        static STENCIL_WRITE: number;
        /** 渲染状态_模板写入掩码 */
        static STENCIL_WRITE_MASK: number;
        /** 渲染状态_模板读取掩码 */
        static STENCIL_READ_MASK: number;
        /**渲染状态_模板写入值 */
        static STENCIL_Ref: number;
        /**渲染状态_模板写入设置 */
        static STENCIL_Op: number;
        /**渲染状态_深度偏移 */
        static DEPTH_BIAS: number;
        /**渲染状态_深度偏移常量 */
        static DEPTH_BIAS_CONSTANT: number;
        /**渲染状态_深度偏移斜率 */
        static DEPTH_BIAS_SLOPESCALE: number;
        /**渲染状态_深度偏移限制 */
        static DEPTH_BIAS_CLAMP: number;
        /**shader变量提交周期，自定义。*/
        static PERIOD_CUSTOM: number;
        /**shader变量提交周期，逐材质。*/
        static PERIOD_MATERIAL: number;
        /**shader变量提交周期，逐精灵和相机，注：因为精灵包含MVP矩阵，为复合属性，所以摄像机发生变化时也应提交。*/
        static PERIOD_SPRITE: number;
        /**shader变量提交周期，逐相机。*/
        static PERIOD_CAMERA: number;
        /**shader变量提交周期，逐场景。*/
        static PERIOD_SCENE: number;
        /**@internal */
        static SHADERDEFINE_LEGACYSINGALLIGHTING: ShaderDefine;
        /**@internal 图形数据传输使用UniformBlock的方式 */
        static SHADERDEFINE_ENUNIFORMBLOCK: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FLOATTEXTURE: ShaderDefine;
        /**@internal */
        static SHADERDEFINE_FLOATTEXTURE_FIL_LINEAR: ShaderDefine;
        /**@internal opengl webgl 需要重新映射深度值 */
        static SHADERDEFINE_REMAP_POSITIONZ: ShaderDefine;
        /**@internal 是否支持指定LOD的贴图采样 */
        static SHADERDEFINE_LOD_TEXTURE_SAMPLE: ShaderDefine;
        /**@internal 是否支持动态中断贴图采样 */
        static SHADERDEFINE_BREAK_TEXTURE_SAMPLE: ShaderDefine;
        /**@internal 是否支持动态中断贴图采样 */
        static SHADERDEFINE_STORAGEBUFFER: ShaderDefine;
        /**@internal */
        static _propertyNameMap: any;
        /**@internal */
        static _preCompileShader: {
            [key: string]: Shader3D;
        };
        /**@internal */
        static _debugShaderVariantInfo: any;
        /**是否开启调试模式。 */
        static debugMode: boolean;
        static init(): void;
        /**
         * @internal
         */
        static _getNamesByDefineData(defineData: IDefineDatas, out: Array<string>): string[];
        /**
         * 注册宏定义。
         * @param name
         */
        static getDefineByName(name: string): ShaderDefine;
        /**
         * 通过Shader属性名称获得唯一ID。
         * @param name Shader属性名称。
         * @return 唯一ID。
         */
        static propertyNameToID(name: string): number;
        static propertyIDToName(id: number): string;
        /**
         * 添加函数库引用。
         * @param fileName 文件名字。
         * @param txt 文件内容
         */
        static addInclude(fileName: string, txt: string): void;
        /**
         * 通过宏定义名字编译shader。
         * @param shaderName Shader名称。
         * @param   subShaderIndex 子着色器索引。
         * @param   passIndex  通道索引。
         * @param defineNames 宏定义名字集合。
         * @param   nodeCommonMap ubo集合名称集合
         */
        static compileShaderByDefineNames(shaderName: string, subShaderIndex: number, passIndex: number, defineNames: string[], nodeCommonMap: string[], additionMap: string[], is2D: boolean, attributeLocations: number[]): boolean;
        /**
         * 通过宏定义和二进制数据编译shader。
         * @param shaderName Shader名称。
         * @param subShaderIndex 子着色器索引。
         * @param passIndex 通道索引。
         * @param defineNames 宏定义名字集合。
         * @param nodeCommonMap ubo集合名称集合
         * @param cacheBuffer 缓存的shader数据
         */
        static compileShaderByBin(shaderName: string, subShaderIndex: number, passIndex: number, defineNames: string[], nodeCommonMap: string[], cacheBuffer: ArrayBuffer): void;
        /**
         * 添加预编译shader文件，主要是处理宏定义
         */
        static add(name: string, enableInstancing?: boolean, supportReflectionProbe?: boolean): Shader3D;
        /**
         * 获取ShaderCompile3D。
         * @param name
         * @return ShaderCompile3D。
         */
        static find(name: string): Shader3D;
        static parse(data: IShaderObjStructor, basePath: string): Shader3D;
        /**@internal */
        _name: string;
        /**@internal */
        _enableInstancing: boolean;
        /**@internal */
        _supportReflectionProbe: boolean;
        /**@internal */
        _supportVolumetricGI: boolean;
        /**@internal */
        _subShaders: SubShader[];
        shaderType: ShaderFeatureType;
        /**
         * 名字。
         */
        get name(): string;
        /**
         * 创建一个 <code>Shader3D</code> 实例。
         */
        constructor(name: string, enableInstancing: boolean, supportReflectionProbe: boolean);
        /**
         * 添加子着色器。
         * @param subShader 子着色器。
         */
        addSubShader(subShader: SubShader): void;
        /**
         * 在特定索引获取子着色器。
         * @param index 索引。
         * @return 子着色器。
         */
        getSubShaderAt(index: number): SubShader;
    }
    /**
     * <code>ShaderPass</code> 类用于实现ShaderPass。
     */
    class ShaderPass extends ShaderCompileDefineBase {
        private _pipelineMode;
        get pipelineMode(): string;
        set pipelineMode(value: string);
        set nodeCommonMap(value: Array<string>);
        get nodeCommonMap(): Array<string>;
        set additionShaderData(value: Array<string>);
        get additionShaderData(): Array<string>;
        /** 优先 ShaderPass 渲染状态 */
        private _statefirst;
        get statefirst(): boolean;
        set statefirst(value: boolean);
        moduleData: IShaderPassData;
        get attributeLocations(): Set<number>;
        set attributeLocations(value: Set<number>);
        /**
         * 渲染状态。
         */
        get renderState(): RenderState;
        constructor(owner: SubShader, compiledObj: IShaderCompiledObj);
        /**
         * @internal
         * @param is2D
         * @param compileDefine
         * @returns
         */
        static createShaderInstance(shaderpass: ShaderPass, is2D: boolean, compileDefine: IDefineDatas): IShaderInstance;
        /**
         * @override
         * @internal
         */
        withCompile(compileDefine: IDefineDatas, is2D?: boolean): IShaderInstance;
        withComplieByBin(compileDefine: IDefineDatas, is2D: boolean, buffer: ArrayBuffer): IShaderInstance;
    }
    /**
     *  <code>shaderVariable</code> 类用于保存shader变量上传相关信息。
     */
    class ShaderVariable {
        static pointID: number;
        /**@internal */
        name: string;
        /**@internal */
        type: number;
        /**@internal */
        location: number;
        /**@internal */
        isArray: boolean;
        /**@internal */
        textureID: number;
        /**@internal */
        dataOffset: number;
        /**@internal */
        caller: any;
        /**@internal */
        fun: any;
        /**@internal */
        uploadedValue: any[];
        /**@internal */
        onID: number;
        /**
         * 创建一个 <code>shaderVariable</code> 实例。
         */
        constructor();
    }
    interface IShaderVariant {
        is2D: boolean;
        subShaderIndex: number;
        passIndex: number;
        defines: string[];
        nodeCommonMap: string[];
        additionMap: string[];
        attributeLocations: number[];
    }
    /**
     * 着色器变种集合。
     */
    class ShaderVariantCollection {
        static active: ShaderVariantCollection;
        private items;
        constructor(items?: Record<string, IShaderVariant[]>);
        add(shaderPass: ShaderPass, defines: ReadonlyArray<string>, is2D: boolean): void;
        compileAll(): void;
        destroy(): void;
    }
    type UniformMapType = {
        [blockName: string]: {
            [uniformName: string]: ShaderDataType;
        } | ShaderDataType;
    };
    type AttributeMapType = {
        [name: string]: [
            number,
            ShaderDataType
        ];
    };
    /**
     * <code>SubShader</code> 类用于创建SubShader。
     */
    class SubShader {
        static IncludeUniformMap: any;
        /**
         * 注册glsl所用到的Uniform
         * 会在生成Uniformmap的时候根据包含的Include文件，添加所需要的uniform因素
         * @param includeName
         * @param uniformMap
         * @param defaultValue
         */
        static regIncludeBindUnifrom(includeName: string, uniformMap: {
            [name: string]: ShaderDataType;
        }, defaultValue: {
            [key: string]: any;
        }): void;
        static readonly DefaultAttributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**@internal */
        _attributeMap: AttributeMapType;
        /**
         * @internal
         * uniform 默认值
         */
        readonly _uniformDefaultValue: {
            [name: string]: ShaderDataItem;
        };
        /**
         * @internal
         * uniform 数据类型
         */
        readonly _uniformMap: Map<number, UniformProperty>;
        _owner: Shader3D;
        /**@internal */
        _flags: any;
        moduleData: ISubshaderData;
        /**@internal */
        _passes: ShaderPass[];
        /**
         * 创建一个 <code>SubShader</code> 实例。
         * @param attributeMap  顶点属性表。
         * @param uniformMap  uniform属性表。
         */
        constructor(attributeMap?: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap?: UniformMapType, uniformDefaultValue?: {
            [name: string]: ShaderDataItem;
        });
        private addUniform;
        /**
         * 添加着色器Pass
         * @param vs
         * @param ps
         * @param pipelineMode 渲染管线模式。
         */
        addShaderPass(vs: string, ps: string, pipelineMode?: string): ShaderPass;
        _addShaderPass(compiledObj: IShaderCompiledObj, pipelineMode?: string): ShaderPass;
        private _addIncludeUniform;
    }
    /**
     * ...
     * @author ...
     */
    class VertexMesh {
        /**顶点位置数据 */
        static MESH_POSITION0: number;
        /**顶点顶点色数据 */
        static MESH_COLOR0: number;
        /**顶点UV0数据 */
        static MESH_TEXTURECOORDINATE0: number;
        /**顶点法线数据 */
        static MESH_NORMAL0: number;
        /**顶点切线数据 */
        static MESH_TANGENT0: number;
        /**顶点骨骼索引数据 */
        static MESH_BLENDINDICES0: number;
        /**顶点骨骼权重数据 */
        static MESH_BLENDWEIGHT0: number;
        /**顶点UV1数据 */
        static MESH_TEXTURECOORDINATE1: number;
        /**顶点世界矩阵数据Row0 */
        static MESH_WORLDMATRIX_ROW0: number;
        /**顶点世界矩阵数据Row1 */
        static MESH_WORLDMATRIX_ROW1: number;
        /**顶点世界矩阵数据Row2 */
        static MESH_WORLDMATRIX_ROW2: number;
        /**顶点世界矩阵数据Row3 */
        static MESH_WORLDMATRIX_ROW3: number;
        /**简单数据动画数据 */
        static MESH_SIMPLEANIMATOR: number;
        /**光照贴图的缩放和偏移 */
        static MESH_LIGHTMAPSCALEOFFSET: number;
        /**instanceworld顶点描述 */
        static instanceWorldMatrixDeclaration: VertexDeclaration;
        /**instanceSimple动画数据顶点描述 */
        static instanceSimpleAnimatorDeclaration: VertexDeclaration;
        /**instanceLightMap光照贴图的缩放和偏移顶点描述 */
        static instanceLightMapScaleOffsetDeclaration: VertexDeclaration;
        /**自定义attribute instance 预留位*/
        /**顶点自定义数据0 */
        static MESH_CUSTOME0: number;
        /**顶点自定义数据1 */
        static MESH_CUSTOME1: number;
        /**顶点自定义数据2 */
        static MESH_CUSTOME2: number;
        /**顶点自定义数据3 */
        static MESH_CUSTOME3: number;
        /**@internal */
        private static _vertexDeclarationMap;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * 获取顶点声明。
         * @param vertexFlag 顶点声明标记字符,格式为:"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT"。
         * @return 顶点声明。
         */
        static getVertexDeclaration(vertexFlag: string, compatible?: boolean): VertexDeclaration;
    }
    class StencilState {
    }
    interface VAElement {
        format: string;
        stride: number;
        shaderLocation: number;
    }
    class VertexAttributeLayout {
        static IPoint: number;
        static _pool: {
            [key: number]: VertexAttributeLayout;
        };
        static getVertexLayoutByPool(vertexs: VertexBuffer[]): VertexAttributeLayout;
        /**
         * vertex attribute byte size Array
         */
        attributeByteSize: Array<number>;
        /**
         * vertex Layout des
         */
        VAElements: Array<VAElement[]>;
        instanceMode: Array<boolean>;
        /**
         * pool index
         */
        id: number;
        /**
         * instance one VertexAttributeLayout
         * @param vertexs
         */
        constructor(vertexs: VertexBuffer[]);
        /**
         * @internal
         * @param vertexs
         * @returns
         */
        deepthEqaul(vertexs: VertexBuffer[]): boolean;
    }
    class VertexBuffer extends Buffer {
        private _instanceBuffer;
        /** @internal */
        _vertexDeclaration: VertexDeclaration | null;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        /**
         * 获取顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    class VertexStateContext {
        elementCount: number;
        elementType: number;
        normalized: number;
        vertexStride: number;
        elementOffset: number;
        elementString: string;
    }
    /**
     * <code>VertexDeclaration</code> 类用于生成顶点声明。
     */
    class VertexDeclaration {
        /**@internal */
        private static _uniqueIDCounter;
        /**@internal */
        private _id;
        /**@internal */
        private _vertexStride;
        /**@internal */
        private _vertexElementsDic;
        /**@internal */
        _shaderValues: {
            [key: number]: VertexStateContext;
        };
        /**@internal [只读]*/
        _vertexElements: Array<VertexElement>;
        /**@internal */
        _VAElements: Array<VAElement>;
        /**
         * 获取唯一标识ID(通常用于优化或识别)。
         * @return 唯一标识ID
         */
        get id(): number;
        /**
         * 顶点跨度，以字节为单位。
         */
        get vertexStride(): number;
        /**
         * 顶点元素的数量。
         */
        get vertexElementCount(): number;
        /**
         * 创建一个 <code>VertexDeclaration</code> 实例。
         * @param vertexStride 顶点跨度。
         * @param vertexElements 顶点元素集合。
         */
        constructor(vertexStride: number, vertexElements: Array<VertexElement>);
        /**
         * 通过索引获取顶点元素。
         * @param index 索引。
         */
        getVertexElementByIndex(index: number): VertexElement;
        /**
         * get vertexElement by usage
         */
        getVertexElementByUsage(usage: number): VertexElement;
    }
    /**
     * @en The class responsible for driving the engine's main loop.
     * @zh 负责驱动引擎主循环的类。
     */
    class Render {
        /**
         * @en The interval time of each frame in milliseconds.
         * @zh 每帧的间隔时间，单位为毫秒。
         */
        static frameInterval: number;
        /**
         * @en The frame number of the last run.
         * @zh 最近一次运行的帧号。
         */
        static lastFrame: number;
        private static _globalRepaintSet;
        private static _globalRepaintGet;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @internal
         */
        static startLoop(): void;
        /**
         * @internal
         */
        static loop(timestamp: number): void;
        /**
         * @ignore
         */
        static vsyncTime(): number;
        /**
         * @ignore
         */
        static isGlobalRepaint(): boolean;
        /**
         * @ignore
         */
        static setGlobalRepaint(): void;
        /** @deprecated */
        static get canvas(): any;
    }
    interface IAutoExpiringResource {
        isRandomTouch: boolean;
        referenceCount: number;
        touch(): void;
    }
    /**
     * VertexElement类用于创建顶点结构分配。
     * @blueprintIgnore
     */
    class VertexElement {
        /**@internal */
        _offset: number;
        /**@internal */
        _elementFormat: string;
        /**@internal */
        _elementUsage: number;
        /**
         * 顶点偏移
         */
        get offset(): number;
        /**
         * 顶点信息名称
         */
        get elementFormat(): string;
        /**
         * 顶点宏标记
         */
        get elementUsage(): number;
        /**
         * 创建顶点结构分配实例
         * @param offset 顶点偏移
         * @param elementFormat 顶点数据格式名称
         * @param elementUsage 顶点宏标记
         */
        constructor(offset: number, elementFormat: string, elementUsage: number);
    }
    /**
     * 类用来定义顶点元素格式
     */
    class VertexElementFormat {
        /**单精度浮点数 */
        static Single: string;
        /**vec2 数据*/
        static Vector2: string;
        /**vec3 数据*/
        static Vector3: string;
        /**vec4 数据 */
        static Vector4: string;
        /**颜色 */
        static Color: string;
        /**字节数组4 */
        static Byte4: string;
        /**字节数组3 */
        static Byte3: string;
        /**字节数组2 */
        static Byte2: string;
        /**字节数组1 */
        static ByteOne: string;
        /**半精度浮点数数组2 */
        static Short2: string;
        /**半精度浮点数数组4 */
        static Short4: string;
        /**归一化半精度浮点数组2 */
        static NormalizedShort2: string;
        /**归一化半精度浮点数组4 */
        static NormalizedShort4: string;
        /**@internal */
        static HalfVector2: string;
        /**@internal */
        static HalfVector4: string;
        /**@internal */
        static NorByte4: string;
        /**@internal */
        static NorUByte4: string;
        /** @internal [组数量,数据类型,是否归一化:0为false]。*/
        private static _elementInfos;
        /**@internal */
        static __init__(): void;
        /**
         * 获取顶点元素格式信息。
         * @param element 元素名称
         * @returns 返回顶点元素信息
         */
        static getElementInfos(element: string): any[];
    }
    /**
     * @en This class is used to describe resources.
     * @zh 此类用来描述资源
     */
    class AssetDb {
        /**
         * @en Default resource instance.
         * @zh 默认资源实例。
         */
        static inst: AssetDb;
        /**
         * @en UUID data.
         * @zh UUID 数据。
         */
        uuidMap: Record<string, string>;
        /**
         * @en Shader name data.
         * @zh 着色器名称数据。
         */
        shaderNameMap: Record<string, string>;
        /**
         * @en Metadata for resources.
         * @zh 资源的元数据。
         */
        metaMap: Record<string, any>;
        /**
         * @en I18n URL map.
         * @zh I18n URL 映射。
         */
        i18nUrlMap: Record<string, string>;
        /**
         * @en Gets the URL from the UUID.
         * @param uuid The UUID.
         * @returns The URL corresponding to the UUID.
         * @zh 根据 UUID 获取 URL。
         * @param uuid UUID
         * @returns UUID 对应的 URL
         */
        UUID_to_URL(uuid: string): string;
        /**
         * @en Asynchronously gets the URL from the UUID.
         * @param uuid The UUID.
         * @returns A promise.
         * @zh 异步根据 uuid 获取 URL。
         * @param uuid UUID
         * @returns 一个promise。
         */
        UUID_to_URL_async(uuid: string): Promise<string>;
        /**
         * @en Asynchronously gets the UUID from the URL.
         * @param url The URL.
         * @returns A promise.
         * @zh 异步根据 URL 获取 UUID。
         * @param url URL
         * @returns 一个 promise。
         */
        URL_to_UUID_async(url: string): Promise<string>;
        /**
         * @en Resolves the real URL from a given URL.
         * @param url The original URL.
         * @param onResolve Optional callback when the URL is resolved.
         * @returns A promise that resolves to the real URL.
         * @zh 根据给定的 URL 解析真实的 URL。
         * @param url 原始 URL。
         * @param onResolve 可选的回调函数，当 URL 被解析时调用。
         * @returns 一个promise，解析为真实的 URL。
         */
        resolveURL(url: string, onResolve?: (url: string) => void): Promise<string>;
        /**
         * @en Finds the URL for a shader name.
         * @param shaderName The shader name.
         * @returns The URL corresponding to the shader name.
         * @zh 根据着色器名称查找 URL。
         * @param shaderName 着色器名称。
         * @returns 着色器名称对应的 URL。
         */
        shaderName_to_URL(shaderName: string): string;
        /**
         * @en Asynchronously finds the URL for a shader name.
         * @param shaderName The shader name.
         * @returns A promise.
         * @zh 异步根据着色器名称查找 URL。
         * @param shaderName 着色器名称。
         * @returns 一个 promise。
         */
        shaderName_to_URL_async(shaderName: string): Promise<string>;
        /**
         * @en Gets the metadata for a resource.
         * @param url The resource URL.
         * @param uuid The resource UUID.
         * @returns A promise.
         * @zh 获取资源的元数据。
         * @param url 资源的 URL。
         * @param uuid 资源的 UUID。
         * @returns 一个 promise。
         */
        getMeta(url: string, uuid: string): Promise<any>;
        /**
         * @en Gets the URL for a sub-asset.
         * @param url The base resource URL.
         * @param uuid The UUID of the base resource.
         * @param subAssetName The name of the sub-asset.
         * @param subAssetExt The file extension of the sub-asset.
         * @returns The URL for the sub-asset.
         * @zh 获取子资源的 URL。
         * @param url 基础资源的 URL。
         * @param uuid 基础资源的 UUID。
         * @param subAssetName 子资源的名称。
         * @param subAssetExt 子资源的文件扩展名。
         * @returns 子资源的 URL。
         */
        getSubAssetURL(url: string, uuid: string, subAssetName: string, subAssetExt: string): string;
        /**
         * @en Gets the URL for the I18n settings.
         * @param id The I18n settings ID.
         * @returns The URL for the I18n settings.
         * @zh 获取 I18n 设置的 URL。
         * @param id I18n 设置的 ID。
         * @returns I18n 设置的 URL。
         */
        getI18nSettingsURL(id: string): string;
    }
    interface IAtlasAnimationInfo {
        /**
         * @en The interval between frame changes, in milliseconds.
         * @zh 帧改变之间的间隔时间，单位为毫秒。
         */
        interval: number;
        /**
         * @en The delay between each repeat, in milliseconds.
         * @zh 每次重复之间的延迟，单位为毫秒。
         */
        repeatDelay: number;
        /**
         * @en Playback order type.
         * @zh 播放顺序类型。
         */
        wrapMode: AnimationWrapMode;
        /**
         * @en The delay time of each frame, in milliseconds.
         * @zh 每帧的延迟时间，单位为毫秒。
         */
        frameDelays: Array<number>;
    }
    /**
     * @en Resource class for managing an atlas, which is a collection of textures and their frames.
     * @zh 管理大图合集资源的类，该类包含纹理和它们的帧。
     */
    class AtlasResource extends Resource {
        /**
         * @en The directory where the atlas resource is stored.
         * @zh 存储大图合集资源的目录。
         */
        dir: string;
        /**
         * @en An array of textures contained within the atlas.
         * @zh 包含在大图合集中的纹理数组。
         */
        readonly textures: Array<Texture>;
        /**
         * @en An array of texture frames, which are individual images within the atlas.
         * @zh 大图合集中的纹理帧数组，它们是大图中的单个图像。
         */
        readonly frames: Array<Texture>;
        /**
         * @en The animation information of the atlas.
         * @zh 大图合集的动画信息。
         */
        animation: IAtlasAnimationInfo;
        /**
         * @en Creates a new instance of the AtlasResource class.
         * @param dir Directory of the atlas.
         * @param textures Array of textures in the atlas.
         * @param frames Array of frames corresponding to the textures.
         * @zh 创建AtlasResource类的新实例。实例化大图合集资源。
         * @param dir 大图合集的目录路径。
         * @param textures 大图合集中的纹理数组。
         * @param frames 对应纹理的帧数组。
         */
        constructor(dir: string, textures: Array<Texture>, frames: Array<Texture>);
        /**
         * @en Updates the atlas resource with new textures and frames.
         * @param textures Array of textures to add to the atlas.
         * @param frames Array of frames corresponding to the textures.
         * @zh 使用新的纹理和帧更新大图合集资源。
         * @param textures 要添加到大图合集的纹理数组。
         * @param frames 对应纹理的帧数组。
         */
        update(textures: Array<Texture>, frames: Array<Texture>): void;
        /**
         * @en Disposes of the resources used by the atlas, destroying all textures and frames.
         * @zh 释放大图合集使用的资源，销毁所有纹理和帧。
         */
        protected _disposeResource(): void;
    }
    /**
     * @en The `BaseTexture` class is an abstract class and serves as the base class for textures. It should not be instantiated directly.
     * @zh `BaseTexture` 类是纹理的父类，是一个抽象类，不允许直接实例化。
     */
    class BaseTexture extends Resource {
        /**
         * @internal
         */
        _texture: InternalTexture;
        /**
         * @en hdr encode format
         * @zh hdr编码格式
         */
        hdrEncodeFormat: HDREncodeFormat;
        protected _width: number;
        protected _height: number;
        /**
         * @en The width of the texture.
         * @zh 纹理的宽度。
         */
        get width(): number;
        set width(width: number);
        /**
         * @en The height of the texture.
         * @zh 纹理的高度。
         */
        get height(): number;
        set height(height: number);
        protected _dimension: TextureDimension;
        /**
         * @en The texture dimension.
         * @zh 纹理几何属性
         */
        get dimension(): TextureDimension;
        protected _format: TextureFormat;
        /**
         * @en The format of the texture.
         * @zh 纹理的格式。
         */
        get format(): TextureFormat;
        /**
         * @en Whether to generate mipmap
         * @zh 是否生成mipmap
         */
        get mipmap(): boolean;
        /**
         * @en The number of mipmap generated for this texture.
         * @zh 为此纹理生成的mipmap数量。
         */
        get mipmapCount(): number;
        /**
         * @en The anisotropy value of texture
         * @zh 纹理的各向异性值
         */
        get anisoLevel(): number;
        set anisoLevel(value: number);
        /**
         * @en The sampling filtering mode of the texture.
         * @zh 纹理的采样过滤模式。
         */
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        /**
         * @en U-direction sampling mode
         * @zh U方向采样模式
         */
        get wrapModeU(): WrapMode;
        set wrapModeU(value: WrapMode);
        /**
         * @en V-direction sampling mode
         * @zh V方向采样模式
         */
        get wrapModeV(): WrapMode;
        set wrapModeV(value: WrapMode);
        /**
         * @en W-direction sampling mode
         * @zh W方向采样模式
         */
        get wrapModeW(): WrapMode;
        set wrapModeW(value: WrapMode);
        /**
         * @en The texture compare mode.
         * @zh 贴图压缩格式
         */
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        /**
         * @en The gamma correction value of the texture. If set to 1.0, texture sampling will be linear without any correction.
         * @zh 纹理的伽马校正值。如果设置为1.0，则纹理采样将为线性，不进行任何校正。
         */
        get gammaCorrection(): number;
        /**
         * @en The base mipmap level of the texture.
         * @zh 纹理的mipmap起始等级。
         */
        get baseMipmapLevel(): number;
        set baseMipmapLevel(value: number);
        /**
         * @en The maximum mipmap level of the texture.
         * @zh 纹理的最大mipmap等级。
         */
        get maxMipmapLevel(): number;
        set maxMipmapLevel(value: number);
        /**@internal */
        _gammaSpace: boolean;
        /**
         * @en Gets whether the texture is using gamma space.
         * @zh 判断纹理是否使用伽马空间。
         */
        get gammaSpace(): boolean;
        /**
         * @en Creates an instance of BaseTexture.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param format The format of the texture, specified as a number.
         * @zh 创建 BaseTexture 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param format 纹理的格式，以数字形式指定。
         */
        constructor(width: number, height: number, format: number);
        /**
         * @en Checks if the texture is in a GPU compressed format.
         * @returns True if the texture is in a GPU compressed format, otherwise false.
         * @zh 是否是gpu压缩纹理格式
         * @returns 如果纹理是gpu压缩格式，则返回true，否则返回false。
         */
        gpuCompressFormat(): boolean;
        /**
         * 获取纹理格式的字节数
         * @internal
         */
        _getFormatByteCount(): number;
        /**
         * @internal
         */
        _getSource(): any;
        /**
         * @en The default texture.
         * @zh 默认贴图
         */
        get defaultTexture(): BaseTexture;
        protected _disposeResource(): void;
    }
    /**
     * @en Prefab class.
     * @zh 预制体类。
     */
    class Prefab extends Resource {
        /**
         * @en Whether the prefab is generated by the DCC tool.
         * @zh 预制体是否是由 DCC 工具生成的。
         */
        fromDCC: boolean;
        /**
         * @ignore @blueprintIgnore
         */
        constructor();
        /**
         * @en If the prefab is loaded from a url, call this method to enable management of the prefab by the resource manager.
         * @zh 如果预制体是从 URL 加载的，则调用此方法以启用资源管理器对预制体的管理。
         */
        onLoad(): this;
        /**
         * @en Create an instance of the prefab.
         * @param options Instantiation options.
         * @param errors Error content.
         * @zh 创建一个预制体的实例。
         * @param options 实例化选项
         * @param errors 错误内容
         */
        create(options?: Record<string, any>, errors?: Array<any>): Node;
        /**
         * @en Instantiate a prefab from a URL.
         * @param url The URL of the prefab.
         * @param classType Optional child node type, used to specify the type of the returned child node.
         * @zh 从 URL 实例化一个预制体。
         * @param url 预制体的 URL。
         * @param classType 可选的节点类型，用于明确返回节点的类型。
         * @returns A promise that resolves to the instantiated Node.
         */
        static instantiate<T extends Node>(url: string, classType?: new () => T): Promise<T>;
    }
    type HierarchyResource = Prefab;
    var HierarchyResource: typeof Prefab;
    /**
     * @en `HTMLCanvas` is a proxy class for the HTML Canvas, encapsulating the properties and methods of the Canvas.
     * @zh `HTMLCanvas` 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。
     * @blueprintIgnore
     */
    class HTMLCanvas {
        source: HTMLCanvasElement;
        protected _ctx: CanvasRenderingContext2D;
        /**
         * @ignore
         */
        constructor(createCanvas?: boolean);
        /**
         * @en Clear the canvas content.
         * @zh 清空画布内容。
         */
        clear(): void;
        /**
         * @en The Canvas rendering context.
         * @zh Canvas 渲染上下文。
         */
        get context(): CanvasRenderingContext2D;
        set context(value: CanvasRenderingContext2D);
        /**
         * @en Set the width and height of the Canvas.
         * @param w The width of the Canvas.
         * @param h The height of the Canvas.
         * @zh 设置画布的宽度和高度。
         * @param w 画布的宽度。
         * @param h 画布的高度。
         */
        size(w: number, h: number): void;
    }
    /**
     * @en The material render mode.
     * @zh 材质渲染模式。
     */
    enum MaterialRenderMode {
        /**
         * @en RenderMode: Opaque
         * @zh 渲染状态：不透明。
         */
        RENDERMODE_OPAQUE = 0,
        /**
         * @en RenderMode: Alpha Testing
         * @zh 渲染状态：阿尔法测试。
         */
        RENDERMODE_CUTOUT = 1,
        /**
         * @en RenderMode: Transparent
         * @zh 渲染状态：透明。
         */
        RENDERMODE_TRANSPARENT = 2,
        /**
         * @en RenderMode: additive mixing
         * @zh 渲染状态：加色法混合。
         */
        RENDERMODE_ADDTIVE = 3,
        /**
         * @en RenderMode: Alpha Blending mixture
         * @zh 渲染状态：透明混合。
         */
        RENDERMODE_ALPHABLENDED = 4,
        /**
         * @en RenderMode: Custom
         * @zh 渲染状态：自定义
         */
        RENDERMODE_CUSTOME = 5
    }
    /**
     * @en The Material class is used to create materials.
     * @zh Material 类用于创建材质。
     * @blueprintIgnoreSubclasses
     */
    class Material extends Resource implements IClone {
        /**
         * @en RenderQueue: Opaque
         * @zh 渲染队列：不透明。
         */
        static readonly RENDERQUEUE_OPAQUE: number;
        /**
         * @en RenderQueue: Alpha Testing
         * @zh 渲染队列：阿尔法测试。
         */
        static readonly RENDERQUEUE_ALPHATEST: number;
        /**
         * @en RenderQueue: Transparent
         * @zh 渲染队列：透明。
         */
        static readonly RENDERQUEUE_TRANSPARENT: number;
        /**
         * @en Shader variables, transparent test values.
         * @zh 着色器变量,透明测试值。
         * @readonly
         */
        static ALPHATESTVALUE: number;
        /**
         * @en Material grade shader macro definition, transparency testing.
         * @zh 材质级着色器宏定义,透明测试。
         * @readonly
         */
        static SHADERDEFINE_ALPHATEST: ShaderDefine;
        /**
         * @en Material grade shader macro definition, main texture.
         * @zh 材质级着色器宏定义,主贴图。
         * @readonly
         */
        static SHADERDEFINE_MAINTEXTURE: ShaderDefine;
        /**
         * @en Material grade shader macro definition, additive fog.
         * @zh 材质级着色器宏定义,叠加雾效。
         * @readonly
         */
        static SHADERDEFINE_ADDTIVEFOG: ShaderDefine;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.MATERIAL)
         * @en Loads a material from a URL.
         * @param url The URL from which to load the material.
         * @param complete A callback function that is called when the material has been loaded.
         * @zh 从URL加载材质。
         * @param url 材质的URL。
         * @param complete 加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        /**
         * @internal
         */
        static __initDefine__(): void;
        private _matRenderNode;
        /** @internal */
        _shader: Shader3D;
        /** @internal */
        _shaderValues: ShaderData | null;
        private _renderQueue;
        /**
         * @en The rendering queue of the material.
         * @zh 所属渲染队列.
         */
        get renderQueue(): number;
        set renderQueue(value: number);
        /**
         * @en Owner element.
         * @zh 所属元素
         */
        ownerElements: Set<IRenderElement3D | IRenderElement2D>;
        /**
         * @internal
         * @param element
         */
        _setOwner3DElement(element: IRenderElement3D): void;
        _setOwner2DElement(element: IRenderElement2D): void;
        /**
         * @internal
         * @param element
         */
        _removeOwnerElement(element: IRenderElement3D | IRenderElement2D): void;
        /**
         * @internal
         * 通知 owner element 材质数据发生改变
         */
        _notifyOwnerElements(): void;
        /**
         * @en The shader data.
         * @zh 着色器数据。
         */
        get shaderData(): ShaderData;
        /**
         * @en The alpha test value used for the alpha test mode of the material.
         * @zh 材质用于透明测试模式的透明测试值。
         */
        get alphaTestValue(): number;
        set alphaTestValue(value: number);
        /**
         * @en Whether the material uses alpha cut mode.
         * @zh 材质是否使用透明裁剪模式。
         */
        get alphaTest(): boolean;
        set alphaTest(value: boolean);
        /**
         * @en Adds a shader define to the material's shader data.
         * @param define The shader define to add.
         * @zh 向材质的着色器数据添加着色器宏定义。
         * @param define 要添加的着色器宏定义。
         */
        addDefine(define: ShaderDefine): void;
        /**
         * @en Removes a shader define from the material's shader data.
         * @param define The shader define to remove.
         * @zh 从材质的着色器数据移除着色器宏定义。
         * @param define 要移除的着色器宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * @en Enables or disables a shader define.
         * @param define The shader define to enable or disable.
         * @param value true to add the define, false to remove it.
         * @zh 开启或关闭着色器宏定义。
         * @param define 要开启或关闭的着色器宏定义。
         * @param value true 表示添加宏定义，false 表示移除宏定义。
         */
        setDefine(define: ShaderDefine, value: boolean): void;
        /**
         * @en Checks if a shader define is present.
         * @param define The shader define to check for.
         * @returns true if the define is present, false otherwise.
         * @zh 检查是否包含特定的着色器宏定义。
         * @param define 要检查的着色器宏定义。
         * @returns 如果存在宏定义返回 true，否则返回 false。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * @en Whether depth writing is enabled for this material.
         * @zh 此材质是否启用深度写入。
         */
        get depthWrite(): boolean;
        set depthWrite(value: boolean);
        /**
         * @en The culling mode for this material.
         * @zh 此材质的剔除方式。
         */
        get cull(): number;
        set cull(value: number);
        /**
         * @en The blend mode for this material.
         * @zh 此材质的混合方式。
         */
        get blend(): number;
        set blend(value: number);
        /**
         * @en The blend source for this material.
         * @zh 此材质的混合源。
         */
        get blendSrc(): number;
        set blendSrc(value: number);
        /**
         * @en The blend destination for this material.
         * @zh 此材质的混合目标。
         */
        get blendDst(): number;
        set blendDst(value: number);
        /**
         * @en The Alpha value of the blend source for this material.
         * @zh 此材质的混合源的 Alpha 值。
         */
        get blendSrcAlpha(): number;
        set blendSrcAlpha(value: number);
        /**
         * @en The RGB value of the blend source for this material.
         * @zh 此材质的混合源的 RGB 值。
         */
        get blendSrcRGB(): number;
        set blendSrcRGB(value: number);
        /**
         * @en The RGB value of the blend destination for this material.
         * @zh 此材质的混合目标的 RGB 值。
         */
        get blendDstRGB(): number;
        set blendDstRGB(value: number);
        /**
         * @en The Alpha value of the blend destination for this material.
         * @zh 此材质的混合目标的 Alpha 值。
         */
        get blendDstAlpha(): number;
        set blendDstAlpha(value: number);
        /**
         * @en The blend equation for this material.
         * @zh 此材质的混合方程。
         */
        get blendEquation(): number;
        set blendEquation(value: number);
        /**
         * @en The RGB value of the blend equation for this material.
         * @zh 此材质的混合方程的 RGB 值。
         */
        get blendEquationRGB(): number;
        set blendEquationRGB(value: number);
        /**
         * @en The Alpha value of the blend equation for this material.
         * @zh 此材质的混合方程的 Alpha 值。
         */
        get blendEquationAlpha(): number;
        set blendEquationAlpha(value: number);
        /**
         * @en The depth test mode.
         * @zh 深度测试方式。
         */
        get depthTest(): number;
        set depthTest(value: number);
        /**
         * @en The stencil test mode.
         * @zh 模板测试方式
         */
        get stencilTest(): number;
        set stencilTest(value: number);
        /**
         * @en Whether to write it into the stencil
         * @zh 是否写入模板。
         */
        get stencilWrite(): boolean;
        set stencilWrite(value: boolean);
        /**
         * @en Stencil write mask value
         * @zh 模板写入掩码值
         */
        get stencilWriteMask(): number;
        set stencilWriteMask(value: number);
        /**
         * @en Stencil read mask value
         * @zh 模板读取掩码值
         */
        get stencilReadMask(): number;
        set stencilReadMask(value: number);
        /**
         * @en Stencil values
         * @zh 模板值
         */
        get stencilRef(): number;
        set stencilRef(value: number);
        /**
         * @en The stencil operation settings for testing. The vector contains (fail, zfail, zpass) .
         * @zh 模板测试设置，向量包含（fail，zfail，zpass）。
         */
        get stencilOp(): Vector3;
        set stencilOp(value: Vector3);
        /**
         * @en Whether to enable depth bias.
         * @zh 是否启用深度偏移。
         */
        get depthBias(): boolean;
        set depthBias(value: boolean);
        /**
         * @en The depth bias constant.
         * @zh 深度偏移常量。
         */
        get depthBiasConstant(): number;
        set depthBiasConstant(value: number);
        /**
         * @en The depth bias slope scale.
         * @zh 深度偏移斜率缩放。
         */
        get dephtBiasSlopeScale(): number;
        set dephtBiasSlopeScale(value: number);
        /**
         * @en The depth bias clamp.
         * @zh 深度偏移限制。
         */
        get depthBiasClamp(): number;
        set depthBiasClamp(value: number);
        /**
         * @en The material properties.
         * @zh 材质属性。
         */
        get MaterialProperty(): any;
        /**
         * @en The material defines.
         * @zh 材质宏定义。
         */
        get MaterialDefine(): Array<string>;
        /**
         * @en Material rendering mode
         * @zh 材质渲染模式
         */
        get materialRenderMode(): MaterialRenderMode;
        set materialRenderMode(value: MaterialRenderMode);
        /**
         * @ignore
         * @en Creates an instance of the Material.
         * @zh 创建一个Material实例。
         */
        constructor();
        /**
         * @en Destroys the resources.
         * @zh 销毁资源。
         */
        protected _disposeResource(): void;
        /**
         * @en The shader of the material.
         * @zh 材质的着色器。
         */
        get shader(): Shader3D;
        /**
         * @en Gets all uniform properties of the material.
         * @returns The map of uniform properties.
         * @zh 获取材质的所有uniform属性。
         * @returns uniform属性的映射表。
         */
        effectiveProperty(): Map<number, UniformProperty>;
        /**
         * @en Sets the shader by its name.
         * @param name The name of the shader to set.
         * @zh 通过名称设置使用Shader。
         * @param name 要设置的着色器名称。
         */
        setShaderName(name: string): void;
        /**
         * @internal
         */
        applyUniformDefaultValue(uniformMap: Map<number, UniformProperty>, defaultValue: Record<string, ShaderDataItem>): void;
        /**
         * @en Gets the boolean uniform value by index.
         * @param uniformIndex The index of the uniform.
         * @returns The boolean value of the property.
         * @zh 通过uniform索引获取布尔值。
         * @param uniformIndex uniform索引。
         * @returns uniform索引的布尔值。
         */
        getBoolByIndex(uniformIndex: number): boolean;
        /**
         * @en Sets the boolean value by uniform index.
         * @param uniformIndex The index of the uniform.
         * @param value The bool value to set.
         * @zh 通过uniform索引设置布尔值。
         * @param uniformIndex uniform索引。
         * @param value 要设置的布尔值。
         */
        setBoolByIndex(uniformIndex: number, value: boolean): void;
        /**
         * @en Gets a boolean value of uniformIndex by property name.
         * @param name The name of the property.
         * @returns The boolean value.
         * @zh 根据属性名称获得uniform索引的布尔值。
         * @param name 属性名称。
         * @returns uniform索引的布尔值。
         */
        getBool(name: string): boolean;
        /**
         * @en Sets a boolean value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的布尔值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setBool(name: string, value: boolean): void;
        /**
         * @en Gets a float value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The float value.
         * @zh 通过属性索引获得浮点值。
         * @param uniformIndex 属性索引。
         * @returns 浮点值。
         */
        getFloatByIndex(uniformIndex: number): number;
        /**
         * @en Sets a float value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The value to set.
         * @zh 通过属性索引设置浮点值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的值。
         */
        setFloatByIndex(uniformIndex: number, value: number): void;
        /**
         * @en Gets a float value by property name.
         * @param name The name of the property.
         * @returns The float value.
         * @zh 根据属性名称获得浮点值。
         * @param name 属性名称。
         * @returns 浮点值。
         */
        getFloat(name: string): number;
        /**
         * @en Sets a float value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的浮点值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setFloat(name: string, value: number): void;
        /**
         * @en Gets an integer value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The integer value.
         * @zh 通过属性索引获得整数值。
         * @param uniformIndex 属性索引。
         * @returns 整数值。
         */
        getIntByIndex(uniformIndex: number): number;
        /**
         * @en Sets an integer value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The value to set.
         * @zh 通过属性索引设置整数值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的值。
         */
        setIntByIndex(uniformIndex: number, value: number): void;
        /**
         * @en Gets an integer value by property name.
         * @param name The name of the property.
         * @returns The integer value.
         * @zh 根据属性名称获得整数值。
         * @param name 属性名称。
         * @returns 整数值。
         */
        getInt(name: string): number;
        /**
         * @en Sets an integer value by property name.
         * @param name The name of the property.
         * @param value The value to set.
         * @zh 设置属性名称对应的整数值。
         * @param name 属性名称。
         * @param value 要设置的值。
         */
        setInt(name: string, value: number): void;
        /**
         * @en Gets a Vector2 value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The Vector2 value.
         * @zh 通过属性索引获得Vector2值。
         * @param uniformIndex 属性索引。
         * @returns Vector2值。
         */
        getVector2ByIndex(uniformIndex: number): Vector2;
        /**
         * @en Sets a Vector2 value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector2 value to set.
         * @zh 通过属性索引设置Vector2值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector2值。
         */
        setVector2ByIndex(uniformIndex: number, value: Vector2): void;
        /**
         * @en Gets a Vector2 value by property name.
         * @param name The name of the property.
         * @returns The Vector2 value.
         * @zh 根据属性名称获得Vector2值。
         * @param name 属性名称。
         * @returns Vector2值。
         */
        getVector2(name: string): Vector2;
        /**
         * @en Sets a Vector2 value by property name.
         * @param name The name of the property.
         * @param value The Vector2 value to set.
         * @zh 设置属性名称对应的Vector2值。
         * @param name 属性名称。
         * @param value 要设置的Vector2值。
         */
        setVector2(name: string, value: Vector2): void;
        /**
         * @en Retrieves a Vector3 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Vector3 value.
         * @zh 通过属性索引获得Vector3值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Vector3值。
         */
        getVector3ByIndex(uniformIndex: number): Vector3;
        /**
         * @en Sets a Vector3 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector3 value to set.
         * @zh 通过属性索引设置Vector3值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector3值。
         */
        setVector3ByIndex(uniformIndex: number, value: Vector3): void;
        /**
         * @en Retrieves a Vector3 value by its property name.
         * @param name The name of the property as defined in the shader.
         * @returns The retrieved Vector3 value.
         * @zh 根据属性名称获得Vector3值。
         * @param name 着色器中定义的属性名称。
         * @returns 检索到的Vector3值。
         */
        getVector3(name: string): Vector3;
        /**
         * @en Sets a Vector3 value by its property name.
         * @param name The name of the property as defined in the shader.
         * @param value The Vector3 value to set.
         * @zh 设置属性名称对应的Vector3值。
         * @param name 着色器中定义的属性名称。
         * @param value 要设置的Vector3值。
         */
        setVector3(name: string, value: Vector3): void;
        /**
         * @en Sets a Vector4 value by uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Vector4 value to set.
         * @zh 通过属性索引设置Vector4值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Vector4值。
         */
        setVector4ByIndex(uniformIndex: number, value: Vector4): void;
        /**
         * @en Retrieves a Vector4 value by uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Vector4 value.
         * @zh 通过属性索引获取Vector4值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Vector4值。
         */
        getVector4ByIndex(uniformIndex: number): Vector4;
        /**
         * @en Sets a Vector4 value by property name.
         * @param name The name of the property.
         * @param value The Vector4 value to set.
         * @zh 设置属性名称对应的Vector4值。
         * @param name 属性名称。
         * @param value 要设置的Vector4值。
         */
        setVector4(name: string, value: Vector4): void;
        /**
         * @en Retrieves a Vector4 value by property name.
         * @param name The name of the property.
         * @returns The retrieved Vector4 value.
         * @zh 根据属性名称获得Vector4值。
         * @param name 属性名称。
         * @returns 检索到的Vector4值。
         */
        getVector4(name: string): Vector4;
        /**
         * @en Retrieves a Color value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Color value.
         * @zh 通过属性索引获得颜色值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的颜色值。
         */
        getColorByIndex(uniformIndex: number): Color;
        /**
         * @en Sets a Color value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Color value to set.
         * @zh 通过属性索引设置颜色值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的颜色值。
         */
        setColorByIndex(uniformIndex: number, value: Color): void;
        /**
         * @en Retrieves a Color value by property name.
         * @param name The name of the property.
         * @returns The retrieved Color value.
         * @zh 根据属性名称获得颜色值。
         * @param name 属性名称。
         * @returns 检索到的颜色值。
         */
        getColor(name: string): Color;
        /**
         * @en Sets a Color value by property name.
         * @param name The name of the property.
         * @param value The Color value to set.
         * @zh 设置属性名称对应的颜色值。
         * @param name 属性名称。
         * @param value 要设置的颜色值。
         */
        setColor(name: string, value: Color): void;
        /**
         * @en Retrieves a Matrix4x4 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved Matrix4x4 value.
         * @zh 通过属性索引获得4x4矩阵值。
         * @param uniformIndex 属性索引。
         * @returns 检索到的4x4矩阵值。
         */
        getMatrix4x4ByIndex(uniformIndex: number): Matrix4x4;
        /**
         * @en Sets a Matrix4x4 value by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The Matrix4x4 value to set.
         * @zh 通过属性索引设置4x4矩阵值。
         * @param uniformIndex 属性索引。
         * @param value 要设置的4x4矩阵值。
         */
        setMatrix4x4ByIndex(uniformIndex: number, value: Matrix4x4): void;
        /**
         * @en Retrieves a Matrix4x4 value by property name.
         * @param name The name of the property.
         * @returns The retrieved Matrix4x4 value.
         * @zh 根据属性名称获得4x4矩阵值。
         * @param name 属性名称。
         * @returns 检索到的4x4矩阵值。
         */
        getMatrix4x4(name: string): Matrix4x4;
        /**
         * @en Sets a Matrix4x4 value by property name.
         * @param name The name of the property.
         * @param value The Matrix4x4 value to set.
         * @zh 设置属性名称对应的4x4矩阵值。
         * @param name 属性名称。
         * @param value 要设置的4x4矩阵值。
         */
        setMatrix4x4(name: string, value: Matrix4x4): void;
        /**
         * @en Retrieves a 3x3 matrix value by its index.
         * @param index The index of the matrix within the shader data.
         * @returns The retrieved 3x3 matrix value.
         * @zh 通过索引获取3x3矩阵值。
         * @param index 着色器数据中矩阵的索引。
         * @returns 检索到的3x3矩阵值。
         */
        getMatrix3x3ByIndex(index: number): Matrix3x3;
        /**
         * @en Sets a 3x3 matrix value by its index.
         * @param index The index of the matrix within the shader data.
         * @param value The 3x3 matrix value to set.
         * @zh 通过索引设置3x3矩阵值。
         * @param index 着色器数据中矩阵的索引。
         * @param value 要设置的3x3矩阵值。
         */
        setMatrix3x3ByIndex(index: number, value: Matrix3x3): void;
        /**
         * @en Retrieves a 3x3 matrix value by its property name.
         * @param name The name of the property.
         * @returns The retrieved 3x3 matrix value.
         * @zh 根据属性名称获取3x3矩阵值。
         * @param name 属性名称。
         * @returns 检索到的3x3矩阵值。
         */
        getMatrix3x3(name: string): Matrix3x3;
        /**
         * @en Sets a 3x3 matrix value by its property name.
         * @param name The name of the property.
         * @param value The 3x3 matrix value to set.
         * @zh 设置属性名称对应的3x3矩阵值。
         * @param name 属性名称。
         * @param value 要设置的3x3矩阵值。
         */
        setMatrix3x3(name: string, value: Matrix3x3): void;
        /**
         * @en Sets a texture by its uniform index.
         * @param uniformIndex The index of the property.
         * @param texture The texture to set.
         * @zh 通过属性索引设置纹理。
         * @param uniformIndex 属性索引。
         * @param texture 要设置的纹理。
         */
        setTextureByIndex(uniformIndex: number, texture: BaseTexture): void;
        private reSetTexture;
        /**
         * @en Retrieves a texture by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved texture.
         * @zh 通过属性索引获得纹理。
         * @param uniformIndex 属性索引。
         * @returns 检索到的纹理。
         */
        getTextureByIndex(uniformIndex: number): BaseTexture;
        /**
         * @en Sets a texture by property name.
         * @param name The name of the property.
         * @param texture The texture to set.
         * @zh 根据属性名称设置纹理。
         * @param name 属性名称。
         * @param texture 要设置的纹理。
         */
        setTexture(name: string, texture: BaseTexture): void;
        /**
         * @en Retrieves a texture by property name.
         * @param name The name of the property.
         * @returns The retrieved texture.
         * @zh 根据属性名称获得纹理。
         * @param name 属性名称。
         * @returns 检索到的纹理。
         */
        getTexture(name: string): BaseTexture;
        /**
         * @en Retrieves a buffer by its uniform index.
         * @param uniformIndex The index of the property.
         * @returns The retrieved buffer.
         * @zh 通过属性索引获得Buffer。
         * @param uniformIndex 属性索引。
         * @returns 检索到的Buffer。
         */
        getBufferByIndex(uniformIndex: number): Float32Array;
        /**
         * @en Sets a buffer by its uniform index.
         * @param uniformIndex The index of the property.
         * @param value The buffer to set.
         * @zh 通过属性索引设置Buffer。
         * @param uniformIndex 属性索引。
         * @param value 要设置的Buffer值。
         */
        setBufferByIndex(uniformIndex: number, value: Float32Array): void;
        /**
         * @en Retrieves a buffer by property name.
         * @param name The name of the property.
         * @returns The retrieved buffer.
         * @zh 根据属性名称获得Buffer。
         * @param name 属性名称。
         * @returns 检索到的Buffer。
         */
        getBuffer(name: string): Float32Array;
        /**
         * @en Sets a buffer by property name.
         * @param name The name of the property.
         * @param value The buffer to set.
         * @zh 根据属性名称设置Buffer。
         * @param name 属性名称。
         * @param value 要设置的Buffer值。
         */
        setBuffer(name: string, value: Float32Array): void;
        /**
         * @en Sets the attribute value of ShaderData by uniform index.
         * @param uniformIndex The index of the attribute.
         * @param type The type of the value to be set.
         * @param value The value to be set.
         * @zh 通过属性索引设置ShaderData的属性值。
         * @param uniformIndex 属性索引。
         * @param type 要设置的值的类型。
         * @param value 要设置的值。
         */
        setShaderDataByIndex(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @en Sets the attribute value of ShaderData by property name.
         * @param name The name of the property.
         * @param type The type of the value to be set.
         * @param value The value to be set.
         * @zh 根据属性名称设置ShaderData的属性值。
         * @param name 属性名称。
         * @param type 要设置的值的类型。
         * @param value 要设置的值。
         */
        setShaderData(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @en Retrieves the attribute value of ShaderData by property name.
         * @param name The name of the property.
         * @param type The type of the value to be retrieved.
         * @returns The retrieved ShaderData attribute value.
         * @zh 根据属性名称获得ShaderData的属性值。
         * @param name 属性名称。
         * @param type 要检索的值的类型。
         * @returns 检索到的ShaderData属性值。
         */
        getShaderData(name: string, type: ShaderDataType): ShaderDataItem;
        /**
         * @en Retrieves the attribute value of ShaderData by uniform index.
         * @param uniformIndex The index of the attribute.
         * @param type The type of the value to be retrieved.
         * @returns The retrieved ShaderData attribute value.
         * @zh 通过属性索引获得ShaderData的属性值。
         * @param uniformIndex 属性索引。
         * @param type 要检索的值的类型。
         * @returns 检索到的ShaderData属性值。
         */
        getShaderDataByIndex(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * @en Clones the current material to destination material object.
         * @param destObject The destination material object.
         * @zh 克隆当前材质到目标材质对象。
         * @param destObject 目标材质对象。
         */
        cloneTo(destObject: Material): void;
        /**
         * @en Creates a clone of the current material.
         * @returns A new material instance that is a clone of the current material.
         * @zh 创建当前材质的克隆副本。
         * @returns 一个克隆自当前材质的新材质实例。
         */
        clone(): Material;
        /**
         * @en Checks if the material type matches the expected type.
         * @param type The expected type.
         * @zh 检查材质类型是否匹配预期类型。
         * @param type 预期类型。
         * @returns 是否匹配。
         */
        checkType(type: ShaderFeatureType): boolean;
        /**
         * @en The material define.
         * @zh 材质宏
         */
        get _defineDatas(): IDefineDatas;
        /**
         * @en Compatible with old parsing end events
         * @zh 兼容老的解析结束事件
         */
        oldparseEndEvent(): void;
    }
    /**
     * @en Class is used to process 2D vertex meshes
     * @zh 类用于处理2D顶点网格
     */
    class VertexMesh2D {
        private static _vertexDeclarationMap;
        /**
         * @en Retrieves the vertex declaration based on the provided vertex flags.
         * @param vertexFlags An array of vertex declaration flag characters, formatted as: "POSITION,COLOR,UV,BLENDWEIGHT,BLENDINDICES".
         * @param compatible Whether to enable compatible mode.
         * @return An array of vertex declarations.
         * @zh 根据提供的顶点声明标志字符获取顶点声明。
         * @param vertexFlags 顶点声明标志字符数组，格式为："POSITION,COLOR,UV,BLENDWEIGHT,BLENDINDICES"。
         * @param compatible 是否启用兼容模式。
         * @return 顶点声明数组。
         */
        static getVertexDeclaration(vertexFlags: string[], compatible?: boolean): VertexDeclaration[];
        /**
        * 获得mesh的宏
        * @param mesh Mesh
        * @param out define
        */
        static getMeshDefine(mesh: Mesh2D, out: Array<ShaderDefine>): void;
    }
    /**
     * @en The `Mesh2D` class represents a 2D mesh in the engine.
     * @zh `Mesh2D` 类表示引擎中的2D网格。
     */
    class Mesh2D extends Resource {
        /**
         * @en create a Mesh2D by data
         * @param vbs vertexBuffers Array
         * @param vbDeclaration vertex declaration info array
         * @param ib index Buffer
         * @param ibFormat index Buffer format
         * @param submeshInfo subMesh render info，start for index offset，length for draw range。one mesh2D can Multisegmental rendering。
         * @param canRead vb & ib data is readable or not
         * @returns return a mesh2D，can use to Mesh2DRender
         * @zh 创建一个Mesh2D
         * @param vbs 顶点数组数据
         * @param vbDeclaration 顶点描述数组
         * @param ib 索引数据
         * @param ibFormat 索引数据格式
         * @param submeshInfo 子Mesh渲染信息，start标识从索引数据哪里开始，length指draw多少索引值的三角形，一个Mesh2D可以分成多端来渲染，方便赋入不同的材质
         * @param canRead vb 和 ib 数据是否可读
         * @returns 返回一个mesh2D实例。可用于mesh2DRender组件渲染
         */
        static createMesh2DByPrimitive(vbs: Float32Array[], vbDeclaration: VertexDeclaration[], ib: Uint16Array | Uint32Array, ibFormat: IndexFormat, submeshInfo: {
            start: number;
            length: number;
        }[], canRead?: boolean): Mesh2D;
        /** @internal */
        _bufferState: IBufferState;
        /** @internal */
        _instanceBufferState: IBufferState;
        /** @internal */
        _instanceBufferStateType: number;
        /**@internal */
        _instanceWorldVertexBuffer: IVertexBuffer;
        /**@internal */
        _instanceSimpleAniVertexBuffer: IVertexBuffer;
        /** @internal */
        _subMeshes: IRenderGeometryElement[];
        /** @internal */
        _vertexBuffers: IVertexBuffer[];
        /** @internal */
        _indexBuffer: IIndexBuffer;
        /** @internal */
        _vertexCount: number;
        /** @internal */
        _indexFormat: IndexFormat;
        /**
         * @en Get the vertex buffer of the mesh.
         * @zh 获取网格的顶点缓冲。
         */
        get vertexBuffers(): IVertexBuffer[];
        /**
         * @en Get the index buffer of the mesh.
         * @zh 获取网格的索引缓冲。
         */
        get indexBuffer(): IIndexBuffer;
        /**
         * @en Get the number of vertices in the mesh.
         * @zh 获取网格中的顶点数。
         */
        get vertexCount(): number;
        /**
         * @en Get the index number of the mesh.
         * @zh 获取网格的索引数。
         */
        get indexCount(): number;
        /**
         * @en Get the number of SubMeshes in the mesh.
         * @zh 获取网格中子网格的个数。
         */
        get subMeshCount(): number;
        /**
         * @en The index format used by the mesh.
         * @zh 网格使用的索引格式。
         */
        get indexFormat(): IndexFormat;
        /** 是否保留数据 */
        canRead: boolean;
        /** @internal */
        _vertices: ArrayBuffer[];
        /** @internal */
        _indices: Uint16Array | Uint32Array | Uint8Array;
        /**
         * @ignore
         * @en prohibition of use.
         * @zh 禁止使用
         */
        constructor();
        /**
         * @en Destroy the resource.
         * @zh 销毁资源
         */
        protected _disposeResource(): void;
        /**
         * @internal
         */
        _setSubMeshes(subMeshes: IRenderGeometryElement[]): void;
        /**
         * @internal
         */
        _setBuffers(vertexBuffers: IVertexBuffer[], indexBuffer: IIndexBuffer): void;
        /**
         * @en Retrieves a SubMesh based on its index.
         * @param index The index of the SubMesh.
         * @returns The SubMesh at the specified index.
         * @zh 根据索引获取子网格。
         * @param index 子网格的索引。
         * @returns 索引指定的子网格。
         */
        getSubMesh(index: number): IRenderGeometryElement;
        /**
         * @en Sets the vertex data for the mesh.
         * @param vertices An array of ArrayBuffer objects containing vertex data.
         * @zh 设置网格的顶点数据。
         * @param vertices 顶点数据数组。
         */
        setVertices(vertices: ArrayBuffer[]): void;
        /**
         * @en VertexBuffer data that was set earlier
         * @zh 之前设置的vertexbuffer数据
         */
        getVertices(): ArrayBuffer[];
        /**
         * @en Set a vertex buffer data
         * @param data  buffer data
         * @param index vertex array index
         * @param bufferOffset  buffer data set offset
         * @zh 设置某个顶点Buffer数据
         * @param data 设置数据
         * @param index 设置的顶点Buffer队列索引
         * @param bufferOffset 设置Buffer数据的偏移
         */
        setVertexByIndex(data: ArrayBuffer, index: number, bufferOffset?: number): void;
        /**
         * @en set index buffer data
         * @param indices index buffer data
         * @zh 设置索引buffer数据。
         * @param indices 网格索引。
         */
        setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void;
        /**
         * @en The indexbuffer data that was set earlier
         * @zh 之前设置的索引buffer数据
         */
        getIndices(): Uint16Array | Uint8Array | Uint32Array;
    }
    /**
     * @en Hierarchy parser API.
     * @zh 层次结构分析器 API。
     */
    interface IHierarchyParserAPI {
        /**
         * @en Collect resource links required by the data.
         * @param data The data object to process.
         * @param basePath The base path used to resolve resource links.
         * @returns An array of strings or ILoadURL objects representing the resource links.
         * @zh 收集数据所需的资源链接。
         * @param data 需要处理的数据对象。
         * @param basePath 用于解析资源链接的基础路径。
         * @returns 返回表示资源链接的字符串或 ILoadURL 对象数组。
         */
        collectResourceLinks: (data: any, basePath: string) => (string | ILoadURL)[];
        /**
         * @en Parse the data and create a hierarchy of nodes.
         * @param data The data object to parse.
         * @param options Optional settings for parsing.
         * @param errors Array to store any errors encountered during parsing.
         * @returns An array of nodes or a single node if only one is created.
         * @zh 解析数据并创建节点的层次结构。
         * @param data 需要解析的数据对象。
         * @param options 解析的可选设置。
         * @param errors 存储解析过程中遇到的错误的数组。
         * @zh 返回节点数组或如果只创建了一个节点，则返回单个节点。
         */
        parse: (data: any, options?: Record<string, any>, errors?: Array<any>) => Array<Node> | Node;
    }
    /**
     * @en This class is used to import prefabs.
     * @zh 该类用于导入预制体。
     * @blueprintIgnore
     */
    class PrefabImpl extends Prefab {
        static v3: IHierarchyParserAPI;
        static v2: IHierarchyParserAPI;
        static legacySceneOrPrefab: IHierarchyParserAPI & {
            createByData(root: Sprite, uiView: any): Sprite;
            createComp(uiView: any, comp: Sprite, view: Sprite, dataMap: any[], initTool?: any): any;
        };
        /**
         * @en The prefab data.
         * @zh 预制体数据。
         */
        data: any;
        /**
         * @en The hierarchy parser API used to parse the prefab data.
         * @zh 用于解析预制体数据的层次结构 API。
         */
        api: IHierarchyParserAPI;
        /**
         * @en Create an instance of the PrefabImpl class.
         * @param api The hierarchy parser API.
         * @param data The data to initialize the prefab instance with.
         * @zh 创建 PrefabImpl 类的实例。
         * @param api 层次结构API
         * @param data 用于初始化预制体实例的数据。
         */
        constructor(api: IHierarchyParserAPI | null, data: any);
        /**
         * @en Create an instance of the prefab.
         * @param options Optional parameters for instance creation.
         * @param errors Array to store any errors encountered during instance creation.
         * @returns The prefab instance.
         * @zh 创建预制体的实例。
         * @param options 创建实例时的可选参数。
         * @param errors 存储实例创建过程中遇到的错误的数组。
         * @returns 预制体实例。
         */
        create(options?: Record<string, any>, errors?: any[]): Node;
    }
    /**
     * @en Depth texture mode
     * @zh 深度贴图模式
     */
    enum DepthTextureMode {
        /**
         * @en Do not generate depth texture.
         * @zh 不生成深度贴图。
         */
        None = 0,
        /**
         * @en Generate depth texture.
         * @zh 生成深度贴图。
         */
        Depth = 1,
        /**
         * @en Generate depth and normal textures.
         * @zh 生成深度和法线贴图。
         */
        DepthNormals = 2,
        /**
         * @en Generate depth and depth normals textures, and indicate whether motion vectors should be rendered.
         * @zh 生成深度和深度法线贴图，并指示是否应该渲染运动矢量。
         */
        DepthAndDepthNormals = 3,
        /**
         * @en Generate motion vectors texture.
         * @zh 生成运动矢量贴图。
         */
        MotionVectors = 4
    }
    /**
     * @en RenderTexture class used to create render texture.
     * @zh RenderTexture 类用于创建渲染纹理。
     */
    class RenderTexture extends BaseTexture implements IRenderTarget {
        private static _pool;
        private static _poolMemory;
        /**
         * @en Creates a RenderTexture instance from the pool.
         * @param width Width of the RenderTexture.
         * @param height Height of the RenderTexture.
         * @param colorFormat Color format of the RenderTexture.
         * @param depthFormat Depth format of the RenderTexture.
         * @param mipmap Whether to generate mipmaps for the RenderTexture.
         * @param multiSamples Number of multisamples for the RenderTexture.
         * @param depthTexture Whether to generate a depth texture.
         * @param sRGB Whether the RenderTexture is in sRGB space.
         * @returns A RenderTexture instance.
         * @zh 从对象池中创建一个RenderTexture实例。
         * @param width 宽度。
         * @param height 高度。
         * @param colorFormat 颜色格式。
         * @param depthFormat 深度格式。
         * @param mipmap 是否生成多级纹理。
         * @param multiSamples 多采样次数。
         * @param depthTexture 是否生成深度纹理。
         * @param sRGB 是否sRGB空间。
         * @returns RenderTexture实例。
         */
        static createFromPool(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean, storage?: boolean): RenderTexture;
        /**
         * @en Recovers the RenderTexture to the pool for reuse.
         * @param rt The RenderTexture to recover.
         * @zh 回收渲染纹理到对象池以便重用。
         * @param rt 要回收的渲染纹理。
         */
        static recoverToPool(rt: RenderTexture): void;
        /**
         * @en Clears the RenderTexture pool.
         * @zh 清空渲染纹理对象池。
         */
        static clearPool(): void;
        /** 最后绑定到主画布上的结果 此值可能为null*/
        private static _bindCanvasRender;
        /**
         * @en The RenderTexture bound to the main canvas.
         * @zh 绑定到主画布上的渲染纹理。
         */
        static get bindCanvasRender(): RenderTexture;
        static set bindCanvasRender(value: RenderTexture);
        /**
         * @internal
         * 是否在对象池中
         */
        _inPool: boolean;
        /**
         * 是否是相机目标纹理
         * @internal
         */
        _isCameraTarget: boolean;
        /**
         * 渲染纹理
         * @internal
         */
        _renderTarget: InternalRenderTarget;
        private _generateDepthTexture;
        /**
         * @en Whether to generate depth texture maps.
         * @zh 是否生成深度纹理贴图。
         */
        get generateDepthTexture(): boolean;
        set generateDepthTexture(value: boolean);
        /**
         * @en Depth and stencil removal texture mapping
         * @zh 深度与模板剔除纹理贴图
         */
        private _depthStencilTexture;
        /**
         * @en Depth and stencil removal texture mapping
         * @zh 深度与模板剔除纹理贴图
         */
        get depthStencilTexture(): BaseTexture;
        /**
         * 是否生成多级纹理
         * @internal
         */
        _generateMipmap: boolean;
        /**
         * @en Color format
         * @zh 颜色格式
         */
        get colorFormat(): RenderTargetFormat;
        /**
         * @en Depth and stencil removal format
         * @zh 深度与模板剔除的格式
         */
        protected _depthStencilFormat: RenderTargetFormat;
        /**
         * @en Depth and stencil removal format
         * @zh 深度与模板剔除的格式
         */
        get depthStencilFormat(): RenderTargetFormat;
        /**
         * @en Number of multisamples.
         * @zh 多采样次数
         */
        protected _multiSamples: number;
        /**
         * @en Number of multisamples.
         * @zh 多采样次数
         */
        get multiSamples(): number;
        /**
         * @en Whether the RenderTexture is a cube texture.
         * @zh 是否是立方体贴图
         */
        get isCube(): boolean;
        /**
         * @en Sampling times
         * @zh 采样次数
         */
        get samples(): number;
        /**
         * @en Whether to generate multi-level textures.
         * @zh 是否生成多级纹理。
         */
        get generateMipmap(): boolean;
        private _storage;
        /**
         * @en Create an instance of the RenderTexture class.
         * @param width Width of the RenderTexture.
         * @param height Height of the RenderTexture.
         * @param colorFormat Color format for the RenderTexture.
         * @param depthFormat Depth format for the RenderTexture.
         * @param generateMipmap Whether to generate mipmaps for the RenderTexture.
         * @param multiSamples Number of multisamples for the RenderTexture.
         * @param generateDepthTexture Whether to generate a depth texture for the RenderTexture.
         * @param sRGB Whether the RenderTexture uses sRGB color space.
         * @zh 创建 RenderTexture 类的实例。
         * @param width 宽度。
         * @param height 高度。
         * @param colorFormat 颜色格式。
         * @param depthFormat 深度格式。
         * @param generateMipmap 是否生成多级纹理。
         * @param multiSamples 多采样次数。
         * @param generateDepthTexture 是否生成深度纹理。
         * @param sRGB 是否sRGB空间。
         */
        constructor(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap?: boolean, multiSamples?: number, generateDepthTexture?: boolean, sRGB?: boolean, stroage?: boolean);
        /**
         * 创建渲染纹理
         * @internal
         */
        _createRenderTarget(): void;
        /**
         * @en Recreates the RenderTexture with the specified parameters.
         * @param width New width of the RenderTexture.
         * @param height New height of the RenderTexture.
         * @param colorFormat New color format for the RenderTexture.
         * @param depthFormat New depth format for the RenderTexture.
         * @param generateMipmap Whether to regenerate mipmaps for the RenderTexture.
         * @param multiSamples New number of multisamples for the RenderTexture.
         * @param generateDepthTexture Whether to generate a new depth texture for the RenderTexture.
         * @param sRGB Whether the RenderTexture uses sRGB color space.
         * @zh 使用指定参数重新创建RenderTexture。
         * @param width 新宽度。
         * @param height 新高度。
         * @param colorFormat 新颜色格式。
         * @param depthFormat 新深度格式。
         * @param generateMipmap 是否重新生成多级纹理。
         * @param multiSamples 新多采样次数。
         * @param generateDepthTexture 是否生成新的深度纹理。
         * @param sRGB 是否sRGB空间。
         */
        recreate(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap?: boolean, multiSamples?: number, generateDepthTexture?: boolean, sRGB?: boolean, storage?: boolean): void;
        /**
         * @deprecated 请使用getDataAsync函数代替
         * 获取渲染纹理的像素数据
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 宽度
         * @param height 高度
         * @param out 输出
         * @returns 二进制数据
         */
        getData(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Uint8Array | Float32Array;
        /**
         * @en Asynchronously retrieves pixel data from the RenderTexture.
         * @param xOffset The x-offset value.
         * @param yOffset The y-offset value.
         * @param width The width of the area to retrieve.
         * @param height The height of the area to retrieve.
         * @param out The array to hold the output data.
         * @returns binary data
         * @zh 异步获取渲染纹理的像素数据。
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 要检索的区域的宽度。
         * @param height 要检索的区域的高度。
         * @param out 用于保存输出数据的数组。
         * @returns 二进制数据
         */
        getDataAsync(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Promise<ArrayBufferView>;
        /**
         * @en Destroy the Resource.
         * @zh 销毁资源
         */
        protected _disposeResource(): void;
    }
    /**
     * @en RenderTexture2D class used to create 2D render targets.
     * @zh RenderTexture2D 类用于创建2D渲染目标。
     */
    class RenderTexture2D extends BaseTexture implements IRenderTarget {
        static _empty: RenderTexture2D;
        /** @internal */
        static __init__(): void;
        private static _currentActive;
        private static _pool;
        private static _poolMemory;
        private static _poolTimeouts;
        /**
         * @en The timeout for cleanup checks.
         * @zh 清理检查的超时时间。
         * @default 30000
         */
        static cleanupTimeout: number;
        /**
         * @en The frame interval for cleanup checks.
         * @zh 清理检查的帧间隔。
         * @default 360
         */
        static cleanupFrameInterval: number;
        private static _lastCleanupFrame;
        /**
         * @en Creates a RenderTexture instance from the pool.
         * @param width Width of the RenderTexture.
         * @param height Height of the RenderTexture.
         * @param colorFormat Color format of the RenderTexture.
         * @param depthFormat Depth format of the RenderTexture.
         * @returns A RenderTexture instance.
         * @zh 从对象池中创建一个RenderTexture实例。
         * @param width 宽度。
         * @param height 高度。
         * @param colorFormat 颜色格式。
         * @param depthFormat 深度格式。
         * @returns RenderTexture实例。
         */
        static createFromPool(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat): RenderTexture2D;
        /**
         * @en Recovers the RenderTexture2D to the pool for reuse.
         * @param rt The RenderTexture2D to recover.
         * @zh 回收渲染纹理到对象池以便重用。
         * @param rt 要回收的渲染纹理。
         */
        static recoverToPool(rt: RenderTexture2D): void;
        /**
         * @en Clears the RenderTexture2D pool.
         * @zh 清空渲染纹理对象池。
         */
        static clearPool(): void;
        /**
         * @en Cleans up expired RenderTexture2D instances from the pool.
         * @returns Number of cleaned up instances.
         * @zh 清理池中过期的RenderTexture2D实例。
         * @returns 清理的实例数量。
         */
        static cleanupExpired(): number;
        /** @internal */
        static _clearColor: Color;
        /** @internal */
        static _clear: boolean;
        /**
         * @en The currently active RenderTexture.
         * @zh 当前激活的渲染纹理。
         */
        static get currentActive(): RenderTexture2D;
        private _depthStencilFormat;
        private _colorFormat;
        /**@internal */
        _mgrKey: number;
        /**@internal */
        _invertY: boolean;
        /** @internal */
        _inPool: boolean;
        /**
         * @en Depth format.
         * @zh 深度格式。
         */
        get depthStencilFormat(): number;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        get defaultTexture(): BaseTexture;
        /**
         * @en Checks whether the RenderTexture2D is ready.
         * @zh 检查2D渲染纹理是否准备好。
         */
        getIsReady(): boolean;
        /**
         * @en get the colorFormat from RenderInternalRT
         * @zh 得到此渲染纹理的颜色格式
         */
        getColorFormat(): RenderTargetFormat;
        /**
         * @en The source width of the RenderTexture2D.
         * @zh 2D渲染纹理的源宽度。
         */
        get sourceWidth(): number;
        /**
         * @en The source height of the RenderTexture2D.
         * @zh 2D渲染纹理的源高度。
         */
        get sourceHeight(): number;
        /**
         * @en The X-axis offset of the RenderTexture2D.
         * @zh 2D渲染纹理的X轴偏移。
         */
        get offsetX(): number;
        /**
         * @en The Y-axis offset of the RenderTexture2D.
         * @zh 2D渲染纹理的Y轴偏移。
         */
        get offsetY(): number;
        /**
         * @en Depth stencil texture
         * @zh 深度模板纹理
         */
        depthStencilTexture: BaseTexture;
        /**
         * @ignore
         * @en The RenderTarget.
         * @zh 渲染目标。
         */
        _renderTarget: InternalRenderTarget;
        /**
         * @en Whether the RenderTexture2D is a CameraTarget.
         * @zh 是否是CameraTarget
         */
        _isCameraTarget: boolean;
        /**
         * @en Creates an instance of RenderTexture2D.
         * @param width The width.
         * @param height The height.
         * @param format The texture format.
         * @param depthStencilFormat The depth format.
         * @zh 创建 RenderTexture2D 类的实例。
         * @param width  宽度。
         * @param height 高度。
         * @param format 纹理格式。
         * @param depthStencilFormat 深度格式。
         */
        constructor(width: number, height: number, format?: RenderTargetFormat, depthStencilFormat?: RenderTargetFormat);
        /**
         * @en Whether the render target is a cube render target.
         * @zh 渲染目标是否是立方体贴图渲染目标。
         */
        get isCube(): boolean;
        /**
         * @en The number of samples for the render target.
         * @zh 渲染目标的采样数。
         */
        get samples(): number;
        /**
         * @en Checks if mipmaps are generated for the render target.
         * @zh 检查是否为渲染目标生成了mipmaps。
         */
        get generateMipmap(): boolean;
        /**
         * @internal
         */
        _start(): void;
        /**
         * @internal
         */
        _end(): void;
        /**
         * @internal
         */
        _create(): void;
        /**
         * @en Clears the render texture.
         * @param r The red component.
         * @param g The green component.
         * @param b The blue component.
         * @param a The alpha component, default is 1.0 for full opacity.
         * @zh 清理渲染纹理。
         * @param r 红色分量。
         * @param g 绿色分量。
         * @param b 蓝色分量。
         * @param a 透明度分量，默认为1.0表示完全不透明。
         */
        clear(r?: number, g?: number, b?: number, a?: number): void;
        /**
         * @en Gets the pixel data from the render texture within the specified area.
         * @param x The X coordinate of the pixel area.
         * @param y The Y coordinate of the pixel area.
         * @param width The width of the pixel area.
         * @param height The height of the pixel area.
         * @returns The pixel data from the specified area.
         * @zh 从指定区域获取渲染纹理的像素数据。
         * @param x 像素区域的X坐标。
         * @param y 像素区域的Y坐标。
         * @param width 像素区域的宽度。
         * @param height 像素区域的高度。
         * @returns 指定区域的像素数据。
         */
        getData(x: number, y: number, width: number, height: number): ArrayBufferView;
        /**
         * @en Asynchronously retrieves pixel data from the RenderTexture.
         * @param xOffset The x-offset value.
         * @param yOffset The y-offset value.
         * @param width The width of the area to retrieve.
         * @param height The height of the area to retrieve.
         * @param out The array to hold the output data.
         * @returns binary data
         * @zh 异步获取渲染纹理的像素数据。
         * @param xOffset x偏移值
         * @param yOffset y偏移值
         * @param width 要检索的区域的宽度。
         * @param height 要检索的区域的高度。
         * @param out 用于保存输出数据的数组。
         * @returns 二进制数据
         */
        getDataAsync(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Promise<ArrayBufferView>;
        /**
         * @internal
         * @en Recycles the RenderTexture2D.
         * @zh 回收渲染纹理。
         */
        recycle(): void;
        /**
         * @internal
         */
        _disposeResource(): void;
    }
    /**
     * @en The `RenderTextureCube` class is used for creating cube map render textures.
     * @zh `RenderTextureCube` 类用于创建立方体贴图渲染纹理。
     */
    class RenderTextureCube extends RenderTexture {
        /**
         * @en The index of the cube face, which can be +x, -x, +y, -y, +z, or -z.
         * @zh 立方体贴图的面索引，可以是 +x, -x, +y, -y, +z 或 -z。
         */
        faceIndex: number;
        /**
         * @en Create a new instance of `RenderTextureCube`.
         * @param size The size of the texture.
         * @param colorFormat The color format of the render target.
         * @param depthFormat The depth format of the render target.
         * @param generateMipmap Whether to generate mipmaps for the render texture.
         * @param multiSamples The number of samples for multi-sampling.
         * @zh 创建一个 `RenderTextureCube` 实例。
         * @param size 纹理的尺寸。
         * @param colorFormat 渲染目标的颜色格式。
         * @param depthFormat 渲染目标的深度格式。
         * @param generateMipmap 是否为渲染纹理生成 mipmaps。
         * @param multiSamples 多采样的样本数量。
         */
        constructor(size: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap: boolean, multiSamples: number);
        /**
         * @internal
         */
        _createRenderTarget(): void;
    }
    /**
     * @en The `Resource` class used for resource access.
     * @zh `Resource` 类用于资源存取。
     * @blueprintable @blueprintableSubclasses
     */
    class Resource extends EventDispatcher {
        /**@ignore */
        static _idResourcesMap: any;
        /** 以字节为单位。*/
        private static _cpuMemory;
        /** 以字节为单位。*/
        private static _gpuMemory;
        /**
         * @en Whether the debug mode is enabled.
         * @zh 是否开启调试模式。
         */
        static DEBUG: boolean;
        /**
         * @en The current CPU memory, in bytes.
         * @zh 当前内存，以字节为单位。
         */
        static get cpuMemory(): number;
        /**
         * @en The current GPU memory, in bytes.
         * @zh 当前显存，以字节为单位。
         */
        static get gpuMemory(): number;
        /**
         * @internal
         */
        static _addCPUMemory(size: number): void;
        /**
         * @internal
         */
        static _addGPUMemory(size: number): void;
        /**
         * @internal
         */
        static _addMemory(cpuSize: number, gpuSize: number): void;
        /**
         * @en Destroy unused resources, this function will ignore resources with lock=true.
         * @zh 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
         */
        static destroyUnusedResources(): void;
        private static _destroyUnusedResources;
        private _cpuMemory;
        private _gpuMemory;
        _id: number;
        protected _destroyed?: boolean;
        protected _referenceCount: number;
        protected _obsolute: boolean;
        protected _deps: Array<Resource>;
        /** 是否建立引用跟踪链。 */
        protected _traceDeps: boolean;
        /**
         * @en Whether to lock the resource, if true, the resource cannot be automatically released.
         * @zh 是否加锁，如果true为不能使用自动释放机制。
         */
        lock?: boolean;
        /**
         * @en The name of the resource.
         * @zh 资源名称。
         */
        name?: string;
        /**
         * @en The URL of the resource.
         * @zh 获取资源的URL地址。
         */
        url: string;
        /**
         * @en The UUID of the resource.
         * @zh 获取资源的UUID。
         */
        uuid: string;
        /**
         * @en Whether to delete the resource immediately when the reference count is 0.
         * @zh 是否在引用计数为0的时候立马删除他
         */
        destroyedImmediately: boolean;
        /**
         * @en Unique identifier ID, usually used for identification.
         * @zh 唯一标识ID,通常用于识别。
         */
        get id(): number;
        /**
         * @en CPU memory size.
         * @zh 内存大小。
         */
        get cpuMemory(): number;
        /**
         * @en GPU memory size.
         * @zh 显存大小。
         */
        get gpuMemory(): number;
        /**
         * @en Whether the resource has been destroyed.
         * @zh 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * @en If a cached resource observer is set to true, then:
         * - 1) getRes will still return this resource;
         * - 2) next time loading will ignore this cached resource and reload it.
         * @zh 如果设置一个已缓存的资源obsolute为true，则
         * - 1）getRes仍然可以返回这个资源；
         * - 2）下次加载时会忽略这个缓存而去重新加载。。
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * @en The list of dependencies for the resource.
         * @zh 资源的依赖列表。
         */
        get deps(): ReadonlyArray<Resource>;
        /**
         * @en The reference count of the resource.
         * @zh 资源的引用计数。
         */
        get referenceCount(): number;
        /**
         * @en Creates an instance of Resource.
         * @param managed If set to true, the resource will be automatically released when the reference count is 0. Default is true.
         * @zh 创建一个 Resource 实例。
         * @param managed 如果设置为true，则在destroyUnusedResources时会检测引用计数并自动释放如果计数为0。默认为true。
         */
        protected constructor(managed?: boolean);
        /**
         * @en Adjusts the cpu memory usage by the specified value.
         * @param value The amount by which to adjust the CPU memory usage.
         * @zh 根据指定的值调整内存使用量。
         * @param value 要调整的内存使用量。
         */
        _setCPUMemory(value: number): void;
        /**
         * @en Adjusts the GPU memory usage by the specified value.
         * @param value The amount by which to adjust the GPU memory usage.
         * @zh 根据指定的值调整显存使用量。
         * @param value 要调整的显存使用量。
         */
        _setGPUMemory(value: number): void;
        /**
         * @en Sets the URL and UUID used to create this resource.
         * @param url The URL used to create the resource.
         * @param uuid The optional UUID of the resource.
         * @zh 设置用于创建此资源的 URL 和 UUID。
         * @param url 用于创建资源的 URL。
         * @param uuid 资源的可选UUID。
         */
        _setCreateURL(url: string, uuid?: string): void;
        /**
         * @en Checks if the resource is created from the specified URL.
         * @param url The URL to check against the resource's creation URL.
         * @returns True if the resource is created from the specified URL, otherwise false.
         * @zh 检查资源是否从指定的 URL 创建。
         * @param url 要检查的资源创建 URL。
         * @returns 如果资源是从指定的 URL 创建的，则返回 true，否则返回 false。
         */
        isCreateFromURL(url: string): boolean;
        /**
         * @en Increments the reference count of the resource by the specified amount.
         * @param count The amount by which to increment the reference count, default is 1.
         * @zh 按指定数量增加资源的引用计数。
         * @param count 要增加的引用计数，默认为1。
         */
        _addReference(count?: number): void;
        /**
         * @en Decrements the reference count of the resource by the specified amount. If the reference count reaches zero and certain conditions are met, the resource may be destroyed.
         * @param count The amount by which to decrement the reference count, default is 1.
         * @zh 按指定数量减少资源的引用计数。如果引用计数达到零并且满足特定条件，资源可能会被销毁。
         * @param count 要减少的引用计数，默认为1。
         */
        _removeReference(count?: number): void;
        /**
         * @en Clears the reference count of the resource.
         * @zh 清除引用
         */
        _clearReference(): void;
        /**
         * 增加一个依赖内容
         * @param res 依赖内容
         */
        addDep(res: Resource): void;
        /**
         * 增加多个依赖内容
         * @param resArr 依赖内容
         */
        addDeps(resArr: Array<Resource>): void;
        private onDepObsolute;
        protected _disposeResource(): void;
        /**
         * @en Destroys the resource, the resource cannot be recovered.
         * @zh 销毁资源,销毁后资源不能恢复。
         */
        destroy(): void;
    }
    /**
     * @en Enum for text resource formats.
     * @zh 文字资源格式的枚举类型。
     */
    enum TextResourceFormat {
        /**
         * @en Represents the buffer format.
         * @zh 表示缓冲区格式。
         */
        Buffer = 0,
        /**
         * @en Represents the plain text format.
         * @zh 表示纯文本格式。
         * TODO:
         */
        Plain = 1,
        /**
         * @en Represents the JSON format.
         * @zh 表示JSON格式。
         */
        JSON = 2,
        /**
         * @en Represents the XML format.
         * @zh 表示XML格式。
         */
        XML = 3
    }
    /**
     * @en The `TextResource` class represents a text resource.
     * @zh `TextResource` 类表示文字资源。
     */
    class TextResource extends Resource {
        /**
         * @en The data of the text resource, read-only.
         * @zh 文字资源的数据，只读。
         */
        readonly data: any;
        /**
         * @en The format of the text resource, read-only.
         * @zh 文字资源的格式，只读。
         */
        readonly format: TextResourceFormat;
        /**
         * @en Creates a new instance of the `TextResource` class.
         * @param data The data of the text resource.
         * @param format The format of the text resource.
         * @zh 创建 TextResource 类的新实例。
         * @param data 文字资源的数据。
         * @param format 文字资源的格式
         */
        constructor(data: any, format: TextResourceFormat);
    }
    /**
     * @en The Texture is a texture processing class.
     * @zh Texture 是一个纹理处理类。
     */
    class Texture extends Resource {
        /**
         * @en Default UV information.
         * @zh 默认 UV 信息。
         */
        static readonly DEF_UV: Float32Array;
        /**
         * @en No UV information.
         * @zh 无 UV 信息
         */
        static readonly NO_UV: Float32Array;
        /**
         * @en Inverse UV information.
         * @zh 反转 UV 信息。
         */
        static readonly INV_UV: Float32Array;
        /**
         * @en Range of UV
         * @zh uv的范围
         */
        uvrect: number[];
        private _bitmap;
        /**@internal */
        _uv: ArrayLike<number>;
        private _w;
        private _h;
        /**
         * @en The offset along the X-axis.
         * @zh 沿 X 轴的偏移量。
         */
        offsetX: number;
        /**
         * @en The offset along the Y-axis.
         * @zh 沿 Y 轴的偏移量。
         */
        offsetY: number;
        /**
         * @en The original width of the texture, including any transparent areas that have been cropped out.
         * @zh 包括已被裁剪掉的透明区域的纹理原始宽度。
         */
        sourceWidth: number;
        /**
         * @en The original height of the texture, including any transparent areas that have been cropped out.
         * @zh 包括已被裁剪掉的透明区域的纹理原始高度。
         */
        sourceHeight: number;
        /**
         * @en The URL of the texture image.
         * @zh 纹理图片的地址。
         */
        url: string;
        /**
         * @en The UUID of the texture.
         * @zh 纹理的 UUID。
         */
        uuid: string;
        /**
         * @en The scale rate of the texture.
         * @zh 纹理的缩放率。
         */
        scaleRate: number;
        /**
         * 九宫格
         * @internal
         */
        _sizeGrid?: Array<number>;
        /**
         * 状态数量
         * @internal
         */
        _stateNum?: number;
        /**
         * @internal
         */
        _clipCache: Map<string, Texture>;
        /**
         * @internal
         * 如果是图集中的小图，记录了图集的引用
         */
        _atlas: AtlasResource;
        /**
         * @internal
         * 是否旋转。
         */
        _rotate: boolean;
        /**
         * @en Creates a `Texture` object based on the specified source, coordinates, dimensions, and offsets.
         * @param source The source texture, either a `Texture2D` or a `Texture` object.
         * @param x The starting absolute x coordinate.
         * @param y The starting absolute y coordinate.
         * @param width The absolute width.
         * @param height The absolute height.
         * @param offsetX The offset on the X-axis (optional). It is the position of [x, y] relative to the original small image. Generally, it is positive, indicating that the size of the blank edge has been cut off. If it is negative, it usually indicates that a protective edge has been added
         * @param offsetY The offset on the Y-axis (optional).
         * @param sourceWidth The original width, including any cropped transparent areas (optional).
         * @param sourceHeight The original height, including any cropped transparent areas (optional).
         * @returns A `Texture` object.
         * @zh 根据指定的资源、坐标、宽高和偏移量等创建 `Texture` 对象。
         * @param source 资源，可以是 `Texture2D` 或 `Texture` 对象。
         * @param x 绝对坐标 x 。
         * @param y 绝对坐标 y 。
         * @param width 绝对宽度。
         * @param height 绝对高度。
         * @param offsetX X 轴偏移量（可选）。 就是[x,y]相对于原始小图片的位置。一般都是正的，表示裁掉了空白边的大小，如果是负的一般表示加了保护边
         * @param offsetY Y 轴偏移量（可选）。
         * @param sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
         * @param sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
         * @return `Texture` 对象。
         */
        static create(source: Texture | BaseTexture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number, rotate?: boolean): Texture;
        /**
         * @internal
         * 根据指定资源和坐标、宽高、偏移量等创建 <code>Texture</code> 对象。
         * @param source 绘图资源 Texture2D 或者 Texture 对象。
         * @param x 起始绝对坐标 x 。
         * @param y 起始绝对坐标 y 。
         * @param width 宽绝对值。
         * @param height 高绝对值。
         * @param offsetX X 轴偏移量（可选）。
         * @param offsetY Y 轴偏移量（可选）。
         * @param sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
         * @param sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
         * @param rotate 是否旋转。
         * @param outTexture 返回的Texture对象。
         * @return  <code>Texture</code> 对象。
         */
        static _create(source: Texture | BaseTexture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number, rotate?: boolean, outTexture?: Texture): Texture;
        /**
         * @en Creates a new `Texture` by cropping a part of an existing `Texture`. If the two areas do not intersect, it returns null.
         * @param texture The target `Texture` to crop.
         * @param x The x position relative to the target `Texture`.
         * @param y The y position relative to the target `Texture`.
         * @param width The width to crop.
         * @param height The height to crop.
         * @returns A new `Texture` or null if the areas do not intersect.
         * @zh 截取 `Texture` 的一部分区域，生成一个新的 `Texture`，如果两个区域没有相交，则返回 null。
         * @param texture 目标 `Texture` 。
         * @param x 相对于目标 `Texture` 的 x 位置。
         * @param y 相对于目标 `Texture` 的 y 位置。
         * @param width 截取的宽度。
         * @param height 截取的高度。
         * @return 一个新的 `Texture` 或 null，如果两个区域没有相交。
         */
        static createFromTexture(texture: Texture, x: number, y: number, width: number, height: number): Texture;
        /**
         * @en The UV coordinates of the texture.
         * @zh 纹理的 UV 坐标。
         */
        get uv(): ArrayLike<number>;
        set uv(value: ArrayLike<number>);
        /**
         * @en The actual width of the texture.
         * @zh 纹理的实际宽度。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en The actual height of the texture.
         * @zh 纹理的实际高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The bitmap of the texture.
         * @zh 纹理的位图。
         */
        get bitmap(): BaseTexture;
        set bitmap(value: BaseTexture);
        get rotate(): boolean;
        set rotate(value: boolean);
        _rotateTexture(rotate: boolean): void;
        /**
         * @en Creates an instance of Texture class.
         * @param source Bitmap resource.
         * @param uv UV data information.
         * @param sourceWidth Original width of the texture.
         * @param sourceHeight Original height of the texture.
         * @zh 创建 Texture 类的新实例
         * @param source 位图资源。
         * @param uv UV 数据信息。
         * @param sourceWidth 纹理原始宽度。
         * @param sourceHeight 纹理原始高度。
         */
        constructor(source?: Texture | BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number);
        /**
         * @internal
         */
        _addReference(count?: number): void;
        /**
         * @internal
         */
        _removeReference(count?: number): void;
        /**
         * @internal
         */
        _getSource(cb?: () => void): any;
        /**
         * @en Sets the bitmap resource and UV data information for this object.
         * @param bitmap The bitmap resource.
         * @param uv The UV data information.
         * @param sourceWidth The original width of the texture.
         * @param sourceHeight The original height of the texture.
         * @zh 设置此对象的位图资源和 UV 数据信息。
         * @param bitmap 位图资源。
         * @param uv UV 数据信息。
         * @param sourceWidth 纹理原始宽度。
         * @param sourceHeight 纹理原始高度。
         */
        setTo(bitmap?: BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number): void;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.IMAGE)
         * @en Loads an image from the specified URL.
         * @param url The URL of the image to load.
         * @param complete An optional callback function that is called when the image is loaded.
         * @returns A promise that resolves to the loaded image.
         * @zh 从指定的 URL 加载图片。
         * @param url 图片地址。
         * @param complete 加载完成回调。
         * @returns 一个 Promise 对象，解析为加载的图片。
         */
        load(url: string, complete?: Handler): Promise<void>;
        /**
         * @en Retrieves the pixel data from a region of the texture.
         * @param x The x-coordinate of the region.
         * @param y The y-coordinate of the region.
         * @param width The width of the region.
         * @param height The height of the region.
         * @returns A Uint8Array containing the pixel data.
         * @zh 从纹理的特定区域获取像素数据。
         * @param x 区域的 x 坐标。
         * @param y 区域的 y 坐标。
         * @param width 区域的宽度。
         * @param height 区域的高度。
         * @return 一个 Uint8Array 对象，包含了像素数据。
         */
        getTexturePixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * @en Retrieves the pixel data from a specific area of the `Texture`.
         * @param x The x-coordinate of the area.
         * @param y The y-coordinate of the area.
         * @param width The width of the area.
         * @param height The height of the area.
         * @returns A `Uint8Array` containing the pixel data.
         * @zh 从 `Texture` 的特定区域获取像素点集合。
         * @param x 区域的 x 坐标。
         * @param y 区域的 y 坐标。
         * @param width 区域的宽度。
         * @param height 区域的高度。
         * @return 一个 `Uint8Array` 对象，包含了像素点集合。
         */
        getPixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * @en Forces the recovery of the `bitmap` from the URL.
         * @param callback An optional callback function to call after the bitmap is recovered.
         * @zh 通过 URL 强制恢复 `bitmap`。
         * @param callback 位图恢复后调用的可选回调函数。
         */
        recoverBitmap(callback?: () => void): void;
        /**
         * @en Forces the disposal of the `bitmap`, regardless of references.
         * @zh 强制释放 `bitmap`，无论它是否被引用。
         */
        disposeBitmap(): void;
        /**
         * @en Whether the texture is valid.
         * @zh 纹理是否有效。
         */
        get valid(): boolean;
        /**
         * @en Whether the texture is considered obsolete.
         * @zh 纹理是否被认为是过时的。
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * @en Destroys the resource.
         * @zh 销毁资源。
         */
        protected _disposeResource(): void;
        /**
         * @en Retrieves a clipped sub-texture from this texture and caches it for future access.
         * @param x The x-coordinate of the clip area.
         * @param y The y-coordinate of the clip area.
         * @param width The width of the clip area.
         * @param height The height of the clip area.
         * @returns A `Texture` object representing the clipped sub-texture, or null if the clip area is out of bounds.
         * @zh 从当前纹理获取裁剪后的子纹理，并将其缓存以供将来访问。
         * @param x 裁剪区域的 x 坐标。
         * @param y 裁剪区域的 y 坐标。
         * @param width 裁剪区域的宽度。
         * @param height 裁剪区域的高度。
         * @return 一个 `Texture` 对象，表示裁剪后的子纹理，如果裁剪区域越界，则返回 null。
         */
        getCachedClip(x: number, y: number, width: number, height: number): Texture;
    }
    /**
     * @en Interface for texture property parameters.
     * @zh 纹理属性参数接口。
     */
    interface TexturePropertyParams {
        /**
         * @en Texture U-coordinate line break mode.
         * @zh 纹理 U 坐标换行模式。
         */
        wrapModeU?: number;
        /**
         * @en Texture V-coordinate line break mode.
         * @zh 纹理 V 坐标换行模式。
         */
        wrapModeV?: number;
        /**
         * @en The filter mode for the texture.
         * @zh 纹理的过滤模式。
         */
        filterMode?: FilterMode;
        /**
         * @en The anisotropic filtering level for the texture.
         * @zh 纹理的各向异性过滤级别。
         */
        anisoLevel?: number;
        /**
         * @en Whether to premultiply the alpha channel.
         * @zh 是否预乘alpha通道。
         */
        premultiplyAlpha?: boolean;
        /**
         * @en The HDR encoding format for the texture.
         * @zh 纹理的HDR编码格式。
         */
        hdrEncodeFormat?: HDREncodeFormat;
    }
    type TextureConstructParams = ConstructorParameters<typeof Texture2D>;
    /**
     * @en The Texture2D class is used to generate 2D textures.
     * @zh Texture2D 类用于生成2D纹理。
     */
    class Texture2D extends BaseTexture {
        /**
         * @en The identifier for Texture2D resources.
         * @zh Texture2D 资源的标识符。
         */
        static TEXTURE2D: string;
        /**
         * @en A pure gray texture.
         * @zh 纯灰色纹理。
         */
        static grayTexture: Texture2D;
        /**
         * @en A pure white texture.
         * @zh 纯白色纹理。
         */
        static whiteTexture: Texture2D;
        /**
         * @en A pure black texture.
         * @zh 纯黑色纹理。
         */
        static blackTexture: Texture2D;
        /**
         * @en The default normal map texture.
         * @zh 默认法线纹理。
         */
        static normalTexture: Texture2D;
        /**
         * @en The error texture displayed when a texture fails to load.
         * @zh 当纹理加载失败时显示的错误纹理。
         */
        static errorTexture: Texture2D;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @internal
         */
        static _SimpleAnimatorTextureParse(data: ArrayBuffer, propertyParams?: TexturePropertyParams, constructParams?: TextureConstructParams): Texture2D;
        /**
         * @internal
         */
        static _parseImage(imageSource: any, propertyParams?: TexturePropertyParams, constructParams?: TextureConstructParams): Texture2D;
        /**
         * @internal
         */
        static _parseDDS(data: ArrayBuffer, propertyParams?: TexturePropertyParams, constructParams?: TextureConstructParams): Texture2D;
        /**
         * @internal
         */
        static _parseKTX(data: ArrayBuffer, propertyParams?: TexturePropertyParams, constructParams?: TextureConstructParams): Texture2D;
        /**
         * @internal
         */
        static _parsePVR(data: ArrayBuffer, propertyParams?: TexturePropertyParams, constructParams?: TextureConstructParams): Texture2D;
        /**
         * @deprecated 请使用Loader.load(url:string, type: ILaya.Loader.TEXTURE2D)
         * @en Loads a texture from the specified URL.
         * @param url The path to the texture file.
         * @param complete The callback function to be called after the texture is loaded.
         * @zh 从指定的 URL 加载纹理。
         * @param url 纹理文件的路径。
         * @param complete 纹理加载完成后的回调函数。
         */
        static load(url: string, complete: Handler): void;
        /**@internal */
        _canRead: boolean;
        /**@internal */
        _pixels: Uint8Array;
        /** @internal */
        _premultiplyAlpha: boolean;
        /**
         * @en Creates an instance of Texture2D.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param format The format of the texture.
         * @param mipmap Indicates whether to generate mipmaps for the texture.
         * @param canRead Indicates whether the texture data can be read.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @param premultiplyAlpha Indicates whether the texture data is premultiplied by the alpha channel.
         * @zh 创建 Texture2D 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param format 纹理的格式。
         * @param mipmap 是否为纹理生成mipmap。
         * @param canRead 纹理数据是否可以读取。
         * @param sRGB 纹理是否使用sRGB色彩空间。
         * @param premultiplyAlpha 纹理数据是否预乘alpha通道。
         */
        constructor(width: number, height: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        /**
         * @en Sets the image data for the texture.
         * @param source The image source, can be an `HTMLImageElement`, `HTMLCanvasElement`, or `ImageBitmap`.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的图像数据。
         * @param source 图像源，可以是 `HTMLImageElement`、`HTMLCanvasElement` 或 `ImageBitmap`。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像的 Y 轴。
         */
        setImageData(source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for the texture.
         * @param source The pixel data to be set.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 设置纹理的像素数据。
         * @param source 要设置的像素数据。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转像素数据的 Y 轴。
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets a sub-region of pixel data for the texture.
         * @param xOffset The x-offset for the sub-region.
         * @param yOffset The y-offset for the sub-region.
         * @param width The width of the sub-region.
         * @param height The height of the sub-region.
         * @param pixels The pixel data for the sub-region.
         * @param mipmapLevel The mipmap level to update, if mipmap is enabled.
         * @param generateMipmap Whether to generate mipmaps for the updated region.
         * @param premultiplyAlpha Whether to premultiply the alpha channel of the pixel data.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 设置纹理的子区域像素数据。
         * @param xOffset 子区域的 x 偏移。
         * @param yOffset 子区域的 y 偏移。
         * @param width 子区域的宽度。
         * @param height 子区域的高度。
         * @param pixels 子区域的像素数据。
         * @param mipmapLevel 要更新的mipmap等级，如果mipmap为true。
         * @param generateMipmap 是否为更新的区域生成mipmap。
         * @param premultiplyAlpha 是否预乘子区域的像素数据的 alpha 通道。
         * @param invertY 是否反转子区域的像素数据的 Y 轴。
         */
        setSubPixelsData(xOffset: number, yOffset: number, width: number, height: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the DDS  data for the texture.
         * @param ddsInfo The DDS texture information containing the data to be set.
         * @zh 设置纹理的 DDS 数据。
         * @param ddsInfo DDS 纹理信息，包含要设置的数据。
         */
        setDDSData(ddsInfo: DDSTextureInfo): void;
        /**
         * @en Sets the KTX  data for the texture.
         * @param ktxInfo The KTX texture information containing the data to be set.
         * @zh 设置纹理的 KTX 数据。
         * @param ktxInfo KTX 纹理信息，包含要设置的数据。
         */
        setKTXData(ktxInfo: KTXTextureInfo): void;
        /**
         * @en Sets the HDR data for the texture.
         * @param hdrInfo The HDR texture information containing the data to be set.
         * @zh 设置纹理的 HDR 数据。
         * @param hdrInfo HDR 纹理信息，包含要设置的数据。
         */
        setHDRData(hdrInfo: HDRTextureInfo): void;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        get defaultTexture(): BaseTexture;
        /**
         * @en Retrieves the pixel data from the texture.
         * @zh 从纹理中检索像素数据。
         */
        getPixels(): Uint8Array;
        private setProperties;
    }
    /**
     * @en `Texture2DArray` represents a 2D texture array.
     * @zh `Texture2DArray` 类表示一个2D纹理数组。
     */
    class Texture2DArray extends BaseTexture {
        private static _defaultTexture;
        /**
         * @en The default texture.
         * @zh 默认纹理。
         */
        static get defaultTexture(): Texture2DArray;
        /** @internal */
        static __init__(): void;
        /**
         * @en The number of texture layers.
         * @zh 纹理层的数量。
         */
        depth: number;
        /**
         * @en Creates a `Texture2DArray` instance.
         * @zh Texture2DArray 的构造函数
         * @param width The width of the texture
         * @param height The height of the texture
         * @param depth The depth of the texture array
         * @param format The format of the texture
         * @param mipmap Whether to generate mipmaps
         * @param canRead Whether the texture can be read
         * @param sRGB Whether the texture is in sRGB color space
         * @zh 创建 Texture2DArray 类的实例。
         * @param width 纹理的宽度
         * @param height 纹理的高度
         * @param depth 纹理数组的深度
         * @param format 纹理的格式
         * @param mipmap 是否生成 mipmap
         * @param canRead 纹理是否可读
         * @param sRGB 纹理是否在 sRGB 颜色空间中
         */
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean);
        /**
         * @en Sets the image data for the texture.
         * @param sources The array of images to set.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的图像数据。
         * @param sources 要设置的图像数组。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setImageData(sources: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for the texture.
         * @param source The pixel data to set.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 设置纹理的像素数据。
         * @param source 要设置的像素数据。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Updates the sub-pixel data for the texture.
         * @param xOffset The x-offset.
         * @param yOffset The y-offset.
         * @param zOffset The z-offset.
         * @param width The width of the data to update.
         * @param height The height of the data to update.
         * @param depth The depth level of the data to update.
         * @param pixels The pixel data to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @param premultiplyAlpha Whether to premultiply the alpha channel.
         * @param invertY Whether to invert the Y-axis of the image.
         * @zh 更新纹理的子像素数据。
         * @param xOffset x 偏移
         * @param yOffset y 偏移
         * @param zOffset z 偏移
         * @param width 要更新的数据的宽度。
         * @param height 要更新的数据的高度。
         * @param depth 要更新的数据的深度。
         * @param pixels 要更新的像素数据。
         * @param mipmapLevel 要更新的 mipmap 等级。
         * @param generateMipmap 是否在更新后生成 mipmap。
         * @param premultiplyAlpha 是否预乘 alpha。
         * @param invertY 是否反转图像 Y 轴。
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    /**
     * @en The Texture3D class is used to generate 3D textures.
     * @zh Texture3D 类用于生成 3D 纹理。
     */
    class Texture3D extends BaseTexture {
        private static _defaultTexture;
        /**
         * @en The default texture for 3D textures.
         * @zh 3D纹理的默认纹理。
         */
        static get defaultTexture(): Texture3D;
        /** @internal */
        static __init__(): void;
        /**
         * @en The depth of the 3D texture.
         * @zh 3D纹理的深度。
         */
        depth: number;
        /**
         * @en Creates an instance of Texture3D.
         * @param width The width of the texture.
         * @param height The height of the texture.
         * @param depth The depth of the texture.
         * @param format The format of the texture.
         * @param mipmap Indicates whether to generate mipmaps for the texture.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @zh 创建 Texture3D 类的实例。
         * @param width 纹理的宽度。
         * @param height 纹理的高度。
         * @param depth 纹理的深度。
         * @param format 纹理的格式。
         * @param mipmap 是否为纹理生成 mipmap。
         * @param sRGB 纹理是否使用 sRGB 色彩空间。
         */
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean);
        /**
         * @en Sets the pixel data for the 3D texture.
         * @param source The source pixel data to set.
         * @zh 设置3D纹理的像素数据。
         * @param source 要设置的源像素数据。
         */
        setPixelsData(source: ArrayBufferView): void;
        /**
         * @en Update pixel data of 3D texture in sub regions
         * @param xOffset The x-offset within the texture.
         * @param yOffset The y-offset within the texture.
         * @param zOffset The z-offset within the texture.
         * @param width The width of the sub-region to update.
         * @param height The height of the sub-region to update.
         * @param depth The depth of the sub-region to update.
         * @param pixels The pixel data to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @zh 更新子区域3D纹理的像素数据。
         * @param xOffset 纹理内的 x 偏移。
         * @param yOffset 纹理内的 y 偏移。
         * @param zOffset 纹理内的 z 偏移。
         * @param width 要更新的子区域的宽度。
         * @param height 要更新的子区域的高度。
         * @param depth 要更新的子区域的深度。
         * @param pixels 要更新的像素数据。
         * @param mipmapLevel 要更新的 mipmap 等级。
         * @param generateMipmap 是否在更新后生成 mipmap。
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean): void;
    }
    /**
     * @en Enum for the map faces of a cube texture.
     * @zh 表示立方体纹理各个面面的枚举。
     */
    enum TextureCubeFace {
        /**
         * @en The positive X face of the cube map.
         * @zh 立方体贴图的正X面。
         */
        PositiveX = 0,
        /**
         * @en The negative X face of the cube map.
         * @zh 立方体贴图的负X面。
         */
        NegativeX = 1,
        /**
         * @en The positive Y face of the cube map.
         * @zh 立方体贴图的正Y面。
         */
        PositiveY = 2,
        /**
         * @en The negative Y face of the cube map.
         * @zh 立方体贴图的负Y面。
         */
        NegativeY = 3,
        /**
         * @en The positive Z face of the cube map.
         * @zh 立方体贴图的正Z面。
         */
        PositiveZ = 4,
        /**
         * @en The negative Z face of the cube map.
         * @zh 立方体贴图的负Z面。
         */
        NegativeZ = 5
    }
    /**
     * @en TextureCube class used to generate cube texture.
     * @zh TextureCube 类用于生成立方体纹理。
     */
    class TextureCube extends BaseTexture {
        private static _blackTexture;
        private static _grayTexture;
        private static _whiteTexture;
        private static _errorTexture;
        /**
         * @en The black solid color texture.
         * @zh 黑色纯色纹理。
         */
        static get blackTexture(): TextureCube;
        /**
         * @en The gray solid color texture.
         * @zh 灰色纯色纹理。
         */
        static get grayTexture(): TextureCube;
        /**
         * @en The white solid color texture.
         * @zh 白色纯色纹理。
         */
        static get whiteTexture(): TextureCube;
        /**
         * @en The error texture used for cube textures.
         * @zh 立方体贴图的错误纹理。
         */
        static get errorTexture(): TextureCube;
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @en Creates an instance of TextureCube.
         * @param size The size of each face of the cube texture.
         * @param format The texture format.
         * @param mipmap Indicates whether to generate mipmaps for the cube texture.
         * @param sRGB Indicates whether the texture uses sRGB color space.
         * @param premultiplyAlpha Indicates whether the texture data is premultiplied by the alpha channel.
         * @zh 创建 TextureCube 类的实例。
         * @param size 立方体纹理各个面大小。
         * @param format 纹理格式。
         * @param mipmap 是否为立方体纹理生成mipmap。
         * @param sRGB 是否使用sRGB色彩空间。
         * @param premultiplyAlpha 是否预乘Alpha。
         * @blueprintIgnore
         */
        constructor(size: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        /**
         * @en Sets the image data for each face of the cube texture.
         * @param source An array of image elements, one for each face of the cube.
         * @param premultiplyAlpha Whether to premultiply the alpha channel of the image data.
         * @param invertY Whether to invert the Y-axis of the image data.
         * @zh 为立方体贴图的每个面设置图像数据。
         * @param source 图像元素数组，每个面一个。
         * @param premultiplyAlpha 是否预乘Alpha通道。
         * @param invertY 是否翻转Y轴。
         */
        setImageData(source: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the pixel data for each face of the cube texture.
         * @param source An array of pixel data, one for each face of the cube.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 为立方体贴图的每个面设置像素数据。
         * @param source 像素数据数组，每个面一个。
         * @param premultiplyAlpha 是否预乘Alpha。
         * @param invertY 是否翻转Y轴。
         */
        setPixelsData(source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Updates sub-pixel data for the cube texture faces.
         * @param source An array of pixel data for each face of the cube texture.
         * @param xOffset The x-offset for the sub-pixel data.
         * @param yOffset The y-offset for the sub-pixel data.
         * @param width The width of the sub-region to update.
         * @param height The height of the sub-region to update.
         * @param mipmapLevel The mipmap level to update.
         * @param generateMipmap Whether to generate mipmaps after the update.
         * @param premultiplyAlpha Whether to premultiply the alpha.
         * @param invertY Whether to invert the Y-axis of the pixel data.
         * @zh 更新立方体贴图的子像素数据。
         * @param source 像素数据数组，每个面一个。
         * @param xOffset 子像素数据x偏移。
         * @param yOffset 子像素数据y偏移。
         * @param width 子像素数据宽度。
         * @param height 子像素数据高度。
         * @param mipmapLevel 子像素数据mipmap等级。
         * @param generateMipmap 是否生成mipmap。
         * @param premultiplyAlpha 是否预乘Alpha。
         * @param invertY 是否翻转Y轴。
         */
        updateSubPixelsData(source: ArrayBufferView[], xOffset: number, yOffset: number, width: number, height: number, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * @en Sets the DDS data for the cube texture.
         * @param ddsInfo The DDS texture information containing the data to be set.
         * @zh 设置立方体贴图的 DDS 数据。
         * @param ddsInfo DDS纹理信息，包含要设置的数据。
         */
        setDDSData(ddsInfo: DDSTextureInfo): void;
        /**
         * @en Sets the KTX data for the cube texture.
         * @param ktxInfo The KTX texture information containing the data to be set.
         * @zh 设置立方体贴图的 KTX 数据。
         * @param ktxInfo KTX纹理信息，包含要设置的数据。
         */
        setKTXData(ktxInfo: KTXTextureInfo): void;
        /**
         * @en The default texture for cube textures.
         * @zh 立方体贴图的默认纹理。
         */
        get defaultTexture(): BaseTexture;
    }
    /**
     * @en WebGLRTMgr is a manager for creating and recycling WebGLRenderTarget.
     * TODO The demand is not high and the management cost is high. Remove it first.
     * @zh WebGLRTMgr 管理WebGLRenderTarget的创建和回收
     * TODO 需求不大，管理成本高。先去掉。
     */
    class WebGLRTMgr {
        private static dict;
        /**
         * @en Retrieves a render target with the specified width and height. For now, the search is based strictly on size.
         * @param w The width of the render target.
         * @param h The height of the render target.
         * @returns A RenderTexture2D instance.
         * @zh 根据指定的宽度和高度获得一个渲染目标。目前，搜索是基于严格大小判断的。
         * @param w 渲染目标的宽度。
         * @param h 渲染目标的高度。
         * @returns RenderTexture2D实例。
         */
        static getRT(w: number, h: number): RenderTexture2D;
        /**
         * @en Releases a render target back to the manager for recycling.
         * @param rt The RenderTexture2D instance to be recycled.
         * @zh 将渲染目标回收至管理器以供循环使用。
         * @param rt 要回收的渲染目标。
         */
        static releaseRT(rt: RenderTexture2D): void;
    }
    /**
     * @en Class representing an external skin for a Spine skeleton.
     * @zh 表示 Spine 骨骼的外部皮肤的类。
     */
    class ExternalSkin {
        /**@internal */
        protected _source: string;
        /**@internal */
        protected _templet: SpineTemplet;
        /**@internal */
        protected _items: ExternalSkinItem[];
        /**
         * @en The target Spine skeleton.
         * @zh 目标 Spine 骨骼。
         */
        target: Spine2DRenderNode;
        normal: boolean;
        /**
         * @en The source of the external skin Spine.
         * @zh 外部皮肤spine的源。
         */
        get source(): string;
        set source(value: string);
        /**
         * @en The content of the external skin.
         * @zh 要设置的外部皮肤的内容。
         */
        get items(): ExternalSkinItem[];
        set items(value: ExternalSkinItem[]);
        /**
         * @en Get the reference of the animation template.
         * @zh 得到动画模板的引用。
         */
        get templet(): SpineTemplet;
        set templet(value: SpineTemplet);
        /**
         * @en Initialize the external skin with a given template.
         * @param templet The animation template reference.
         * @zh 使用给定的模板初始化外部皮肤。
         * @param templet 动画模板的引用。
         */
        protected init(templet: SpineTemplet): void;
        /**
         * @en Replace the external skin Spine.
         * @zh 替换外部皮肤 Spine。
         */
        flush(): void;
    }
    class ExternalSkinItem {
        /**@internal */
        protected _skin: string;
        /**@internal */
        protected _slot: string;
        /**@internal */
        protected _attachment: string;
        /**
         * @en The skin.
         * @zh 皮肤。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The slot.
         * @zh 槽位。
         */
        get slot(): string;
        set slot(value: string);
        /**
         * @en The attachment.
         * @zh 附件。
         */
        get attachment(): string;
        set attachment(value: string);
    }
    interface ISpineRender {
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
        destroy(): void;
    }
    /**
     * @en SpineShaderInit class handles the initialization and management of Spine shader-related components.
     * @zh SpineShaderInit 类用于处理 Spine 着色器相关组件的初始化和管理。
     */
    class SpineShaderInit {
        /**
         * @en Vertex declaration for normal Spine rendering.
         * @zh 用于普通 Spine 渲染的顶点声明。
         */
        static SpineNormalVertexDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for instance normal matrix.
         * @zh 实例法线矩阵的顶点声明。
         */
        static instanceNMatrixDeclaration: VertexDeclaration;
        /**
         * @en Vertex declaration for instance simple animator.
         * @zh 实例简单动画器的顶点声明。
         */
        static instanceSimpleAnimatorDeclaration: VertexDeclaration;
        /**
         * @en Set the blend mode for Spine material.
         * @param value The blend mode value.
         * @param mat The material to set the blend mode for.
         * @param premultipliedAlpha Whether to premultiply the alpha channel.
         * @zh 设置 Spine 材质的混合模式。
         * @param value 混合模式值。
         * @param mat 要设置混合模式的材质。
         * @param premultipliedAlpha 是否预乘alpha通道。
         */
        static SetSpineBlendMode(value: number, mat: Material, premultipliedAlpha?: boolean): void;
        /**
         * @en Initialize the Spine material with default settings.
         * @param mat The material to initialize.
         * @zh 使用默认设置初始化 Spine 材质。
         * @param mat 要初始化的材质。
         */
        static initSpineMaterial(mat: Material): void;
        /**
         * @en Property ID for bone matrix.
         * @zh 骨骼矩阵的属性 ID。
         */
        static BONEMAT: number;
        /**
         * @internal
         * @en Simple animator texture.
         * @zh 简单动画器纹理。
         */
        static SIMPLE_SIMPLEANIMATORTEXTURE: number;
        /**
         * @internal
         * @en Simple animator parameters.
         * @zh 简单动画器参数。
         */
        static SIMPLE_SIMPLEANIMATORPARAMS: number;
        /**
         * @internal
         * @en Simple animator texture size.
         * @zh 简单动画器纹理尺寸。
         */
        static SIMPLE_SIMPLEANIMATORTEXTURESIZE: number;
        /**
         * @internal
         * @en Bone matrix 0.
         * @zh Rigidbody骨骼矩阵0。
         */
        static BONEMAT_0: number;
        /**
         * @internal
         * @en Bone matrix 1.
         * @zh Rigidbody骨骼矩阵1。
         */
        static BONEMAT_1: number;
        /**
         * @en Property ID for Spine texture.
         * @zh Spine 纹理的属性 ID。
         */
        static SpineTexture: number;
        /**
         * @en Shader define for fast Spine rendering.
         * @zh 快速 Spine 渲染的着色器定义。
         */
        static SPINE_FAST: ShaderDefine;
        /**
         * @en Shader define for Spine rendering with runtime blending.
         * @zh 运行时混合 Spine 渲染的着色器定义。
         */
        static SPINE_RB: ShaderDefine;
        static SPINE_UV: ShaderDefine;
        static SPINE_COLOR: ShaderDefine;
        static SPINE_SIMPLE: ShaderDefine;
        static SPINE_TWOCOLORTINT: ShaderDefine;
        static SPINE_COLOR2: ShaderDefine;
        /**
         * @en Shader define for GPU instance rendering.
         * @zh GPU 实例渲染的着色器定义。
         */
        static SPINE_GPU_INSTANCE: ShaderDefine;
        static SPINE_PREMULTIPLYALPHA: ShaderDefine;
        /**
         * @en Change the vertex define for the mesh.
         * @zh 更改网格的顶点定义。
         * @param shaderData 着色器数据。
         * @param mesh 网格。
         */
        static changeVertexDefine(shaderData: ShaderData, mesh: Mesh2D): void;
        /**
         * @en TextureSV Mesh Descript.
         * @zh 纹理 Spine 顶点属性描述。
         */
        static readonly textureSpineAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * @en Initialize Spine shader-related components.
         * @zh 初始化 Spine 着色器相关组件。
         */
        static init(): void;
    }
    /**
     * @en Abstract base class for Spine mesh rendering.
     * @zh Spine 网格渲染的抽象基类。
     */
    abstract class SpineMeshBase {
        /**
         * @en Maximum number of vertices. Limited by 64K indexbuffer constraint.
         * @zh 最大顶点数。受64K索引缓冲区限制。
         */
        static maxVertex: number;
        /**
         * @en Render element for 2D rendering.
         * @zh 用于2D渲染的渲染元素。
         */
        element: IRenderElement2D;
        /**
         * @en Geometry element for rendering.
         * @zh 用于渲染的几何元素。
         */
        geo: IRenderGeometryElement;
        private _material;
        /**
         * @en The material of the mesh.
         * @zh 网格的材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * @en Vertex buffer interface.
         * @zh 顶点缓冲区接口。
         */
        protected vb: IVertexBuffer;
        /**
         * @en Index buffer interface.
         * @zh 索引缓冲区接口。
         */
        protected ib: IIndexBuffer;
        /**
         * @en Vertex array.
         * @zh 顶点数组。
         */
        protected vertexArray: Float32Array;
        /**
         * @en Index array.
         * @zh 索引数组。
         */
        protected indexArray: Uint16Array;
        /**
         * @en Vertex array length.
         * @zh 顶点数组中顶点的数量。
         */
        protected verticesLength: number;
        /**
         * @en Index array length.
         * @zh 索引数组中索引的数量。
         */
        protected indicesLength: number;
        /**
         * @en Vertex Buffer length.
         * @zh 顶点缓冲区大小。
         */
        protected vertexBufferLength: number;
        /**
         * @en Index Buffer length.
         * @zh 索引缓冲区大小。
         */
        protected indexBufferLength: number;
        /**
         * @en Create a new instance of SpineMeshBase.
         * @param material The material to use for this mesh.
         * @zh 创建 SpineMeshBase 类的新实例。
         * @param material 网格使用的材质。
         */
        constructor(material: Material);
        /**
         * @en Initialize the mesh.
         * @zh 初始化网格。
         */
        init(): void;
        /**
         * @en The vertex declaration for the mesh.
         * @zh 网格的顶点声明。
         */
        get vertexDeclarition(): VertexDeclaration;
        /**
         * @en Add the mesh to the rendering queue.
         * @zh 添加到渲染队列。
         */
        draw(): void;
        /**
         * @en Draw the mesh using provided vertex and index data.
         * @param vertices Vertex data array.
         * @param vblength Number of vertices.
         * @param indices Index data array.
         * @param iblength Number of indices.
         * @zh 使用提供的顶点和索引数据绘制网格。
         * @param vertices 顶点数据数组。
         * @param vblength 顶点数量。
         * @param indices 索引数据数组。
         * @param iblength 索引数量。
         */
        drawByData(vertices: Float32Array, vblength: number, indices: Uint16Array, iblength: number): void;
        /**
         * @en Clear the mesh data.
         * @zh 清空网格数据。
         */
        clear(): void;
        /**
         * @en Destroy the mesh.
         * @zh 销毁网格。
         */
        destroy(): void;
        /** @internal */
        _cloneTo(target: SpineMeshBase): void;
    }
    class SpineMeshUtils {
        /**
         * @en Creates a Mesh2D object for Spine rendering
         * @param type The Spine render type
         * @param vbCreator Vertex buffer creator
         * @param ibCreator Index buffer creator
         * @param isDynamic Whether the mesh is dynamic
         * @param uploadBuffer Whether to upload buffer data
         * @returns The created Mesh2D object
         * @zh 创建用于 Spine 渲染的 Mesh2D 对象
         * @param type Spine 渲染类型
         * @param vbCreator 顶点缓冲区创建器
         * @param ibCreator 索引缓冲区创建器
         * @param isDynamic 是否为动态网格
         * @param uploadBuffer 是否上传缓冲区数据
         * @returns 创建的 Mesh2D 对象
         */
        static createMesh(type: ESpineRenderType, vbCreator: VBCreator, ibCreator: IBCreator, isDynamic?: boolean, uploadBuffer?: boolean): Mesh2D;
        /**
         * @en Creates a dynamic mesh based on the given vertex declaration.
         * This method is used to generate a Mesh2D object with dynamic vertex data.
         * @param vertexDeclaration The vertex declaration that defines the structure of vertex data.
         * @returns A new Mesh2D object configured for dynamic rendering.
         * @zh 根据给定的顶点声明创建一个动态网格。
         * 此方法用于生成一个具有动态顶点数据的 Mesh2D 对象。
         * @param vertexDeclaration 定义顶点数据结构的顶点声明。
         * @returns 一个配置为动态渲染的新 Mesh2D 对象。
         */
        static createMeshDynamic(vertexDeclaration: VertexDeclaration): Mesh2D;
        static _updateSpineSubMesh(mesh: Mesh2D, frameData: FrameRenderData): boolean;
        private static _vertexDeclarationMap;
        static getVertexDeclaration(vertexFlag: string): VertexDeclaration;
        static getIndexFormat(vertexCount: number): IndexFormat;
    }
    /**
     * @en SpineVirtualMesh class for handling Spine skeleton mesh rendering.
     * @zh SpineVirtualMesh 类用于处理 Spine 骨骼网格渲染。
     */
    class SpineVirtualMesh extends SpineMeshBase {
        /**
         * @en Size of each vertex in the vertex array.
         * @zh 顶点数组中每个顶点的大小。
         */
        static vertexSize: number;
        /**
         * @en Size of each vertex in the vertex array with Two Color.
         * @zh 双顶点色模式顶点数组中每个顶点的大小。
         */
        static vertexSize_TwoColor: number;
        /**
         * @en Shared vertex array for all instances.
         * @zh 所有实例共享的顶点数组。
         */
        static vertexArray: Float32Array;
        /**
         * @en Shared index array for all instances.
         * @zh 所有实例共享的索引数组。
         */
        static indexArray: Uint16Array;
        /**
         * @en Create a SpineVirtualMesh instance.
         * @param material Material to be used for rendering.
         * @zh 创建 SpineVirtualMesh 实例。
         * @param material 用于渲染的材质。
         */
        constructor(material: Material);
        /**
         * @en Append clipped vertices and indices.
         * @param vertices Array of vertex data.
         * @param indices Array of index data.
         * @zh 裁剪后的顶点和索引。
         * @param vertices 顶点数据数组。
         * @param indices 索引数据数组。
         */
        appendVerticesClip(vertices: ArrayLike<number>, indices: ArrayLike<number>): void;
        /**
         * @en Check if the mesh can append more vertices and indices.
         * @param verticesLength Number of vertices to be appended.
         * @param indicesLength Number of indices to be appended.
         * @returns True if the mesh can append, false otherwise.
         * @zh 检查网格是否能够添加更多的顶点和索引。
         * @param verticesLength 要添加的顶点数量。
         * @param indicesLength 要添加的索引数量。
         * @returns 如果网格可以添加则返回 true，否则返回 false。
         */
        canAppend(verticesLength: number, indicesLength: number): boolean;
        /**
         * @en Append vertices to the mesh.
         * @param vertices Array of vertex positions.
         * @param verticesLength Number of vertices to append.
         * @param indices Array of indices.
         * @param indicesLength Number of indices to append.
         * @param finalColor Color to apply to vertices.
         * @param darkColor Color to apply to vertices.
         * @param uvs Array of UV coordinates.
         * @zh 向网格添加顶点。
         * @param vertices 顶点位置数组。
         * @param verticesLength 要添加的顶点数量。
         * @param indices 索引数组。
         * @param indicesLength 要添加的索引数量。
         * @param finalColor 应用于顶点的颜色。
         * @param darkColor 应用于顶点的暗色。
         * @param uvs UV 坐标数组。
         */
        appendVertices(vertices: ArrayLike<number>, verticesLength: number, indices: number[], indicesLength: number, finalColor: spine.Color, darkColor: spine.Color, uvs: ArrayLike<number>): void;
    }
    /**
     * @en SpineWasmVirturalMesh class for handling Spine skeleton mesh rendering using WebAssembly.
     * @zh SpineWasmVirturalMesh 类用于使用 WebAssembly 处理 Spine 骨骼网格渲染。
     */
    class SpineWasmVirturalMesh extends SpineMeshBase {
        private _renderElement2D;
        /**
         * @en Create a SpineWasmVirturalMesh instance.
         * @param material Material to be used for rendering.
         * @zh 创建 SpineWasmVirturalMesh 实例。
         * @param material 用于渲染的材质。
         */
        constructor(material: Material);
        /**
         * @en Destroy the mesh.
         * @zh 销毁网格。
         */
        destroy(): void;
    }
    /**
     * @en Abstract base class for Spine normal rendering.
     * @zh Spine 普通渲染的抽象基类。
     */
    abstract class SpineNormalRenderBase {
        /**
         * @en Array of SpineMeshBase objects.
         * @zh SpineMeshBase 对象数组。
         */
        protected vmeshs: SpineMeshBase[];
        /**
         * @en Index for the next batch.
         * @zh 下一批次的索引。
         */
        protected nextBatchIndex: number;
        /**
         * @en Clears all batches by resetting meshes and batch index.
         * @zh 通过重置网格和批次索引来清除所有批次。
         */
        protected clearBatch(): void;
        /**
         * @en Abstract method to create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @zh 创建具有给定材质的网格的抽象方法。
         * @param material 用于网格的材质。
         */
        abstract createMesh(material: Material): SpineMeshBase;
        /**
         * @en Prepares the next batch for rendering.
         * @param material The material to be used for the batch.
         * @param spineRenderNode The Spine2DRenderNode to be rendered.
         * @zh 准备下一批次用于渲染。
         * @param material 用于批次的材质。
         * @param spineRenderNode 要渲染的 Spine2DRenderNode。
         */
        protected nextBatch(material: Material, spineRenderNode: Spine2DRenderNode): SpineMeshBase;
        /**
         * @en Destroy the render.
         * @zh 销毁渲染。
         */
        destroy(): void;
    }
    /**
     * @en SpineSkeletonRenderer class for rendering Spine skeletons.
     * @zh SpineSkeletonRenderer 类用于渲染 Spine 骨骼。
     */
    class SpineSkeletonRenderer extends SpineNormalRenderBase implements ISpineRender {
        /**
         * @en Indicates if alpha should be premultiplied.
         * @zh 指示是否应预乘 alpha。
         */
        premultipliedAlpha: boolean;
        /**
         * @en Spine templet associated with this renderer.
         * @zh 与此渲染器关联的 Spine 模板。
         */
        templet: SpineTemplet;
        private tempColor;
        private tempColor2;
        private static vertices;
        private renderable;
        private clipper;
        /**
         * @en Create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @returns A SpineMeshBase object.
         * @zh 创建具有给定材质的网格。
         * @param material 用于网格的材质。
         * @returns SpineMeshBase 对象。
         */
        createMesh(material: Material): SpineMeshBase;
        /**
         * @en Create a new instance of the SpineSkeletonRenderer class.
         * @param templet The Spine templet to use.
         * @zh 创建 SpineSkeletonRenderer 类的新实例。
         * @param templet 要使用的 Spine 模板。
         */
        constructor(templet: SpineTemplet);
        /**
         * @en Draw the skeleton.
         * @param skeleton The skeleton to draw.
         * @param renderNode The render node.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制骨骼。
         * @param skeleton 要绘制的骨骼。
         * @param renderNode 渲染节点。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
        /**
         * @param clipper
         * @param slot
         * @param clip
         * @param ofx
         * @param ofy
         * @returns
         */
        clipStart(clipper: spine.SkeletonClipping, slot: spine.Slot, clip: spine.VertexAttachment, ofx: number, ofy: number): any;
        /**
         * @param attachment
         * @param bone
         * @param worldVertices
         * @param offset
         * @param stride
         * @param ofx
         * @param ofy
         */
        private computeWorldVertices_RegionAttachment;
        /**
         * @param attachment
         * @param slot
         * @param start
         * @param count
         * @param worldVertices
         * @param offset
         * @param stride
         * @param ofx
         * @param ofy
         * @returns
         */
        private computeWorldVertices_MeshAttachment;
    }
    /**
     * @en SpineWasmRender class for rendering Spine skeletons using WebAssembly.
     * @zh SpineWasmRender 类用于使用 WebAssembly 渲染 Spine 骨骼。
     */
    class SpineWasmRender extends SpineNormalRenderBase implements ISpineRender {
        /**
         * @en Spine templet associated with this renderer.
         * @zh 与此渲染器关联的 Spine 模板。
         */
        templet: SpineTemplet;
        /**
         * @en Graphics object for rendering.
         * @zh 用于渲染的图形对象。
         */
        graphics: Graphics;
        /**
         * @en Spine render object.
         * @zh Spine 渲染对象。
         */
        spineRender: any;
        /**
         * @en Creates a new SpineWasmRender instance.
         * @param templet The Spine templet to use.
         * @zh 创建 SpineWasmRender 类的新实例。
         * @param templet 要使用的 Spine 模板。
         */
        constructor(templet: SpineTemplet);
        /**
         * @en Create a mesh with the given material.
         * @param material The material to be used for the mesh.
         * @returns A SpineMeshBase object.
         * @zh 创建具有给定材质的网格。
         * @param material 用于网格的材质。
         * @returns SpineMeshBase 对象。
         */
        createMesh(material: Material): SpineMeshBase;
        /**
         * @en Draw the skeleton.
         * @param skeleton The skeleton to draw.
         * @param renderNode The render node.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制骨骼。
         * @param skeleton 要绘制的骨骼。
         * @param renderNode 渲染节点。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        draw(skeleton: spine.Skeleton, renderNode: Spine2DRenderNode, slotRangeStart?: number, slotRangeEnd?: number): void;
    }
    type FrameRenderData = {
        ib?: Uint16Array | Uint32Array | Uint8Array;
        vChanges?: IVBChange[];
        mulitRenderData?: MultiRenderData;
        type?: IndexFormat;
        size?: number;
    };
    type FrameChanges = {
        iChanges?: IChange[];
        vChanges?: IVBChange[];
    };
    /**
     * @en Represents an animation renderer for spine animations.
     * @zh 表示骨骼动画的动画渲染器。
     */
    class AnimationRender {
        /**
         * @en Name of the animation.
         * @zh 动画的名称。
         */
        name: string;
        /**
         * @en Animation Corresponding Frame Change Queue.
         * @zh 动画对应帧变化队列。
         */
        changeMap: Map<number, FrameChanges>;
        /**
         * @en Whether it is a dynamic mesh.
         * @zh 是否为动态网格
         */
        isDynamic: boolean;
        /**
         * @en Array of frame numbers.
         * @zh 帧号数组。
         */
        frames: number[];
        /**
         * @en Total number of frames in the animation.
         * @zh 动画中的总帧数。
         */
        frameNumber: number;
        /**
         * @en Array of skin animation render data.
         * @zh 皮肤动画渲染数据数组。
         */
        skinDataArray: SkinAniRenderData[];
        /**
         * @en Array of bone transforms for each frame.
         * @zh 每帧的骨骼变换数组。
         */
        boneFrames: Float32Array[][];
        /**
         * @en Array of events for each frame.
         * @zh 每帧的事件数组。
         */
        eventsFrames: spine.Event[][];
        /**
         * @en Indicates if the animation is cached.
         * @zh 指示动画是否已缓存。
         */
        isCache: boolean;
        /**
         * @en Creates a Float32Array representing a bone's transform.
         * @param bone The spine bone to get the transform from.
         * @zh 创建表示骨骼变换的Float32Array。
         * @param bone 要获取变换的spine骨骼。
         */
        static getFloat32Array(bone: spine.Bone): Float32Array;
        /** @ignore */
        constructor();
        /**
         * @en Gets the frame index for a given time.
         * @param time The time to get the frame index for.
         * @param frameIndex The current frame index.
         * @zh 获取给定时间的帧索引。
         * @param time 要获取帧索引的时间。
         * @param frameIndex 当前帧索引。
         */
        getFrameIndex(time: number, frameIndex: number): number;
        /**
         * @en Caches bone transforms for the animation.
         * @param preRender The pre-renderer to use for caching.
         * @zh 缓存动画的骨骼变换。
         * @param preRender 用于缓存的预渲染器。
         */
        cacheBones(preRender: SketonOptimise): void;
        /**
         * @en Checks and prepares the animation data.
         * @param animation The spine animation to check.
         * @param preRender The pre-renderer to use.
         * @zh 检查并准备动画数据。
         * @param animation 要检查的spine动画。
         * @param preRender 要使用的预渲染器。
         */
        check(animation: spine.Animation, preRender: SketonOptimise): void;
        /**
         * @en Creates skin animation render data.
         * @param mainVB The main vertex buffer creator.
         * @param mainIB The main index buffer creator.
         * @param tempIbCreate Temp index buffer creator.
         * @param slotAttachMap Map of slot attachments.
         * @param attachMap Array of attachment parses.
         * @param type Animtion Render Type.
         * @returns The created skin animation render data.
         * @zh 创建皮肤动画渲染数据。
         * @param mainVB 主顶点缓冲区创建器。
         * @param mainIB 主索引缓冲区创建器。
         * @param tempIbCreate 临时索引缓冲区创建器。
         * @param slotAttachMap 插槽附件映射。
         * @param attachMap 附件解析数组。
         * @param type 动画渲染类型。
         * @returns 创建的皮肤动画渲染数据。
         */
        createSkinData(mainVB: VBCreator, mainIB: IBCreator, tempIbCreate: IBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>, attachMap: AttachmentParse[], type: ESpineRenderType): SkinAniRenderData;
        destroy(): void;
    }
    /**
     * @en Represents skin animation render data for spine animations.
     * @zh 表示骨骼动画的皮肤动画渲染数据。
     * @blueprintIgnore
     */
    class SkinAniRenderData {
        /** 当前皮肤动画的最大顶点数 */
        maxVertexCount: number;
        /** 当前皮肤动画的最大索引数 */
        maxIndexCount: number;
        isDynamic: boolean;
        /**
         * @en Name of the skin animation.
         * @zh 皮肤动画的名称。
         */
        name: string;
        /**
         * @en Indicates if the skin can be instanced.
         * @zh 指示皮肤是否可以实例化。
         */
        canInstance: boolean;
        /**
         * @en Default Mesh
         * @zh 默认mesh
         */
        _defaultMesh: Mesh2D;
        /**
         * @en Default FrameData
         * @zh 默认帧数据
         */
        _defaultFrameData: FrameRenderData;
        /**
         * @en Vertex buffer creator.
         * @zh 顶点缓冲区创建器。
         */
        vb: VBCreator;
        /**
         * @en Main index buffer creator.
         * @zh 主索引缓冲区创建器。
         */
        mainIB: IBCreator;
        /**
         * @en Animtion Render Type.
         * @zh 动画渲染类型。
         */
        type: ESpineRenderType;
        /**
         * @en Animation Frame Data.
         * @zh 动画帧数据。
         */
        renderDatas: FrameRenderData[];
        /**
         * @en Indicates if normal rendering is required.
         * @zh 指示是否需要正常渲染。
         */
        isNormalRender: boolean;
        /**
         * @en Function to update bone matrices.
         * @zh 更新骨骼矩阵的函数。
         */
        updateBoneMat: (delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array, ofx: number, ofy: number) => void;
        /** @ignore */
        constructor();
        getMesh(): Mesh2D;
        getFrameData(frameIndex: number): FrameRenderData;
        /**
         * @en Updates bone matrices using cached data.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用缓存数据更新骨骼矩阵。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatCache(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array, ofx?: number, ofy?: number): void;
        /**
         * @en Updates bone matrices using cached data and handles events.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用缓存数据更新骨骼矩阵并处理事件。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatCacheEvent(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array): void;
        /**
         * @en Updates bone matrices using individual bone data.
         * @param delta Time delta.
         * @param animation Animation render data.
         * @param bones Spine bones.
         * @param state Spine animation state.
         * @param boneMat Bone matrix array.
         * @zh 使用单个骨骼数据更新骨骼矩阵。
         * @param delta 时间增量。
         * @param animation 动画渲染数据。
         * @param bones 骨骼数组。
         * @param state 骨骼动画状态。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneMatByBone(delta: number, animation: AnimationRender, bones: spine.Bone[], state: spine.AnimationState, boneMat: Float32Array, ofx?: number, ofy?: number): void;
        /**
         * @en Initializes the skin animation render data.
         * @param changeMap Map of frame changes.
         * @param mainVB Main vertex buffer creator.
         * @param ibCreator Main index buffer creator.
         * @param tempCreator Temp index buffer creator.
         * @param frames Array of frame numbers.
         * @param slotAttachMap Map of slot attachments.
         * @param attachMap Array of attachment parses.
         * @param isDynamic Whether it is a dynamic mesh.
         * @zh 初始化皮肤动画渲染数据。
         * @param changeMap 帧变化映射。
         * @param mainVB 主顶点缓冲区创建器。
         * @param ibCreator 主索引缓冲区创建器。
         * @param tempCreator 临时索引缓冲区创建器。
         * @param frames 帧号数组。
         * @param slotAttachMap 插槽附件映射。
         * @param attachMap 附件解析数组。
         * @param isDynamic 是否为动态网格
         */
        init(changeMap: Map<number, FrameChanges>, mainVB: VBCreator, ibCreator: IBCreator, tempCreator: IBCreator, frames: number[], slotAttachMap: Map<number, Map<string, AttachmentParse>>, attachMap: AttachmentParse[], isDynamic: boolean): void;
        /**
         * @en Destroy Render.
         * @zh 销毁当前Render。
         */
        destroy(): void;
    }
    /**
     * @en Animation rendering proxy class for managing animation state and rendering.
     * @zh 动画渲染代理类，用于管理动画状态和渲染。
     */
    class AnimationRenderProxy {
        /**
         * @en The animation state.
         * @zh 动画状态。
         */
        state: spine.AnimationState;
        /**
         * @en The current animation time.
         * @zh 当前动画时间。
         */
        currentTime: number;
        /**
         * @en The current frame index.
         * @zh 当前帧索引。
         */
        currentFrameIndex: number;
        /**
         * @en The animation renderer.
         * @zh 动画渲染器。
         */
        animator: AnimationRender;
        /**
         * @en The current skin animation render data.
         * @zh 当前皮肤动画渲染数据。
         */
        currentSKin: SkinAniRenderData;
        /**
         * @en Creates an instance of AnimationRenderProxy.
         * @param animator The animation renderer.
         * @zh 创建 AnimationRenderProxy 的实例。
         * @param animator 动画渲染器。
         */
        constructor(animator: AnimationRender);
        /**
         * @en Sets the skin index.
         * @param value The skin index to set.
         * @zh 设置皮肤索引。
         * @param value 要设置的皮肤索引。
         */
        set skinIndex(value: number);
        /**
         * @en Gets the name of the animator.
         * @returns The name of the animator.
         * @zh 获取动画器的名称。
         * @returns 动画器的名称。
         */
        get name(): string;
        /**
         * @en Resets the animation state.
         * @zh 重置动画状态。
         */
        reset(): void;
        /**
         * @en Renders the animation without matrix transformation.
         * @param slots The slots to render.
         * @param updator The VB/IB updater.
         * @param curTime The current animation time.
         * @zh 不进行矩阵变换的动画渲染。
         * @param slots 要渲染的插槽。
         * @param updator VB/IB 更新器。
         * @param curTime 当前动画时间。
         */
        renderWithOutMat(slots: spine.Slot[], updator: SkinRenderUpdate, curTime: number): void;
        /**
         * @en Renders the animation with matrix transformation.
         * @param bones The bones to render.
         * @param slots The slots to render.
         * @param updator The VB/IB updater.
         * @param curTime The current animation time.
         * @param boneMat The bone matrix.
         * @param ofx 偏移x。
         * @param ofy 偏移y。
         * @zh 进行矩阵变换的动画渲染。
         * @param bones 要渲染的骨骼。
         * @param slots 要渲染的插槽。
         * @param updator VB/IB 更新器。
         * @param curTime 当前动画时间。
         * @param boneMat 骨骼矩阵。
         * @param ofx 偏移x。
         * @param ofy 偏移y。
         */
        render(bones: spine.Bone[], slots: spine.Slot[], updator: SkinRenderUpdate, curTime: number, boneMat: Float32Array, ofx: number, ofy: number): void;
    }
    /**
     * @en Represents a parser for spine attachments.
     * @zh 表示一个spine附件解析器。
     * @blueprintIgnore
     */
    class AttachmentParse {
        /**
         * @en The ID of the slot.
         * @zh 插槽的ID。
         */
        slotId: number;
        /**
         * @en The name of the attachment.
         * @zh 附件的名称。
         */
        attachment: string;
        /**
         * @en The color of the attachment.
         * @zh 附件的颜色。
         */
        color: TColor;
        lightColor: TColor;
        /** @internal 双顶点色 */
        darkColor: TColor;
        /**
         * @en The blend mode of the attachment.
         * @zh 附件的混合模式。
         */
        blendMode: number;
        /**
         * @en The vertex array of the attachment.
         * @zh 附件的顶点数组。
         */
        vertexArray: Float32Array;
        /**
         * @en The index array of the attachment.
         * @zh 附件的索引数组。
         */
        indexArray: Array<number>;
        /**
         * @en The UV coordinates of the attachment.
         * @zh 附件的UV坐标。
         */
        uvs: spine.ArrayLike<number>;
        /**
         * @en The stride of the vertex data.
         * @zh 顶点数据的步长。
         */
        stride: number;
        /**
         * @en The index of the bone.
         * @zh 骨骼的索引。
         */
        boneIndex: number;
        /**
         * @en The name of the texture.
         * @zh 纹理的名称。
         */
        textureName: string;
        /**
         * @en Indicates if the attachment is a clipping attachment.
         * @zh 指示附件是否为裁剪附件。
         */
        isClip: boolean;
        /**
         * @en the attachment is a path attachment.
         * @zh 是否为路径解析器
         */
        isPath: boolean;
        /**
         * @en The source data of the attachment.
         * @zh 附件的源数据。
         */
        sourceData: spine.Attachment;
        /**
         * @en The number of vertices in the attachment.
         * @zh 附件中的顶点数量。
         */
        vertexCount: number;
        /**
         * @en The number of indices in the attachment.
         * @zh 附件中的索引数量。
         */
        indexCount: number;
        /**
         * @en Indicates if normal rendering is required.
         * @zh 指示是否需要正常渲染。
         */
        isNormalRender: boolean;
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /**
         * @en The bones that affect a vertex.
         * @zh 影响一个顶点的骨骼。
         */
        bones: Set<number>;
        /**
         * @en Initializes the attachment parser with the given parameters.
         * @param attachment The spine attachment to parse.
         * @param boneIndex The index of the bone.
         * @param slotId The ID of the slot.
         * @param deform The deformation array.
         * @param slot The slot data.
         * @zh 使用给定的参数初始化附件解析器。
         * @param attachment 要解析的spine附件。
         * @param boneIndex 骨骼的索引。
         * @param slotId 插槽的ID。
         * @param deform 变形数组。
         * @param slot 插槽数据。
         */
        init(attachment: spine.Attachment, boneIndex: number, slotId: number, deform: number[], slot: spine.SlotData): boolean;
    }
    type TColor = {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    /**
     * @en Represents a change in deformation for a slot in a spine animation.
     * @zh 表示骨骼动画中一个插槽的变形变化。
     */
    class ChangeDeform implements IVBChange {
        /**
         * @en The ID of the slot affected by this deformation change.
         * @zh 受此变形变化影响的插槽ID。
         */
        slotId: number;
        /**
         * @en Map storing the attachment positions for the slot.
         * @zh 存储插槽附件位置的映射。
         */
        sizeMap: Map<string, TAttamentPos>;
        /**
         * @en The start frame of this Change.
         * @zh 变化的起始帧。
         */
        startFrame: number;
        /**
         * @en The end frame of this Change.
         * @zh 变化的结束帧。
         */
        endFrame: number;
        private _lastFrame;
        /** @ignore */
        constructor();
        apply(frame: number, vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Initializes the change with the given VBCreator.
         * @param vb The VBCreator to initialize with.
         * @returns True if initialization is successful, false otherwise.
         * @zh 使用给定的VBCreator初始化变化。
         * @param vb 用于初始化的VBCreator。
         * @returns 如果初始化成功则返回true，否则返回false。
         */
        initChange(vb: VBCreator): boolean;
        /**
         * @en Updates the vertex buffer based on the deformation change.
         * @param vb The VBCreator to update.
         * @param slots Array of spine slots.
         * @returns True if the update is successful, false otherwise.
         * @zh 根据变形变化更新顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slots 骨骼插槽数组。
         * @returns 如果更新成功则返回true，否则返回false。
         */
        updateVB(vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Creates a clone of this ChangeDeform instance.
         * @returns A new IVBChange instance with the same properties as this one.
         * @zh 创建此ChangeDeform实例的克隆。
         * @returns 具有与此实例相同属性的新IVBChange实例。
         */
        clone(): IVBChange;
    }
    /**
     * @en Represents a change in draw order for spine animation.
     * @zh 表示骨骼动画中绘制顺序的变化。
     */
    class ChangeDrawOrder implements IChange {
        /**
         * @en The new draw order for slots.
         * @zh 插槽的绘制顺序。
         */
        order: number[];
        /**
         * @en Changes the draw order of attachments.
         * @param attachMap An array of AttachmentParse objects.
         * @returns The new draw order as an array of numbers, or null if no change is needed.
         * @zh 更改附件的绘制顺序。
         * @param attachMap AttachmentParse对象的数组。
         * @returns 新的绘制顺序（数字数组），如果不需要更改则返回null。
         */
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
        /**
         * @en Applies the draw order change to the vertex buffer.
         * @param vb The VBCreator to update.
         * @param slotAttachMap A map of slot IDs to their attachment maps.
         * @zh 将绘制顺序变化应用到顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slotAttachMap 插槽ID到其附件映射的Map。
         */
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
    }
    /**
     * @en Represents a change in RGBA color for a slot in a spine animation.
     * @zh 表示骨骼动画中一个插槽的RGBA颜色变化。
     */
    class ChangeRGBA implements IVBChange {
        /**
         * @en The ID of the slot affected by this color change.
         * @zh 受此颜色变化影响的插槽ID。
         */
        slotId: number;
        /**
         * @en Map storing the attachment positions for the slot.
         * @zh 存储插槽附件位置的映射。
         */
        sizeMap: Map<string, TAttamentPos>;
        /**
         * @en The start frame of this Change.
         * @zh 变化的起始帧。
         */
        startFrame: number;
        /**
         * @en The end frame of this Change.
         * @zh 变化的结束帧。
         */
        endFrame: number;
        /**
         * @en Creates a new instance of ChangeRGBA.
         * @param slotId The ID of the slot to change.
         * @zh 创建ChangeRGBA的新实例。
         * @param slotId 要更改的插槽ID。
         */
        constructor(slotId: number);
        apply(frame: number, vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Initializes the change with the given VBCreator.
         * @param vb The VBCreator to initialize with.
         * @returns True if initialization is successful, false otherwise.
         * @zh 使用给定的VBCreator初始化变化。
         * @param vb 用于初始化的VBCreator。
         * @returns 如果初始化成功则返回true，否则返回false。
         */
        initChange(vb: VBCreator): boolean;
        /**
         * @en Updates the vertex buffer with new RGBA values.
         * @param vb The VBCreator to update.
         * @param slots Array of spine slots.
         * @returns True if the update is successful, false otherwise.
         * @zh 使用新的RGBA值更新顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slots 骨骼插槽数组。
         * @returns 如果更新成功则返回true，否则返回false。
         */
        updateVB(vb: VBCreator, slots: spine.Slot[]): boolean;
        /**
         * @en Creates a clone of this ChangeRGBA instance.
         * @returns A new IVBChange instance with the same slot ID.
         * @zh 创建此ChangeRGBA实例的克隆。
         * @returns 具有相同插槽ID的新IVBChange实例。
         */
        clone(): IVBChange;
    }
    /**
     * @en Represents a change in slot attachment for a spine animation.
     * @zh 表示骨骼动画中插槽附件的变化。
     */
    class ChangeSlot implements IChange {
        /**
         * @en The ID of the slot to change.
         * @zh 要更改的插槽ID。
         */
        slotId: number;
        /**
         * @en The name of the new attachment.
         * @zh 新附件的名称。
         */
        attachment: string;
        /**
         * @en The parsed attachment data.
         * @zh 解析后的附件数据。
         */
        attachmentParse: AttachmentParse;
        /**
         * @en Applies the slot change to the vertex buffer.
         * @param vb The VBCreator to update.
         * @param slotAttachMap A map of slot IDs to their attachment maps.
         * @zh 将插槽变化应用到顶点缓冲区。
         * @param vb 要更新的VBCreator。
         * @param slotAttachMap 插槽ID到其附件映射的Map。
         */
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
        /**
         * @en Updates the attachment map with the new attachment.
         * @param attachMap An array of AttachmentParse objects.
         * @zh 使用新附件更新附件映射。
         * @param attachMap AttachmentParse对象的数组。
         */
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
    }
    /**
     * @en Creator class for index buffer (IB) in spine rendering.
     * @zh Spine渲染中用于创建索引缓冲区（IB）的类。
     * @blueprintIgnore
     */
    class IBCreator {
        /**
         * @en The index type.
         * @zh 索引类型。
         */
        type: IndexFormat;
        /**
         * @en The byte count of the index type.
         * @zh 索引类型字节数量。
         */
        size: number;
        /**
         * @en The index buffer array.
         * @zh 索引缓冲区数组。
         */
        ib: Uint16Array | Uint32Array | Uint8Array;
        /**
         * @en The actual length of the index buffer.
         * @zh 索引缓冲区的实际长度。
         */
        ibLength: number;
        /**
         * @en The Max length of the index buffer.
         * @zh 索引缓冲区的最大长度。
         */
        maxIndexCount: number;
        /**
         * @en The output render data for multiple renders.
         * @zh 用于多重渲染的输出渲染数据。
         */
        outRenderData: MultiRenderData;
        /** @ignore */
        constructor();
        /**
         *
         * @zh 根据顶点长度设置索引类型
         * @param vertexCount 顶点数目
         */
        updateFormat(vertexCount: number): void;
        /**
         * @en set index buffer length.
         * @param maxIndexCount The Max length of Index count.
         * @zh 设置索引缓冲长度。
         * @param maxIndexCount 索引最大个数。
         */
        setBufferLength(maxIndexCount: number): void;
        private _updateBuffer;
        /**
         * @en Create index buffer for attachments.
         * @param attachs Array of attachment parse data.
         * @param vbCreator Vertex buffer creator.
         * @param order Optional draw order array.
         * @zh 为附件创建索引缓冲区。
         * @param attachs 附件解析数据数组。
         * @param vbCreator 顶点缓冲区创建器。
         * @param order 可选的绘制顺序数组。
         */
        createIB(attachs: AttachmentParse[], vbCreator: VBCreator, order?: number[]): void;
    }
    interface IChange {
        change(vb: VBCreator, slotAttachMap: Map<number, Map<string, AttachmentParse>>): boolean;
        changeOrder(attachMap: AttachmentParse[]): number[] | null;
    }
    interface IGetBone {
        getBoneId(boneIndex: number): number;
    }
    /**
     * @blueprintIgnore
     */
    interface ISpineOptimizeRender {
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: BaseRenderNode2D, state: spine.AnimationState): void;
        play(animationName: string): void;
        render(time: number): void;
        setSkinIndex(index: number): void;
        initBake(obj: TSpineBakeData): void;
        changeSkeleton(skeleton: spine.Skeleton): void;
        getSpineColor(): Color;
        complete(): void;
        destroy(): void;
    }
    interface IVBChange {
        slotId: number;
        startFrame: number;
        endFrame: number;
        apply(frame: number, vb: VBCreator, slots: spine.Slot[]): boolean;
        initChange(vb: VBCreator): boolean;
        clone(): IVBChange;
    }
    type RenderData = {
        attachment: string;
        material?: Material;
        textureName: string;
        blendMode: number;
        offset: number;
        length: number;
    };
    /**
     * @en Represents a collection of multiple render data.
     * @zh 表示多个渲染数据的集合。
     */
    class MultiRenderData {
        /**
         * @en Unique identifier for MultiRenderData instances.
         * @zh MultiRenderData 实例的唯一标识符。
         */
        static ID: number;
        id: number;
        /**
         * @en Render data array.
         * @zh 渲染数据数组。
         */
        renderData: RenderData[];
        /**
         * @en The current RenderData being processed.
         * @zh 当前正在处理的 RenderData。
         */
        currentData: RenderData;
        /** @ignore */
        constructor();
        /**
         * @en Adds new render data to the collection.
         * @param textureName The name of the texture.
         * @param blendMode The blend mode for rendering.
         * @param offset The starting offset in the vertex buffer.
         * @param length The initial length of data.
         * @zh 向集合中添加新的渲染数据。
         * @param textureName 纹理的名称。
         * @param blendMode 渲染的混合模式。
         * @param offset 顶点缓冲区中的起始偏移量。
         * @param length 数据的初始长度。
         */
        addData(textureName: string, blendMode: number, offset: number, length: number, attachment: string): void;
        /**
         * @en Finalizes the current render data by updating its length.
         * @param length The final length of the data.
         * @zh 通过更新长度来完成当前渲染数据的处理。
         * @param length 数据的最终长度。
         */
        endData(length: number): void;
    }
    /**
     * @en SketonOptimise class used for skeleton optimization.
     * @zh SketonOptimise 类用于骨骼优化。
     */
    class SketonOptimise {
        /**
         * @en Switch for normal rendering mode.
         * @zh 普通渲染模式的开关。
         */
        static normalRenderSwitch: boolean;
        /** optimise render的最大骨骼数 */
        static MAX_BONES: number;
        /**
         * @en Switch for caching mode.
         * @zh 缓存模式的开关。
         */
        static cacheSwitch: boolean;
        /**
         * @en Indicates whether caching is possible.
         * @zh 表示是否可以缓存。
         */
        canCache: boolean;
        /**
         * @en The spine skeleton object.
         * @zh spine骨骼对象。
         */
        sketon: spine.Skeleton;
        _stateData: spine.AnimationStateData;
        _state: spine.AnimationState;
        /**
         * @en Map of blend modes.
         * @zh 混合模式的映射。
         */
        blendModeMap: Map<number, number>;
        /**
         * @en Array of animation renderers.
         * @zh 动画渲染器数组。
         */
        animators: AnimationRender[];
        /**
         * @en Array of skin attachments.
         * @zh 皮肤附件数组。
         */
        skinAttachArray: SkinAttach[];
        /**
         * @en Default skin attachment.
         * @zh 默认皮肤附件。
         */
        defaultSkinAttach: SkinAttach;
        private _tempIbCreate;
        /**
         * @en Maximum number of bones.
         * @zh 最大骨骼数量。
         */
        maxBoneNumber: number;
        /**
         * @en Baked spine data.
         * @zh 烘焙的spine数据。
         */
        bakeData: TSpineBakeData;
        /** @ignore */
        constructor();
        /** @internal */
        _initSpineRender(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode, state: spine.AnimationState): ISpineOptimizeRender;
        /** @internal */
        _updateState(delta: number): spine.Bone[];
        /** @internal */
        _play(animationName: string): number;
        /**
         * @en Check and initialize the main attachment.
         * @param skeletonData The skeleton data to check.
         * @zh 检查并初始化主附件。
         * @param skeletonData 要检查的骨骼数据。
         */
        checkMainAttach(skeletonData: spine.SkeletonData): void;
        /**
         * @en Parse attachments from skeleton data.
         * @param skeletonData The skeleton data to parse.
         * @zh 从骨骼数据解析附件。
         * @param skeletonData 要解析的骨骼数据。
         */
        attachMentParse(skeletonData: spine.SkeletonData): void;
        /**
         * @en Initialize animations from the skeleton data.
         * @param animations Array of animations to initialize.
         * @zh 从骨骼数据初始化动画。
         * @param animations 要初始化的动画数组。
         */
        initAnimation(animations: spine.Animation[]): void;
        /**
         * @en Cache bone data for optimization.
         * @zh 缓存骨骼数据以进行优化。
         */
        cacheBone(): void;
        destroy(): void;
        /**
         * @en Initialize the skeleton with given slots.
         * @param slots Array of spine slots.
         * @zh 使用给定的插槽初始化骨骼。
         * @param slots spine插槽数组。
         */
        init(slots: spine.Slot[]): void;
    }
    /**
     * @en SkinAttach class represents skin attachment.
     * @zh SkinAttach类表示皮肤附件。
     */
    class SkinAttach {
        /**
         * @en Name of the skin attachment.
         * @zh 皮肤附件的名称。
         */
        name: string;
        /**
         * @en Attachments for each slot
         * @zh 每个插槽的附件。
         */
        slotAttachMap: Map<number, Map<string, AttachmentParse>>;
        /**
         * @en Order of main attachments.
         * @zh 主要附件的顺序。
         */
        mainAttachMentOrder: AttachmentParse[];
        /**
         * @en Indicates if normal rendering is used.
         * @zh 表示是否使用普通渲染。
         */
        isNormalRender: boolean;
        /**
         * @en Main vertex buffer creator.
         * @zh 主顶点缓冲区创建器。
         */
        mainVB: VBCreator;
        /**
         * @en Main index buffer creator.
         * @zh 主索引缓冲区创建器。
         */
        mainIB: IBCreator;
        /**
         * @en Used for constructing temp Mesh2D
         * @zh 用于构建临时Mesh2D
         */
        _tempIbCreate: IBCreator;
        /**
         * @en Indicates if there's any normal rendering.
         * @zh 表示是否存在任何普通渲染。
         */
        hasNormalRender: boolean;
        /**
         * @en Type of spine rendering.
         * @zh spine渲染的类型。
         */
        type: ESpineRenderType;
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /**
         * @en The index of the rigid body bone.
         * @zh 刚体骨骼的索引。
         */
        rbBoneIndex: number;
        /** @ignore */
        constructor();
        /**
         * @en Copy data from another SkinAttach.
         * @param other The SkinAttach to copy from.
         * @zh 从另一个SkinAttach复制数据。
         * @param other 要复制的SkinAttach。
         */
        copyFrom(other: SkinAttach): void;
        /**
         * @en Parse attachments from skin data.
         * @param skinData The spine skin data.
         * @param slots Array of spine slot data.
         * @zh 从皮肤数据解析附件。
         * @param skinData spine皮肤数据。
         * @param slots spine插槽数据数组。
         */
        attachMentParse(skinData: spine.Skin, slots: spine.SlotData[]): void;
        /**
         * @en Initialize the skin attachment.
         * @param slots Array of spine slot data.
         * @zh 初始化皮肤附件。
         * @param slots spine插槽数据数组。
         */
        init(slots: spine.SlotData[]): void;
        /**
         * @en Initialize an animator with this skin attachment.
         * @param animator The animation renderer to initialize.
         * @zh 使用此皮肤附件初始化动画器。
         * @param animator 要初始化的动画渲染器。
         */
        initAnimator(animator: AnimationRender): void;
    }
    type TSpineBakeData = {
        bonesNums: number;
        aniOffsetMap: {
            [key: string]: number;
        };
        texture2d?: Texture2D;
        simpPath?: string;
    };
    type SketonDynamicInfo = {
        /** 所有皮肤动画的最大顶点数 */
        maxVertexCount: number;
        /** 所有皮肤动画的最大索引数 */
        maxIndexCount: number;
    };
    /**
     * @en SkinRenderUpdate used for rendering Spine skins.
     * @zh SkinRenderUpdate 类用于渲染 Spine 皮肤。
     */
    class SkinRenderUpdate {
        /**
         * @en The owner of this SkinRender.
         * @zh 此 SkinRender 的所有者。
         */
        owner: SpineOptimizeRender;
        /**
         * @en The name of the skin.
         * @zh 皮肤的名称。
         */
        name: string;
        private hasNormalRender;
        /** @internal */
        _renderer: ISpineRender;
        /**
         * @en The Spine template.
         * @zh Spine 模板。
         */
        templet: SpineTemplet;
        /**
         * @en The type of skin attachment.
         * @zh 皮肤附件的类型。
         */
        skinAttachType: ESpineRenderType;
        /**
         * @en Array of current materials.
         * @zh 当前材质数组。
         */
        currentMaterials: Material[];
        /**
         * @en An array to cache materials for different render states.
         * Each inner array represents a set of materials for a specific render state.
         * @zh 用于缓存不同渲染状态的材质数组。
         * 每个内部数组代表一个特定渲染状态的材质集合。
         */
        cacheMaterials: Material[][];
        vChanges: IVBChange[];
        /**
         * @en The number of bones that affect a vertex.
         * @zh 影响一个顶点的最大骨骼数。
         */
        vertexBones: number;
        /**
         * @en The index of the rigid body bone.
         * @zh 刚体骨骼的索引。
         */
        rbBoneIndex: number;
        /**
         * @en Create a new instance of SkinRender.
         * @param owner The SpineOptimizeRender that owns this SkinRender.
         * @param skinAttach The SkinAttach data.
         * @zh 创建 SkinRender 的新实例。
         * @param owner 拥有此 SkinRender 的 SpineOptimizeRender。
         * @param skinAttach SkinAttach 数据。
         */
        constructor(owner: SpineOptimizeRender, skinAttach: SkinAttach);
        /**
         * @en Get material by name and blend mode.
         * @param name The name of the texture.
         * @param blendMode The blend mode.
         * @zh 通过名称和混合模式获取材质。
         * @param name 纹理的名称。
         * @param blendMode 混合模式。
         */
        getMaterialByName(name: string, blendMode: number): Material;
        /**
         * 渲染更新
         * @param skindata 动画渲染数据
         * @param frame 当前帧
         * @param lastFrame 上一帧
         */
        renderUpdate(skindata: SkinAniRenderData, frame: number, lastFrame: number): void;
        private updateDynamicRender;
        private handleRender;
        private createMaterials;
        /**
         * @en Submit IndexData.
         * @param frameData Frame rendering data.
         * @param mesh Mesh2D object.
         * @zh 提交索引数据。
         * @param frameData 帧渲染数据。
         * @param mesh 网格对象。
         */
        uploadIndexBuffer(frameData: FrameRenderData, mesh: Mesh2D): void;
        /**
         * @en Submit vertex data.
         * @param vbCreator Vertex buffer creator object.
         * @param mesh Mesh2D object.
         * @zh 提交顶点数据。
         * @param vbCreator 构建顶点缓冲区对象。
         * @param mesh 网格对象。
         */
        uploadVertexBuffer(vbCreator: VBCreator, mesh: Mesh2D): void;
        /**
         * @en Initialize renderer
         * @param skeleton spine.skeleton instance
         * @param templet Engine spine animation template
         * @param renderNode Rendering component
         * @zh 初始化渲染器
         * @param skeleton spine.skeleton 实例
         * @param templet 引擎spine动画模板
         * @param renderNode 渲染组件
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode): void;
        /**
         * @en Render the skin at a specific time.
         * @param time The time to render at.
         * @zh 在特定时间渲染皮肤。
         * @param time 要渲染的时间。
         */
        render(time: number): void;
        private _resetVertexBuffset;
        /**
         * @en Destroy the SkinRenderUpdate instance.
         * @zh 销毁 SkinRenderUpdate 实例。
         */
        destroy(): void;
    }
    /**
     * @en Utility class for Spine slot operations.
     * @zh Spine 插槽操作的实用工具类。
     */
    class SlotUtils {
        /**
         * @en Check the type of attachment and determine the appropriate render type.
         * @param attachment The spine attachment to check.
         * @zh 检查附件的类型并确定适当的渲染类型。
         * @param attachment 要检查的 Spine 附件。
         */
        static checkAttachment(attachment: spine.Attachment): ESpineRenderType;
        /**
         * @en Append index array from attachment parse to the target index array.
         * @param attachmentParse The attachment parse containing the source index array.
         * @param indexArray The target index array to append to.
         * @param size The size to offset each index by.
         * @param offset The starting offset in the target index array.
         * @zh 将附件解析中的索引数组追加到目标索引数组。
         * @param attachmentParse 包含源索引数组的附件解析。
         * @param indexArray 要追加到的目标索引数组。
         * @param size 每个索引的偏移量。
         * @param offset 目标索引数组中的起始偏移量。
         */
        static appendIndexArray(attachmentParse: AttachmentParse, indexArray: Uint16Array | Uint8Array | Uint32Array, size: number, offset: number): number;
    }
    /**
     * @en Script class for baking Spine animations.
     * @zh 用于烘焙 Spine 动画的脚本类。
     */
    class SpineBakeScript extends Script {
        /**
         * @en URL of the data.
         * @zh 数据的地址。
         */
        url: string;
        /**
         * @en Bake data in string format.
         * @zh 字符串格式的烘焙数据。
         */
        bakeData: string;
        /** @ignore */
        constructor();
        /**
         * @en Called when the script is enabled.
         * @zh 当脚本被启用时调用。
         */
        onEnable(): void;
        /**
         * @en Called when the script is disabled.
         * @zh 当脚本被禁用时调用。
         */
        onDisable(): void;
        /**
         * @en Attaches bake data to the spine renderer.
         * @param spine The spine optimizer renderer interface.
         * @zh 将烘焙数据附加到 Spine 渲染器。
         * @param spine Spine 优化渲染器接口。
         */
        attach(spine: ISpineOptimizeRender): Promise<void>;
        private initBake;
    }
    /**
     * @en Empty implementation of the renderer for optimizing Spine animations.
     * @zh 空实现的渲染器，用于优化 Spine 动画的渲染。
     */
    class SpineEmptyRender implements ISpineOptimizeRender {
        getSpineColor(): Color;
        /**
         * @en Changes the skeleton.
         * @param skeleton The new spine skeleton.
         * @zh 更改骨骼。
         * @param skeleton 新的 Spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Singleton instance of SpineEmptyRender.
         * @zh SpineEmptyRender 的单例实例。
         */
        static instance: SpineEmptyRender;
        /**
         * @en Initializes the renderer.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The base render node.
         * @param state The spine animation state.
         * @zh 初始化渲染器。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode 基础渲染节点。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: BaseRenderNode2D, state: spine.AnimationState): void;
        /**
         * @en Plays the specified animation.
         * @param animationName The name of the animation to play.
         * @zh 播放指定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        /**
         * @en Renders the spine animation.
         * @param time The current time for rendering.
         * @zh 渲染 Spine 动画。
         * @param time 当前渲染时间。
         */
        render(time: number): void;
        /**
         * @en Sets the skin index.
         * @param index The index of the skin to set.
         * @zh 设置皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        /**
         * @en Initializes bake data.
         * @param obj The spine bake data.
         * @zh 初始化烘焙数据。
         * @param obj Spine 烘焙数据。
         */
        initBake(obj: TSpineBakeData): void;
        /**
         * @en Destroys the renderer.
         * @zh 销毁渲染器。
         */
        destroy(): void;
        /**
         * @en Completes the animation.
         * @zh 完成动画。
         */
        complete(): void;
    }
    /**
     * @en SpineInstanceBatch used for efficient rendering Spine instances.
     * @zh SpineInstanceBatch 用于高效渲染 Spine 实例。
     */
    class SpineInstanceBatch {
        /**
         * @en The instance of SpineInstanceBatch.
         * @zh SpineInstanceBatch 的实例。
         */
        static instance: SpineInstanceBatch;
        _recoverList: FastSinglelist<SpineInstanceInfo>;
        /**
         * @en Check if two render elements can be merged.
         * @param left The left render element to compare.
         * @param right The right render element to compare.
         * @returns True if the elements can be merged, false otherwise.
         * @zh 检测两个渲染元素是否可以合并。
         * @param left 要比较的左侧渲染元素。
         * @param right 要比较的右侧渲染元素。
         * @returns 如果元素可以合并则返回 true，否则返回 false。
         */
        check(left: IRenderElement2D, right: IRenderElement2D): boolean;
        /**
         * @en Batch render elements.
         * @param list The list of render elements.
         * @param start The starting index in the list.
         * @param length The number of elements to process.
         * @zh 批量渲染元素。
         * @param list 渲染元素列表。
         * @param start 列表中的起始索引。
         * @param length 要处理的元素数量。
         */
        batchRenderElement(list: FastSinglelist<IRenderElement2D>, start: number, length: number, elementCount?: number): void;
        /**
         * @en Update the instance buffer with new data.
         * @param info The SpineInstanceInfo object.
         * @param nMatrixData The new matrix data.
         * @param simpleAnimatorData The new animator data.
         * @param instanceCount The number of instances.
         * @zh 使用新数据更新实例缓冲区。
         * @param info SpineInstanceInfo 对象。
         * @param nMatrixData 新的矩阵数据。
         * @param simpleAnimatorData 新的动画器数据。
         * @param instanceCount 实例数量。
         */
        updateBuffer(info: SpineInstanceInfo, nMatrixData: Float32Array, simpleAnimatorData: Float32Array, instanceCount: number): void;
        /**
         * @en Organize instance data for batching.
         * @param list The list of render elements.
         * @param start The starting index in the list.
         * @param length The number of elements to process.
         * @zh 组织实例数据以进行批处理。
         * @param list 渲染元素列表。
         * @param start 列表中的起始索引。
         * @param length 要处理的元素数量。
         */
        batch(list: FastSinglelist<IRenderElement2D>, start: number, length: number): void;
        /**
         * @en Recover instance data.
         * @zh 回收实例数据。
         */
        recover(): void;
    }
    interface SpineInstanceInfo {
        element: IRenderElement2D;
        source: IRenderGeometryElement;
        state: IBufferState;
        nMatrixInstanceVB?: IVertexBuffer;
        simpleAnimatorVB?: IVertexBuffer;
    }
    /**
     * @en Tool class for managing Spine instance elements in 2D rendering.
     * @zh 用于管理 2D 渲染中的 Spine 实例元素的工具类。
     */
    class SpineInstanceElement2DTool {
        /**
         * @en Maximum number of instances that can be batched.
         * @zh 可以批处理的最大实例数量。
         */
        static MaxInstanceCount: number;
        /**
         * get Instance BufferState
         */
        private static _instanceBufferInfoMap;
        /**
         * @en Get or create a SpineInstanceInfo for a given geometry.
         * @param geometry The render geometry element.
         * @zh 获取或创建给定几何体的 SpineInstanceInfo。
         * @param geometry 渲染几何体元素。
         */
        static getInstanceInfo(geometry: IRenderGeometryElement): SpineInstanceInfo;
        /**
         * @en Create a new SpineInstanceInfo for a given geometry.
         * @param geometry The render geometry element.
         * @zh 为给定的几何体创建一个新的 SpineInstanceInfo。
         * @param geometry 渲染几何体元素。
         */
        static createInstanceInfo(geometry: IRenderGeometryElement): SpineInstanceInfo;
        /**
         * @en Recover a SpineInstanceInfo object.
         * @param info The SpineInstanceInfo to recover.
         * @zh 回收一个 SpineInstanceInfo 对象。
         * @param info 要回收的 SpineInstanceInfo。
         */
        static recover(info: SpineInstanceInfo): void;
        /**
         * pool of Buffer
         */
        private static _bufferPool;
        static _instanceBufferCreate(length: number): Float32Array;
        static _instanceBufferRecover(float32: Float32Array): void;
    }
    /**
     * @en Class for normal Spine rendering implementation.
     * @zh 普通 Spine 渲染实现类。
     */
    class SpineNormalRender implements ISpineOptimizeRender {
        getSpineColor(): Color;
        /**
         * @en Destroys the renderer.
         * @zh 销毁渲染器。
         */
        destroy(): void;
        /**
         * @en Initializes bake data.
         * @param obj The spine bake data.
         * @zh 初始化烘焙数据。
         * @param obj Spine 烘焙数据。
         */
        initBake(obj: TSpineBakeData): void;
        /** @internal */
        _owner: Spine2DRenderNode;
        /** @internal */
        _renderer: ISpineRender;
        /** @internal */
        _skeleton: spine.Skeleton;
        /**@internal */
        _spineColor: Color;
        /** @internal */
        _skinIndex: number;
        /**
         * @en Initializes the renderer.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The Spine2DRenderNode.
         * @param state The spine animation state.
         * @zh 初始化渲染器。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode Spine2DRenderNode。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode, state: spine.AnimationState): void;
        /**
         * @en Plays the specified animation.
         * @param animationName The name of the animation to play.
         * @zh 播放指定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        /**
         * @en Sets the skin index.
         * @param index The index of the skin to set.
         * @zh 设置皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        /**
         * @en Changes the skeleton.
         * @param skeleton The new spine skeleton.
         * @zh 更改骨骼。
         * @param skeleton 新的 Spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Renders the spine animation.
         * @param time The current time for rendering.
         * @zh 渲染 Spine 动画。
         * @param time 当前渲染时间。
         */
        render(time: number): void;
        /**
         * @en Completes the animation.
         * @zh 完成动画。
         */
        complete(): void;
    }
    /**
     * @en Constants used in Spine optimization.
     * @zh Spine 优化中使用的常量。
     */
    class SpineOptimizeConst {
        /**
         * @en The number of vertices for a bone in the optimized Spine rendering.
         * @zh 优化后的 Spine 渲染中，一个骨骼的顶点数。
         */
        static BONEVERTEX: number;
        /**
         * @en The number of vertices for a rigid body in the optimized Spine rendering.
         * @zh 优化后的 Spine 渲染中，一个刚体的顶点数。
         */
        static RIGIDBODYVERTEX: number;
    }
    enum ERenderProxyType {
        RenderNormal = 0,
        RenderRigidBody = 1,
        RenderOptimize = 2,
        RenderBake = 3
    }
    /**
     * @en SpineOptimizeRender used for optimized rendering of Spine animations.
     * @zh SpineOptimizeRender 类用于优化 Spine 动画的渲染。
     */
    class SpineOptimizeRender implements ISpineOptimizeRender {
        /**
         * @en Map of animation names to AnimationRenderProxy objects.
         * @zh 动画名称到 AnimationRenderProxy 对象的映射。
         */
        animatorMap: Map<string, AnimationRenderProxy>;
        /**
         * @en Current animation being rendered.
         * @zh 当前正在渲染的动画。
         */
        currentAnimation: AnimationRenderProxy;
        /**
         * @en Array of SkinRender objects.
         * @zh SkinRender 对象数组。
         */
        skinRenderArray: SkinRenderUpdate[];
        /**
         * @en Current SkinRender being used.
         * @zh 当前使用的 SkinRender。
         */
        currentRender: SkinRenderUpdate;
        /** @internal */
        _skinIndex: number;
        /** @internal */
        _curAnimationName: string;
        /** @internal */
        _dynamicMap: Map<number, Mesh2D>;
        /**
         * @en Color of the Spine object.
         * @zh Spine 对象的颜色。
         */
        spineColor: Color;
        /** @internal */
        _skeleton: spine.Skeleton;
        /** @internal */
        _state: spine.AnimationState;
        /**
         * @en Current render proxy.
         * @zh 当前渲染代理。
         */
        renderProxy: IRender;
        /**
         * @en Map of ERenderProxyType to IRender objects.
         * @zh ERenderProxyType 到 IRender 对象的映射。
         */
        renderProxyMap: Map<ERenderProxyType, IRender>;
        /** @internal */
        _nodeOwner: Spine2DRenderNode;
        /**
         * @en Float32Array for bone matrices.
         * @zh 用于骨骼矩阵的 Float32Array。
         */
        boneMat: Float32Array;
        /**
         * @en Indicates if the animation is baked.
         * @zh 指示动画是否被烘焙。
         */
        isBake: boolean;
        /**
         * @en Bake data for the Spine animation.
         * @zh Spine 动画的烘焙数据。
         */
        bakeData: TSpineBakeData;
        private _renderProxytype;
        /**
         * @en Create a new SpineOptimizeRender instance.
         * @param spineOptimize SketonOptimise object containing optimization data.
         * @zh 创建 SpineOptimizeRender 的新实例。
         * @param spineOptimize 包含优化数据的 SketonOptimise 对象。
         */
        constructor(spineOptimize: SketonOptimise);
        getSpineColor(): Color;
        /**
         * @en Destroy the SpineOptimizeRender instance.
         * @zh 销毁 SpineOptimizeRender 实例。
         */
        destroy(): void;
        /**
         * @en Initialize bake data for the Spine animation.
         * @param obj Bake data object.
         * @zh 初始化 Spine 动画的烘焙数据。
         * @param obj 烘焙数据对象。
         */
        initBake(obj: TSpineBakeData): void;
        /**
         * @en Change the current skeleton.
         * @param skeleton The new spine skeleton to use.
         * @zh 更改当前骨骼。
         * @param skeleton 要使用的新 spine 骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Initialize the SpineOptimizeRender with necessary components.
         * @param skeleton The spine skeleton.
         * @param templet The spine templet.
         * @param renderNode The Spine2DRenderNode.
         * @param state The spine animation state.
         * @zh 使用必要的组件初始化 SpineOptimizeRender。
         * @param skeleton Spine 骨骼。
         * @param templet Spine 模板。
         * @param renderNode Spine2DRenderNode。
         * @param state Spine 动画状态。
         */
        init(skeleton: spine.Skeleton, templet: SpineTemplet, renderNode: Spine2DRenderNode, state: spine.AnimationState): void;
        /**
         * @en The current render proxy type.
         * @zh 当前渲染代理类型。
         */
        get renderProxytype(): ERenderProxyType;
        set renderProxytype(value: ERenderProxyType);
        /**
         * @en Begin caching the animation.
         * @zh 开始缓存动画。
         */
        beginCache(): void;
        /**
         * @en End caching the animation.
         * @zh 结束缓存动画。
         */
        endCache(): void;
        /**
         * @en Set the skin index for rendering.
         * @param index The index of the skin to set.
         * @zh 设置用于渲染的皮肤索引。
         * @param index 要设置的皮肤索引。
         */
        setSkinIndex(index: number): void;
        /**
         * 获取对应类型的 Dynamic mesh
         * @param vertexDeclaration
         * @param create
         * @returns
         */
        getDynamicMesh(vertexDeclaration: VertexDeclaration, create?: boolean): Mesh2D;
        private _clear;
        /**
         * @en Play a specific animation.
         * @param animationName The name of the animation to play.
         * @zh 播放特定的动画。
         * @param animationName 要播放的动画名称。
         */
        play(animationName: string): void;
        complete(): void;
        /**
         * @en Render the current animation at a specific time.
         * @param time The time to render the animation at.
         * @zh 在特定时间渲染当前动画。
         * @param time 要渲染动画的时间。
         */
        render(time: number): void;
    }
    interface IRender {
        changeSkeleton(skeleton: spine.Skeleton): void;
        change(skinRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        leave(): void;
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en Base class for all Spine renderers.
     * @zh 所有 Spine 渲染器的基础类。
     */
    abstract class SpineBaseRenderer implements IRender {
        /** @internal */
        protected _renderNode: Spine2DRenderNode;
        /** @internal */
        protected _skeleton: spine.Skeleton;
        /**
         * @en Array of Spine bones.
         * @zh Spine 骨骼数组。
         */
        bones: spine.Bone[];
        /**
         * @en Array of Spine slots.
         * @zh Spine 插槽数组。
         */
        slots: spine.Slot[];
        /**
         * @en The current skin updater.
         * @zh 当前皮肤更新器
         */
        skinUpdate: SkinRenderUpdate;
        /**
         * @en The current animation render proxy.
         * @zh 当前动画渲染代理。
         */
        currentAnimation: AnimationRenderProxy;
        /**
         * @en Create a new instance of SpineBaseRenderer.
         * @param renderNode The Spine2D render node.
         * @zh 创建 SpineBaseRenderer 的新实例。
         * @param renderNode Spine2D 渲染节点。
         */
        constructor(renderNode: Spine2DRenderNode);
        /**
         * @en Change the current skeleton.
         * @param skeleton The new skeleton to use.
         * @zh 更改当前骨骼。
         * @param skeleton 要使用的新骨骼。
         */
        changeSkeleton(skeleton: spine.Skeleton): void;
        /**
         * @en Abstract method to change the current skin renderer and animation.
         * @param skinRender The new skin renderer to use.
         * @param currentAnimation The new animation render proxy to use.
         * @zh 更改当前皮肤渲染器和动画的抽象方法。
         * @param skinRender 要使用的新皮肤渲染器。
         * @param currentAnimation 要使用的新动画渲染代理。
         */
        abstract change(skinRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        /**
         * @en Abstract method called when leaving the current render state.
         * @zh 离开当前渲染状态时调用的抽象方法。
         */
        abstract leave(): void;
        /**
         * @en Abstract method to render the current animation at a specific time.
         * @param curTime The current time for rendering.
         * @param boneMat The bone matrix for rendering.
         * @zh 在特定时间渲染当前动画的抽象方法。
         * @param curTime 渲染的当前时间。
         * @param boneMat 用于渲染的骨骼矩阵。
         */
        abstract render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en RigidBodySpineRenderer used for rigid body rendering of Spine animations.
     * @zh RigidBodySpineRenderer 类用于刚体渲染的 Spine 动画。
     */
    class RigidBodySpineRenderer extends SpineBaseRenderer {
        private _matrix_0;
        private _matrix_1;
        leave(): void;
        change(currentRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en OptimizedSpineRenderer used for optimized rendering of Spine animations.
     * @zh OptimizedSpineRenderer 类用于优化 Spine 动画的渲染。
     */
    class OptimizedSpineRenderer extends SpineBaseRenderer {
        /**
         * @en Change the current skin renderer and animation.
         * @param currentRender The new skin renderer to use.
         * @param currentAnimation The new animation render proxy to use.
         * @zh 更改当前皮肤渲染器和动画。
         * @param currentRender 要使用的新皮肤渲染器。
         * @param currentAnimation 要使用的新动画渲染代理。
         */
        change(currentRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        /**
         * @en Called when leaving the current render state.
         * @zh 离开当前渲染状态时调用。
         */
        leave(): void;
        /**
         * @en Render the current animation at a specific time.
         * @param curTime The current time for rendering.
         * @param boneMat The bone matrix for rendering.
         * @zh 在特定时间渲染当前动画。
         * @param curTime 渲染的当前时间。
         * @param boneMat 用于渲染的骨骼矩阵。
         */
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en StandardSpineRenderer used for standard rendering of Spine animations.
     * @zh StandardSpineRenderer 类用于标准的 Spine 动画渲染。
     */
    class StandardSpineRenderer extends SpineBaseRenderer {
        /** @internal */
        _renderer: ISpineRender;
        /**
         * @en Create a new instance of StandardSpineRenderer.
         * @param skeleton The Spine skeleton.
         * @param renderNode The Spine2D render node.
         * @zh 创建 StandardSpineRenderer 的一个新实例。
         * @param skeleton Spine 骨骼。
         * @param renderNode Spine2D 渲染节点。
         */
        constructor(renderNode: Spine2DRenderNode);
        /**
         * @en Called when leaving the current render state.
         * @zh 离开当前渲染状态时调用。
         */
        leave(): void;
        /**
         * @en Change the current skin renderer and animation.
         * @param currentRender The new skin renderer to use.
         * @param currentAnimation The new animation render proxy to use.
         * @zh 更改当前皮肤渲染器和动画。
         * @param currentRender 要使用的新皮肤渲染器。
         * @param currentAnimation 要使用的新动画渲染代理。
         */
        change(currentRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        /**
         * @en Render the current animation at a specific time.
         * @param curTime The current time for rendering.
         * @param boneMat The bone matrix for rendering .
         * @zh 在特定时间渲染当前动画。
         * @param curTime 渲染的当前时间。
         * @param boneMat 用于渲染的骨骼矩阵。
         */
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en BakedSpineRenderer used for baked Spine animation rendering.
     * @zh BakedSpineRenderer 类用于烘焙 Spine 动画的渲染。
     */
    class BakedSpineRenderer extends SpineBaseRenderer {
        /** @internal */
        private _simpleAnimatorParams;
        private _simpleAnimatorTextureSize;
        private _simpleAnimatorTexture;
        /** x simpleAnimation offset,y simpleFrameOffset*/
        private _simpleAnimatorOffset;
        /** @internal */
        _bonesNums: number;
        /**
         * @en Map of animation offsets.
         * @zh 动画偏移量映射。
         */
        aniOffsetMap: Record<string, number>;
        /**
         * @en Animatioin frame texture.
         * @zh 动画帧贴图。
         */
        get simpleAnimatorTexture(): Texture2D;
        set simpleAnimatorTexture(value: Texture2D);
        /**
         * @en The simple animator offset.
         * @zh 简单动画偏移量
         */
        get simpleAnimatorOffset(): Vector2;
        set simpleAnimatorOffset(value: Vector2);
        /**
         * @en The time step for animation.
         * @zh 动画的时间步长。
         */
        step: number;
        /**
         * @en Called when leaving the current render state.
         * @zh 离开当前渲染状态时调用。
         */
        leave(): void;
        /**
         * @en Change the current skin renderer and animation.
         * @param currentRender The new skin renderer to use.
         * @param currentAnimation The new animation render proxy to use.
         * @zh 更改当前皮肤渲染器和动画。
         * @param currentRender 要使用的新皮肤渲染器。
         * @param currentAnimation 要使用的新动画渲染代理。
         */
        change(currentRender: SkinRenderUpdate, currentAnimation: AnimationRenderProxy): void;
        /**
         * @internal
         */
        _computeAnimatorParamsData(): void;
        /**
         * @en Set custom data for the animator.
         * @param value1 First custom value.
         * @param value2 Second custom value.
         * @zh 为动画器设置自定义数据。
         * @param value1 自定义数据1。
         * @param value2 自定义数据2。
         */
        setCustomData(value1: number, value2?: number): void;
        /**
         * @en Render the current animation at a specific time.
         * @param curTime The current time for rendering.
         * @param boneMat The bone matrix for rendering.
         * @zh 在特定时间渲染当前动画。
         * @param curTime 渲染的当前时间。
         * @param boneMat 用于渲染的骨骼矩阵。
         */
        render(curTime: number, boneMat: Float32Array): void;
    }
    /**
     * @en Abstract class for creating vertex buffers in a spine skeleton animation system.
     * @zh 用于在spine骨骼动画系统中创建顶点缓冲区的抽象类。
     * @blueprintIgnore
     */
    abstract class VBCreator implements IGetBone {
        /**
         * @en Map of bone index to bone ID.
         * @zh 骨骼索引到骨骼ID的映射。
         */
        mapIndex: Map<number, number>;
        /**
         * @en Array of bone IDs and indices.
         * @zh 骨骼ID和索引的数组。
         */
        boneArray: number[];
        /**
         * @en Vertex buffer data.
         * @zh 顶点缓冲区数据。
         */
        vb: Float32Array;
        /**
         * @en Length of the vertex buffer.
         * @zh 顶点缓冲区的长度。
         */
        vbLength: number;
        /**
         * @en The Max Length of the vertex buffer.
         * @zh 顶点缓冲区的最大长度。
         */
        maxVertexCount: number;
        /**
         * @en Map of slot ID to attachment position data.
         * @zh 插槽ID到附件位置数据的映射。
         */
        slotVBMap: Map<number, Map<string, TAttamentPos>>;
        /**
         * @en Bone matrix data.
         * @zh 骨骼矩阵数据。
         */
        boneMat: Float32Array;
        /** @internal */
        _vertexSize: number;
        /** @internal 没有骨骼的顶点数 */
        _baseVtxCount: number;
        _boneVtxCount: number;
        /** @internal TODO 双顶点色模式 */
        twoColorTint: boolean;
        private boneMaxId;
        private _vertexDeclaration;
        /**
         * @en
         * @zh
         */
        vertexFlag: string;
        constructor(vertexFlag: string, maxVertexCount?: number, auto?: boolean);
        /**
         * @en set vertex buffer length.
         * @param maxVertexCount The Max length of Vertex count.
         * @zh 设置顶点缓冲长度。
         * @param maxVertexCount 顶点缓存区最大个数。
         */
        setBufferLength(maxVertexCount: number): void;
        protected _updateBuffer(): void;
        get vertexSize(): number;
        get vertexDeclaration(): VertexDeclaration;
        abstract appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Append deform data to the output array.
         * @param attachmentParse Attachment parse data.
         * @param deform Deform data array.
         * @param offset Offset in the output array.
         * @param out Output array.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的偏移量。
         * @param out 输出数组。
         */
        abstract appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
        /**
         * @en Append vertex buffer and create index buffer for an attachment.
         * @param attach Attachment parse data.
         * @zh 为附件追加顶点缓冲区并创建索引缓冲区。
         * @param attach 附件解析数据。
         */
        appendAndCreateIB(attach: AttachmentParse): void;
        /**
         * @en Get the bone ID for a given bone index.
         * @param boneIndex Bone index.
         * @returns Bone ID.
         * @zh 获取给定骨骼索引的骨骼ID。
         * @param boneIndex 骨骼索引。
         * @returns 骨骼ID。
         */
        getBoneId(boneIndex: number): number;
        /**
         * @en Initialize the bone matrix.
         * @zh 初始化骨骼矩阵。
         */
        initBoneMat(): void;
        /**
         * @en Append vertex buffer data for an attachment.
         * @param attach Attachment parse data.
         * @returns Offset in the vertex buffer.
         * @zh 为附件追加顶点缓冲区数据。
         * @param attach 附件解析数据。
         * @returns 顶点缓冲区中的偏移量。
         */
        appendVB(attach: AttachmentParse): number | TAttamentPos;
        /**
         * @en Reset the vertex buffer.
         * @param attach Attachment parse data.
         * @zh 重置顶点缓冲区。
         * @param attach 附件解析数据。
         */
        resetVB(attach: AttachmentParse): void;
        /**
         * @en Update bone matrices.
         * @param bones Array of bones.
         * @param boneMat Bone matrix array.
         * @param ofx Offset x.
         * @param ofy Offset y.
         * @zh 更新骨骼矩阵。
         * @param bones 骨骼数组。
         * @param boneMat 骨骼矩阵数组。
         * @param ofx 偏移x。
         * @param ofy 偏移y。
         */
        updateBone(bones: spine.Bone[], boneMat: Float32Array, ofx?: number, ofy?: number): void;
        /**
         * @en Update bone cache.
         * @param boneFrames Array of bone frame data.
         * @param frames Frame number.
         * @param boneMat Bone matrix array.
         * @zh 更新骨骼缓存。
         * @param boneFrames 骨骼帧数据数组。
         * @param frames 帧数。
         * @param boneMat 骨骼矩阵数组。
         */
        updateBoneCache(boneFrames: Float32Array[][], frames: number, boneMat: Float32Array, ofx?: number, ofy?: number): void;
        _cloneTo(target: VBCreator): void;
        abstract _create(): VBCreator;
        /**
         * @en Clone this VBCreator.
         * @zh 克隆此VBCreator。
         */
        clone(): VBCreator;
    }
    /**
     * @en VBBoneCreator class used to handle bone-specific vertex buffer creation.
     * @zh VBBoneCreator 类用于处理骨骼特定的顶点缓冲区创建。
     */
    class VBBoneCreator extends VBCreator {
        _create(): VBCreator;
        /**
         * @en Appends vertex array data for an attachment.
         * @param attachmentParse The attachment parse data.
         * @param vertexArray The vertex array to append to.
         * @param offset The current offset in the vertex array.
         * @param boneGet The interface for getting bone IDs.
         * @zh 为附件追加顶点数组数据。
         * @param attachmentParse 附件解析数据。
         * @param vertexArray 要追加到的顶点数组。
         * @param offset 顶点数组中的当前偏移量。
         * @param boneGet 获取骨骼ID的接口。
         */
        appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Appends deform data to the output array.
         * @param attachmentParse The attachment parse data.
         * @param deform The deform data array.
         * @param offset The current offset in the output array.
         * @param out The output array to append to.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的当前偏移量。
         * @param out 要追加到的输出数组。
         */
        appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
    }
    /**
     * @en VBRigBodyCreator class used to handle rigid body specific vertex buffer creation.
     * @zh VBRigBodyCreator 类用于处理刚体特定的顶点缓冲区创建。
     */
    class VBRigBodyCreator extends VBCreator {
        /** @internal */
        _create(): VBCreator;
        /**
         * @en Appends vertex array data for an attachment.
         * @param attachmentParse The attachment parse data.
         * @param vertexArray The vertex array to append to.
         * @param offset The current offset in the vertex array.
         * @param boneGet The interface for getting bone IDs.
         * @zh 为附件追加顶点数组数据。
         * @param attachmentParse 附件解析数据。
         * @param vertexArray 要追加到的顶点数组。
         * @param offset 顶点数组中的当前偏移量。
         * @param boneGet 获取骨骼ID的接口。
         */
        appendVertexArray(attachmentParse: AttachmentParse, vertexArray: Float32Array, offset: number, boneGet: IGetBone): number;
        /**
         * @en Appends deform data to the output array.
         * @param attachmentParse The attachment parse data.
         * @param deform The deform data array.
         * @param offset The current offset in the output array.
         * @param out The output array to append to.
         * @zh 将变形数据追加到输出数组。
         * @param attachmentParse 附件解析数据。
         * @param deform 变形数据数组。
         * @param offset 输出数组中的当前偏移量。
         * @param out 要追加到的输出数组。
         */
        appendDeform(attachmentParse: AttachmentParse, deform: Array<number>, offset: number, out: Float32Array): void;
    }
    type TAttamentPos = {
        offset: number;
        attachment: AttachmentParse;
    };
    /**
     * @zh Spine动画渲染节点。
     * - Event.PLAYED:动画开始播放调度。
     * - Event.STOPPED:动画停止播放调度。
     * - Event.PAUSED:动画暂停播放调度。
     * - Event.LABEL:自定义事件。
     * @en spine render node.
     * - Event.PLAYED:Animation start play dispatch.
     * - Event.STOPPED:Animation stop play dispatch.
     * - Event.PAUSED:Animation pause play dispatch.
     * - Event.LABEL:Custom event.
     */
    class Spine2DRenderNode extends BaseRenderNode2D {
        /** @ignore @blueprintIgnore */
        static _pool: IRenderElement2D[];
        /** @ignore @blueprintIgnore */
        static createRenderElement2D(): IRenderElement2D;
        /** @ignore @blueprintIgnore */
        static recoverRenderElement2D(value: IRenderElement2D): void;
        /** @ignore */
        spineItem: ISpineOptimizeRender;
        /** @internal */
        _mesh: Mesh2D;
        /**
         * @zh 物理更新模式。
         * @en The physics update mode.
         **/
        physicsUpdate: number;
        /**状态-停止 */
        static readonly STOPPED: number;
        /**状态-暂停 */
        static readonly PAUSED: number;
        /**状态-播放中 */
        static readonly PLAYING: number;
        protected _renderHandle: ISpineRenderDataHandle;
        protected _source: string;
        protected _templet: SpineTemplet;
        protected _timeKeeper: TimeKeeper;
        protected _skeleton: spine.Skeleton;
        protected _state: spine.AnimationState;
        protected _stateData: spine.AnimationStateData;
        protected _currentPlayTime: number;
        private _pause;
        private _needUpdate;
        /** 动画播放的起始时间位置*/
        private _playStart;
        /** 动画播放的结束时间位置*/
        private _playEnd;
        /** 动画的总时间*/
        private _duration;
        /** 播放速率*/
        private _playbackRate;
        private _playAudio;
        private _soundChannelArr;
        private trackIndex;
        private _skinName;
        private _animationName;
        private _loop;
        private _externalSkins;
        private _skin;
        private _offset;
        /** @ignore */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        protected _getcommonUniformMap(): Array<string>;
        protected _createRenderHandle(): ISpineRenderDataHandle;
        /**
         * @zh 外部皮肤，用于根据不同皮肤，替换对应插槽的附件。
         * @en External skins, used to replace the attachments of corresponding slots according to different skins.
         */
        get externalSkins(): ExternalSkin[];
        set externalSkins(value: ExternalSkin[]);
        /** @ignore @blueprintIgnore */
        renderUpdate(context: IRenderContext2D): void;
        /**
         * @zh 重置外部加载的皮肤数据。更换附件或皮肤数据后，需要调用此方法，否则不会生效。
         * @en Resets the external loaded skin data. After replacing attachments or skin data, this method needs to be called, otherwise it will not take effect.
         */
        resetExternalSkin(): void;
        /**
         * @zh 动画源文件路径
         * @en Spine source file path.
         */
        get source(): string;
        set source(value: string);
        /**
         * @zh 当前的Spine动画皮肤名称。
         * @en The current spine animation skin name.
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * @zh 当前的Spine动画名称
         * @en The current spine animation name.
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * @zh 最大播放间隔
         * @en The current spine animation state.
         */
        get maxDetlaTime(): number;
        set maxDetlaTime(value: number);
        /**
         * @zh 是否循环播放Spine动画
         * @en Whether to loop spine animation.
         */
        get loop(): boolean;
        set loop(value: boolean);
        /** @deprecated */
        get url(): string;
        /** @deprecated */
        set url(value: string);
        /**
         * @zh 是否启用双色着色（Two-Color Tinting）的渲染效果
         * @en Whether to use two color tint.
         */
        get twoColorTint(): boolean;
        set twoColorTint(value: boolean);
        /**
         * @zh Spine动画模板的引用
         * @en The Spine template reference.
         */
        get templet(): SpineTemplet;
        set templet(value: SpineTemplet);
        /**
         * @zh 设置当前播放位置
         * @param value 当前时间
         * @en Set the current play time.
         * @param value The current play time.
         */
        set currentTime(value: number);
        /**
         * @zh 获取当前播放状态
         * @en Get the current play time.
         */
        get playState(): number;
        private _useFastRender;
        /**
         * @zh 是否使用快速渲染，默认开启，某些复杂的Spine开启此值会渲染错误，比如spine资源中某个顶点的骨骼控制数大于4
         * @en Whether to use fast rendering. It is enabled by default. When some complex spines are enabled, this value will render errors. For example, the number of bone controls of a vertex in the spine resource is greater than 4.
         */
        get useFastRender(): boolean;
        set useFastRender(value: boolean);
        get offset(): Vector2;
        set offset(value: Vector2);
        private _autoAdjust;
        get autoAdjust(): boolean;
        set autoAdjust(value: boolean);
        private _doAutoAdjust;
        /** @ignore @blueprintIgnore */
        onEnable(): void;
        /** @ignore @blueprintIgnore */
        onDisable(): void;
        /**
         * @zh 初始化渲染器。
         * @param templet Spine 模板
         * @en Initializes the renderer.
         * @param templet The Spine template.
         */
        protected init(templet: SpineTemplet): void;
        /**
         * @zh 播放动画
         * @param nameOrIndex	Spine动画名字或者索引
         * @param loop		    是否循环播放
         * @param force		    false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param start		    起始时间
         * @param end			结束时间
         * @param freshSkin	    是否刷新皮肤数据
         * @param playAudio	    是否播放音频
         * @en Play Spine animation.
         * @param nameOrIndex	Spine animation name or index.
         * @param loop			Whether to loop play.
         * @param force			false, if the animation to play is the same as the last one then it won't be played again. true, force playing even if the animation is the same.
         * @param start			Start time.
         * @param end			End time.
         * @param freshSkin		Whether to refresh skin data.
         * @param playAudio		Whether to play audio.
         */
        play(nameOrIndex: string | number, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        private _update;
        private _flushExtSkin;
        /**
         * @zh 得到当前动画的数量
         * @en Get the number of current animations.
         */
        getAnimNum(): number;
        /**
         * @zh 得到指定动画的名字
         * @param index	动画的索引
         * @en Get the name of the specified animation.
         * @param index The index of the animation.
         */
        getAniNameByIndex(index: number): string;
        /**
    
         * @zh 通过名字得到插槽的引用
         * @param slotName 插槽的名字
         * @en Get the reference to the slot by name.
         * @param slotName The name of the slot.
         */
        getSlotByName(slotName: string): spine.Slot;
        /**
         * @zh 设置动画播放速率
         * @param value	速率值，1为标准速率
         * @en Set the animation playback rate.
         * @param value The playback rate.
         */
        playbackRate(value: number): void;
        /**
         * @zh 通过名字显示一套皮肤
         * @param name	皮肤的名字
         * @en Show a set of skins by name.
         * @param name The name of the skin.
         */
        showSkinByName(name: string): void;
        /**
         * @zh 通过索引显示一套皮肤
         * @param skinIndex	皮肤索引
         * @en Show a set of skins by index.
         * @param skinIndex The index of the skin.
         */
        showSkinByIndex(skinIndex: number): void;
        /**
         * @zh 停止动画
         * @en Stop the animation.
         */
        stop(): void;
        /** @ignore @blueprintIgnore */
        onUpdate(): void;
        /**
         * @zh 暂停动画的播放
         * @en Pause the animation playback.
         */
        paused(): void;
        /**
         * @zh 恢复动画的播放
         * @en Resume the animation playback.
         */
        resume(): void;
        /**
         * @zh 清掉播放完成的音频
         * @param force 是否强制删掉所有的声音channel
         * @en Clear the finished audio.
         * @param force Whether to force delete all audio channels.
         */
        private _onAniSoundStoped;
        /** @internal */
        reset(): void;
        /**
         * @zh 添加一个动画
         * @param nameOrIndex   动画名字或者索引
         * @param loop          是否循环播放
         * @param delay         延迟调用，可以为负数
         * @en Add an animation
         * @param nameOrIndex   Animation name or index
         * @param loop          Whether to play in a loop
         * @param delay         Delay call, can be negative
         */
        addAnimation(nameOrIndex: string | number, loop?: boolean, delay?: number): void;
        /**
         * @zh 设置当动画被改变时，存储混合(交叉淡出)的持续时间
         * @param fromNameOrIndex 原来的动画名字或者索引
         * @param toNameOrIndex   目标的动画名字或者索引
         * @param duration 混合(交叉淡出)的持续时间
         * @en Set the duration of mixing (cross-fade) when an animation is changed.
         * @param fromNameOrIndex The name or index of the original animation.
         * @param toNameOrIndex The name or index of the target animation.
         * @param duration The duration of mixing (cross-fade).
         */
        setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number): void;
        /**
         * @zh 获取骨骼信息(spine.Bone)
         * - 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法
         * @param boneName  骨骼名称
         * @en Get the bone information (spine.Bone)
         * - Note: Get the spine runtime bone information (spine.Bone), not the engine method.
         * @param boneName The name of the bone.
         */
        getBoneByName(boneName: string): spine.Bone;
        /**
         * @zh 获取骨骼(spine.Skeleton)
         * @en Get the Skeleton(spine.Skeleton)
         */
        getSkeleton(): spine.Skeleton;
        /**
         * @zh 根据给定的坐标移动物体,支持Spine物理时有效（不能低于Spine4.2版本）
         * @param x X轴坐标
         * @param y Y轴坐标
         * @en Move the object according to the given coordinates, effective when Spine physics is enabled (cannot be lower than version 4.2 of Spine)
         * @param x X-axis coordinate
         * @param y Y-axis coordinate
         */
        physicsTranslate(x: number, y: number): void;
        /**
         * @zh 当transform改变时，更新骨骼的位置
         * @en Transform changed, update the skeleton position.
         */
        private onTransformChanged;
        /**
         * @zh 替换插槽皮肤
         * @param slotName 插槽名称
         * @param attachmentName 附件名称
         * @en Replace the slot skin.
         * @param slotName Slot name.
         * @param attachmentName Attachment name.
         */
        setSlotAttachment(slotName: string, attachmentName: string): void;
        /**
         * @zh 清除方法，用于释放和重置相关资源。
         * @en Clear method, used to release and reset related resources.
         */
        clear(): void;
        /**
         * @zh 切换至快速渲染模式，开启后可以大幅度提升渲染性能，但是有骨骼顶点限制，比如spine资源中某个顶点的骨骼控制数不能大于4
         * @en Use fast rendering mode, which can greatly improve rendering performance but has limitations on bone vertices. For example, the number of bones controlling a vertex in spine resources cannot be greater than 4
         */
        changeFast(): void;
        /**
         * @zh 切换至普通渲染模式，采用未优化过的Spine运行时，性能不如快速渲染模式，但没有骨骼顶点限制
         * @en Switch to normal rendering mode, which uses the unoptimized Spine runtime and has no bone vertex limitations. Performance is not as good as fast rendering mode.
         */
        changeNormal(): void;
        /**
         * @ignore @blueprintIgnore
         * @zh 销毁当前对象
         * @en Destroy the current object.
         */
        onDestroy(): void;
        /** @internal */
        _updateMaterials(elements: Material[]): void;
        /** @internal */
        _updateRenderElements(): void;
        /** @internal */
        _onMeshChange(mesh: Mesh2D, force?: boolean): boolean;
        get rect(): Vector4;
    }
    class TimeKeeper {
        maxDelta: number;
        framesPerSecond: number;
        delta: number;
        totalTime: number;
        lastTime: number;
        frameCount: number;
        frameTime: number;
        timer: Timer;
        constructor(timer: Timer);
        update(): void;
    }
    /**
     * @en SpineAdapter is an adapter class for integrating the Spine animation system.
     * @zh SpineAdapter 是一个适配器类，用于集成 Spine 动画系统。
     */
    class SpineAdapter {
        static _vbArray: Float32Array;
        static _ibArray: Uint16Array;
        static _spine: any;
        /**
         * @en Indicates whether the Spine system is using WebAssembly.
         * @zh 指示 Spine 系统是否使用 WebAssembly。
         */
        static isWasm: boolean;
        /**
         * @en Map of state values to their corresponding string representations.
         * @zh 状态值到其对应字符串表示的映射。
         */
        static stateMap: any;
        /**
         * @internal
         * @en Initialize the system, called internally by the system.
         * @zh 初始化系统，由系统内部调用。
        */
        static initialize(): any;
        /**
         * @en Create a normal render object for Spine animation.
         * @param templet The Spine template.
         * @zh 为 Spine 动画创建一个普通渲染对象。
         * @param templet Spine 模板。
         */
        static createNormalRender(templet: SpineTemplet): SpineSkeletonRenderer | SpineWasmRender;
        /**
         * @en Perform all necessary adaptations for Spine integration.
         * @zh 执行所有必要的 Spine 集成适配。
         */
        static allAdpat(): void;
        /**
         * @en Adapt the JavaScript version of Spine.
         * @zh 适配 JavaScript 版本的 Spine。
         */
        static adaptJS(): void;
        /**
         * @en Initialize and extend the Spine animation library's AnimationState prototype.
         * @zh 初始化并扩展Spine动画库的AnimationState原型。
         */
        static initClass(): void;
        /**
         * @en Bind vertex and index buffers for Spine rendering.
         * @param maxNumVertices Maximum number of vertices.
         * @param maxNumIndices Maximum number of indices.
         * @zh 为 Spine 渲染绑定顶点和索引缓冲区。
         * @param maxNumVertices 最大顶点数量。
         * @param maxNumIndices 最大索引数量。
         */
        static bindBuffer(maxNumVertices: number, maxNumIndices: number): void;
        /**
         * @en Draw a Spine skeleton.
         * @param fun The drawing function.
         * @param skeleton The Spine skeleton to draw.
         * @param twoColorTint Whether to use two-color tinting.
         * @param slotRangeStart The starting slot index.
         * @param slotRangeEnd The ending slot index.
         * @zh 绘制 Spine 骨骼。
         * @param fun 绘制函数。
         * @param skeleton 要绘制的 Spine 骨骼。
         * @param twoColorTint 是否使用两色混色。
         * @param slotRangeStart 起始插槽索引。
         * @param slotRangeEnd 结束插槽索引。
         */
        static drawSkeleton(fun: Function, skeleton: any, twoColorTint: boolean, slotRangeStart: number, slotRangeEnd: number): void;
    }
    /**
     * @deprecated 请使用Sprite+Spine2DRenderNode组件
     * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。
     */
    class SpineSkeleton extends Sprite {
        private _spineComponent;
        constructor();
        /**
         * 外部皮肤
         */
        get externalSkins(): ExternalSkin[];
        set externalSkins(value: ExternalSkin[]);
        /**
         * 重置外部加载的皮肤的样式
         */
        resetExternalSkin(): void;
        /**
         * 动画源
         */
        get source(): string;
        set source(value: string);
        /**
         * 皮肤名
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * 动画名
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * 是否循环
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * 得到动画模板的引用
         * @return templet
         */
        get templet(): SpineTemplet;
        /**
         * 设置动画模板的引用
         */
        set templet(value: SpineTemplet);
        /**
         * 设置当前播放位置
         * @param value 当前时间
         */
        set currentTime(value: number);
        /**
         * 获取当前播放状态
         * @return	当前播放状态
         */
        get playState(): number;
        get spineItem(): ISpineOptimizeRender;
        set spineItem(value: ISpineOptimizeRender);
        /**
         * 播放动画
         *
         * @param nameOrIndex	动画名字或者索引
         * @param loop		是否循环播放
         * @param force		false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param start		起始时间
         * @param end			结束时间
         * @param freshSkin	是否刷新皮肤数据
         * @param playAudio	是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        /**
         * 得到当前动画的数量
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * 得到指定动画的名字
         * @param index	动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * 通过名字得到插槽的引用
         * @param slotName
         */
        getSlotByName(slotName: string): spine.Slot;
        /**
         * 设置动画播放速率
         * @param value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * 通过名字显示一套皮肤
         * @param name	皮肤的名字
         */
        showSkinByName(name: string): void;
        /**
         * 通过索引显示一套皮肤
         * @param skinIndex	皮肤索引
         */
        showSkinByIndex(skinIndex: number): void;
        /**
         * 停止动画
         */
        stop(): void;
        /**
         * 暂停动画的播放
         */
        paused(): void;
        /**
         * 恢复动画的播放
         */
        resume(): void;
        /**
         * 销毁当前动画
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 添加一个动画
         * @param nameOrIndex   动画名字或者索引
         * @param loop          是否循环播放
         * @param delay         延迟调用，可以为负数
         */
        addAnimation(nameOrIndex: any, loop?: boolean, delay?: number): void;
        /**
         * 设置当动画被改变时，存储混合(交叉淡出)的持续时间
         * @param fromNameOrIndex
         * @param toNameOrIndex
         * @param duration
         */
        setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number): void;
        /**
         * 获取骨骼信息(spine.Bone)
         * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法
         * @param boneName
         */
        getBoneByName(boneName: string): spine.Bone;
        /**
         * 获取Skeleton(spine.Skeleton)
         */
        getSkeleton(): spine.Skeleton;
        /**
         * 替换插槽皮肤
         * @param slotName
         * @param attachmentName
         */
        setSlotAttachment(slotName: string, attachmentName: string): void;
    }
    enum ESpineRenderType {
        boneGPU = 0,
        normal = 1,
        rigidBody = 2
    }
    /**
     * @en Base class for Spine animation template
     * @zh Spine动画模板基类
     */
    class SpineTemplet extends Resource {
        /**
         * @en Runtime version of Spine
         * @zh Spine运行时版本
         */
        static RuntimeVersion: string;
        /**
         * @en Skeleton data for the Spine animation
         * @zh Spine动画的骨骼数据
         */
        skeletonData: spine.SkeletonData;
        /**
         * @en Map of materials used in the Spine animation
         * @zh Spine动画中使用的材质映射
         */
        materialMap: Map<string, Material>;
        private _textures;
        private _atlas;
        private _basePath;
        /**
         * @en Base width of spine animation
         * @zh spine 动画基础宽度
         */
        width: number;
        /**
         * @en Base height of spine animation
         * @zh spine 动画基础高度
         */
        height: number;
        /**
         * @en X-axis offset of spine animation
         * @zh spine 动画X轴偏移
         */
        offsetX: number;
        /**
         * @en Y-axis offset of spine animation
         * @zh spine 动画Y轴偏移
         */
        offsetY: number;
        /**
         * @en Indicates if slot is needed
         * @zh 是否需要插槽
         */
        needSlot: boolean;
        /**
         * @en Skeleton optimization object
         * @zh 骨骼优化对象
         */
        sketonOptimise: SketonOptimise;
        /**
         * 4.2版本以上支持物理
         * @en Indicates if physics is needed
         * @zh 是否需要物理
         */
        hasPhysics: boolean;
        /** @ignore */
        constructor();
        /** @internal */
        get _mainTexture(): Texture2D;
        /**
         * @en The main texture of the Spine animation
         * @zh Spine动画的主纹理
         */
        mainTexture: Texture2D;
        /**
         * @en The main blend mode of the Spine animation
         * @zh Spine动画的主混合模式
         */
        mainBlendMode: number;
        private _premultipliedAlpha;
        /**
         * @en Switch for premultipliedAlpha.
         * @zh 透明预乘的开关。
         */
        get premultipliedAlpha(): boolean;
        /**
         * @en The base path of the Spine animation resources
         * @zh Spine动画资源的基础路径
         */
        get basePath(): string;
        /**
         * @en Get or create a material for the given texture and blend mode
         * @param texture The texture to use
         * @param blendMode The blend mode to use
         * @zh 获取或创建给定纹理和混合模式的材质
         * @param texture 要使用的纹理
         * @param blendMode 要使用的混合模式
         */
        getMaterial(texture: Texture2D, blendMode: number): Material;
        /**
         * @en Get a texture by its name
         * @param name The name of the texture
         * @zh 通过名称获取纹理
         * @param name 纹理的名称
         */
        getTexture(name: string): Texture2D;
        setTexture(name: string, tex: Texture2D): void;
        /** @internal */
        _parse(desc: string | ArrayBuffer, atlas: spine.TextureAtlas, textures: Record<string, Texture2D>, premultipliedAlpha?: boolean): void;
        /**
         * @en Get the animation name by its index
         * @param index The index of the animation
         * @zh 通过索引获取动画名称
         * @param index 动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * @en Find the animation by its name
         * @param name The name of the animation to find
         * @returns The found animation index, or -1 if not found
         * @zh 通过动画名称查找动画
         * @param name 要查找的动画名称
         * @returns 找到的动画索引，如果未找到则返回-1
         */
        findAnimation(name: string): spine.Animation;
        /**
         * @en Get the skin index by its name
         * @param skinName The name of the skin
         * @zh 通过皮肤名称获取皮肤索引
         * @param skinName 皮肤名称
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * @en Release textures and materials
         * @zh 释放纹理和材质
         */
        protected _disposeResource(): void;
    }
    /**
     * @en Used for adaptation to version 3.8
     * @zh 用于3.8版本适配
     */
    class SpineTexture {
        /**
         * @en The actual Texture2D object
         * @zh 实际的Texture2D对象
         */
        realTexture: Texture2D;
        /**
         * @en Creates a new SpineTexture instance.
         * @param tex The Texture2D to be wrapped
         * @zh 创建SpineTexture的新实例
         * @param tex 要被包装的Texture2D
         */
        constructor(tex: Texture2D);
        /**
         * @en Get the image dimensions
         * @zh 获取图像尺寸
         */
        getImage(): Object;
        /**
         * @en Set the texture filters
         * @param minFilter The minification filter
         * @param magFilter The magnification filter
         * @zh 设置纹理过滤器
         * @param minFilter 缩小过滤器
         * @param magFilter 放大过滤器
         */
        setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter): void;
        /**
         * @en Convert Spine texture wrap mode to LayaAir wrap mode
         * @param mode The Spine texture wrap mode
         * @zh 将Spine纹理包裹模式转换为LayaAir包裹模式
         * @param mode Spine纹理包裹模式
         */
        convertWrapMode(mode: spine.TextureWrap): WrapMode;
        /**
         * @en Set the texture wrap modes
         * @param uWrap The horizontal wrap mode
         * @param vWrap The vertical wrap mode
         * @zh 设置纹理包裹模式
         * @param uWrap 水平包裹模式
         * @param vWrap 垂直包裹模式
         */
        setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap): void;
    }
    class BaseSheet {
        protected _origMatix: Matrix;
        protected _matrix: Matrix;
        protected _reverseMatrix: Matrix;
        protected _width: number;
        protected _height: number;
        protected _vbData: number[];
        protected _ibData: number[];
        protected _outline: number[];
        constructor();
        getMatrix(): Matrix;
        getInverseMatrix(): Matrix;
        getTileWidth(): number;
        getTileHeight(): number;
        getTileBaseOutline(): number[];
        protected _initData(): void;
        /**
         * 设置格子大小
         * @param width 每个格子的宽度
         * @param height 每个格子的高度
         */
        setTileSize(width: number, height: number): void;
        getvbs(): number[];
        getibs(): number[];
        /**
         * 像素系统转格子系统
         */
        pixelToGrid(pixelx: number, pixely: number, out: Vector2): void;
        /**
         * 格子系统转像素系统
         */
        gridToPixel(row: number, col: number, out: Vector2): void;
        /**
         * @internal
         * 计算chunk的大小,内部方法。不对用户开发
         * @param rowCount chunk的宽度
         * @param colCount chunk的高度
         * @param out 输出的Vector2
         */
        _getChunkSize(rowCount: number, colCount: number, out: Vector2): void;
        /**
         * @internal
         * 计算 chunk 左上角的坐标,内部方法。不对用户开发
         * @param row
         * @param col
         * @param rowCount
         * @param colCount
         * @param out
         */
        _getChunkLeftTop(row: number, col: number, rowCount: number, colCount: number, out: Vector2): void;
    }
    /**
     * @internal
     * 生成渲染网格的顶点数据
     * 实现像素和格子系统之间的转换
     */
    class Grid {
        /**@internal */
        _sheet: BaseSheet;
        /**@internal */
        _tileShape: TileShape;
        private _offset;
        private _color;
        private _vbs;
        private _ibs;
        private _vbLength;
        constructor();
        /**
         * @internal
         */
        _updateTileShape(tileShape: TileShape, size: Vector2): boolean;
        /**
         * @internal
         */
        _updateColor(color: Color): boolean;
        /**
         * @internal
         */
        _updateBufferData(): void;
        /**
         * @internal
         */
        _setTileSize(x: number, y: number): void;
        /**
         * @internal
        * 像素系统转格子系统
        */
        _pixelToGrid(pixelX: number, pixelY: number, out: Vector2): void;
        /**
         * @internal
         * 格子系统转像素系统
         */
        _gridToPixel(row: number, col: number, out: Vector2): void;
        /**
         * 获得网格渲染VbBuffer
         */
        _getBaseVertexBuffer(): IVertexBuffer;
        /**
         * 获得网格渲染VbBuffer
         */
        _getBaseIndexBuffer(): IIndexBuffer;
        _getBaseIndexCount(): number;
    }
    /**
     * 半错位四边形
     */
    class HalfOffSquareSheet extends BaseSheet {
        private _offset;
        constructor(_offset?: number);
        protected _initData(): void;
        pixelToGrid(pixelX: number, pixelY: number, out: Vector2): void;
        gridToPixel(row: number, col: number, out: Vector2): void;
        _getChunkSize(rowCount: number, colCount: number, out: Vector2): void;
        _getChunkLeftTop(row: number, col: number, rowCount: number, colCount: number, out: Vector2): void;
    }
    /**
     * 六边形
     */
    class HeixSheet extends BaseSheet {
        private _offset;
        constructor(_offset?: number);
        protected _initData(): void;
        private prixToGrid;
        pixelToGrid(pixelX: number, pixelY: number, out: Vector2): void;
        gridToPixel(row: number, col: number, out: Vector2): void;
        _getChunkSize(rowCount: number, colCount: number, out: Vector2): void;
        _getChunkLeftTop(row: number, col: number, rowCount: number, colCount: number, out: Vector2): void;
    }
    /**
     * 菱形
     */
    class IsometricSheet extends BaseSheet {
        private _offset;
        constructor(_offset?: number);
        protected _initData(): void;
        pixelToGrid(pixelX: number, pixelY: number, out: Vector2): void;
        gridToPixel(row: number, col: number, out: Vector2): void;
        _getChunkSize(rowCount: number, colCount: number, out: Vector2): void;
        _getChunkLeftTop(row: number, col: number, rowCount: number, colCount: number, out: Vector2): void;
    }
    /**
     * 四边形
     */
    class RectSheet extends BaseSheet {
        constructor();
        protected _initData(): void;
        gridToPixel(row: number, col: number, out: Vector2): void;
        _getChunkSize(rowCount: number, colCount: number, out: Vector2): void;
        _getChunkLeftTop(row: number, col: number, rowCount: number, colCount: number, out: Vector2): void;
    }
    class TileSetCustomDataLayer {
        /** 识别用索引 */
        id: number;
        name: string;
        variant: string;
    }
    class TileMapNavigationLayer {
        /** 识别用索引 */
        id: number;
        name: string;
        layers: number[];
        constructor();
    }
    class TileSetOcclusionLayer {
        /** 识别用索引 */
        id: number;
        name: string;
        layerMask: number;
    }
    class TileSetPhysicsLayer {
        /** 识别用索引 */
        id: number;
        /** @internal 密度值，值可以为零或者是正数，建议使用相似的密度，这样做可以改善堆叠稳定性，默认值为10*/
        private _density;
        /** @internal 摩擦力，取值范围0-1，值越大，摩擦越大，默认值为0.2*/
        private _friction;
        /** @internal 弹性系数，取值范围0-1，值越大，弹性越大，默认值为0*/
        private _restitution;
        /**
         * @en [Read-only] Specifies the collision group to which the body belongs, default is 0, the collision rules are as follows:
         * 1. If the group values of two objects are equal:
         *    - If the group value is greater than zero, they will always collide.
         *    - If the group value is less than zero, they will never collide.
         *    - If the group value is equal to 0, then rule 3 is used.
         * 2. If the group values are not equal, then rule 3 is used.
         * 3. Each rigidbody has a category, this property receives a bit field, the range is the power of 2 in the range of [1,2^31].
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @zh [只读] 指定了该主体所属的碰撞组，默认为0，碰撞规则如下：
         * 1. 如果两个对象 group 相等：
         *    - group 值大于零，它们将始终发生碰撞。
         *    - group 值小于零，它们将永远不会发生碰撞。
         *    - group 值等于0，则使用规则3。
         * 2. 如果 group 值不相等，则使用规则3。
         * 3. 每个刚体都有一个 category 类别，此属性接收位字段，范围为 [1,2^31] 范围内的2的幂。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        group: number;
        /**
         * @en [Read-only] Collision category, specified using powers of 2, with 32 different collision categories available.
         * @zh [只读] 碰撞类别，使用2的幂次方值指定，有32种不同的碰撞类别可用。
         */
        category: number;
        /**
         * @en [Read-only] Specifies the category of collision bit mask, the result of category bitwise operation.
         * Each rigidbody also has a mask category, which specifies the sum of the category values it collides with (the value is the result of bitwise AND of all categories).
         * @zh [只读] 指定冲突位掩码碰撞的类别，category 位操作的结果。
         * 每个刚体也都有一个 mask 类别，指定与其碰撞的类别值之和（值是所有 category 按位 AND 的值）。
         */
        mask: number;
        /**
         * @en The density value. The value can be zero or a positive number. It is recommended to use similar densities to improve stacking stability. The default value is 10.
         * @zh 密度值。值可以为零或者是正数，建议使用相似的密度以改善堆叠稳定性。默认值为 10。
         */
        get density(): number;
        set density(value: number);
        /**
       * @en The friction coefficient. The value ranges from 0 to 1, the larger the value, the greater the friction. The default value is 0.2.
       * @zh 摩擦力。取值范围0-1，值越大，摩擦越大。默认值为0.2。
       */
        get friction(): number;
        set friction(value: number);
        /**
        * @en The restitution coefficient. The value ranges from 0 to 1, the larger the value, the greater the elasticity. The default value is 0.
        * @zh 弹性系数。取值范围0-1，值越大，弹性越大。默认值为0。
        */
        get restitution(): number;
        set restitution(value: number);
    }
    class TileSetTerrainSet {
        /** 识别用索引 */
        id: number;
        private _terrainBatchMode;
        set terrainPatchMode(value: TileMapTerrainMode);
        get terrainPatchMode(): TileMapTerrainMode;
        _neighbors: TileMapCellNeighbor[];
        updateShape(shape: TileShape): void;
        private _terrains;
        getTerrain(id: number): TileSetTerrain;
        get terrains(): TileSetTerrain[];
        set terrains(value: TileSetTerrain[]);
    }
    class TileSetTerrain {
        name: string;
        color: Color;
        id: number;
    }
    /**
     * 2D灯光遮挡器（遮光器）
     */
    class TileMapOccluder {
        private _core;
        owner: Sprite;
        /**
         * @en the layer mask
         * @zh 遮光器层遮罩（遮光器影响哪些层）
         */
        get layerMask(): number;
        set layerMask(value: number);
        set manager(value: Light2DManager);
        /**
         * @en Can in light boolean value
         * @zh 灯光在内部时是否挡光
         */
        get canInLight(): boolean;
        set canInLight(value: boolean);
        /**
         * @en polygon endpoint data
         * @zh 边形端点数据
         */
        get polygonPoint(): PolygonPoint2D;
        set polygonPoint(value: PolygonPoint2D);
        /**
        * @en Only outside shadow the light
        * @zh 是否只是外圈遮挡光线
        */
        get outside(): boolean;
        set outside(value: boolean);
        constructor();
        _onEnable(): void;
        _onDisable(): void;
        /**
          * 销毁
          */
        destroy(): void;
    }
    class TileMapDatasParse {
        static read(buffer: ArrayBuffer): {
            x: number;
            y: number;
            length: number;
            tiles: number[];
        }[];
    }
    /**
     * 矩形裁切器
     * 用于裁切矩形区域，判断一个平行四边形是否在矩形区域内
     * 原理： 分离轴定理
     */
    class RectClipper {
        private _clipperRect;
        private _polygonSize;
        private _polygonTransform;
        private _ploygRect;
        private _matrix;
        private _axis;
        private _rectDatas;
        private _polygons;
        private _polygonW;
        private _polygonH;
        constructor();
        private _mrgePoint;
        private _updateCliperInPolygonRect;
        private _updateAxiDatas;
        private _updateClipRect;
        private _updatePolygonSize;
        private _updatePolygonTransform;
        getploygRect(): Vector4;
        /**
         * 设置裁切区域数据
         * @param clipperRect 裁切区域矩形（相对于世界的参数） pixel
         * @param size 测试区域大小 pixel
         * @param matrix 测试区域转世界矩阵
         * @returns pixel
         */
        setClipper(clipperRect: Rectangle, size: Vector2, matrix: Matrix, ofx?: number, ofy?: number, clipperRot?: number): Vector4;
        isClipper(x: number, y: number): boolean;
    }
    class TileMapShaderInit {
        /**
         * @internal
         */
        static _tileMapPositionUVColorDec: VertexDeclaration;
        /**
         * @internal
         */
        static _tileMapCellColorInstanceDec: VertexDeclaration;
        /**
         * @internal
         */
        static _tileMapCellPosScaleDec: VertexDeclaration;
        /**
         * @internal
         */
        static _tileMapCellUVOriScaleDec: VertexDeclaration;
        /**
         * @internal
         */
        static _tileMapCellUVTrans: VertexDeclaration;
        static __init__(): void;
    }
    class TileMapTerrain {
        static fillConnect(tileMapLayer: TileMapLayer, list: IV2[], terrainSetId: number, terrainId: number, ignoreEmpty?: boolean): Map<TTerrainVector2, TerrainsParams>;
        private static getReady2FillRule;
        /** @internal */
        private static _fillRules;
        /**
         *  @internal
         *  按这个块本身是否匹配，这个块周围是否匹配，不匹配就加分，取分值最小的地块
         */
        private static _getBestTerrainParams;
        /** @internal */
        private static _getRulesByParams;
    }
    class TerrainsParams {
        terrainSet: number;
        terrain: number;
        terrain_peering_bits: number[];
        links: Set<TileSetCellData>;
        _debugs: string[];
        private _modified;
        private _arr;
        link(cellData: TileSetCellData): void;
        get arr(): TileSetCellData[];
        /**
         * @internal
         */
        _getDebugs(): void;
        clearLinks(): void;
    }
    type TTerrainVector2 = {
        x: number;
        y: number;
        chunkX?: number;
        chunkY?: number;
        index?: number;
    };
    type NeighborObject = {
        getNeighborGird: (x: number, y: number, neighbor: TileMapCellNeighbor, out: IV2) => void;
        getRuleInfo: (rule: TileMapTerrainRule, neighbor: TileMapCellNeighbor) => void;
        getOverlap: (x: number, y: number, data: number, vec2Map: TerrainVector2Set, outs: Map<TTerrainVector2, TileMapCellNeighbor>) => void;
        neighbors: Map<TileMapTerrainMode, TileMapCellNeighbor[]>;
        links: TileMapCellNeighbor[];
    };
    class TileMapTerrainUtil {
        static shape_mode_map: Map<TileShape, NeighborObject>;
        /** @internal */
        private static initSquare;
        /** @internal */
        private static initIsometric;
        /** @internal */
        private static initHalfOffset;
        /** @internal */
        static __init__(): void;
        static temp_vec2: Vector2;
        static temp_vec3: Vector3;
        static getNeighborObject(shape: TileShape): NeighborObject;
        static getNeighborGird_Isometric(x: number, y: number, neighbor: TileMapCellNeighbor, out: IV2): void;
        static getNeighborGird_Square(x: number, y: number, neighbor: TileMapCellNeighbor, out: IV2): void;
        static getNeighborGird_HalfOffset(x: number, y: number, neighbor: TileMapCellNeighbor, out: IV2): void;
        static getRuleInfo_Square(rule: TileMapTerrainRule, neighbor: TileMapCellNeighbor): void;
        static getRuleInfo_Isometric(rule: TileMapTerrainRule, neighbor: TileMapCellNeighbor): void;
        static getRuleInfo_HalfOffset(rule: TileMapTerrainRule, neighbor: TileMapCellNeighbor): void;
        static getOverlap_Square(x: number, y: number, data: number, vec2Map: TerrainVector2Set, outs: Map<TTerrainVector2, TileMapCellNeighbor>): void;
        static getOverlap_Isometric(x: number, y: number, data: number, vec2Map: TerrainVector2Set, outs: Map<TTerrainVector2, TileMapCellNeighbor>): void;
        static getOverlap_HalfOffset(x: number, y: number, data: number, vec2Map: TerrainVector2Set, outs: Map<TTerrainVector2, TileMapCellNeighbor>): void;
        static getChunkCellInfo(layer: TileMapLayer, vec2: TTerrainVector2): ChunkCellInfo;
    }
    class TileMapTerrainRule {
        data: number;
        x: number;
        y: number;
        terrain: number;
        neighborObject: NeighborObject;
        priority: number;
        constructor(x: number, y: number, terrain: number, neighborObject: NeighborObject);
        setCellNeighbor(cellNeighbor: TileMapCellNeighbor): void;
        clone(): TileMapTerrainRule;
    }
    abstract class Vector2LikeSet<T extends IV2> {
        /** 无序表 */
        map: any;
        /** 快速查找 */
        list: T[];
        abstract add(ele: T): T;
        abstract get(...argv: (number | boolean | T)[]): T;
        abstract delete(...argv: (number | boolean | T)[]): T;
    }
    class TerrainRuleSet extends Vector2LikeSet<TileMapTerrainRule> {
        /** 无序表 */
        map: TileMapTerrainRule[][][];
        add(ele: TileMapTerrainRule): TileMapTerrainRule;
        get(x: number, y: number, data: number): TileMapTerrainRule;
        delete(x: number, y: number, data: number): TileMapTerrainRule;
    }
    class TerrainVector2Set extends Vector2LikeSet<TTerrainVector2> {
        /** 无序表 */
        map: TTerrainVector2[][];
        /** 快速查找 */
        list: TTerrainVector2[];
        add(ele: TTerrainVector2): TTerrainVector2;
        get(x: number, y: number, create?: boolean): TTerrainVector2;
        delete(x: number, y: number): TTerrainVector2;
    }
    enum TileAnimationMode {
        DEFAULT = 0,
        RANDOM_START_TIMES = 1
    }
    /**
     * 模板数据
     * 定义一个 tile 各种样式
     */
    class TileAlternativesData {
        /** @internal */
        _tileDatas: Record<number, TileSetCellData>;
        /** @internal */
        _owner: TileSetCellGroup;
        /** Base Data 瓦片在group中的位置 uint int */
        private _localPos;
        /** group中单位大小 uint int */
        private _sizeByAtlas;
        /** uv 原点,瓦片正中心的uv值 */
        private _uvOri;
        /** uv范围 0- 1 */
        private _uvExtends;
        /** 实际区域大小 */
        private _regionSize;
        private _animation_columns;
        private _animation_separation;
        private _animation_speed;
        private _animationNode;
        private _animationFrams;
        private _totalAnimatorTime;
        private _animationFramsTime;
        private _frameIndex;
        private _animatorUpdateMask;
        /** @private */
        nativeId: number;
        /**
         * 格子的位置
         */
        get localPos(): Vector2;
        set localPos(value: Vector2);
        /**
         * 格子的大小
         */
        get sizeByAtlas(): Vector2;
        set sizeByAtlas(value: Vector2);
        get owner(): TileSetCellGroup;
        set owner(value: TileSetCellGroup);
        /**
         * 格子的备份数据IDE todo?
         */
        get tileDatas(): Record<number, TileSetCellData>;
        set tileDatas(value: Record<number, TileSetCellData>);
        get animation_columns(): number;
        set animation_columns(value: number);
        get animation_separation(): Vector2;
        set animation_separation(value: Vector2);
        get animation_speed(): number;
        set animation_speed(value: number);
        get animationMode(): TileAnimationMode;
        set animationMode(value: TileAnimationMode);
        set animationFrams(frams: number[]);
        get animationFrams(): number[];
        constructor();
        /**
         * @internal
         */
        _initialIndexFIrstCellData(): void;
        /**
         * @internal
         */
        _hasAni(): boolean;
        /**
         * @internal
         */
        _init(): void;
        /**
         * @internal
         */
        _updateOriginUV(x: number, y: number, data: number): void;
        /**
         * @internal
         */
        _getTextureUVOri(): Vector2;
        /**
         * @internal
         */
        _getTextureUVExtends(): Vector2;
        /**
         * @internal
         */
        _getRegionSize(): Vector2;
        /**
         * @internal
         */
        _updateAnimator(): void;
        getCelldata(index: number): TileSetCellData;
        removeCellData(index: number): void;
        addCellData(index: number): TileSetCellData;
        destroy(): void;
    }
    /**
     * @internal
     * TileMapChunk 瓦片地图块与渲染块之间的转换
     * 因为瓦片地图是无限的；因此 Chunk 也是无限的；
     * 瓦块的坐标是相对原点的，而一个Chunk的坐标是相对于瓦块的;
     * 一个Chunk 内部的单元格索引从左到右，从上到下计算
     */
    class TileMapChunk {
        private _grid;
        private _chunkWidth;
        private _chunkHeight;
        private _maxCell;
        constructor(grid: Grid);
        /**
         * 获得一个块内格子的最大数量
         */
        get maxCell(): number;
        /**
         * @internal
         * 设置chunk的宽高
         * @param width 设置块的列数
         * @param height 设置块的行数
         */
        _setChunkSize(width: number, height: number): void;
        /**
         * @internal
         * 将像素单位转换相应cell对应的ChunckLocal位置以及ChunckLocalIndex
         * @param pixelx  像素单位x
         * @param pixely  像素单位y
         * @param out 输出 x chunk列坐标 y chunk行坐标 z Chunk内部索引
         */
        _getChunkPosByPixel(pixelx: number, pixely: number, out: Vector3): void;
        /**
         * 根据cell坐标找到对应Chuck位置以及cell在chunck中的index
         * @param x 单元格x索引
         * @param y 单元格y索引
         * @param out 输出 x chunk列坐标 y chunk行坐标 z Chunk内部索引
         */
        _getChunkPosByCell(cellRow: number, cellCol: number, out: Vector3): void;
        /**
         * 获得cell 在chunk内部的索引 从第一行第一列开始计数，从左到右，从上到下计算
         * @param cellRow 单元格的列索引
         * @param cellCol 单元格的行索引
         * @returns 单元格在chunk内部的索引
         */
        _getChunkIndexByCellPos(cellRow: number, cellCol: number): number;
        /**
         * 通过块的行列索引和块内部的索引获得单元格的行列索引
         * @param chunkx 块的列索引
         * @param chunky 块的行索引
         * @param index 块内部的索引
         * @param out 输出单元格的行列索引
         */
        _getCellPosByChunkPosAndIndex(chunkx: number, chunky: number, chunklocalindex: number, out: Vector2): void;
        _getPixelByChunkPosAndIndex(chunkx: number, chunky: number, chunklocalindex: number, out: Vector2): void;
        /**
         * @internal
         * 获得块的像素宽高
         * @param out 输出块的像素宽高
         */
        _getChunkSize(out: Vector2): void;
        /**
         * @internal
         * 获得块的左上角像素坐标
         */
        _getChunkLeftTop(chunkx: number, chunky: number, out: Vector2): void;
    }
    interface IMergeCellInfo {
        cell: TileSetCellData;
        transFlag: number;
    }
    class ChunkCellInfo {
        cell: TileSetCellData;
        chuckLocalindex: number;
        zOrderValue: number;
        cellx: number;
        celly: number;
        _physicsDatas: any[];
        _occluderDatas: TileMapOccluder[];
        _renderElementIndex: number;
        _cellPosInRenderData: number;
        /** 位操作 2 旋转 3 翻转h  4翻转v 5 斜角 transpose */
        _transFlag: number;
        updateTransFlag: boolean;
        constructor();
    }
    /**
     * 用来处理各项数据
     */
    class TileMapChunkData {
        static instanceColorBufferIndex: number;
        static instanceposScalBufferIndex: number;
        static instanceuvOriScalBufferIndex: number;
        static instanceuvTransBufferIndex: number;
        private _reCreateRenderData;
        /**
         * Key1 cellData GID
         * Value chuckLocalIndex[],同时计算引用
         */
        private _cellDataRefMap;
        private _refGids;
        /**
         * 帧处理cell数据更新
         * 0 render , 1 physics 3 light
         * Key1 cellData GID ----
         * value dirtyFlag
         */
        private _dirtyFlags;
        /**
         * @internal
         */
        private _transFlags;
        /**
         * 缓存chuckCellInfo数据
         * Key1 chuckLocalIndex
         * value ChunkCellInfo
         */
        private _cellDataMap;
        /** @internal 用于排序的列表 */
        _chuckCellList: ChunkCellInfo[];
        private _renderElementArray;
        private _animatorAlterArray;
        _tileLayer: TileMapLayer;
        /** 左上角格子chunk xy 坐标 */
        private _oriCellIndex;
        private _gridShape;
        private _tileSize;
        private _sortMode;
        /** @private Editor */
        _material: Material;
        /**
         * 渲染块 x 坐标
         */
        chunkX: number;
        /**
         * 渲染块 y 坐标
         */
        chunkY: number;
        private _rigidBody;
        /**
         * @internal
         */
        _needUpdateRange: boolean;
        private _range;
        constructor();
        /** @internal */
        get cellDataRefMap(): number[][];
        /**
         * @internal
         * @deprecated
         * 危险操作
         */
        set cellDataRefMap(data: number[][]);
        /**
         * 获取使用得压缩数据
         */
        get compressData(): Record<number, number[]>;
        /**
         * 危险操作
         * @internal
         */
        set compressData(value: Record<number, number[]>);
        get transFlags(): Record<number, number>;
        set transFlags(value: Record<number, number>);
        /** @internal */
        _parseCellDataRefMap(): void;
        /**
         * @internal
         * 将数据合并到二维map中
         */
        _mergeBuffer(datas: Map<number, Map<number, IMergeCellInfo>>, minRange: Vector2, maxRange: Vector2): void;
        _setBuffer(datas: Map<number, Map<number, IMergeCellInfo>>, minRange: Vector2, maxRange: Vector2, tileSize: number): number;
        _updateChunkData(chunkX: number, chunkY: number): void;
        private _upeateGridData;
        private _updateRenderData;
        private _updatePhysicsData;
        private _updateLightShadowData;
        private _updateNavigationData;
        private _breakBatch;
        private _createRenderElement;
        private _clearRenderElement;
        /**
         * @internal
         * @param datas 渲染数据
         */
        _setRenderData(datas: {
            x: number;
            y: number;
            length: number;
            tiles: number[];
        }): void;
        /**
         * @internal
         * 清理引用格子的数据
         */
        _clearnRefTileCellData(): void;
        _clearAllChunkCellInfo(): void;
        /**
         * @internal
         */
        _update(): void;
        /**
         * @internal
         */
        _getCellPos(sheetCell: ChunkCellInfo, out: Vector2): void;
        /**
         * @internal
         * 合并到渲染列表
         */
        _mergeToElement(renderElements: IRenderElement2D[]): void;
        /**
         * @internal
         * 更新一个格子
         * @param index local chunck index
         * @param gid cellData
         * @param transFlag 位操作
         */
        _setCell(index: number, cellData: TileSetCellData, transFlag: number): void;
        private _clearChunkCellInfo;
        /**
         * @internal
         */
        _removeCell(index: number): void;
        _modifyData(): void;
        getRange(): Rectangle;
        /**
         * 根据四种形状计算包围盒
         */
        private _calculateRange;
        /**
         * 根据localIndex 获取CellData数据
         * @param index
         * @returns
         */
        getCell(index: number): ChunkCellInfo;
        /**
         * tileSetCellData 删除或者无效
         * @internal
         */
        _clearOneCell(cell: TileSetCellData): void;
        /**
         * @internal
         */
        _setDirtyFlag(gid: number, flag: TileMapDirtyFlag, type?: DirtyFlagType): void;
        /**
         * @internal
         */
        _forceUpdateDrity(flags: boolean[]): void;
        /**
         * @internal
         */
        _clearCell(): void;
        /**
         * @internal
         */
        _destroy(): void;
        /**
         * debug
         * @param sprite
         * @param points
         */
        _debugDrawLines(sprite: Sprite, points: number[]): void;
    }
    enum TileMapCellNeighbor {
        RIGHT_SIDE = 0,
        RIGHT_CORNER = 1,
        BOTTOM_RIGHT_SIDE = 2,
        BOTTOM_RIGHT_CORNER = 3,
        BOTTOM_SIDE = 4,
        BOTTOM_CORNER = 5,
        BOTTOM_LEFT_SIDE = 6,
        BOTTOM_LEFT_CORNER = 7,
        LEFT_SIDE = 8,
        LEFT_CORNER = 9,
        TOP_LEFT_SIDE = 10,
        TOP_LEFT_CORNER = 11,
        TOP_SIDE = 12,
        TOP_CORNER = 13,
        TOP_RIGHT_SIDE = 14,
        TOP_RIGHT_CORNER = 15,
        MAX = 16
    }
    enum TileMapTerrainMode {
        MATCH_CORNERS_AND_SIDES = 0,
        MATCH_CORNERS = 1,
        MATCH_SIDES = 2
    }
    enum TileShape {
        TILE_SHAPE_SQUARE = 0,
        TILE_SHAPE_ISOMETRIC = 1,
        TILE_SHAPE_HALF_OFFSET_SQUARE = 2,
        TILE_SHAPE_HEXAGON = 3
    }
    enum TileLayerSortMode {
        YSort = 0,
        ZINDEXSORT = 1,
        XSort = 2
    }
    enum TileMapDirtyFlag {
        CELL_CHANGE = 1,
        CELL_COLOR = 2,
        CELL_QUAD = 4,
        CELL_QUADUV = 8,
        CELL_UVTRAN = 16,
        CELL_PHYSICS = 32,
        CELL_TERRAIN = 64,
        CELL_LIGHTSHADOW = 128,
        CELL_NAVIGATION = 256,
        CELL_SORTCHANGE = 512,
        TILESET_SAZE = 1024,
        LAYER_COLOR = 2048,
        LAYER_PHYSICS = 4096
    }
    enum DirtyFlagType {
        ALL = -1,
        RENDER = 0,
        PHYSICS = 1,
        OCCLUSION = 2
    }
    const DIRTY_TYPES = 3;
    enum TILEMAPLAYERDIRTYFLAG {
        CELL_CHANGE = 1,
        CELL_COLOR = 2,
        CELL_QUAD = 4,
        CELL_QUADUV = 8,
        CELL_UVTRAN = 16,
        CELL_PHYSICS = 32,
        CELL_TERRAIN = 64,
        CELL_LIGHTSHADOW = 128,
        CELL_NAVIGATION = 256,
        CELL_SORTCHANGE = 512,
        TILESET_SAZE = 1024,
        LAYER_COLOR = 2048,
        LAYER_PHYSICS = 4096
    }
    class TileMapLayer extends BaseRenderNode2D {
        private static _inited;
        /**
         * @internal
         * @returns
         */
        static __init__(): void;
        private _tileSet;
        /**
         * @internal
         * 工具类；用于计算格子所在的大块
         */
        _chunk: TileMapChunk;
        /**
         * @internal
         * 工具类；实现像素坐标和格子坐标的转换
         */
        _grid: Grid;
        readonly owner: Sprite;
        /**
         * @internal
         */
        _cliper: RectClipper;
        private _layerColor;
        private _sortMode;
        private _renderTileSize;
        private _navigationEnable;
        private _physicsEnable;
        private _lightOccluderEnable;
        private _tileMapDatas;
        private _chunkDatas;
        /**物理模块 */
        private _tileMapPhysics;
        private _tileMapOccluder;
        /** @internal */
        _needUpdateDirtys: boolean[];
        /** @internal */
        get chunkDatas(): Record<number, Record<number, TileMapChunkData>>;
        set chunkDatas(datas: Record<number, Record<number, TileMapChunkData>>);
        get layerColor(): Color;
        set layerColor(value: Color);
        get sortMode(): TileLayerSortMode;
        set sortMode(value: TileLayerSortMode);
        get navigationEnable(): boolean;
        set navigationEnable(value: boolean);
        get physicsEnable(): boolean;
        set physicsEnable(value: boolean);
        get lightOccluderEnable(): boolean;
        set lightOccluderEnable(value: boolean);
        get tileSet(): TileSet;
        set tileSet(value: TileSet);
        get renderTileSize(): number;
        /**
         * @en The size of the chunk, when set, it will recalculate the range of all tiles.
         * @param value how many tiles in a chunk.
         * @zh 设置chunk 的尺寸,当设置后会重新计算所有格子的范围
         * @param value 一个chunk 多少格子
         */
        set renderTileSize(value: number);
        get tileMapDatas(): Uint8Array;
        set tileMapDatas(value: Uint8Array);
        get tileMapPhysics(): TileMapPhysics;
        get tileMapOccluder(): TileMapOccluderAgent;
        /**
         * @ignore
         */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        private _initialTileSet;
        /**
         * 修改renderTileSize 会触发此函数
         * 将所有的 TileMapChunkData 合并到一个二维表格中；同时计算所有格子的范围
         * 根据范围重新生成 TileMapChunkData
         */
        private _updateChunkData;
        /**
         * @internal
         */
        _updateMapDatas(): void;
        /**
         * @internal
         * @param tile
         */
        _setLayerDataByPos(tile: TileMapChunkData): void;
        /**
         * @internal
         */
        _getLayerDataTileByPos(chunkX: number, chunkY: number): TileMapChunkData;
        onAwake(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _globalChangeHandler(): void;
        /**
         * @internal
         * @returns
         */
        _globalTransfrom(): Matrix;
        /**
         * @internal
         * cmd run时调用，可以用来计算matrix等获得即时context属性
         * @param context
         * @param px
         * @param py
         */
        addCMDCall(px: number, py: number): void;
        get rect(): Vector4;
        /**
         * 计算所有chunkdata的包围盒合并到layer
         * @private
         */
        private _calculateLayerRect;
        /**
         * 根据相机和设置做裁剪;更新所有格子的渲染数据
         * @param context
         */
        renderUpdate(context: IRenderContext2D): void;
        /**
         * 添加一个格子
         * @param x 横向坐标
         * @param y 纵向坐标
         * @param cellData 格子数据
         * @param isPixel 是否是像素坐标 true: 像素坐标 false: 格子坐标
         * @param rotateCount 旋转次数
         * @param flipH 水平翻转
         * @param flipV 垂直翻转
         * @param transpose 斜角翻转
         */
        setCellData(x: number, y: number, cellData: TileSetCellData, isPixel?: boolean, rotateCount?: number, flipH?: boolean, flipV?: boolean, transpose?: boolean): void;
        /**
         * 添加一个格子
         * @param x 横向坐标
         * @param y 纵向坐标
         * @param cellData 格子数据
         * @param transFlag 位操作
         * @param isPixel 是否是像素坐标 true: 像素坐标 false: 格子坐标
         */
        _setCellData(x: number, y: number, cellData: TileSetCellData, transFlag?: number, isPixel?: boolean): void;
        /**
         * 获取一个CellData数据
         * @param x
         * @param y
         * @param isPixel 是否是像素坐标 true: 像素坐标 false: 格子坐标
         */
        getCellData(x: number, y: number, isPixel?: boolean): ChunkCellInfo;
        /**
         * 移除一个格子
         * @param x 横向坐标
         * @param y 纵向坐标
         * @param isPixel 是否是像素坐标 true: 像素坐标 false: 格子坐标
         */
        removeCell(x: number, y: number, isPixel?: boolean): void;
        /**
        * 像素系统转格子系统
        */
        pixelToGrid(pixelX: number, pixelY: number, out: Vector2): void;
        /**
         * 格子系统转像素系统
         */
        gridToPixel(cellRow: number, cellCol: number, out: Vector2): void;
        getDefalutMaterial(texture: Texture2D): Material;
    }
    /**
     * @en TileMap occluder manager.
     * Manages and maintains occluders for the TileMap layer, providing unified interfaces for adding and removing occluders.
     * @zh 瓦片地图遮光器管理器。
     * 负责管理和维护瓦片地图层的遮光器，提供统一的添加和移除接口。
     */
    class TileMapOccluderAgent {
        /** 当前绑定的TileMap层 */
        private _layer;
        private _manager;
        /**
         * @en Whether the occlusion function is enabled.
         * @zh 遮光功能是否启用。
         */
        enable: boolean;
        private _occluders;
        /**
         * @en Create a TileMap occluder manager.
         * @param layer The associated TileMap layer.
         * @zh 创建 TileMap 遮光器管理器。
         * @param layer 关联的 TileMap 层级。
         */
        constructor(layer: TileMapLayer);
        /**
         * @en Update the Light2D manager instance.
         * @zh 更新 Light2D 管理器实例。
         */
        _updateManager(): void;
        /**
         * @en Update the occlusion state.
         * @param bool The new state to set.
         * @zh 更新遮光状态。
         * @param bool 要设置的新状态。
         */
        updateState(bool: boolean): void;
        /**
         * @en Enable all occluders
         * @zh 激活所有遮光器
         */
        enableAllOccluders(): void;
        /**
         * @en Disable all occluders
         * @zh 禁用所有遮光器
         */
        disableAllOccluders(): void;
        /**
         * @en Remove all occluders.
         * @zh 移除所有遮光器。
         */
        _removeAllOccluders(): void;
        /**
         * @en Add an occluder.
         * @param poly The occlusion polygon points.
         * @param layerMask The occlusion layer mask.
         * @returns Returns the occluder instance.
         * @zh 添加一个遮光器。
         * @param poly 遮光多边形顶点数组。
         * @param layerMask 遮光层掩码。
         * @returns 返回遮光器实例。
         */
        addOccluder(poly: PolygonPoint2D, layerMask: number): TileMapOccluder;
        /**
         * @en Remove the specified occluder.
         * @param occluder The occluder instance to remove.
         * @returns Returns whether the removal was successful.
         * @zh 移除指定的遮光器。
         * @param occluder 要移除的遮光器实例。
         * @returns 是否成功移除。
         */
        removeOccluder(occluder: TileMapOccluder): boolean;
        /**
         * @en Destroy all occluders.
         * @zh 清理所有遮光器。
         */
        destroy(): void;
    }
    /**
     * @ignore
     * 瓦片地图物理
     */
    class TileMapPhysics {
        private static _tempDef;
        static __init__(): void;
        private _layer;
        /**
         * 是否启动了物理
         */
        enable: boolean;
        _rigidBodys: any[];
        constructor(layer: TileMapLayer);
        updateState(bool: boolean): void;
        createRigidBody(): any;
        enableRigidBodys(): void;
        disableRigidBodys(): void;
        _enableRigidBody(rigidBody: any): void;
        _disableRigidBody(rigidBody: any): void;
        destroyRigidBody(rigidBody: any): void;
        /** 创建Shape */
        createFixture(rigidBody: any, layer: TileSetPhysicsLayer, data: number[]): any;
        /** @internal */
        _updateTransfrom(): void;
        /**
         * 移除物理形状
         */
        destroyFixture(rigidBody: any, fixture: any): void;
        destroy(): void;
    }
    class TileMapUtils {
        private static CACHE_UVs;
        static getRotateCount(transFlag: number): number;
        static getFlipH(transFlag: number): boolean;
        static getFlipV(transFlag: number): boolean;
        static getTranspose(transFlag: number): boolean;
        static parseCellIndex(gid: number): number;
        static parseGroupId(gid: number): number;
        static parseNativeIndex(gid: number): number;
        static getNativeId(groupId: number, index: number): number;
        static getGid(cellindex: number, nativeId: number): number;
        static quickFoundIndex(array: number[], value: number): number;
        static getRotateAngle(rotateCount: number, tileShape: TileShape): number;
        /**
         * 获得transFlag
         * @param rotateCount 旋转次数
         * @param flip_h 水平翻转
         * @param flip_v 垂直翻转
         * @param transpose 斜角翻转
         * @returns
         */
        static getTransFlag(rotateCount: number, flip_h: boolean, flip_v: boolean, transpose: boolean): number;
        static parseTransFlag(tileshape: TileShape, transFlag: number, cellData: TileSetCellData): Vector4;
        /**
        * 对格子进行uv翻转
        * 先做45度斜角翻转，然后再做水平或者垂直翻转,最后再旋转 (六边形旋转每次旋转60度，四边形旋转每次旋转90度)
        * @param flip_h 水平翻转
        * @param flip_v 垂直翻转
        * @param transpose 斜角翻转
        * @param rountCount 旋转次数
        */
        static getUvRotate(tileshape: TileShape, flip_h?: boolean, flip_v?: boolean, transpose?: boolean, rountCount?: number, out?: Vector4): Vector4;
        static transfromPointByValue(matrix: Matrix, x: number, y: number, point: Vector2): void;
        static transfromPointNByValue(matrix: Matrix, x: number, y: number, point: Vector2): void;
        static getCellDataIndex(nativeData: TileAlternativesData): number;
    }
    class TileSet extends Resource {
        private _tileShape;
        private _tileSize;
        private _physicsLayers;
        private _terrainSets;
        private _navigationLayers;
        private _customDataLayers;
        private _lightOcclusion;
        private _groups;
        private _groupIds;
        private _defalutMaterials;
        private _ownerList;
        private _terrainsDirty;
        private _paramsLists;
        constructor();
        /**
         * 设置瓦片的形状
         *
         */
        get tileShape(): TileShape;
        set tileShape(value: TileShape);
        /**
         * 获取瓦片的像素大小
         */
        get tileSize(): Vector2;
        set tileSize(value: Vector2);
        protected _disposeResource(): void;
        getCellDataByGid(gid: number): TileSetCellData;
        _addOwner(tilemapLayer: TileMapLayer): void;
        _removeOwner(tilemapLayer: TileMapLayer): void;
        _notifyTileSetCellGroupsChange(): void;
        /**
         * TODO 改成事件？
         * @internal
         */
        private _notifyCustomDataLayerChange;
        /**
         * @internal
         */
        private _notifyRenderLayerChange;
        /**
         * @internal
         */
        private _notifyTerrainSetChange;
        /**
         * @internal
         */
        private _notifyNavigationLayerChange;
        /**
         * @internal
         */
        private _notifyPhysicsLayerChange;
        addTileSetCellGroup(resource: TileSetCellGroup): void;
        getTileSetCellGroup(id: number): TileSetCellGroup;
        removeTileSetCellGroup(id: number): void;
        get customLayers(): TileSetCustomDataLayer[];
        set customLayers(value: TileSetCustomDataLayer[]);
        addCustomDataLayer(layer: TileSetCustomDataLayer): boolean;
        getCustomDataLayer(name: string): TileSetCustomDataLayer;
        removeCustomDataLayer(name: string): TileSetCustomDataLayer;
        get navigationLayers(): TileMapNavigationLayer[];
        set navigationLayers(value: TileMapNavigationLayer[]);
        addNavigationLayers(layer: TileMapNavigationLayer): void;
        getNavigationLayers(id: number): TileMapNavigationLayer;
        removeNavigationLayers(id: number): void;
        get lightInfoLayers(): TileSetOcclusionLayer[];
        set lightInfoLayers(value: TileSetOcclusionLayer[]);
        addLightInfoLayer(layer: TileSetOcclusionLayer): boolean;
        getLightInfoLayer(id: number): TileSetOcclusionLayer;
        removeLightInfoLayer(id: number): TileSetOcclusionLayer;
        get physicsLayers(): TileSetPhysicsLayer[];
        set physicsLayers(value: TileSetPhysicsLayer[]);
        addPhysicsLayer(layer: TileSetPhysicsLayer): boolean;
        getPhysicsLayer(id: number): TileSetPhysicsLayer;
        removePhysicsLayer(id: number): TileSetPhysicsLayer;
        private _addLayer;
        private _getLayer;
        private _removeLayer;
        get terrainSets(): TileSetTerrainSet[];
        set terrainSets(value: TileSetTerrainSet[]);
        addTerrainSet(set: TileSetTerrainSet): void;
        getTerrainSet(id: number): TileSetTerrainSet;
        removeTerrainSet(id: number): TileSetTerrainSet;
        updateTerrains(): void;
        _getParamsList(terrainSet: number): TerrainsParams[][];
        private _clearTerrainParams;
        private addTerrainParams;
        private _addTerrainParams;
        private _addEmptyParams;
        /**
         * @param texture 对象
         * @returns 获取实例
         */
        getDefalutMaterial(texture: Texture2D): Material;
    }
    class TileSetCellOcclusionInfo {
        shape: number[];
    }
    class TileSetCellPhysicsInfo {
        shape: number[];
    }
    class TileSetCellNavigationInfo {
        shape: number[];
    }
    /**
     * TileMap中一个Cell的数据结构
     */
    class TileSetCellData {
        /** @internal */
        static _EMPTY: TileSetCellData;
        private _index;
        private _cellowner;
        private _flip_h;
        private _flip_v;
        private _transpose;
        private _rotateCount;
        private _transChange;
        private _transFlag;
        private _texture_origin;
        private _material;
        private _colorModulate;
        private _z_index;
        private _y_sort_origin;
        private _lightOccluderDatas;
        private _navigationDatas;
        private _physicsDatas;
        private _customDatas;
        private _terrainSet;
        private _terrain;
        private _terrain_peering_bits;
        private _notiveRenderTile;
        private _probability;
        private _destroyed;
        gid: number;
        get index(): number;
        get transFlag(): number;
        /**
         * 原始顶点图块的引用
         */
        get cellowner(): TileAlternativesData;
        set cellowner(value: TileAlternativesData);
        /**
         *  是否水平翻转
         */
        get flip_h(): boolean;
        set flip_h(value: boolean);
        /**
         * 是否垂直翻转
         */
        get flip_v(): boolean;
        set flip_v(value: boolean);
        get transpose(): boolean;
        /**
         * 是否转置
         */
        set transpose(value: boolean);
        /**
         * 旋转次数
         */
        get rotateCount(): number;
        set rotateCount(value: number);
        /**
         * 贴图原点
         */
        get texture_origin(): Vector2;
        set texture_origin(value: Vector2);
        /**
         * 材质
         */
        get material(): Material;
        set material(value: Material);
        /**
         * 颜色
         */
        get colorModulate(): Color;
        set colorModulate(value: Color);
        /**
         * 生成地形时概率
         */
        get probability(): number;
        set probability(value: number);
        /**
         * z_index
         */
        get z_index(): number;
        set z_index(value: number);
        get y_sort_origin(): number;
        set y_sort_origin(value: number);
        get terrainSet(): number;
        set terrainSet(value: number);
        get terrain(): number;
        set terrain(value: number);
        get physicsDatas(): Record<number, TileSetCellPhysicsInfo>;
        set physicsDatas(value: Record<number, TileSetCellPhysicsInfo>);
        get lightOccluderDatas(): Record<number, TileSetCellOcclusionInfo>;
        set lightOccluderDatas(value: Record<number, TileSetCellOcclusionInfo>);
        get customDatas(): Record<number, any>;
        set customDatas(value: Record<number, any>);
        get navigationDatas(): Record<number, TileSetCellNavigationInfo>;
        set navigationDatas(value: Record<number, TileSetCellNavigationInfo>);
        constructor();
        /**
         * 初始化引用数据
         * @param owner
         * @param index
         */
        __init(owner: TileAlternativesData, index: number): void;
        _notifyDataChange(data: TileMapDirtyFlag, type: DirtyFlagType): void;
        _noticeRenderChange(): void;
        _removeNoticeRenderTile(layerRenderTile: TileMapChunkData): void;
        _addNoticeRenderTile(layerRenderTile: TileMapChunkData): void;
        set_lightOccluder(layerIndex: number, data: TileSetCellOcclusionInfo): void;
        get_lightOccluder(layerIndex: number): TileSetCellOcclusionInfo;
        set_terrainPeeringBit(index: TileMapCellNeighbor, terrainIndex: number): void;
        get_terrainPeeringBit(index: TileMapCellNeighbor): number;
        set_physicsData(layerIndex: number, data: TileSetCellPhysicsInfo): void;
        get_physicsData(layerIndex: number): TileSetCellPhysicsInfo;
        getTerrainsParams(): TerrainsParams;
        /**
         * @internal
         */
        _getTerrainPeeringBits(): number[];
        set_navigationData(layerIndex: number, data: TileSetCellNavigationInfo): void;
        get_navigationData(layerIndex: number): TileSetCellNavigationInfo;
        set_customData(name: string, value: any): void;
        get_customData(name: string): any;
        set_customDataById(id: number, value: any): void;
        get_customDataById(id: number): any;
        cloneTo(dst: TileSetCellData): void;
        destroy(): void;
    }
    class TileSetCellGroup {
        _maxAlternativesCount: number;
        private _maxCellCount;
        _owner: TileSet;
        private _atlas;
        private _atlasSize;
        private _separation;
        private _margin;
        /** cell size*/
        private _textureRegionSize;
        private _tiles;
        private _tileMatrix;
        /** 创建时固定 */
        id: number;
        name: string;
        get tiles(): Record<number, Record<number, TileAlternativesData>>;
        set tiles(value: Record<number, Record<number, TileAlternativesData>>);
        get atlas(): Texture2D;
        set atlas(value: Texture2D);
        get atlasSize(): Vector2;
        set atlasSize(value: Vector2);
        get margin(): Vector2;
        set margin(value: Vector2);
        get separation(): Vector2;
        set separation(value: Vector2);
        /**
         * 每个块的大小
         */
        get textureRegionSize(): Vector2;
        set textureRegionSize(value: Vector2);
        constructor();
        get owner(): TileSet;
        set owner(value: TileSet);
        _recaculateUVOriProperty(needNotiveCell: boolean): void;
        onAtlasSizeChange(): void;
        _getGlobalAlternativesId(x: number, y: number): number;
        _getCellPosByAlternativesId(nativeIndex: number, out: Vector2): void;
        /** 获取瓦片的像素起始点 */
        _getTilePixelOrgin(localPos: Vector2, out: Vector2): Vector2;
        _getTileUVExtends(size: Vector2, out: Vector2): Vector2;
        getAlternative(x: number, y: number): TileAlternativesData;
        addAlternaltive(x: number, y: number, sizeInAtlas: Vector2): TileAlternativesData;
        removeAlternaltive(localPos: Vector2): void;
        getCellData(localPos: Vector2, index: number): TileSetCellData;
        getCellDataByIndex(nativeIndex: number, cellIndex: number): TileSetCellData;
        removeCellData(localPos: Vector2, index: number): void;
        release(): void;
    }
    class Trail2DShaderInit {
        static init(): void;
    }
    class Trail2DRender extends BaseRenderNode2D {
        static defaultTrail2DMaterial: Material;
        private _color;
        private _baseRender2DTexture;
        private _time;
        private _widthMultiplier;
        _trailFilter: TrailBaseFilter;
        /**
         * @en Fade out time. Unit: s.
         * @zh 淡出时间。单位: 秒。
         */
        get time(): number;
        set time(value: number);
        /**
         * @en Minimum distance between new and old vertices.
         * @zh 新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        set minVertexDistance(value: number);
        /**
         * @en The width multiplier.
         * @zh 宽度倍数。
         */
        get widthMultiplier(): number;
        set widthMultiplier(value: number);
        /**
         * @en The width curve. Maximum 10.
         * @zh 宽度曲线。最多10个。
         */
        get widthCurve(): FloatKeyframe[];
        set widthCurve(value: FloatKeyframe[]);
        /**
         * @en The color gradient.
         * @zh 颜色梯度。
         */
        get colorGradient(): Gradient;
        set colorGradient(value: Gradient);
        /**
         * @en The texture mode.
         * @zh 纹理模式。
         */
        get textureMode(): TrailTextureMode;
        set textureMode(value: TrailTextureMode);
        /**
      * @en Rendering textures will not take effect if there is no UV in 2dmesh
      * @zh 渲染纹理，如果2DMesh中没有uv，则不会生效
      */
        set texture(value: BaseTexture);
        get texture(): BaseTexture;
        /**
       * @en The color of the line segment.
       * @zh 线段颜色
       */
        set color(value: Color);
        get color(): Color;
        protected _isMaterialVaild(value: Material): boolean;
        /**
         * 基于不同BaseRender的uniform集合
         * @internal
         */
        protected _getcommonUniformMap(): Array<string>;
        protected _onAdded(): void;
        private _initRender;
        onPreRender(): void;
        clear(): void;
        protected _initDefaultRenderData(): void;
        constructor();
    }
    class TrailShaderInit {
        static init(): void;
    }
    /**
     * @en Enum for trail alignment options.
     * @zh 拖尾对齐方式枚举。
     */
    enum TrailAlignment {
        /**
         * @en Align the trail to face the camera.
         * @zh 使拖尾面向摄像机。
         */
        View = 0,
        /**
         * @en Align the trail with the direction of the component
         * @zh 使拖尾与组件的方向对齐。
         */
        TransformZ = 1
    }
    /**
     * @en The TrailFilter class is used to create a trailing filter.
     * @zh TrailFilter 类用于创建拖尾过滤器。
     */
    class TrailFilter extends TrailBaseFilter {
        /**
         * @en The trail alignment.
         * @zh 轨迹准线。
         */
        alignment: TrailAlignment;
        /**@internal */
        _ownerRender: TrailRenderer;
        /** @ignore */
        constructor(owner: TrailRenderer);
        /**
         * @internal
         * @en Adds a render element to the renderer.
         * @zh 向渲染器添加渲染元素。
         */
        addRenderElement(): void;
        /**
         * @internal
         */
        _update(state: RenderContext3D): void;
    }
    /**
     * @en The `TrailMaterial` class is used to implement trail materials.
     * @zh `TrailMaterial` 类用于实现拖尾材质。
     */
    class TrailMaterial extends Material {
        /**
         * @en The default material, do not modify.
         * @zh 默认材质，禁止修改。
         */
        static defaultMaterial: TrailMaterial;
        /**@internal */
        static MAINTEXTURE: number;
        /**@internal */
        static TINTCOLOR: number;
        /**@internal */
        static TILINGOFFSET: number;
        /**
         * @internal
         */
        static __initDefine__(): void;
        /**
         * @en The color of the material.
         * @zh 材质的颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * @en The texture of the material.
         * @zh 材质贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * @en The tiling and offset of the texture.
         * @zh 纹理的平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**@ignore */
        constructor();
        /**
         * @inheritdoc
         * @override
         * @en Clones the material.
         * @returns A cloned instance of the material.
         * @zh 克隆材质。
         * @returns 材质的一个克隆实例。
         */
        clone(): TrailMaterial;
        /**
         * @deprecated
         * 渲染状态_透明混合。
         */
        static RENDERMODE_ALPHABLENDED: number;
        /**
        * @deprecated
        * 渲染状态_加色法混合。
        */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式。现在可以直接使用materialRenderMode
         */
        set renderMode(value: number);
    }
    /**
     * @en The `TrailRenderer` class is used to create a trail renderer.
     * @zh `TrailRenderer` 类用于创建拖尾渲染器。
     */
    class TrailRenderer extends BaseRender {
        /**@internal */
        _trailFilter: TrailFilter;
        /** @ignore */
        constructor();
        protected _isMaterialVaild(value: Material): boolean;
        protected _getcommonUniformMap(): Array<string>;
        protected _createBaseRenderNode(): IBaseRenderNode;
        protected _onAdded(): void;
        /**
         * @en Fade out time. Unit: s.
         * @zh 淡出时间。单位: 秒。
         */
        get time(): number;
        set time(value: number);
        /**
         * @en Minimum distance between new and old vertices.
         * @zh 新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        set minVertexDistance(value: number);
        /**
         * @en The width multiplier.
         * @zh 宽度倍数。
         */
        get widthMultiplier(): number;
        set widthMultiplier(value: number);
        /**
         * @en The width curve. Maximum 10.
         * @zh 宽度曲线。最多10个。
         */
        get widthCurve(): FloatKeyframe[];
        set widthCurve(value: FloatKeyframe[]);
        /**
         * @en The color gradient.
         * @zh 颜色梯度。
         */
        get colorGradient(): Gradient;
        set colorGradient(value: Gradient);
        /**
         * @en The texture mode.
         * @zh 纹理模式。
         */
        get textureMode(): TrailTextureMode;
        set textureMode(value: TrailTextureMode);
        /**
         * @en The trail alignment.
         * @zh 拖尾轨迹准线
         */
        get alignment(): TrailAlignment;
        set alignment(value: TrailAlignment);
        protected _onEnable(): void;
        /**
         * @en Render update.
         * @param context 3D rendering context.
         * @zh 渲染更新。
         * @param context 3D渲染上下文
         */
        renderUpdate(context: RenderContext3D): void;
        /**
         * @en The bounding box. Read-only, do not modify its value.
         * @zh 包围盒,只读,不允许修改其值。
         */
        get bounds(): Bounds;
        /**
         * @inheritDoc
         * @internal
         * @override
         */
        _calculateBoundingBox(): void;
        /**
         * @en Clear the trail.
         * @zh 清除拖尾
         */
        clear(): void;
        /**
         * @internal
         */
        protected _onDestroy(): void;
        /**
         * @internal
         * @param dest
         */
        _cloneTo(dest: TrailRenderer): void;
    }
    /**
     * @en The `TrailGeometry2` class is used to create trail rendering elements.
     * @zh `TrailGeometry2` 类用于创建拖尾渲染单元。
     */
    class TrailGeometry {
        /**
         * @en Tolerance for single-precision floating-point (float) zero.
         * @zh 单精度浮点(float)零的容差。
         */
        static zeroTolerance: number;
        /**@internal */
        static _tempVector33: Vector3;
        /**@internal */
        static _tempVector34: Vector3;
        /**@internal */
        static _tempVector35: Vector3;
        /**@internal */
        static _tempVector36: Vector3;
        /**@internal */
        _floatCountPerVertices1: number;
        /**@internal */
        private _floatCountPerVertices2;
        /**@internal */
        private _increaseSegementCount;
        /**@internal */
        private _needAddFirstVertex;
        /**@internal */
        private _isTempEndVertex;
        /**@internal 顶点出生时间*/
        private _subBirthTime;
        /**@internal 顶点间隔距离*/
        private _subDistance;
        /**@internal */
        private _segementCount;
        /**@internal 缓存数据,可以用来计算包围盒 */
        _vertices1: Float32Array;
        /**@internal */
        private _vertices2;
        /**@internal */
        private _vertexBuffer1;
        /**@internal */
        private _vertexBuffer2;
        /**@internal 上个有效点位置*/
        _lastFixedVertexPosition: Vector3;
        private tmpColor;
        /**@internal 拖尾长度 */
        _totalLength: number;
        /**@internal 顶点开始位置*/
        _activeIndex: number;
        /**@internal 顶点结束位置*/
        _endIndex: number;
        /** @private 是否需要重新计算包围盒*/
        _disappearBoundsMode: Boolean;
        /**@internal */
        _geometryElementOBj: IRenderGeometryElement;
        /** @internal */
        _bufferState: IBufferState;
        constructor();
        /**
         * @internal
         */
        private _resizeData;
        /**
         * @internal
         */
        private _resetData;
        /**
         * @internal
         * 通过起始位置添加TrailRenderElement起始数据
         */
        _addTrailByFirstPosition(position: Vector3, curtime: number): void;
        /**
         * @internal
         * @param position 当前的位置
         * @param curtime 当前时间
         * @param minVertexDistance 顶点最小距离
         * @param pointAtoBVector3 顶点扩张方向和长度
         * @param delLength 和上一个顶点的距离
         */
        _addTrailByNextPosition(position: Vector3, curtime: number, minVertexDistance: number, pointAtoBVector3: Vector3, delLength: number): void;
        /**
         * @internal
         * 通过位置更新顶点数据
         */
        private _updateVerticesByPositionData;
        /**
         * @internal
         * 通过位置更新顶点数据、距离、出生时间
         */
        private _updateVerticesByPosition;
        /**
         * @internal
         * 更新VertexBuffer2数据
         */
        _updateVertexBufferUV(colorGradient: Gradient, textureMode: TrailTextureMode, tileUnit?: number): void;
        /**
         * @internal
         */
        _updateDisappear(curtime: number, lifetime: number): void;
        /**
         * @inheritDoc
         * @internal
         * @override
         */
        _updateRenderParams(): void;
        /**
         * @inheritDoc
         * @override
         * @en Destroys the instance and releases resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
        /**
         * @en Clear.
         * @zh 清除。
         */
        clear(): void;
    }
    class TrailShaderCommon {
        /**@internal */
        static CURTIME: number;
        /**@internal */
        static LIFETIME: number;
        /**@internal */
        static WIDTHCURVE: number;
        /**@internal */
        static WIDTHCURVEKEYLENGTH: number;
        /**@internal */
        static inited: boolean;
        /**@internal */
        static attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**@internal */
        static uniformMap: {
            [name: string]: ShaderDataType;
        };
        /**@internal */
        static defaultValue: {
            [name: string]: any;
        };
        /**@internal */
        static init(): void;
    }
    /**
     * @en Trail Texture Mode
     * @zh 拖尾纹理模式
     */
    enum TrailTextureMode {
        /**
         * @en Stretch mode.
         * @zh 拉伸模式。
         */
        Stretch = 0,
        /**
         * @en Tile mode.
         * @zh 平铺模式。
         */
        Tile = 1
    }
    /**
     * @internal
     * @en The `VertexTrail` class is used to create the vertex structure for a trail.
     * @zh `VertexTrail` 类用于创建拖尾的顶点结构。
     */
    class VertexTrail {
        /**@internal */
        static TRAIL_POSITION0: number;
        /**@internal */
        static TRAIL_OFFSETVECTOR: number;
        /**@internal */
        static TRAIL_TIME0: number;
        /**@internal */
        static TRAIL_TEXTURECOORDINATE0Y: number;
        /**@internal */
        static TRAIL_TEXTURECOORDINATE0X: number;
        /**@internal */
        static TRAIL_COLOR: number;
        /**@internal */
        private static _vertexDeclaration1;
        /**@internal */
        private static _vertexDeclaration2;
        /**
         * @internal
         * @en The vertex declaration for the first set of vertex elements.
         * @zh 第一组顶点元素的顶点声明。
         */
        static get vertexDeclaration1(): VertexDeclaration;
        /**
         * @internal
         * @en The vertex declaration for the second set of vertex elements.
         * @zh 第二组顶点元素的顶点声明。
         */
        static get vertexDeclaration2(): VertexDeclaration;
        /**
         * @en The vertex declaration for this vertex structure.
         * @zh 此顶点结构的顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration;
        /**
         * @internal
         */
        static __init__(): void;
    }
    class TrailBaseFilter {
        /**@internal */
        protected _minVertexDistance: number;
        /**@internal */
        protected _widthMultiplier: number;
        /**@internal */
        protected _time: number;
        /**@internal */
        protected _widthCurve: FloatKeyframe[];
        /**@internal */
        protected _colorGradient: Gradient;
        /**@internal */
        protected _textureMode: TrailTextureMode;
        /**@internal */
        _trialGeometry: TrailGeometry;
        /**@internal */
        _lastPosition: Vector3;
        /**@internal */
        _curtime: number;
        protected _nodeShaderData: ShaderData;
        /**
             * @en Fade out time.
             * @zh 淡出时间。
             */
        get time(): number;
        set time(value: number);
        /**
         * @en Minimum distance between new and old vertices
         * @zh 新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        set minVertexDistance(value: number);
        /**
         * @en The width multiplier.
         * @zh 宽度倍数。
         */
        get widthMultiplier(): number;
        set widthMultiplier(value: number);
        /**
         * @en The width curve. The maximum number is 10.
         * @zh 宽度曲线。最多10个。
         */
        get widthCurve(): FloatKeyframe[];
        set widthCurve(value: FloatKeyframe[]);
        /**
         * @en The color gradient.
         * @zh 颜色梯度。
         */
        get colorGradient(): Gradient;
        set colorGradient(value: Gradient);
        /**
         * @en The texture mode.
         * @zh 纹理模式。
         */
        get textureMode(): TrailTextureMode;
        set textureMode(value: TrailTextureMode);
        constructor(nodeShaderData: ShaderData);
        /**
         * @internal
         * @returns
         */
        _isRender(): boolean;
        /**
         * @internal
         */
        private _initDefaultData;
        /**
         * @internal
         * @en Destroys the instance and releases resources.
         * @zh 销毁实例并释放资源。
         */
        destroy(): void;
        /**
         * @en Clears the trail.
         * @zh 清除拖尾。
         */
        clear(): void;
    }
    class CurvePath {
        private _segments;
        private _points;
        private _fullLength;
        private _cacheT;
        private _curPt;
        private _parPos;
        private _parPosCatch;
        /**
        * 0或者null为不旋转，1为沿路径曲线路径旋转，2为沿运动路径旋转
        */
        rotationType: RotationType;
        constructor();
        /**
         * @en The total length of the curve.
         * @zh 曲线的总长度。
         */
        get length(): number;
        is2D: boolean;
        /**
         * @en Create a curve.
         * @param points Point list.
         * @zh 创建一条曲线。
         * @param points 点列表。
         */
        create(...points: ReadonlyArray<PathPoint>): void;
        private createSplineSegment;
        /**
         * @en Clear the curve.
         * @zh 清空曲线。
         */
        clear(): void;
        /**
         * @en Get the rotation (tangent direction) on the curve at the specified distance.
         * Automatically detects 2D/3D data and returns appropriate rotation format.
         * For 2D data (z=0), returns Vector3(0, 0, rotationAngle).
         * For 3D data, returns Vector3(pitch, yaw, roll).
         * @param t Distance value. It should be a value between 0 and 1.
         * @param out Optional output Vector3 to store the result. If not provided, a new Vector3 will be created.
         * @returns The rotation angles in degrees representing the tangent direction at the specified point.
         * @zh 获取曲线上指定距离点的旋转角度（切线方向）。
         * 自动检测2D/3D数据并返回相应的旋转格式。
         * 对于2D数据（z=0），返回Vector3(0, 0, 旋转角度)。
         * 对于3D数据，返回Vector3(俯仰角, 偏航角, 滚转角)。
         * @param t 距离值，它应该是0到1之间的值。
         * @param out 可选的输出Vector3用于存储结果。如果未提供，将创建新的Vector3。
         * @returns 表示指定点切线方向的旋转角度（度）。
         */
        getRotationAt(t: number, out?: Vector3): Vector3;
        /**
         * @en Convert a tangent vector to Euler angles in degrees.
         * Automatically detects if the curve is 2D (z=0) or 3D and returns appropriate rotation format.
         * For 2D curves, returns Vector3(0, 0, rotationAngle).
         * For 3D curves, returns Vector3(pitch, yaw, roll).
         * @param tangent The normalized tangent vector.
         * @param out The output Vector3 to store the Euler angles (x, y, z) in degrees.
         * @zh 将切线向量转换为欧拉角（度）。
         * 自动检测曲线是2D（z=0）还是3D，并返回相应的旋转格式。
         * 对于2D曲线，返回Vector3(0, 0, 旋转角度)。
         * 对于3D曲线，返回Vector3(俯仰角, 偏航角, 滚转角)。
         * @param tangent 归一化的切线向量。
         * @param out 输出Vector3存储欧拉角（x, y, z），单位为度。
         */
        private tangentToEulerAngles;
        /**
         * @en Calculate the tangent vector at a specific point within a curve segment.
         * @param seg The curve segment.
         * @param t The parameter value within the segment (0-1).
         * @param out The output tangent vector.
         * @zh 计算曲线段内指定点的切线向量。
         * @param seg 曲线段。
         * @param t 段内的参数值（0-1）。
         * @param out 输出的切线向量。
         */
        private getTangentAtSegment;
        /**
         * @en Calculate the tangent vector for a Bezier curve at parameter t.
         * @param ptStart Starting point index in the points array.
         * @param ptCount Number of control points (3 for quadratic, 4 for cubic).
         * @param t Parameter value (0-1).
         * @param out Output tangent vector.
         * @zh 计算贝塞尔曲线在参数t处的切线向量。
         * @param ptStart 点数组中的起始点索引。
         * @param ptCount 控制点数量（二次贝塞尔为3，三次贝塞尔为4）。
         * @param t 参数值（0-1）。
         * @param out 输出切线向量。
         */
        private getBezierTangent;
        /**
         * @en Calculate the tangent vector for a CR Spline curve at parameter t.
         * @param ptStart Starting point index in the points array.
         * @param ptCount Number of control points.
         * @param t Parameter value (0-1).
         * @param out Output tangent vector.
         * @zh 计算CR样条曲线在参数t处的切线向量。
         * @param ptStart 点数组中的起始点索引。
         * @param ptCount 控制点数量。
         * @param t 参数值（0-1）。
         * @param out 输出切线向量。
         */
        private getCRSplineTangent;
        /**
         * @en Get the point on the curve at the specified distance.
         * @param t Distance value. It should be a value between 0 and 1.
         * @returns The point on the curve at the specified distance.
         * @zh 获取曲线上的指定距离的点。
         * @param t 距离值，它应该是0到1之间的值。
         * @returns 曲线上的指定距离的点。
         */
        getPointAt(t: number): Readonly<Vector3>;
        /**
         * @en Get the segment count of the curve.
         * @zh 获得曲线上的分段数。
         */
        get segmentCount(): number;
        /**
         * @en Get the anchor points of the specified segment.
         * @param segmentIndex The index of the segment.
         * @param out The array to store the result.
         * @returns The anchor points of the specified segment.
         * @zh 获取指定分段的锚点。
         * @param segmentIndex 分段的索引。
         * @param out 用于存储结果的数组。
         * @returns 指定分段的锚点。
         */
        getAnchorsInSegment(segmentIndex: number, out?: Array<Vector3>): Array<Readonly<Vector3>>;
        /**
         * @en Get the points in the specified segment.
         * @param segmentIndex The index of the segment.
         * @param t0 The start distance of the segment. It should be a value between 0 and 1.
         * @param t1 The end distance of the segment. It should be a value between 0 and 1.
         * @param outPoints The array to store the result.
         * @param outTs The array to store the distance value of each point.
         * @param pointDensity The density of the points. It means the step of distance value between two points. Default is 0.1.
         * @returns The points in the specified segment.
         * @zh 获取指定分段中的点。
         * @param segmentIndex 分段的索引。
         * @param t0 分段的起始距离值，应该是0到1之间的值。
         * @param t1 分段的结束距离值，应该是0到1之间的值。
         * @param outPoints 用于存储结果的数组。
         * @param outTs 用于存储每个点的距离值的数组。
         * @param pointDensity 点的密度，表示两个点之间的距离值的步长。默认是0.1。
         * @returns 指定分段中的点。
         */
        getPointsInSegment(segmentIndex: number, t0: number, t1: number, outPoints?: Array<Vector3>, outTs?: Array<number>, pointDensity?: number): Array<Vector3>;
        /**
         * @en Get all the points on the curve.
         * @param out The array to store the result.
         * @param outTs The array to store the distance value of each point.
         * @param pointDensity The density of the points. It means the step of distance value between two points. Default is 0.1.
         * @returns All the points on the curve.
         * @zh 获取曲线上的所有点。
         * @param out 用于存储结果的数组。
         * @param outTs 用于存储每个点的距离值的数组。
         * @param pointDensity 点的密度，表示两个点之间的距离值的步长。默认是0.1。
         * @returns 曲线上的所有点。
         */
        getAllPoints(out?: Array<Vector3>, outTs?: Array<number>, pointDensity?: number): Array<Vector3>;
        private onCRSplineCurve;
        private onBezierCurve;
        static getRotation(parPos: Vector3, currPos: Vector3): Vector3;
    }
    /**
     * @en The `Ease` class defines easing functions for Tween animations to achieve various transition effects.
     * @zh `Ease` 类定义了缓动函数，用于实现 Tween 动画的缓动效果，以便于创建各种转换效果。
     */
    var Ease: {
        /**
         * @en Define continuous motion without acceleration.
         * @zh 定义无加速持续运动。
         */
        linear: typeof linear;
        /**
         * @deprecated Use linear instead
         */
        linearNone: typeof linear;
        /**
         * @en Define continuous motion without acceleration.
         * @zh 定义无加速持续运动。
         */
        linearIn: typeof linearIn;
        /**
         * @en Define continuous motion without acceleration.
         * @zh 定义无加速持续运动。
         */
        linearInOut: typeof linearInOut;
        /**
         * @en Define continuous motion without acceleration.
         * @zh 定义无加速持续运动。
         */
        linearOut: typeof linearOut;
        /**
         * @en Starts the motion with zero velocity, then accelerates the motion.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         */
        bounceIn: typeof bounceIn;
        /**
         * @en Starts the motion with zero velocity, accelerates, and then decelerates to zero velocity.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         */
        bounceInOut: typeof bounceInOut;
        /**
         * @en Begins the motion at a faster velocity, then decelerates until the velocity is zero.
         * The motion is similar to a ball falling towards the floor and bouncing back with decreasing rebounds.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         */
        bounceOut: typeof bounceOut;
        /**
         * @en Starts the motion with a backward movement, then moves towards the target in the opposite direction, overshoots, and then returns.
         * @zh 开始时往后运动，然后反向朝目标移动。
         */
        backIn: typeof backIn;
        /**
         * @en Starts the motion with a backward movement, then moves towards the target, overshoots slightly, reverses direction again, and finally moves towards the target.
         * @zh 开始运动时是向后跟踪，再倒转方向并朝目标移动，稍微过冲目标，然后再次倒转方向，回来朝目标移动。
         */
        backInOut: typeof backInOut;
        /**
         * @en Starts the motion towards the target, overshoots slightly, then reverses direction and moves back towards the target.
         * @zh 开始运动时是朝目标移动，稍微过冲，再倒转方向回来朝着目标。
         */
        backOut: typeof backOut;
        /**
         * @en Starts the motion from zero velocity, then accelerates.
         * The motion is defined by a sine wave that elastically decays in an exponential manner.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         */
        elasticIn: typeof elasticIn;
        /**
         * @en Starts the motion with zero velocity, accelerates, and then decelerates to zero velocity.
         * The motion is defined by a sine wave that elastically decays in an exponential manner.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         */
        elasticInOut: typeof elasticInOut;
        /**
         * @en Starts the motion at a faster velocity, then decelerates until the velocity reaches zero.
         * The motion is defined by a sine wave that decays in an exponential manner.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         */
        elasticOut: typeof elasticOut;
        /**
         * @en Starts the motion from zero velocity and then accelerates rapidly.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         */
        strongIn: typeof strongIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         */
        strongInOut: typeof strongInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         */
        strongOut: typeof strongOut;
        /**
         * @en Starts the motion with zero velocity, accelerates the motion, and then decelerates to zero velocity.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         */
        sineInOut: typeof sineInOut;
        /**
         * @en Starts the motion from zero velocity, then accelerates the motion.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         */
        sineIn: typeof sineIn;
        /**
         * @en Starts the motion at a faster pace, then decelerates until the velocity reaches zero.
         * The motion acceleration in the Sine slow motion equation is smaller than that in the Quad equation.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         */
        sineOut: typeof sineOut;
        /**
         * @en Start moving at zero speed and then accelerate the motion speed during execution.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @zh 以零速率开始运动，然后在执行时加快运动速度。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         */
        quintIn: typeof quintIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         */
        quintInOut: typeof quintInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quint slow motion equation is greater than that of the Quart slow motion equation.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         */
        quintOut: typeof quintOut;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         */
        quartIn: typeof quartIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         */
        quartInOut: typeof quartInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         */
        quartOut: typeof quartOut;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         */
        cubicIn: typeof cubicIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         */
        cubicInOut: typeof cubicInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration of the Quart slow motion equation is greater than that of the Cubic slow motion equation.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         */
        cubicOut: typeof cubicOut;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         */
        quadIn: typeof quadIn;
        /**
         * @en Starts the motion with zero velocity, accelerates the motion, and then decelerates to zero velocity.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         */
        quadInOut: typeof quadInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The motion acceleration in the Quad deceleration equation is equal to the motion acceleration between the 100% deceleration time axis and is significantly smaller than the motion acceleration in the Cubic deceleration equation.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         */
        quadOut: typeof quadOut;
        /**
         * @en Starts the motion with zero velocity, then accelerates the motion.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         */
        expoIn: typeof expoIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         */
        expoInOut: typeof expoInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * Each time interval is the remaining distance minus a fixed proportion.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         */
        expoOut: typeof expoOut;
        /**
         * @en The method starts at zero speed and then accelerates the motion speed during execution.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @zh 方法以零速率开始运动，然后在执行时加快运动速度。
         * 缓动方程的运动加速会产生突然的速率变化。
         */
        circIn: typeof circIn;
        /**
         * @en At the beginning of the motion, the velocity is zero. Accelerate the motion first, then decelerate until the velocity is zero.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @zh 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         */
        circInOut: typeof circInOut;
        /**
         * @en Start moving at a faster speed, then slow down the motion speed during execution until the speed reaches zero.
         * The acceleration of the slow motion equation will result in a sudden change in velocity.
         * @zh 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         */
        circOut: typeof circOut;
    };
    function linear(t: number, b: number, c: number, d: number): number;
    function linearIn(t: number, b: number, c: number, d: number): number;
    function linearInOut(t: number, b: number, c: number, d: number): number;
    function linearOut(t: number, b: number, c: number, d: number): number;
    function bounceIn(t: number, b: number, c: number, d: number): number;
    function bounceInOut(t: number, b: number, c: number, d: number): number;
    function bounceOut(t: number, b: number, c: number, d: number): number;
    function backIn(t: number, b: number, c: number, d: number, s?: number): number;
    function backInOut(t: number, b: number, c: number, d: number, s?: number): number;
    function backOut(t: number, b: number, c: number, d: number, s?: number): number;
    function elasticIn(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
    function elasticInOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
    function elasticOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
    function strongIn(t: number, b: number, c: number, d: number): number;
    function strongInOut(t: number, b: number, c: number, d: number): number;
    function strongOut(t: number, b: number, c: number, d: number): number;
    function sineInOut(t: number, b: number, c: number, d: number): number;
    function sineIn(t: number, b: number, c: number, d: number): number;
    function sineOut(t: number, b: number, c: number, d: number): number;
    function quintIn(t: number, b: number, c: number, d: number): number;
    function quintInOut(t: number, b: number, c: number, d: number): number;
    function quintOut(t: number, b: number, c: number, d: number): number;
    function quartIn(t: number, b: number, c: number, d: number): number;
    function quartInOut(t: number, b: number, c: number, d: number): number;
    function quartOut(t: number, b: number, c: number, d: number): number;
    function cubicIn(t: number, b: number, c: number, d: number): number;
    function cubicInOut(t: number, b: number, c: number, d: number): number;
    function cubicOut(t: number, b: number, c: number, d: number): number;
    function quadIn(t: number, b: number, c: number, d: number): number;
    function quadInOut(t: number, b: number, c: number, d: number): number;
    function quadOut(t: number, b: number, c: number, d: number): number;
    function expoIn(t: number, b: number, c: number, d: number): number;
    function expoInOut(t: number, b: number, c: number, d: number): number;
    function expoOut(t: number, b: number, c: number, d: number): number;
    function circIn(t: number, b: number, c: number, d: number): number;
    function circInOut(t: number, b: number, c: number, d: number): number;
    function circOut(t: number, b: number, c: number, d: number): number;
    /**
     * @en Tween callback function.
     * @param tweener The current tweener.
     * @zh 缓动回调函数。
     * @param tweener 当前的tweener。
     */
    type TweenCallback = (tweener: ITweener) => void;
    /**
     * @en Builtin ease function names.
     * @zh 内置的缓动函数名称。
     */
    type EaseType = keyof typeof Ease;
    /**
     * @en Ease function is a function that takes a time parameter and returns a value between 0 and 1.
     * @param t Current time between 0 and the duration (inclusive).
     * @param b The initial value of the animated property.
     * @param c The total change in the animated property.
     * @param d The duration of the motion.
     * @param args Additional arguments.
     * @zh Ease函数是一个接受时间参数并返回0到1之间值的函数。
     * @param t 当前时间，取值范围是0到持续时间（包括持续时间）。
     * @param b 属性的初始值。
     * @param c 属性的变化总量。
     * @param d 动画的持续时间。
     * @param args 额外的参数。
     */
    type EaseFunction = (t: number, b: number, c: number, d: number, ...args: any[]) => number;
    /**
     * @en TweenInterpolator is a function that calculates the value of the tween at a given time.
     * @param time The current time.
     * @param start The start value.
     * @param end The end value.
     * @param result The result value.
     * @param args The additional arguments.
     * @zh TweenInterpolator 是一个在给定时间计算缓动值的函数。
     * @param time 当前时间。
     * @param start 开始值。
     * @param end 结束值。
     * @param result 结果值。
     * @param args 额外的参数。
     */
    type TweenInterpolator<T extends any[]> = (time: number, start: ReadonlyArray<number>, end: ReadonlyArray<number>, result: Array<number>, ...args: T) => void;
    /**
     * @en The Tween system uses adapters to convert different value types to and from number arrays for tween calculations.
     * @zh Tween系统通过适配器来将不同的值类型与数字数组互相转换，以便进行缓动计算。
     */
    type TweenValueAdapter = {
        /**
         * @en Push value to number array.
         * @param array The number array to write to.
         * @param value The value to write.
         * @zh 将值推入到数字数组中。
         * @param array 要写入的数字数组。
         * @param value 要写入的值。
         */
        write: (array: Array<number>, value: any) => void;
        /**
         * @en Read value from number array.
         * @param array The number array to read from.
         * @param offset The offset of the number array.
         * @returns The value read.
         * @zh 从数字数组中读取值。
         * @param array 要读取的数字数组。
         * @param offset 数字数组的偏移量。
         * @returns 读取的值。
         */
        read: (array: Array<number>, offset: number) => any;
    };
    interface ITweenValue {
        /**
         * @en The numbers array of the tween value.
         * @zh 缓动值的数字数组。
         */
        readonly nums: Array<number>;
        /**
         * @en Get value by property name.
         * @param name Property name.
         * @returns Value.
         * @zh 通过属性名称获取值。
         * @param name 属性名称。
         * @returns 值。
         */
        get(name: string): any;
        /**
         * @en Get value by property index.
         * @param index Property index.
         * @returns Value.
         * @zh 通过属性索引获取值。
         * @param index 属性索引。
         * @returns 值。
         */
        getAt(index: number): any;
        /**
         * @en Set value by property name.
         * @param name Property name.
         * @param value Value.
         * @zh 通过属性名称设置值。
         * @param name 属性名称。
         * @param value 值。
         */
        set(name: string, value: any): void;
        /**
         * @en Set value by property index.
         * @param index Property index.
         * @param value Value.
         * @zh 通过属性索引设置值。
         * @param index 属性索引。
         * @param value 值。
         */
        setAt(index: number, value: any): void;
        /**
         * @en The number of properties in the tween value.
         * @zh 缓动值中的属性数量。
         */
        readonly count: number;
        /**
         * @en Copy all values from another ITweenValue.
         * @param source The source ITweenValue.
         * @returns The current ITweenValue.
         * @zh 从另一个 ITweenValue 复制所有值。
         * @param source 源 ITweenValue。
         * @returns 当前 ITweenValue。
         */
        copy(source: ITweenValue): this;
    }
    interface ITweener {
        /**
         * @en The starting value of the tweener. Even if the tweener is running, you can still modify it.
         * @zh 缓动的初始值。即使tweener在运行过程中，也可以修改它。
         */
        readonly startValue: ITweenValue;
        /**
         * @en The end value of the tweener. Even if the tweener is running, you can still modify it.
         * @zh 缓动的结束值。即使tweener在运行过程中，也可以修改它。
         */
        readonly endValue: ITweenValue;
        /**
         * @en The current value of the tweener. You can get the tweener value at any time during the tweener.
         * @zh 缓动的当前值。可以在缓动进行中的任意时刻获取tweener的值。
         */
        readonly value: Readonly<ITweenValue>;
        /**
         * @en The difference between the value of the last update callback and the value of the current update callback.
         * @zh 上一次update回调与本次update回调的value值的差值。
         */
        readonly deltaValue: Readonly<ITweenValue>;
        /**
         * @en The name of the Tweener.
         * @zh Tweener的名称。
         */
        readonly name: string;
        /**
         * @en The owner of the Tweener.
         * @zh 获取Tweener的拥有者。
         */
        readonly owner: Tween;
        /**
         * @en Get the target of the tweener.
         * @zh 获得缓动的目标对象。
         */
        readonly target: any;
        /**
         * @en Get the duration of the tweener.
         * @zh 获取缓动的持续时间，以毫秒为单位。
         */
        duration: number;
        /**
         * @en Get the delay time in milliseconds.
         * @zh 获取延迟时间，以毫秒为单位。
         */
        delay: number;
        /**
         * @en The breakpoint of the tweener. If the time reaches the breakpoint, the tweener will end.
         * @zh 缓动的断点时间。如果时间达到断点时间，缓动将会结束。
         */
        breakpoint: number;
        /**
         * @en Get the number of repetitions of the tweener.
         * If the repeat is 0, then the tweener will play once. If the repeat is -1, then the tweener will loop indefinitely.
         * If the repeat is 1, then the tweener will play twice, and so on.
         * @zh 获取缓动的重复次数。
         * 如果 repeat 为 0，则缓动将播放一次。如果 repeat 为 -1，则缓动将无限循环。
         * 如果 repeat 为 1，则缓动将播放两次，依此类推。
         */
        repeat: number;
        /**
         * @en If yoyo is true, after the first play, the tweener will alternate back and forth.
         * @zh 如果 yoyo 为 true，缓动将在第一次播放后来回交替播放。
         */
        yoyo: boolean;
        /**
         * @en The time scale of the tweener.
         * @zh 设置缓动的时间缩放。
         */
        timeScale: number;
        /**
         * @en Whether the tweener ignores the time scale from Laya.timer.
         * @zh 缓动是否忽略Laya.timer的时间缩放。
         */
        ignoreEngineTimeScale: boolean;
        /**
         * @en The user data of the tweener.
         * @zh 缓动的用户数据。
         */
        userData: any;
        /**
         * @en Get or set the pause state of the tweener.
         * @zh 获取或者设置tweener的暂停状态.
         */
        paused: boolean;
        /**
         * @en The normalized time of the tweener. The value is between 0 and 1.
         * @zh 缓动的归一化时间。取值在 0 和 1 之间。
         */
        readonly normalizedTime: number;
        /**
         * @en When the tweener reaches the breakpoint and ends, it is true.
         * @zh 当缓动到达breakpoint后结束，此值为true。
         */
        readonly breaking: boolean;
        /**
         * @en The time remaining for the tweener.
         * @zh 缓动剩余的时间。
         */
        readonly remainTime: number;
        /**
         * @en Seek the tweener to a specified time.
         * @param time The time to seek to, in milliseconds.
         * @returns The tweener object.
         * @zh 将缓动播放头跳转到指定的时间。
         * @param time 要跳转到的时间，以毫秒为单位。
         * @return tweener对象。
         */
        seek(time: number): void;
        /**
         * @en Kill the tweener. The tweener will be stopped and will be removed from the Tween system.
         * @param complete If true, the tweener will be set to the end state, and the complete callback will be called.
         * If false, the complete callback will not be called.
         * @returns The tweener object.
         * @zh 结束缓动。缓动将会停止，并从缓动系统中移除。
         * @param complete 如果为 true，缓动将设置到结束状态, complete 回调将会被执行。
         * 如果为 false，complete 回调将不会被执行。
         * @return tweener对象。
         */
        kill(complete?: boolean): void;
    }
    enum CurveType {
        /**
         * @en Curve type: Cardinal spline.
         * @zh 曲线类型：基数样条。
         */
        CRSpline = 0,
        /**
         * @en Curve type: Bezier curve.
         * @zh 曲线类型：贝塞尔曲线。
         */
        Bezier = 1,
        /**
         * @en Curve type: Cubic Bezier curve.
         * @zh 曲线类型：三次贝塞尔曲线。
         */
        CubicBezier = 2,
        /**
         * @en Curve type: Straight line.
         * @zh 曲线类型：直线。
         */
        Straight = 3
    }
    enum RotationType {
        /**
         * @en No rotation.
         * @zh 不旋转。
         */
        NoRotation = 0,
        /**
         * @en Rotate along the path curve.
         * @zh 沿路径曲线旋转。
         */
        RotateAlongPathCurve = 1,
        /**
         * @en Rotate along the motion path.
         * @zh 沿运动路径旋转。
         */
        RotateAlongMotionPath = 2
    }
    class PathPoint {
        /**
         * @en Position.
         * @zh 位置。
         */
        pos: Vector3;
        /**
         * @en Control point 1.
         * @zh 控制点1。
         */
        c1: Vector3;
        /**
         * @en Control point 2.
         * @zh 控制点2。
         */
        c2: Vector3;
        /**
         * @en Curve type.
         * @zh 曲线类型。
         */
        curve: CurveType;
        /**
         * 0或者null为不旋转，1为沿路径曲线路径旋转，2为沿运动路径旋转
         */
        rotationType?: RotationType;
        /**
         * @en Create a cardinalspline curve point.
         * @zh 创建一个 PathPoint 的实例。
         */
        static create(x: number, y: number, z: number, curve?: number): PathPoint;
        /**
         * @en Recycle a PathPoint, make it available for reuse.
         * @zh 回收一个 PathPoint，将其置为可重用状态。
         */
        recover(): void;
        /**
         * @en Clone a new PathPoint.
         * @returns A new instance of PathPoint.
         * @zh 克隆一个新的 PathPoint。
         * @returns PathPoint 实例。
         */
        clone(): PathPoint;
        /**
         * @internal
         */
        _reset(): void;
    }
    /**
     * @en When the entire slow motion ends, it will be scheduled
     * @zh 整个缓动结束的时候会调度
     * @eventType Event.COMPLETE
     */
    /**
     * @en When the slow motion reaches the label, it will be scheduled
     * @zh 当缓动到达标签时会调度。
     * @eventType Event.LABEL
     */
    /**
     * @en TimeLine is a class used to create timeline animations.
     * @zh TimeLine 是一个用来创建时间轴动画的类。
     */
    class TimeLine extends EventDispatcher {
        private _labelDic;
        private _tweenDic;
        private _tweenDataList;
        private _endTweenDataList;
        private _currTime;
        private _lastTime;
        private _startTime;
        /**当前动画数据播放到第几个了*/
        private _index;
        /**保留所有对象第一次注册动画时的状态（根据时间跳转时，需要把对象的恢复，再计算接下来的状态）*/
        private _firstTweenDic;
        /**是否需要排序*/
        private _startTimeSort;
        private _endTimeSort;
        /**是否循环*/
        private _loopKey;
        /**
         * @en Scaling the speed of animation playback.
         * @zh 缩放动画播放的速度。
         */
        scale: number;
        private _frameRate;
        private _frameIndex;
        private _total;
        /**
         * @en Controls an object to move to a target position.
         * @param target The object to be controlled.
         * @param props The properties of the object to be controlled.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The type of easing.
         * @param offset The time offset relative to the previous object (in milliseconds).
         * @returns An instance of TimeLine.
         * @zh 控制一个对象，从当前位置移动到目标位置。
         * @param target  要控制的对象。
         * @param props  要控制对象的属性。
         * @param duration 对象TWEEN的时间。
         * @param ease  缓动类型
         * @param offset  相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        static to(target: any, props: any, duration: number, ease?: EaseFunction, offset?: number): TimeLine;
        /**
         * @en From the props attribute, slow down to the current state.
         * @param target The target object whose properties will be changed.
         * @param props The properties to control the object.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The type of easing function.
         * @param offset The time offset relative to the previous object (in milliseconds).
         * @zh 从 props 属性，缓动到当前状态。
         * @param target  target 目标对象(即将更改属性值的对象)
         * @param props  要控制对象的属性
         * @param duration 对象TWEEN的时间
         * @param ease  缓动类型
         * @param offset  相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        static from(target: any, props: any, duration: number, ease?: EaseFunction, offset?: number): TimeLine;
        /**
         * @en Controls an object to move to a target position.
         * @param target The object to be controlled.
         * @param props The properties to be changed during the TWEEN.
         * @param duration The duration of the TWEEN for the object.
         * @param ease The easing function to be used.
         * @param offset The time offset from the start of the previous TWEEN (in milliseconds).
         * @returns An instance of TimeLine.
         * @zh 控制一个对象，从当前位置移动到目标位置。
         * @param target  要控制的对象。
         * @param props  要控制对象的属性。
         * @param duration 对象TWEEN的时间。
         * @param ease  缓动类型
         * @param offset  相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        to(target: any, props: any, duration: number, ease?: EaseFunction, offset?: number): TimeLine;
        /**
         * @en From the props attribute, slow down to the current state.
         * @param target The target object whose properties are to be tweened.
         * @param props The properties to be controlled and their target values.
         * @param duration The duration of the tween for the target object.
         * @param ease The type of easing function to be used for the tween.
         * @param offset The time offset in milliseconds to delay the start of the tween relative to the previous tween.
         * @zh 从 props 属性，缓动到当前状态。
         * @param target 目标对象，其属性将被缓动。
         * @param props 要控制的对象属性及其目标值。
         * @param duration 对象缓动的持续时间。
         * @param ease 缓动类型，用于指定缓动效果的函数。
         * @param offset 相对于上一个缓动，延迟启动当前缓动的时间偏移量（单位：毫秒）。。
         */
        from(target: any, props: any, duration: number, ease?: EaseFunction, offset?: number): TimeLine;
        /** @private */
        private _create;
        /**
         * @en Adds a label to the timeline at a specified offset from the previous animation.
         * @param label The name of the label to add.
         * @param offset The offset time in milliseconds from the previous animation.
         * @zh 在时间队列中加入一个标签，相对于上一个动画的偏移时间。
         * @param label 标签名称。
         * @param offset 标签相对于上个动画的偏移时间(单位：毫秒)。
         */
        addLabel(label: string, offset: number): TimeLine;
        /**
         * @en Removes a specified label from the timeline.
         * @param label The label to remove
         * @zh 移除指定的标签。
         * @param label 要删除的标签.
         */
        removeLabel(label: string): void;
        /**
         * @en Jumps to a specific time in the animation.
         * @param time The time in milliseconds to jump to within the animation.
         * @zh 动画从整个动画的某一时间开始。
         * @param time 在动画中跳转到的时间（以毫秒为单位）。
         */
        gotoTime(time: number): void;
        /**
         * @en Jump to a specific label and start playing from there.
         * @param Label The name of the label to jump to.
         * @zh 跳转到指定的标签并从那里开始播放。
         * @param Label 要跳转的标签名。
         */
        gotoLabel(Label: string): void;
        /**
         * @en Pause the entire animation.
         * @zh 暂停整个动画。
         */
        pause(): void;
        /**
         * @en Resume playing of a paused animation.
         * @zh 恢复暂停的动画播放。
         */
        resume(): void;
        /**
         * @en Play the animation from a specified time point or label.
         * @param timeOrLabel The time point or label name to start playing from.
         * @param loop Whether to loop the playback.
         * @zh 从指定的时间点或标签名播放动画。
         * @param timeOrLabel 开始播放的时间点或标签名。
         * @param loop 是否循环播放。
         */
        play(timeOrLabel?: any, loop?: boolean): void;
        /**
         * 更新当前动画。
         */
        private _update;
        /**
         * 指定的动画索引处的动画播放完成后，把此动画从列表中删除。
         * @param index
         */
        private _animComplete;
        /** @private */
        private _complete;
        /**
         * @private
         * @en frame index
         * @zh 帧索引
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The total number of frames
         * @zh 总帧数。
         */
        get total(): number;
        /**
         * @en Resets all objects, used when reusing objects.
         * @zh 重置所有对象，复用对象时使用。
         */
        reset(): void;
        /**
         * @en Completely destroys this object.
         * @zh 彻底销毁此对象。
         */
        destroy(): void;
    }
    /**
     * @en The `Tween` class is an easing class. It is used to implement the interpolation of properties of a target object.
     * @zh `Tween` 类是一个缓动类。使用此类能够实现对目标对象属性的渐变。
     * @example
     * ```ts
     * //tween a numeric property of an object
     * let tween = Laya.Tween.create(target).duration(1000).delay(1000)
     *  .to("x", 100).to("y", 200).ease(Laya.Ease.sineInOut).then(callback);
     *
     * //tween a vector property of an object
     * Laya.Tween.create(target.transform, target).duration(1000).to("localPosition", new Laya.Vector3(1,1,1));
     *
     * //tween a hex color property of an object, r/g/b channel are tweened separately.
     * Laya.Tween.create(target).duration(1000).to("color", 0xffffff).interp(Laya.Tween.seperateChannel, 3);
     *
     * //Somewhere want to kill the tween immediately.
     * tween.kill();
     *
     * //or kill by target
     * Laya.Tween.killAll(target);
     *
     * //use chain and parallel to create complex sequences
     * Laya.Tween.create(target).duration(1000).to("x", 100)
     *   .chain().duration(500).to("y", 200)
     *   .parallel().to("visible", true)
     * ```
     * @blueprintable
     */
    class Tween {
        private _target;
        private _lo;
        private _cur;
        private _par;
        private _queue;
        private _head;
        /**
         * @en Create a new Tween object. You can set the properties of the Tween by chaining. It will start automatically and does not need to be called separately.
         * @param target The target object of the Tween. It can be empty.
         * @param lifecycleOwner The lifecycle object, when destroyed, the tween will automatically stop. In general, if the target object of the task has a destroyed property, this property does not need to be set. If the target object of the task does not have a destroyed property, this property can be set.
         * @returns A Tween object.
         * @zh 创建一个新的缓动对象。使用返回的对象可以设置缓动的属性和其他选项。
         * 缓动会自动开始，无需额外API调用。如果不想tween被立刻执行，可以调用pause，后续再调用resume。
         * @param target 缓动的目标对象。可以为空。
         * @param lifecycleOwner 生命周期对象，当销毁时，缓动会自动停止。一般情况下，如果任务的目标对象有 destroyed 属性，则不需要设置此属性。如果任务的目标对象没有 destroyed 属性，则可以设置此属性。
         * @returns 返回一个Tween对象。
         */
        static create(target?: any, lifecycleOwner?: any): Tween;
        /**
         * @en Check if any Tween is running on the specified target.
         * @param target The target object.
         * @returns Returns true if there is a Tween running on the target.
         * @zh 检查指定对象上是否有任何 Tween 正在运行。
         * @param target 指定的对象。
         * @return 如果有任何 Tween 正在运行，则返回 true。
         */
        static isTweening(target: any): boolean;
        /**
         * Query a Tween object by target.
         * @param target The target object.
         * @returns The Tween object. If it doesn't exist, it will return null.
         */
        static getTween(target: any): Tween | null;
        /**
         * @en Get all Tweens that are running on the specified target. If none, returns an empty array or the passed-in non-null array.
         * @param target The target object.
         * @param out An array to receive the Tween objects.
         * @returns An array of Tween objects that are running on the specified target.
         * @zh 获取指定对象上正在运行的所有 Tween。如果没有，返回空数组或传入的非空对象。
         * @param target 指定的对象。
         * @param out 接收 Tween 对象的数组。
         * @return 正在运行的所有 Tween 的数组。
         */
        static getTweens(target: any, out?: Array<Tween>): Array<Tween>;
        /**
         * @en Kill a specific tween.
         * @param tween The tween object to clear.
         * @zh 清理某个特定的缓动。
         * @param tween 要清理的缓动对象。
         */
        static kill(tween: Tween): void;
        /**
         * @deprecated Use kill instead.
         */
        static clear(tween: Tween): void;
        /**
         * @en Kill all Tweens by the specified target.
         * @param target The target object.
         * @param completed If true, the tweens will be set to the end state, and the complete callback will be called.
         * If false, the complete callback will not be called.
         * @returns Returns true if there any tweens are existing and killed.
         * @zh 结束指定对象上的所有 Tween。
         * @param target 指定的对象。
         * @param completed 如果为 true，Tween 将设置到结束状态, complete 回调将会被执行。
         * 如果为 false，complete 回调将不会被执行。
         * @return 如果存在并且成功结束 Tween 返回 true，否则返回 false。
         */
        static killAll(target: any, completed?: boolean): boolean;
        /**
         * @deprecated Use killAll instead.
         */
        static clearAll(target: any): void;
        /**
         * @deprecated Use create instead.
         * @en Tweens the object's properties to the target values. This is a compatibility function, recommended to use Tween.create instead.
         * @param target The target object whose properties will be tweened.
         * @param props The list of properties to change, e.g., {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onUpdate)}.
         * @param duration The time taken for the tween in milliseconds.
         * @param ease The type of easing, defaults to linear motion.
         * @param complete The callback function when the tween completes.
         * @param delay The delay before the tween starts.
         * @param coverBefore Whether to override the previous tween.
         * @returns Returns the Tween object.
         * @zh 缓动对象的props属性到目标值。这是兼容老版本的函数签名，建议使用Twee.create替代。
         * @param target 目标对象(即将更改属性值的对象)。
         * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param duration 花费的时间，单位毫秒。
         * @param ease 缓动类型，默认为匀速运动。
         * @param complete 结束回调函数。
         * @param delay 延迟执行时间。
         * @param coverBefore 是否覆盖之前的缓动。
         * @return 返回Tween对象。
         */
        static to(target: any, props: Readonly<Record<string, any>>, duration: number, ease?: EaseFunction, complete?: Handler, delay?: number, coverBefore?: boolean): Tween;
        /**
         * @deprecated Use create instead.
         * @en From the props attribute, tween to the current state.
         * This is a compatibility function, recommended to use Tween.create instead.
         * @param target The target object whose properties will be tweened.
         * @param props The list of properties to change, e.g., {x:100, y:20, ease:Ease.backOut, complete:Handler.create(this,onComplete), update:new Handler(this,onUpdate)}.
         * @param duration The time taken for the tween in milliseconds.
         * @param ease The type of easing, defaults to linear motion.
         * @param complete The callback function when the tween completes.
         * @param delay The delay before the tween starts.
         * @param coverBefore Whether to override the previous tween.
         * @returns Returns the Tween object.
         * @zh 从props属性，缓动到当前状态。
         * 这是兼容老版本的函数签名，建议使用Twee.create替代。
         * @param target 目标对象(即将更改属性值的对象)。
         * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param duration 花费的时间，单位毫秒。
         * @param ease 缓动类型，默认为匀速运动。
         * @param complete 结束回调函数。
         * @param delay 延迟执行时间。
         * @param coverBefore 是否覆盖之前的缓动。
         * @return	返回Tween对象。
         */
        static from(target: any, props: Record<string, any>, duration: number, ease?: EaseFunction, complete?: Handler, delay?: number, coverBefore?: boolean): Tween;
        private static tweenLegacy;
        /**
         * @en Tweens the object's property to the sepecified value.
         * @param propName The name of the property.
         * The property can be a number, string, boolean, Vector2, Vector3, Vector4, or Color. If it is a string, it is implicitly a color value.
         * @param value The target value of the property.
         * @returns The Tween object.
         * @zh 缓动对象的属性到指定值。
         * 属性类型可以是数字，字符串，布尔值，Vector2, Vector3, Vector4, Color。如果是字符串，则隐含为颜色值。
         * @param propName 属性名称。
         * @param value 属性目标值。
         * @return Tween对象。
         */
        to(propName: string, value: any): this;
        /**
         * @en Tweens the object's property from the specified value to the current value.
         * @param propName The name of the property.
         * The property can be a number, string, boolean, Vector2, Vector3, Vector4, or Color. If it is a string, it is implicitly a color value.
         * @param value The start value of the property.
         * @returns The Tween object.
         * @zh 缓动对象的属性从指定值到当前值。
         * @param propName 属性名称。
         * 属性类型可以是数字，字符串，布尔值，Vector2, Vector3, Vector4, Color。如果是字符串，则隐含为颜色值。
         * @param value 属性目标值。
         * @return Tween对象。
         */
        from(propName: string, value: any): this;
        /**
         * @en Tweens the object's property from the start value to the end value.
         * @param propName The name of the property.
         * The property can be a number, string, boolean, Vector2, Vector3, Vector4, or Color. If it is a string, it is implicitly a color value.
         * @param startValue The start value of the property.
         * @param endValue The end value of the property.
         * @returns The Tween object.
         * @zh 缓动对象的属性从指定的起始值到指定的结束值。
         * @param propName 属性名称。
         * 属性类型可以是数字，字符串，布尔值，Vector2, Vector3, Vector4, Color。如果是字符串，则隐含为颜色值。
         * @param startValue 属性起始值。
         * @param endValue 属性结束值。
         * @return Tween对象。
         */
        go<T>(propName: string, startValue: T, endValue: T): this;
        /**
         * @en Start a new tween task, which will start immediately after the current task ends.
         * @param target The target object of the Tween. If it is empty, the target object pass in create method will be used.
         * @param lifecycleOwner The lifecycle object, when destroyed, the tween will automatically stop. In general, if the target object of the task has a destroyed property, this property does not need to be set. If the target object of the task does not have a destroyed property, this property can be set.
         * @returns The Tween object.
         * @zh 开启一个新的缓动任务，它将在当前任务结束后立刻开始。
         * @param target 缓动的目标对象。如果为空，将使用create方法传入的目标对象。
         * @param lifecycleOwner 生命周期对象，当销毁时，缓动会自动停止。一般情况下，如果任务的目标对象有 destroyed 属性，则不需要设置此属性。如果任务的目标对象没有 destroyed 属性，则可以设置此属性。
         * @return Tween对象。
         */
        chain(target?: any, lifecycleOwner?: any): this;
        /**
         * @en Start a new tween task, which will start at the same time as the current task.
         * @param target The target object of the Tween. If it is empty, the target object pass in chain or create method will be used.
         * @param lifecycleOwner The lifecycle object, when destroyed, the tween will automatically stop. In general, if the target object of the task has a destroyed property, this property does not need to be set. If the target object of the task does not have a destroyed property, this property can be set.
         * @returns The Tween object.
         * @zh 开启一个新的缓动任务，它和当前任务同时开始。
         * @param target 缓动的目标对象。如果为空，将使用chain或create方法传入的目标对象。
         * @param lifecycleOwner 生命周期对象，当销毁时，缓动会自动停止。一般情况下，如果任务的目标对象有 destroyed 属性，则不需要设置此属性。如果任务的目标对象没有 destroyed 属性，则可以设置此属性。
         * @return Tween对象。
         */
        parallel(target?: any, lifecycleOwner?: any): this;
        /**
         * @en Set the delay time of the current task.
         * @param value The delay time in milliseconds.
         * @return Tween object.
         * @zh 设置当前任务的延迟时间。
         * @param value 延迟时间，以毫秒为单位。
         * @return Tween对象。
         */
        delay(value: number): this;
        /**
         * @en Set the duration of the current task.
         * @param value The duration in milliseconds.
         * @returns The Tween object.
         * @zh 设置当前任务的持续时间。
         * @param value 持续时间，以毫秒为单位。
         * @return Tween对象。
         */
        duration(value: number): this;
        /**
         * @en Set the breakpoint of the current task. If the time reaches the breakpoint, the task will end.
         * @param value The breakpoint in milliseconds.
         * @returns The Tween object.
         * @zh 设置当前任务的断点时间。如果时间达到断点时间，任务将会结束。
         * @param value 任务的断点时间，以毫秒为单位。
         * @return Tween对象。
         */
        breakpoint(value: number): this;
        /**
         * @en Set the easing function of the current task. Use the Laya.Ease class for preset easing functions.
         * @param value The easing function, or the name of the easing function.
         * @param args Extra parameters for the easing function.
         * @returns The Tween object.
         * @zh 设置当前任务的缓动函数。可以使用Laya.Ease类中的预设缓动函数，或者一个缓动函数的名称。
         * @param value 缓动函数。
         * @param args 缓动函数的额外参数。
         * @return Tween对象。
         */
        ease(value: EaseFunction | EaseType, ...args: Array<any>): this;
        /**
         * @en Set the interpolation function of the current task. e.g. Laya.Tween.seperateChannel.
         * @param value The interpolation function.
         * @param args Extra parameters for the interpolation function.
         * @returns The Tween object.
         * @zh 设置当前任务的插值函数。比如Laya.Tween.seperateChannel。
         * @param value 插值函数。
         * @param args 插值函数的额外参数。
         * @return Tween对象。
         */
        interp<T extends any[]>(value: TweenInterpolator<T>, ...args: T): this;
        /**
         * @en Set the number of repetitions of the current task.
         * If the repeat is 0, then the task will play once. If the repeat is -1, then the task will loop indefinitely.
         * If the repeat is 1, then the task will play twice, and so on.
         * @param repeat The number of repetitions of the task.
         * @param yoyo If yoyo is true, after the first play, the task will alternate back and forth.
         * @returns The Tween object.
         * @zh 设置当前任务的重复次数。
         * 如果 repeat 为 0，则任务将播放一次。如果 repeat 为 -1，则任务将无限循环。
         * 如果 repeat 为 1，则任务将播放两次，依此类推。
         * @param repeat 任务的重复次数。
         * @param yoyo 如果 yoyo 为 true，任务将在第一次播放后来回交替播放。
         * @return Tween对象。
         */
        repeat(repeat: number, yoyo?: boolean): this;
        /**
         * @en Set the time scale of the current task.
         * @param value The time scale.
         * @returns The Tween object.
         * @zh 设置当前任务的时间缩放。
         * @param value 任务的时间缩放。
         * @return Tween对象。
         */
        timeScale(value: number): this;
        /**
         * @en Set whether current task will ignore the time scale from Laya.timer.
         * @param value If true, then the time scale of current task will not be affected by Laya.timer.
         * @returns The Tween object.
         * @zh 设置当前任务是否忽略Laya.timer的时间缩放。
         * @param value 如果为 true，任务的时间缩放不会受到Laya.timer的影响。
         * @return Tween对象。
         */
        ignoreEngineTimeScale(value: boolean): this;
        /**
         * @en Set whether the property values of current task is rounded to an integer.
         * @param value If true, the property values will be rounded to an integer.
         * @returns The Tween object.
         * @zh 设置当前任务的属性值是否取整。
         * @param value 如果为 true，属性值将会取整。
         * @return Tween对象。
         */
        snapping(value: boolean): this;
        /**
         * @en Set the user data of the current task.
         * @param value The user data of the current task.
         * @returns The Tween object.
         */
        userData(value: any): this;
        /**
         * @en Set the name of current task.
         * @param value The name of the current task.
         * @returns The Tween object.
         * @zh 设置当前任务的名称。
         * @param value 当前任务的名称。
         * @return Tween对象。
         */
        name(value: string): this;
        /**
         * @en Set a custom update callback for the current task. The update callback is executed for every frame during the task.
         * @param callback The update callback.
         * @param callbackThis The update callback execution context.
         * @returns The Tween object.
         * @zh 设置当前任务的自定义更新回调。更新回调会在任务的每一帧执行。
         * @param callback 更新回调函数。
         * @param callbackThis 更新回调执行上下文。
         * @return Tween对象。
         */
        onUpdate(callback: TweenCallback, callbackThis?: any): this;
        /**
         * @en Set a custom start callback for the current task. The start callback is executed when the task starts.
         * @param callback The start callback.
         * @param callbackThis The start callback execution context.
         * @returns The Tween object.
         * @zh 设置当前任务的自定义开始回调。开始回调会在任务开始时执行。
         * @param callback 开始回调函数。
         * @param callbackThis 开始回调执行上下文。
         * @return Tween对象。
         */
        onStart(callback: TweenCallback, callbackThis?: any): this;
        /**
         * @en Set a custom complete callback for the current task. The complete callback is executed when the task finishes.
         * Note that if there are parallel tasks, the complete callback will be called when the current task ends, not when all parallel tasks end.
         * If the task is killed before it ends, and the parameter complete is false, the complete callback will not be called.
         * @param callback The complete callback.
         * @param callbackThis The complete callback execution context.
         * @returns The Tween object.
         * @zh 设置当前任务的自定义结束回调。结束回调会在任务结束时执行。
         * 注意，如果有并行任务，只是在当前任务结束就会调用结束回调，而并不是所有并行的任务。
         * 如果任务在结束前被 kill，并且参数 complete 为 false，则不会调用结束回调。
         * @param callback 结束回调函数。
         * @param callbackThis 结束回调执行上下文。
         * @return Tween对象。
         */
        then(callback: TweenCallback, callbackThis?: any): this;
        /**
         * @en Wait for the completion of the current task.
         * Note that if there are parallel tasks, the Promise will resolve when the current task ends, not when all parallel tasks end.
         * @zh 等待当前任务完成。
         * 注意，如果有并行任务，Promise 将在当前任务结束时解析，而不是所有并行任务结束时。
         */
        waitForCompletion(): Promise<void>;
        /**
         * @en Seek current task to a specified time.
         * @param time The time to seek to, in milliseconds.
         * @returns The Tween object.
         * @zh 将当前任务的播放头跳转到指定的时间。
         * @param time 要跳转到的时间，以毫秒为单位。
         * @return Tween对象。
         */
        seek(time: number): this;
        /**
         * @en Pause the tween. It can be resumed using resume() or restart().
         * @zh 暂停缓动。可以通过 resume() 重新开始。
         */
        pause(): this;
        /**
         * @en Resume the paused tween.
         * @zh 恢复已暂停的缓动。
         */
        resume(): this;
        /**
         * @en Find a tweener by name.
         * @param name The name of the tweener.
         * @returns The Tween object.
         * @zh 通过名字查找一个缓动。
         * @param name 缓动的名字。
         * @return Tween对象。
         */
        findTweener(name: string): ITweener | null;
        /**
         * @en Kill the Tween. The Tween will be stopped and will be removed from the Tween system.
         * @param complete If true, the Tween will be set to the end state, and the complete callback will be called.
         * If false, the complete callback will not be called.
         * @returns The Tween object.
         * @zh 结束缓动。缓动将会停止，并从缓动系统中移除。
         * @param complete 如果为 true，缓动将设置到结束状态, complete 回调将会被执行。
         * 如果为 false，complete 回调将不会被执行。
         * @return Tween对象。
         */
        kill(complete?: boolean): void;
        /**
         * @en Whether the Tween is completed.
         * If the Tween is killed, this property will still be false.
         * @zh 缓动是否已结束。如果缓动是被kill掉的，此属性仍然为false。
         */
        get completed(): boolean;
        /**
         * @en Immediately complete the tween and reach the end point.
         * @zh 立即结束缓动并到达终点。
         */
        complete(): void;
        /**
         * @en Clear the tween. Same as kill(false).
         * @zh 清理缓动。和kill(false)作用一样。
         */
        clear(): void;
        /**
         * @en Clear the tween and return it to the object pool. Note: After calling this method, this object cannot be used again, otherwise it will cause unpredictable problems.
         * @zh 清理缓动，并将缓动对象回收到对象池。注意：调用此方法，本对象不能再使用，否则会造成不可预料的问题。
         */
        recover(): void;
        private constructor();
        private cur;
        /**
         * @internal
         */
        _check(): void;
        /**
         * @en This is an interpolator that implements a shake effect.
         * @param amplitude The amplitude of the shake effect.
         * @zh 这是一个实现震动效果的插值器。
         * @param amplitude 震动幅度。
         * @example
         * ```ts
         * //The value pass in `to` is not used, so it can be any value.
         * Laya.Tween.create(target).duration(1000).to("x",0).to("y",0).interp(Laya.Tween.shake, 3);
         * ```
         */
        static shake(time: number, start: ReadonlyArray<number>, end: ReadonlyArray<number>, result: Array<number>, amplitude: number): void;
        /**
         * @en This is an interpolator that separates a numeric color value into each channel for interpolation.
         * For example, from 0x000000 to 0xffffff tween, by default, it will increase directly from 0x000000 to 0xffffff, instead of R/G/B increasing from 0x00 to 0xff respectively. Using this interpolator, R/G/B can increase from 0x00 to 0xff respectively.
         * @param channels The number of channels to interpolate. For example, if it is RGB, this value is 3. If it is RGBA, this value is 4. Default is 3.
         * @zh 这是一个实现将一个数字颜色值分离各个通道分别进行插值的插值器。
         * 例如从0x000000到0xffffff缓动，默认情况下是直接从0x000000一直增大到0xffffff，而不是R/G/B分别从0x00到0xff。使用这个插值器可以让R/G/B分别从0x00到0xff。
         * @param channels 要插值的通道数。例如，如果是RGB，这个值就是3。如果是RGBA，这个值就是4。默认为3。
         * @example
         * ```ts
         * Laya.Tween.create(target).duration(1000).to("color",0xffffff).interp(Laya.Tween.seperateChannel, 3);
         * ```
         */
        static seperateChannel(time: number, start: ReadonlyArray<number>, end: ReadonlyArray<number>, result: Array<number>, channels?: number): void;
        /**
         * @en This is an interpolator that uses a curve path. The value will be obtained from the curve path.
         * @zh 这是一个使用曲线路径的插值器。数值将从曲线路径中获取。
         */
        static useCurvePath(time: number, start: ReadonlyArray<number>, end: ReadonlyArray<number>, result: Array<number>, path: CurvePath): void;
        /**
         * @internal
         */
        static _pool: IPool<Tween>;
    }
    /**
     * @internal
     */
    type TweenPropInfo = {
        name: string;
        type: 0 | 1 | 2 | TweenValueAdapter;
        offset: number;
        renewFlags?: number;
    };
    /**
     * @internal
     */
    class Tweener implements ITweener {
        id: number;
        name: string;
        owner: Tween;
        target: any;
        userData: any;
        lifecycleOwner: {
            destroyed: boolean;
        };
        startValue: TweenValue;
        endValue: TweenValue;
        value: TweenValue;
        deltaValue: TweenValue;
        delay: number;
        duration: number;
        breakpoint: number;
        repeat: number;
        paused: boolean;
        props: Array<TweenPropInfo>;
        ease: EaseFunction;
        easeArgs: any[];
        yoyo: boolean;
        timeScale: number;
        ignoreEngineTimeScale: boolean;
        snapping: boolean;
        interp: TweenInterpolator<any>;
        interpArgs: any[];
        onUpdate: TweenCallback;
        onStart: TweenCallback;
        onComplete: TweenCallback;
        onCompleteResolvers: Array<Function>;
        onUpdateCaller: any;
        onStartCaller: any;
        onCompleteCaller: any;
        _killed: boolean;
        _started: boolean;
        _ended: number;
        _startFrame: number;
        _elapsedTime: number;
        _normalizedTime: number;
        _active: boolean;
        static create(owner: Tween): Tweener;
        static getTween(id: number): Tweener | null;
        static isTweening(target: any): boolean;
        static getTweens(target: any, out?: Array<Tween>): Array<Tween>;
        static kill(tweenId: number, complete?: boolean): boolean;
        static killAll(target: any, completed?: boolean): boolean;
        constructor();
        go<T>(propName: string, startValue: T, endValue: T): this;
        get normalizedTime(): number;
        get breaking(): boolean;
        get remainTime(): number;
        activate(): void;
        seek(time: number): void;
        kill(complete?: boolean): void;
        private init;
        private reset;
        private update;
        private update2;
        private callStartCallback;
        private callUpdateCallback;
        private callCompleteCallback;
        static _pool: IPool<Tweener>;
        static _runAll(): void;
        static _getMap(): ReadonlyMap<number, Tweener>;
    }
    class TweenValue implements ITweenValue {
        readonly nums: Array<number>;
        private _props;
        /**
         * @internal
         */
        constructor(props: Array<TweenPropInfo>);
        get(name: string): any;
        set(name: string, value: any): void;
        getAt(index: number): any;
        setAt(index: number, value: any): void;
        get count(): number;
        copy(source: ITweenValue): this;
        /**
         * @internal
         */
        read(type: TweenPropInfo["type"], offset: number): any;
        /**
         * @internal
         */
        write(type: TweenPropInfo["type"], offset: number, value: any): void;
    }
    const TweenValueAdapterKey: unique symbol;
    /**
     * @en The `AutoBitmap` class is a display object that represents bitmap images or graphics.
     * It encapsulates the handling of position, width, height, and nine-patch for UI components.
     * @zh `AutoBitmap` 类是用于表示位图图像或绘制图形的显示对象。
     * 封装了位置，宽高及九宫格的处理，供UI组件使用。
     */
    class AutoBitmap extends Graphics {
        /** 宽度*/
        private _width;
        /** 高度*/
        private _height;
        /** 源数据*/
        private _source;
        /** 纹理的九宫格数据 */
        private _sizeGrid;
        protected _isChanged: boolean;
        protected _stateIndex: number;
        protected _stateNum: number;
        /**@internal */
        _color: string;
        /**@internal */
        _offset: any[];
        private _drawCmd;
        uv: number[];
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): number[];
        set sizeGrid(value: number[]);
        /**
         * @en The width of the display object, in pixels.
         * @zh 表示显示对象的宽度，以像素为单位。
         */
        get width(): number;
        set width(value: number);
        /**
         * @en The height of the display object, in pixels.
         * @zh 表示显示对象的高度，以像素为单位。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en The texture resource of the object.
         * @zh 对象的纹理资源。
         */
        get source(): Texture;
        set source(value: Texture);
        /**
         * @en The color of the object.
         * @zh 对象的颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Mark the object as changed.
         * @zh 标记对象为已更改状态。
         */
        protected _setChanged(): void;
        /**
         * @en Change the texture resource.
         * @zh 修改纹理资源。
         */
        protected changeSource(): void;
        /**
         * @en Destroy the object.
         * @zh 销毁对象。
         */
        destroy(): void;
        /**
         * @internal
         * @en Set the state of the object.
         * @param index The state index.
         * @param numStates The total number of states.
         * @zh 设置对象的状态。
         * @param index 状态索引。
         * @param numStates 状态的总数。
         */
        setState(index: number, numStates: number): void;
    }
    /**
     * @en The `Box` class is the base class for UI containers.
     * Other container components will inherit from this class.
     * @zh `Box` 类是 UI 容器的基类。
     * 其他的容器组件都会继承于该类。
     * @blueprintInheritable
     */
    class Box extends UIComponent {
        /**
         * @en The background color.
         * @zh 背景颜色。
         */
        private _bgColor;
        set_dataSource(value: any): void;
        /**
        * @en background color
        * @zh 容器的背景颜色
        */
        get bgColor(): string;
        set bgColor(value: string);
    }
    /**
     * @en The Button component is used to represent a button with multiple states. The Button component can display a text label, an icon, or both.
     * The states can be single-state, two-state (normal, pressed), or three-state (normal, hover, pressed). By default, it is three-state.
     * @zh `Button` 组件用来表示多种状态的按钮。`Button` 组件可显示文本标签、图标或同时显示两者。
     * 多种状态，可以是单态，两态（移出、按下）和三态(移出、悬停、按下)，默认是三态。
     * @blueprintInheritable
     */
    class Button extends UIComponent implements ISelect {
        /**
         * @en Controls whether the button can toggle its display state. When the value is true, the display state can be toggled by clicking, such as switching between selected and unselected states.
         * @zh 用于控制按钮是否可切换显示状态；值为 true 时，才可以在运行后通过点击切换显示状态。例如选中状态和未选中状态。
         */
        toggle: boolean;
        /**
         * @en The text on the button.
         * @zh 按钮上的文本。
         */
        protected _text: Text;
        /**
         * @en The color value of the button's text label.
         * @zh 按钮文本标签的颜色值。
         */
        protected _labelColors: string[];
        /**
         * @en The color value of the button's text label stroke.
         * @zh 按钮文本标签描边的颜色值。
         */
        protected _strokeColors: string[];
        /**
         * @en The state value of the button.
         * @zh 按钮的状态值。
         */
        protected _state: number;
        /**
         * @en Indicates the selected state of the button.
         * @zh 表示按钮的选中状态。
         */
        protected _selected: boolean;
        /**
         * @en The skin resource of the button.
         * @zh 按钮的皮肤资源。
         */
        protected _skin: string;
        /**
         * @en Specifies whether the display object automatically calculates and changes size and other attributes.
         * @zh 指定此显示对象是否自动计算并改变大小等属性。
         */
        protected _autoSize: boolean;
        /**
         * @en The number of states for the button.
         * @zh 按钮的状态数。
         */
        protected _stateNum: number;
        /**
         * @en The click event handler of the button.
         * @zh 按钮的点击事件函数。
         */
        protected _clickHandler: Handler;
        protected _stateChanged: boolean;
        /**
         * @internal
         */
        _graphics: AutoBitmap;
        /**
         * @en The state value of the button.
         * @zh 对象的状态值。
         */
        protected get state(): number;
        protected set state(value: number);
        /**
         * @en The skin resource address of the object.
         * Supports single state, two states and three states, set with the `stateNum` property.
         * @zh 对象的皮肤资源地址。
         * 支持单态，两态和三态，用 `stateNum` 属性设置
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The state value of the object, expressed as a number.
         * The default value is 3. This value determines how the skin resource image is sliced.
         * Values:
         * - 1: Single state. The image is not sliced, and the button has only one skin state.
         * - 2: Two states. The image will be sliced equally in the vertical direction into 2 parts, from top to bottom, the up state skin and the down and over and selected state skin, respectively.
         * - 3: Three states. The image will be sliced equally in the vertical direction into 3 parts, from top to bottom, the up state skin, the over state skin, and the down and selected state skin, respectively.
         * @zh 指定对象的状态值，以数字表示。
         * 默认值为3。此值决定皮肤资源图片的切割方式。
         * 取值：
         * - 1：单态。图片不做切割，按钮的皮肤状态只有一种。
         * - 2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为弹起状态皮肤、按下和经过及选中状态皮肤。
         * - 3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为弹起状态皮肤、经过状态皮肤、按下和选中状态皮肤
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @en The text content of the button.
         * @zh 按钮的文本内容。
         */
        get label(): string;
        set label(value: string);
        /**
         * @en Indicates the selected state of the button.
         * If the value is true, it indicates that the object is in the selected state. Otherwise, it is not selected.
         * @zh 表示按钮的选中状态。
         * 如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。
         */
        get selected(): boolean;
        set selected(value: boolean);
        /**
          * @en The text color of the button in each state.
          * Format: "upColor,overColor,downColor".
          * @zh 表示按钮各个状态下的文本颜色。
          * 格式: "upColor,overColor,downColor"。
          */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @en The stroke color of the button in each state.
         * Format: "upColor,overColor,downColor".
         * @zh 表示按钮各个状态下的描边颜色。
         * 格式: "upColor,overColor,downColor"。
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * @en The margins of the button's text label.
         * Format: "top,right,bottom,left".
         * @zh 表示按钮文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"。
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * @en The font size of the button's text label.
         * @zh 表示按钮文本标签的字体大小。
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * @en The stroke width, in pixels.
         * Default value is 0, indicating no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * @en The stroke color, represented by a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）;
         * @see laya.display.Text.strokeColor()
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * @en Indicates whether the button's text label is bold.
         * @zh 表示按钮文本标签是否为粗体字。
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @en The font name of the button's text label, expressed as a string.
         * @zh 表示按钮文本标签的字体名称，以字符串形式表示。
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @en The text alignment mode.
         * @zh 标签水平对齐模式。
         */
        get labelAlign(): string;
        set labelAlign(value: string);
        /**
         * @en The vertical alignment mode.
         * @zh 标签垂直对齐模式。
         */
        get labelVAlign(): string;
        set labelVAlign(value: string);
        /**
         * @en The click event handler of the object (without default parameters).
         * @zh 对象的点击事件处理器函数（无默认参数）。
         */
        get clickHandler(): Handler;
        set clickHandler(value: Handler);
        /**
         * @en The button's text label `Text` control.
         * @zh 按钮文本标签 `Text` 控件。
         */
        get text(): Text;
        set text(value: Text);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 皮肤纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en The x and y offset of the icon, format: 100,100
         * @zh 图标x,y偏移，格式：100,100
         */
        get iconOffset(): string;
        set iconOffset(value: string);
        /**
         * @en Creates a new instance of the `Button` class.
         * @param skin The address of the skin resource.
         * @param label The text content of the button.
         * @zh 创建一个新的 `Button` 类实例。
         * @param skin 皮肤资源地址。
         * @param label 按钮的文本内容。
         */
        constructor(skin?: string, label?: string);
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Destroy the object and release resources.
         * @zh 销毁
         * @param destroyChild 是否删除子节点
         */
        destroy(destroyChild?: boolean): void;
        protected createChildren(): void;
        protected createText(): void;
        protected initialize(): void;
        /**
         * @en The event listener process function for the object's `Event.MOUSE_OVER`, `Event.MOUSE_OUT`, `Event.MOUSE_DOWN`, `Event.MOUSE_UP`, and `Event.CLICK` events.
         * @param e The event object.
         * @zh 对象的 `Event.MOUSE_OVER`、`Event.MOUSE_OUT`、`Event.MOUSE_DOWN`、`Event.MOUSE_UP`、`Event.CLICK` 事件侦听处理函数。
         * @param e 事件对象
         */
        protected onMouse(e: Event): void;
        /**
         * @internal
         * @en Set the skin resource of the button.
         * @param url The URL of the skin resource.
         * @zh 设置皮肤资源。
         * @param url 皮肤资源的URL。
         */
        _setSkin(url: string): Promise<void>;
        /**
         * @en The skin resource is loaded.
         * @param tex The texture resource.
         * @zh 皮肤资源加载完成后的处理。
         * @param tex 纹理资源。
         */
        protected _skinLoaded(tex: any): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en The resource slices of the object have changed.
         * @zh 对象的资源切片发生改变。
         */
        protected changeClips(): void;
        /**
         * @en Change the state of the object.
         * @zh 改变对象的状态。
         */
        protected changeState(): void;
        protected _setStateChanged(): void;
        /**
         * @en Sets the data source.
         * @zh 设置数据源。
         */
        set_dataSource(value: any): void;
        /** @internal @blueprintEvent */
        Button_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @en The `CheckBox` component displays a small box that can have a check mark.
     * - The `CheckBox` component can also display an optional text label, which is positioned to the right of the CheckBox by default.
     * - When assigning a value to `CheckBox` using `dataSource`, the default property is `selected`.
     * - `change` event, dispatched when the button's selected state (`selected` property) changes.
     * @zh `CheckBox` 组件显示一个小方框，该方框内可以有选中标记。
     * - `CheckBox` 组件还可以显示可选的文本标签，默认该标签位于 CheckBox 右侧。
     * - 使用 `dataSource` 赋值时，`CheckBox` 的默认属性是 `selected`。
     * - `change`事件，当按钮的选中状态（ `selected` 属性）发生改变时调度。
     * @blueprintInheritable
     */
    class CheckBox extends Button {
        /**
         * @en `CheckBox` component constructor.
         * @param skin The skin resource address.
         * @param label The content of the text label.
         * @zh `CheckBox` 组件的构造函数。
         * @param skin 皮肤资源地址。
         * @param label 文本标签的内容。
         */
        constructor(skin?: string, label?: string);
        /**
         * @en Preinitialization method. Called before the object is initialized.
         * @zh 预初始化方法。在对象初始化之前调用。
         */
        protected preinitialize(): void;
        /**
         * @en Initialization method. Called when the object is initialized.
         * @zh 初始化方法。在对象初始化时调用。
         */
        protected initialize(): void;
        /**
         * @en Sets the data source of the component.
         * @param value The data source.
         * @zh 设置组件的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The `Clip` class is a bitmap slice animation.
     * `Clip` can split an image into a slice animation by horizontal split count `clipX`, vertical split count `clipY`,
     * or horizontal split width `clipWidth`, vertical split height `clipHeight`,
     * from left to right, from top to bottom.
     * The Image and Clip components are the only two components that support asynchronous loading, such as clip.skin = "abc/xxx.png". Other UI components do not support asynchronous loading.
     * @zh `Clip` 类是位图切片动画。
     * `Clip` 可将一张图片，按横向分割数量 `clipX` 、竖向分割数量 `clipY` ，
     * 或横向分割每个切片的宽度 `clipWidth` 、竖向分割每个切片的高度 `clipHeight` ，
     * 从左向右，从上到下，分割组合为一个切片动画。
     * Image和Clip组件是唯一支持异步加载的两个组件，比如clip.skin = "abc/xxx.png"，其他UI组件均不支持异步加载。
     * @blueprintInheritable
     */
    class Clip extends UIComponent {
        protected _sources: Texture[];
        protected _skin: string;
        protected _clipX: number;
        protected _clipY: number;
        protected _clipWidth: number;
        protected _clipHeight: number;
        protected _autoPlay: boolean;
        protected _interval: number;
        protected _complete: Handler;
        protected _isPlaying: boolean;
        protected _index: number;
        protected _clipChanged: boolean;
        protected _group: string;
        protected _toIndex: number;
        protected _clipBySize: boolean;
        /**@internal */
        _graphics: AutoBitmap;
        /**
         * @en The address of the skin resource.
         * @zh 皮肤资源地址
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en Number of slices on the X-axis (horizontal).
         * @zh X轴（横向）切片数量。
         */
        get clipX(): number;
        set clipX(value: number);
        /**
         * @en Number of slices on the Y-axis (vertical).
         * @zh Y轴(竖向)切片数量。
         */
        get clipY(): number;
        set clipY(value: number);
        /**
         * @en Width of each slice when dividing horizontally. Takes precedence over `clipX` when set together with `clipX`.
         * @zh 横向分割时每个切片的宽度，与 `clipX` 同时设置时优先级高于 `clipX` 。
         */
        get clipWidth(): number;
        set clipWidth(value: number);
        /**
         * @en Height of each slice when dividing vertically. Takes precedence over `clipY` when set together with `clipY`.
         * @zh 竖向分割时每个切片的高度，与 `clipY` 同时设置时优先级高于 `clipY` 。
        */
        get clipHeight(): number;
        set clipHeight(value: number);
        /**
         * @zh 切片是否按宽高切割。默认为false，采用数量切割。
         * @en Indicates whether the slice is clipped by width and height. Default is false, which means clipping by count.
         */
        get clipBySize(): boolean;
        set clipBySize(value: boolean);
        /**
         * @en Source data.
         * @zh 源数据。
         */
        get sources(): Texture[];
        set sources(value: Texture[]);
        /**
         * @en Resource group.
         * @zh 资源分组。
        */
        get group(): string;
        set group(value: string);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Current frame index.
         * @zh 当前帧索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en Total frames of the slice animation.
         * @zh 切片动画的总帧数。
         */
        get total(): number;
        /**
         * @en Indicates whether the slice animation is automatically played. If true, the slice animation is automatically played; otherwise, it is not.
         * It can control the playback and stop of the slice animation.
         * @zh 是否自动播放切片动画，若自动播放值为true,否则值为false。
         * 可控制切片动画的播放、停止。
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Indicates the interval (in milliseconds) at which the slice animation is played.
         * @zh 切片动画播放间隔时间（以毫秒为单位）。
         */
        get interval(): number;
        set interval(value: number);
        /**
         * @en Indicates the current playback state of the slice animation.
         * If the slice animation is playing, the value is true; otherwise, it is false.
         * @zh 切片动画的当前播放状态。
         * 如果切片动画正在播放中，则为true，否则为false。
         */
        get isPlaying(): boolean;
        set isPlaying(value: boolean);
        /**
         * @en 'Clip' constructor.
         * @param url Resource address.
         * @param clipX Number of divisions in the X direction.
         * @param clipY Number of divisions in the Y direction.
         * @zh  `Clip` 构造函数。
         * @param url 资源地址。
         * @param clipX X方向分割数量。
         * @param clipY Y方向分割数量。
         */
        constructor(url?: string, clipX?: number, clipY?: number);
        private _onDisplay;
        /**@internal */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        protected _setClipChanged(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected _loop(): void;
        protected createChildren(): void;
        /**
         * @en Changes the resources and size of the slices.
         * @zh 改变切片的资源、切片的大小。
         */
        protected changeClip(): void;
        /**
         * @en Callback function when the sliced image resources are loaded.
         * @param url Resource URL.
         * @param img Texture.
         * @zh 加载切片图片资源完成函数。
         * @param url 资源地址。
         * @param img 纹理。
         */
        protected loadComplete(url: string, img: Texture): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Plays the slice animation.
         * @param from Start index.
         * @param to End index, -1 is not limited.
         * @zh 播放切片动画。
         * @param from	开始索引
         * @param to		结束索引，-1为不限制
         */
        play(from?: number, to?: number): void;
        /**
         * @en Stops the slice animation.
         * @zh 停止切片动画。
         */
        stop(): void;
        set_dataSource(value: any): void;
        /** @internal @blueprintEvent */
        Clip_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en The `ColorPicker` component displays a color palette from which the user can select a color.
     * @zh `ColorPicker` 组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。
     * @blueprintInheritable
     */
    class ColorPicker extends UIComponent {
        /**
         * @en Specifies the width and height of each color cell (in pixels).
         * @zh 指定每个正方形的颜色小格子的宽高（以像素为单位）。
         */
        protected _gridSize: number;
        /**
         * @en The background color value of the color palette panel.
         * @zh 表示颜色样本列表面板的背景颜色值。
         */
        protected _bgColor: string;
        /**
         * @en The border color value of the color palette panel.
         * @zh 表示颜色样本列表面板的边框颜色值。
         */
        protected _borderColor: string;
        /**
         * @en Represents the color value selected or input in the color sample list panel.
         * @zh 表示颜色样本列表面板选择或输入的颜色值。
         */
        protected _inputColor: string;
        /**
         * @en The background color value of the color input box.
         * @zh 表示颜色输入框的背景颜色值。
         */
        protected _inputBgColor: string;
        /**
         * @en Represents the color palette panel.
         * @zh 表示颜色样本列表面板。
         */
        protected _colorPanel: Box;
        /**
         * @en Represents the color grid.
         * @zh 表示颜色网格。
         */
        protected _colorTiles: Sprite;
        /**
         * @en Represents the color block display object.
         * @zh 表示颜色块显示对象。
         */
        protected _colorBlock: Sprite;
        /**
         * @en Represents the color input box control `Input`.
         * @zh 表示颜色输入框控件 `Input`。
         */
        protected _colorInput: Input;
        /**
         * @en Represents the button control `Button` that displays the color palette panel when clicked.
         * @zh 表示点击后显示颜色样本列表面板的按钮控件 `Button`。
         */
        protected _colorButton: Button;
        /**
        * @en Represents the list of color values.
        * @zh 表示颜色值列表。
        */
        protected _colors: any[];
        /**
         * @en Represents the selected color value.
         * @zh 表示选择的颜色值。
         */
        protected _selectedColor: string;
        protected _panelChanged: boolean;
        /**
         * @en The function handler executed when the color changes.
         * The default return parameter is `color`: the color value string.
         * @zh 当颜色发生改变时执行的函数处理器。
         * 默认返回参数color：颜色值字符串。
         */
        changeHandler: Handler;
        /**
         * @en The selected color value.
         * @zh 表示选择的颜色值。
         */
        get selectedColor(): string;
        set selectedColor(value: string);
        /**
         * @en The skin URL of the color picker.
         * @zh 颜色选择器的皮肤地址。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The background color value of the color palette panel.
         * @zh 表示颜色样本列表面板的背景颜色值。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en The border color value of the color palette panel.
         * @zh 表示颜色样本列表面板的边框颜色值。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en The color value selected or entered in the color palette panel.
         * @zh 表示颜色样本列表面板选择或输入的颜色值。
         */
        get inputColor(): string;
        set inputColor(value: string);
        /**
         * @en The background color value of the color input box.
         * @zh 表示颜色输入框的背景颜色值。
         */
        get inputBgColor(): string;
        set inputBgColor(value: string);
        constructor(createChildren?: boolean);
        protected _setPanelChanged(): void;
        protected createChildren(): void;
        protected initialize(): void;
        private onPanelMouseDown;
        /**
         * @en Changes the color palette panel.
         * @zh 改变颜色样本列表面板。
         */
        protected changePanel(): void;
        /**
         * @en Handles the `Event.MOUSE_DOWN` event of the color button.
         * @param e The event object.
         * @zh 颜色样本列表面板显示按钮的 `Event.MOUSE_DOWN` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorButtonClick;
        /**
         * @en Handles the `Event.MOUSE_DOWN` event of the stage to close the color palette panel.
         * @param e (Optional) The event object.
         * @zh 处理舞台的 `Event.MOUSE_DOWN` 事件侦听处理函数，关闭颜色面板。
         * @param e (可选) 事件对象。
         */
        private removeColorBox;
        /**
         * @en Handles the `Event.KEY_DOWN` event of the color input field.
         * @param e The event object.
         * @zh 处理颜色输入框的 `Event.KEY_DOWN` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorFieldKeyDown;
        /**
         * @en Handles the `Event.CHANGE` event of the color input field.
         * @param e (Optional) The event object.
         * @zh 处理颜色输入框的 `Event.CHANGE` 事件侦听处理函数。
         * @param e (可选) 事件对象。
         */
        private onColorInputChange;
        /**
         * @en Handles the `Event.CLICK` event of the color tiles.
         * @param e The event object.
         * @zh 处理颜色格子的 `Event.CLICK` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorTilesClick;
        /**
         * @en Handles the `Event.MOUSE_MOVE` event of the color tiles.
         * @param e The event object.
         * @zh 处理颜色格子的 `Event.MOUSE_MOVE` 事件侦听处理函数。
         * @param e 事件对象。
         */
        private onColorTilesMouseMove;
        /**
         * @en Gets the color value of the corresponding color block based on the mouse position.
         * @zh 通过鼠标位置取对应的颜色块的颜色值。
         */
        protected getColorByMouse(): string;
        /**
         * @en Draws the color block.
         * @param color The color value to draw.
         * @zh 绘制颜色块。
         * @param color 要绘制的颜色值。
         */
        private drawBlock;
        /**
         * @en Changes the color.
         * @zh 改变颜色。
         */
        private changeColor;
        /**
         * @en Opens the color palette panel.
         * @zh 打开颜色样本列表面板。
         */
        open(): void;
        /**
         * @en Closes the color palette panel.
         * @zh 关闭颜色样本列表面板。
         */
        close(): void;
        /**
         * @en Destroys the color picker component.
         * @param destroyChild Indicates whether to destroy the component's children as well. Default value is true.
         * @zh 销毁颜色选择器组件。
         * @param destroyChild 是否同时销毁子项。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /** @internal @blueprintEvent */
        ColorPicker_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @zh `ComboBox` 组件包含一个下拉列表，用户可以从该列表中选择单个值。
     * - `change`事件：当用户更改 `ComboBox` 组件中的选定内容时调度。
     * @en The `ComboBox` component contains a drop-down list from which the user can select a single value.
     * - `change` event: Dispatched when the user changes the selected content in `ComboBox` component.
     * @blueprintInheritable
     */
    class ComboBox extends UIComponent {
        protected _visibleNum: number;
        protected _button: Button;
        protected _list: List;
        protected _isOpen: boolean;
        protected _itemColors: string[];
        protected _itemPadding: number[];
        protected _itemSize: number;
        protected _labels: string[];
        /**
         * 下拉提示文本
         */
        protected _defaultLabel: string;
        protected _selectedIndex: number;
        protected _selectHandler: Handler;
        protected _itemHeight: number;
        protected _listHeight: number;
        protected _listChanged: boolean;
        protected _itemChanged: boolean;
        protected _scrollBarSkin: string;
        protected _scrollType: ScrollType;
        protected _isCustomList: boolean;
        /**
         * @zh 渲染项，用来显示下拉列表展示对象
         * @en Rendering item, used to display a dropdown list to display objects
         */
        itemRender: any;
        /**
         * @zh 对象的皮肤纹理资源地址。 支持单态，两态和三态，用 `stateNum` 属性设置
         * @en The skin resource address of the object. Supports single state, two states and three states, set with the `stateNum` property.
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @zh 下拉列表文本的边距。
         * - 格式：上边距,右边距,下边距,左边距
         * @en The padding of the drop-down list text.
         * - The format is: top, right, bottom, left
         */
        get itemPadding(): string;
        set itemPadding(value: string);
        /**
         * @zh 标签集合字符串。
         * @en The string of label collection.
         */
        get labels(): string;
        set labels(value: string);
        /**
         * @zh 表示选择的下拉列表项的索引。
         * @en Indicates the index of the selected drop-down list item.
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @zh 默认的下拉提示文本。
         * @en The default drop-down prompt text.
         */
        get defaultLabel(): string;
        set defaultLabel(value: string);
        /**
         * @zh 改变下拉列表的选择项时执行的处理器(默认返回参数index:int)。
         * @en The handler to be executed when changing the selection of the drop-down list (default returns parameter index:int).
         */
        get selectHandler(): Handler;
        set selectHandler(value: Handler);
        /**
         * @zh 表示选择的下拉列表项的的标签。
         * @en Indicates the label of the selected drop-down list item.
         */
        get selectedLabel(): string;
        set selectedLabel(value: string);
        /**
         * @zh 获取或设置没有滚动条的下拉列表中可显示的最大行数。
         * @en Gets or sets the maximum number of rows that can be displayed in the drop-down list without a scrollbar.
         */
        get visibleNum(): number;
        set visibleNum(value: number);
        /**
         * @zh 下拉列表项的高度。
         * @en The height of the drop-down list item.
         */
        get itemHeight(): number;
        set itemHeight(value: number);
        /**
         * @zh 下拉列表项颜色。
         * 格式：悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色"。
         * @en The color of drop-down list items.
         * The format is: "background color when hovering or selected, label color when hovering or selected, label color, border color, background color"
         */
        get itemColors(): string;
        set itemColors(value: string);
        /**
         * @zh 下拉列表项标签的字体大小。
         * @en The font size of the drop-down list item label.
         */
        get itemSize(): number;
        set itemSize(value: number);
        /**
         * @zh 表示下拉列表的打开状态。
         * @en Indicates the open state of the drop-down list.
         */
        get isOpen(): boolean;
        set isOpen(value: boolean);
        /**
         * @zh 滚动类型。
         * @en The scroll type.
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @zh 滚动条皮肤。
         * @en The scrollbar skin.
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @zh `ComboBox` 组件所包含的 `VScrollBar` 滚动条组件的引用。
         * @en a reference to the `VScrollBar` scrollbar component contained in the `ComboBox` component.
         */
        get scrollBar(): VScrollBar;
        /**
         * @zh `ComboBox` 组件所包含的 `Button` 组件的引用。
         * @en a reference to the `Button` component contained in the `ComboBox` component.
         */
        get button(): Button;
        /**
         * @zh `ComboBox` 组件所包含的 `List` 列表组件的引用。
         * @en a reference to the `List` list component contained in the `ComboBox` component.
         */
        get list(): List;
        set list(value: List);
        /**
         * @zh  `ComboBox` 组件所包含的 `Button` 组件的文本标签颜色。
         * 格式：upColor,overColor,downColor
         * @en the text label color of the `Button` component contained in the `ComboBox` component.
         * The format is: upColor,overColor,downColor
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @zh `ComboBox` 组件所包含的 `Button` 组件的文本边距。
         * 格式：上边距,右边距,下边距,左边距
         * @en the text margin of the `Button` component contained in the `ComboBox` component.
         * The format is: top, right, bottom, left
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
        * @zh `ComboBox` 组件所包含的 `Button` 组件的标签字体大小。
        * @en the label font size of the `Button` component contained in the `ComboBox` component.
        */
        get labelSize(): number;
        set labelSize(value: number);
        /**
        * @zh 表示按钮文本标签是否为粗体字。
        * @en Indicates whether the button text label is bold.
        */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @zh 表示按钮文本标签的字体名称，以字符串形式表示。
         * @en Indicates the font name of the button text label, expressed as a string.
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @zh 表示按钮的状态值。
         * @en Indicates the state value of the button.
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @zh  `ComboBox` UI组件的构造函数。
         * @param skin 皮肤资源地址。
         * @param labels 下拉列表的标签集字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         * @en `ComboBox` constructor.
         * @param skin The skin resource address.
         * @param labels The string of the label collection in the drop-down list. Separated by commas, such as "item0,item1,item2,item3,item4,item5".
         */
        constructor(skin?: string, labels?: string);
        protected createChildren(): void;
        private _createList;
        private _setListEvent;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        private _onStageMouseWheel;
        /**
         * @zh 关闭下拉列表。
         * @en Close the drop-down list of ComboBox.
         */
        protected removeList(e: Event): void;
        private onListDown;
        private onScrollBarDown;
        private onButtonMouseDown;
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected changeList(): void;
        /**
         * @zh 处理列表项的鼠标事件。该方法根据鼠标交互（如悬停和点击）管理列表项的视觉状态。
         * @param e 鼠标事件。
         * @param index 列表项的索引。
         * @en Handles mouse events on a list item. This method manages the visual state of the list item based on mouse interaction, such as hover and click.
         * @param e The mouse event.
         * @param index The index of the list item.
         */
        protected onlistItemMouse(e: Event, index: number): void;
        private switchTo;
        /**
         * @zh 更改下拉列表的打开状态。
         * @en Changing the open state of the drop-down list.
         */
        protected changeOpen(): void;
        /**
         * @zh 更新列表中的项目并调整其视觉表现。此方法重新计算列表高度，如果不是自定义列表，则更新背景，并使用新数据填充列表。
         * @en Updates the items in the list and adjusts its visual representation. This method recalculates the list height, updates the background if it's not a custom list, and populates the list with new data.
         */
        protected changeItem(): void;
        private changeSelected;
        /**
         * @zh 销毁组件并释放组件所占用的内存。默认会同时销毁组件的子对象。
         * @param destroyChild 是否同时销毁组件的子对象。默认值为true。
         * @en Destroy the component and release the memory occupied by the component. Destroy the child objects of the component at the same time by default.
         * @param destroyChild Whether to simultaneously destroy the child objects of the component. The default value is true.
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @zh 设置下拉选项框的数据源。
         * @param value 新的数据源。
         * @en Set the data source of the ComboBox.
         * @param value The new data source.
         */
        set_dataSource(value: any): void;
        /** @internal @blueprintEvent */
        ComboBox_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @en The `Dialog` component is a pop-up dialog box that implements the functionality of popping up, dragging, and modal windows.
     * You can set the background transparency of the pop-up box through the `UIConfig`, and whether to close the window when clicking the edge in modal mode.
     * By setting the `zOrder` property, you can change the popup hierarchy.
     * By setting the `popupEffect` and `closeEffect`, you can set the popup and close effects. If you don't want any popup or close effects, you can set the aforementioned properties to empty.
     * @zh `Dialog` 组件是一个弹出对话框，实现对话框弹出，拖动，模式窗口功能。
     * 可以通过 `UIConfig` 设置弹出框背景透明度，模式窗口点击边缘是否关闭等。
     * 通过设置 `zOrder` 属性，可以更改弹出的层次。
     * 通过设置 `popupEffect` 和 `closeEffect` 可以设置弹出效果和关闭效果，如果不想有任何弹出关闭效果，可以设置前述属性为空。
     * @blueprintInheritable
     */
    class Dialog extends View {
        /**
         * @en If a button in the dialog is named `close`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `close`，点击此按钮则会关闭对话框。
         */
        static readonly CLOSE: string;
        /**
         * @en If a button in the dialog is named `cancel`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `cancel`，点击此按钮则会关闭对话框。
         */
        static readonly CANCEL: string;
        /**
         * @en If a button in the dialog is named `sure`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `sure`，点击此按钮则会关闭对话框。
         */
        static readonly SURE: string;
        /**
         * @en If a button in the dialog is named `no`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `no`，点击此按钮则会关闭对话框。
         */
        static readonly NO: string;
        /**
         * @en If a button in the dialog is named `yes`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `yes`，点击此按钮则会关闭对话框。
         */
        static readonly YES: string;
        /**
         * @en If a button in the dialog is named `ok`, clicking it will close the dialog.
         * @zh 对话框内的某个按钮命名为 `ok`，点击此按钮则会关闭对话框。
         */
        static readonly OK: string;
        /** 表示对话框管理器。*/
        private static _manager;
        /**
         * @en
         * The dialog management container. All dialogs are inside this container and managed by the manager.
         * You can customize your own manager to change the window management process.
         * Any dialog opened or closed will trigger the `open` and `close` events of the management class.
         * @zh
         * 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理，可以自定义自己的管理器，来更改窗口管理的流程。
         * 任意对话框打开和关闭，都会触发管理类的 `open` 和 `close` 事件。
         */
        static get manager(): DialogManager;
        /**
         * @blueprintIgnore
         */
        static set manager(value: DialogManager);
        /**
         * @en Set the lock view. Display the lock view before the interface is ready, and remove the lock layer after it is ready.
         * If it is empty, nothing will be displayed.
         * @param view The content of the lock view.
         * @zh 设置锁定界面，在界面未准备好前显示锁定界面，准备完毕后则移除锁定层，如果为空则什么都不显示
         * @param view 锁定界面内容
         */
        static setLockView(view: UIComponent): void;
        /**
         * @en Lock all layers, display loading information, and prevent the content below from being clicked.
         * @param value Whether to lock.
         * @zh 锁定所有层，显示加载条信息，防止下面内容被点击。
         * @param value 是否锁定
         */
        static lock(value: boolean): void;
        /**
         * @en Close all dialogs.
         * @zh 关闭所有对话框。
         */
        static closeAll(): void;
        /**
         * @en Get the dialog collection by group.
         * @param group The group name.
         * @returns The dialog array.
         * @zh 根据组获取对话框集合。
         * @param group 组名称
         * @returns 对话框数组
         */
        static getDialogsByGroup(group: string): any[];
        /**
         * @en Close all pop-up boxes by group.
         * @param group The group name that needs to be closed.
         * @returns The closed dialogs.
         * @zh 根据组关闭所有弹出框。
         * @param group 需要关闭的组名称
         * @returns 关闭的对话框集合
         */
        static closeByGroup(group: string): any[];
        private _dragArea;
        /**@internal */
        _param: any;
        /**@internal */
        _effectTween: Tween;
        /**
         * @en The handler function that will be triggered when the dialog is closed.
         * The callback function parameter is the button name clicked by the user, of type `String`.
         * @zh 对话框被关闭时会触发的回调函数处理器。
         * 回调函数参数为用户点击的按钮名字name:String。
         */
        closeHandler: Handler;
        /**
         * @en The popup effect of the dialog. You can set an effect to replace the default popup effect.
         * If you don't want any effect, you can set it to `null`.
         * The default global popup effect can be set via `manager.popupEffect`.
         * @zh 弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null。
         * 全局默认弹出效果可以通过manager.popupEffect修改。
         */
        popupEffect: Handler;
        /**
         * @en The close effect of the dialog. You can set an effect to replace the default close effect.
         * If you don't want any effect, you can set it to `null`.
         * The default global close effect can be set via `manager.closeEffect`.
         * @zh 关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null。
         * 全局默认关闭效果可以通过manager.closeEffect修改。
         */
        closeEffect: Handler;
        /**
         * @en The dialog group name.
         * @zh 组名称。
         */
        group: string;
        /**
         * @en Indicates whether it is a modal dialog.
         * @zh 是否是模式窗口。
         */
        isModal: boolean;
        /**
         * @en Indicates whether to show popup effect.
         * @zh 是否显示弹出效果。
         */
        isShowEffect: boolean;
        /**
         * @en Specifies whether the dialog is popped up at the center.
         * If the value is `true`, the dialog will be centered. Otherwise, it will be displayed based on the object coordinates. The default value is `true`.
         * @zh 指定对话框是否居中弹出。
         * 如果值为true，则居中弹出，否则，则根据对象坐标显示，默认为true。
         */
        isPopupCenter: boolean;
        /**
         * @en The close type. Automatically records the name of the clicked button when its name is `"close"`, `"cancel"`, `"sure"`, `"no"`, `"yes"`, or `"no"`.
         * @zh 关闭类型，点击name为`"close"`，`"cancel"`，`"sure"`，`"no"`，`"yes"`，`"no"`的按钮时，会自动记录点击按钮的名称。
         */
        closeType: string;
        /**
         * @en Used to specify the drag area of the dialog. The default value is `"0,0,0,0"`.
         * The format is a string of `"x,y,width,height"` that represents a rectangle. For example, `"0,0,100,200"`.
         * @zh 用来指定对话框的拖拽区域。默认值为 `"0,0,0,0"`。
         * 格式：构成一个矩形所需的 x,y,width,heith 值，用逗号连接为字符串。例如："0,0,100,200"。
         */
        get dragArea(): string;
        set dragArea(value: string);
        /**
         * @en The display status of the pop-up box. If the pop-up box is being displayed, it is `true`; otherwise, it is `false`.
         * @zh 弹出框的显示状态。如果弹框处于显示中，则为 `true`，否则为 `false`。
         */
        get isPopup(): boolean;
        /**
         * @en The z-order of the dialog.
         * @zh 对话框的层级。
         */
        get zOrder(): number;
        set zOrder(value: number);
        /** @ignore */
        constructor();
        /** 提取拖拽区域*/
        protected _dealDragArea(): void;
        private _onMouseDown;
        /**
         * @en Handle the click event for the dialog box. Close the dialog box based on the button name.
         * @zh 处理对话框的点击事件。根据按钮的名称关闭对话框。
         * @param e 鼠标事件。
         */
        protected _onClick(e: Event): void;
        /**
         * @en Open the dialog.
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed. The default value is `true`.
         * @param param The parameters to pass to the dialog.
         * @zh 打开对话框。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param param 传递给对话框的参数。
         */
        open(closeOther?: boolean, param?: any): void;
        /**
         * @en Close the dialog.
         * @param type The reason for closing. It will be passed to the `onClosed` function.
         * @zh 关闭对话框。
         * @param type 关闭的原因，会传递给onClosed函数
         * @override
         */
        close(type?: string): void;
        /**
         * @en Destroy the dialog.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁对话框。
         * @param destroyChild 是否销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @en Display the dialog (non-modal).
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed.
         * @param showEffect Whether to show pop-up effect.
         * @zh 显示对话框（以非模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        show(closeOther?: boolean, showEffect?: boolean): void;
        /**
         * @en Display the dialog (modal).
         * @param closeOther Whether to close other dialogs. If the value is `true`, other dialogs will be closed.
         * @param showEffect Whether to show pop-up effect.
         * @zh 显示对话框（以模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        popup(closeOther?: boolean, showEffect?: boolean): void;
        protected _open(modal: boolean, closeOther: boolean, showEffect: boolean): void;
    }
    /**
     * @en The `DialogManager` is a container for managing all dialog boxes, which are managed by the manager.
     * Opening and closing any dialog will trigger the manager's open and close events.
     * open event is used for any window after dispatching, and close event is used to dispatch events when closing any dialog.
     * The background transparency of the popup, whether the modal window closes when the edge is clicked, and whether the layer changes when the window is clicked can be set in UIConfig.
     * The layer of the popup can be changed by setting the dialog's zOrder property.
     * @zh DialogManager 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理。
     * 任意对话框打开和关闭，都会触发管理类的 open 和 close 事件。
     * open事件用于任意窗口后调度，close事件用于关闭任意对话框时调度的事件。
     * 可以通过 UIConfig 设置弹出框背景透明度，模式窗口点击边缘是否关闭，点击窗口是否切换层次等。
     * 通过设置对话框的 zOrder 属性，可以更改弹出的层次。
     */
    class DialogManager extends Sprite {
        /**
         * @en Mask layer
         * @zh 遮罩层。
         */
        maskLayer: Sprite;
        /**
         * @en Lock screen layer.
         * @zh 锁屏层。
         */
        lockLayer: Sprite;
        /**
         * @en The global default popup effect for dialogs. You can set an effect to replace the default popup effect.
         * If you do not want any effect, you can assign it to null.
         * @zh 全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为 null。
         */
        popupEffect: (dialog: Dialog) => void;
        /**
         * @en The global default close effect for dialogs. You can set an effect to replace the default close effect.
         * If you do not want any effect, you can assign it to null.
         * @zh 全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为 null。
         */
        closeEffect: (dialog: Dialog) => void;
        /**
         * @en Sets the global default opening effect for the dialog. You can specify an effect to replace the default opening effect.
         * If you do not want any effect, it can be set to null.
         * @zh 设置全局默认的对话框打开效果。可以指定一个效果来替代默认的打开效果，如果不想有任何效果，可以设置为 null。
         */
        popupEffectHandler: Handler;
        /**
         * @en Sets the global default closing effect for the dialog. You can specify an effect to replace the default closing effect.
         * If you do not want any effect, it can be set to null.
         * @zh 设置全局默认的对话框关闭效果。可以指定一个效果来替代默认的关闭效果，如果不想有任何效果，可以设置为 null。
         */
        closeEffectHandler: Handler;
        /** @ignore */
        constructor();
        private _closeOnSide;
        private _onResize;
        private _centerDialog;
        private _clearDialogEffect;
        private _closeAll;
        /**
         * @internal
         * @en Checks and readjusts the mask layer after a change in the z-order of dialogs.
         * @zh 发生层次改变后，重新检查遮罩层是否正确
         */
        _checkMask(): void;
        /**
         * @en Sets the lock view. If no value is provided, the lock layer will be empty and won't display anything.
         * @param value The UIComponent to display on the lock layer, or null for an empty lock layer.
         * @zh 设置锁定界面，如果参数为空则什么都不显示。
         * @param value 要在锁定层上显示的UI组件，空锁定层为null。
         */
        setLockView(value: UIComponent): void;
        /**
         * @en Opens a dialog.
         * @param dialog The Dialog instance to be displayed.
         * @param closeOther Whether to close other dialogs. If true, other dialogs will be closed.
         * @param showEffect Whether to show the popup effect.
         * @zh 打开对话框。
         * @param dialog 需要显示的对话框 Dialog 实例。
         * @param closeOther 是否关闭其他对话框。若为 true，则关闭其他对话框。
         * @param showEffect 是否显示弹出效果。
         */
        open(dialog: Dialog, closeOther?: boolean, showEffect?: boolean): void;
        /**
         * @en Executes the opening of a dialog.
         * @param dialog The Dialog instance that needs to be opened.
         * @zh 执行打开对话框操作。
         * @param dialog 需要打开的对话框 Dialog 实例。
         */
        doOpen(dialog: Dialog): void;
        /**
         * @en Locks all layers, displays loading information, and prevents double-clicking.
         * @param value If true, the lock layer is shown, otherwise it is hidden.
         * @zh 锁定所有层，显示加载信息，防止双击。
         * @param value 如果为true，则显示锁定层，否则隐藏锁定层。
         */
        lock(value: boolean): void;
        /**
         * @en Closes the dialog.
         * @param dialog The Dialog instance that needs to be closed.
         * @zh 关闭对话框。
         * @param dialog 需要关闭的对话框 Dialog 实例。
         */
        close(dialog: Dialog): void;
        /**
         * @en Executes the closing of a dialog.
         * @param dialog The Dialog instance that needs to be closed.
         * @zh 执行关闭对话框操作。
         * @param dialog 需要关闭的对话框 Dialog 实例。
         */
        doClose(dialog: Dialog): void;
        /**
         * @en Closes all dialogs.
         * @zh 关闭所有对话框。
         */
        closeAll(): void;
        /**
         * @en Gets all dialogs by group name.
         * @param group The name of the group.
         * @returns An array of dialogs that belong to the specified group.
         * @zh 根据组名获取所有对话框。
         * @param group 组名。
         * @returns 属于指定组的对话框数组。
         */
        getDialogsByGroup(group: string): any[];
        /**
         * @en Closes all popups by group name.
         * @param group The name of the group to close.
         * @returns An array of dialogs that have been closed.
         * @zh 根据组名关闭所有弹出框。
         * @param group 需要关闭的组名。
         * @returns 已关闭的对话框数组。
         */
        closeByGroup(group: string): any[];
    }
    /**
     * @en Font clipping for simplified bitmap fonts, which can be used by setting a slice image and text content, similar to bitmap fonts.
     * Usage: Set the skin for the bitmap font and the corresponding font content sheet (if multiple lines are needed, use spaces for line breaks).
     * @zh 字体切片，简化版的位图字体，只需设置一个切片图片和文字内容即可使用，效果同位图字体
     * 使用方式：设置位图字体皮肤skin，设置皮肤对应的字体内容sheet（如果多行，可以使用空格换行）
     * 示例：
     * fontClip.skin = "font1.png";//设置皮肤
     * fontClip.sheet = "abc123 456";//设置皮肤对应的内容，空格换行。此皮肤为2行5列（显示时skin会被等分为2行5列），第一行对应的文字为"abc123"，第二行为"456"
     * fontClip.value = "a1326";//显示"a1326"文字
     * @blueprintInheritable
     */
    class FontClip extends Clip {
        /**
         * @en Internal use. The array of values.
         * @zh 内部使用，数值数组。
        */
        protected _valueArr: string;
        /**
         * @en Internal use. The array of text content.
         * @zh 内部使用，文字内容数组。
         */
        protected _indexMap: Record<string, number>;
        /**
         * @en Internal use. The content of the font clip.
         * @zh 内部使用，字体切片内容。
         */
        protected _sheet: string;
        /**
         * @en Internal use. The direction.
         * @zh 内部使用，方向。
         */
        protected _direction: string;
        /**
         * @en Internal use. The gap on the X-axis.
         * @zh 内部使用，X轴方向间隙。
         */
        protected _spaceX: number;
        /**
         * @en Internal use. The gap on the Y-axis.
         * @zh 内部使用，Y轴方向间隙。
         */
        protected _spaceY: number;
        /**
         * @en Internal use. The horizontal alignment method.
         * @zh 内部使用，水平对齐方式。
         */
        private _align;
        /**
         * @en Internal use. The width of the displayed text.
         * @zh 内部使用，显示文字的宽度。
         */
        private _wordsW;
        /**
         * @en Internal use. The height of the displayed text.
         * @zh 内部使用，显示文字的高度。
         */
        private _wordsH;
        /**
         * @en Font clip index.
         * @zh 字体切片索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The content of the font clip, with spaces representing line breaks.
         * @zh 字体切片的内容，空格表示换行符。
         */
        get sheet(): string;
        set sheet(value: string);
        /**
         * @en Gets the display content of the font clip.
         * @zh 字体切片的显示内容。
         */
        get value(): string;
        set value(value: string);
        /**
         * @en Layout direction of the font clip characters.
         * The default value is "horizontal".
         * values:
         * "horizontal": Indicates a horizontal layout.
         * "vertical": Indicates a vertical layout.
         * @zh 字体切片字符的布局方向。
         * 默认值为 "horizontal"。
         * 取值：
         * "horizontal": 表示水平布局。
         * "vertical": 表示垂直布局。
         */
        get direction(): string;
        set direction(value: string);
        /**
         * @en The X-axis spacing between characters in the font clip.
         * @zh 字体切片中字符的X轴方向间隙。
         */
        get spaceX(): number;
        set spaceX(value: number);
        /**
         * @en The Y-axis spacing between characters in the font clip.
         * @zh 字体切片中字符的Y轴方向间隙。
         */
        get spaceY(): number;
        set spaceY(value: number);
        /**
         * @en Horizontal alignment
         * @zh 水平对齐方式。
         */
        get align(): string;
        set align(v: string);
        /**
         * @en Creates an instance of the FontClip.
         * @param skin The skin path for the font clip.
         * @param sheet The content string for the font clip, with spaces representing line breaks.
         * @zh 创建 FontClip 实例。
         * @param skin 字体切片的皮肤路径。
         * @param sheet 字体切片的内容字符串，空格代表换行。
         */
        constructor(skin?: string, sheet?: string);
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @internal
         * @en Resource loading completed
         * @zh 资源加载完毕
         */
        protected loadComplete(url: string, img: Texture): void;
        /**
         * @internal
         * @en Implementation logic after font clip property changes
         * @zh 字体切片属性变化后的实现逻辑
         */
        protected changeValue(): void;
        /**
         * @internal
         * @override
         * @en the width of the font clip.
         * @zh 获得字体切片的宽度。
         */
        protected measureWidth(): number;
        /**
         * @internal
         * @override
         * @en the height of the font clip.
         * @zh 获得字体切片的高度。
         */
        protected measureHeight(): number;
        /**
         * @override
         * @en Destroys the FontClip instance and optionally its children.
         * @param destroyChild  Whether to destroy the children of the FontClip.
         * @zh 销毁字体切片实例及其子项（如果指定）。
         * @param destroyChild 是否销毁字体切片的子节点。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @zh `HBox` 是一个水平布局容器类。
     * @en The `HBox` class is a horizontal layout container.
     * @blueprintInheritable
     */
    class HBox extends LayoutBox {
        /**
         * @zh 无对齐。
         * @en No alignment.
         */
        static readonly NONE: string;
        /**
         * @zh 居顶部对齐。
         * @en Align to the top.
         */
        static readonly TOP: string;
        /**
         * @zh 居中对齐。
         * @en Align to the center.
         */
        static readonly MIDDLE: string;
        /**
         * @zh 居底部对齐。
         * @en Align to the bottom.
         */
        static readonly BOTTOM: string;
        /**
         * @zh 自适应模式 - 宽适配
         * @en AUTO_SIZE_WIDTH - Width adaptive.
         */
        static readonly AUTO_SIZE_WIDTH: string;
        /**
         * @zh 自适应模式。
         * - none：无自适应模式。
         * - both：宽高自适应模式。
         * - width：宽度自适应模式。
         * @en Adaptive mode.
         * - none: No adaptive mode.
         * - both: Both width and height are adaptive.
         * - width: Width adaptive.
         */
        get autoSizeMode(): string;
        set autoSizeMode(value: string);
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @zh 排序项目列表。可通过重写改变默认排序规则。
         * @param items  项目列表。
         * @en Sort the item list. Default sorting rules can be changed by overriding.
         * @param items The item list.
         */
        private sortItem;
        protected changeItems(): void;
    }
    /**
     * @en Use the `HScrollBar` (horizontal `ScrollBar`) control to control the displayed data portion when there is too much data to display completely in the display area.
     * @zh 使用 `HScrollBar`（水平 `ScrollBar`）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
     */
    class HScrollBar extends ScrollBar {
        protected initialize(): void;
    }
    /**
     * @en The HSlider control allows the user to select a value by moving a slider between the end points of the slider track.
     * The HSlider control is displayed horizontally. The slider track stretches from left to right, and the labels are displayed at the top or bottom of the track.
     * @zh 使用 HSlider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * HSlider 控件采用水平方向。滑块轨道从左向右扩展，而标签位于轨道的顶部或底部。
     * @blueprintInheritable
     */
    class HSlider extends Slider {
        /**
         * @en Creates an instance of HSlider, and sets the direction to horizontal.
         * @param skin The skin of the HSlider.
         * @zh 创建Slider实例，设置滑动方向为水平，
         * @param skin 皮肤纹理。
         */
        constructor(skin?: string);
    }
    /**
     * @en The Image class represents a bitmap image or drawing graphics display object.
     * Image and Clip are the only two components that support asynchronous loading. For example, `img.skin = "abc/xxx.png"`, other UI components do not support asynchronous loading.
     * Event.LOADED: When the resource is loaded.
     *  @zh Image类是用于表示位图图像或绘制图形的显示对象。
     * Image和Clip组件是唯一支持异步加载的两个组件，比如`img.skin = "abc/xxx.png"`，其他UI组件均不支持异步加载。
     * Event.LOADED：资源加载完成后调度。
     * @blueprintInheritable
     */
    class Image extends UIComponent {
        protected _skin: string;
        protected _group: string;
        protected _useSourceSize: boolean;
        /**@internal */
        _graphics: AutoBitmap;
        /**
         * @en The skin address of the object, represented as a string.
         * If the resource is not loaded, it will be loaded first and then applied to this object after loading is complete.
         * Note: After the resource is loaded, it will be automatically cached in the resource library.
         * @zh 图片对象的皮肤纹理资源地址，以字符串表示。
         * 如果资源未加载，则先自动加载资源，加载完成后应用于此对象。
         * 注意：资源加载完成后，会自动缓存至资源库中。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en The texture of the object.
         * Note, this is not the image URL, but the image texture. It is recommended to use the skin property to avoid directly using the texture when the image resource has not finished loading.
         * @zh 图片对象的纹理。
         * 注意，这里不是图片的地址，而是图片的纹理。建议使用skin属性，避免图片资源未加载完成时，直接使用texture。
         */
        get source(): Texture;
        set source(value: Texture);
        /**
         * @en The color of the Image.
         * @zh 图片的纹理颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en The resource group.
         * @zh 资源分组。
         */
        get group(): string;
        set group(value: string);
        /**
         * @en Whether to use the original size of the resource.
         * @zh 是否使用资源的原始大小。
         */
        get useSourceSize(): boolean;
        set useSourceSize(value: boolean);
        /**
         * @en consruct method.
         * @param skin The skin resource address.
         * @zh 构造方法
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string | null);
        /**
         * @internal
         */
        _setSkin(url: string): Promise<void>;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected createChildren(): void;
        /**
         * @en Set the data source of the object.
         * @param value The data source.
         * @zh 设置对象的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Destroy the object and release the loaded skin resources.
         * @zh 销毁对象并释放加载的皮肤资源。
         */
        dispose(): void;
        /** @internal @blueprintEvent */
        Image_bpEvent: {
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en The ISelect interface, which should be implemented by objects that have a selected property and a clickHandler for selection callback function processing.
     * @zh ISelect 接口，实现对象的 selected属性和clickHandler 选择回调函数处理器。
     */
    interface ISelect extends UIComponent {
        /**
         * @en A boolean value indicating whether the object is selected.
         * @zh 是否被选择。
         */
        selected: boolean;
        /**
         * @en The click event callback function processing handler of the object.
         * @zh 对象的点击事件回调函数处理器。
         */
        clickHandler: Handler;
    }
    type LabelFitContent = "no" | "yes" | "height";
    /**
     * @en The Label class is used to create display objects to display text
     * `change` event is dispatched when the text content changes.
     * @zh Label 类用于创建显示对象以显示文本。
     * `change`事件用于文本内容发生改变后调度。
     * @blueprintInheritable
     */
    class Label extends UIComponent {
        /**
         * @en Text instance.
         * @zh 文本 Text 实例。
         */
        protected _tf: Text;
        protected _fitContent: LabelFitContent;
        private _fitFlag;
        /**
         * @en Current text content string.
         * @zh 当前文本内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en Whether the text automatically wraps when it reaches the maximum width.
         * @zh 文本是否在达到最大宽度时自动换行。
         * 值为 true，则该文本字段自动换行；值为 false，则该文本字段不自动换行。
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * @en Color of the text.
         * @zh 文本颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Font of the text.
         * @zh 文本字体。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Horizontal alignment of the text within the label.
         * @zh 文本的水平对齐方式。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Vertical alignment of the text within the label.
         * @zh 文本的垂直对齐方式。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en The alignment of images and text when mixed. The optional values are top, middle, and bottom.
         * @zh 图文混排时图片和文字的对齐方式。可选值是top,middle,bottom。
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @en Whether the text is bold.
         * @zh 文本是否加粗。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Whether the text is italic.
         * @zh 文本是否斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Space between lines of text.
         * @zh 文本行之间的间距（以像素为单位）
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Font size of the text.
         * @zh 文本的字号大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en The margins of the text label.
         * Format: "top,right,bottom,left".
         * @zh 文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"（以像素为单位）。
         */
        get padding(): string;
        set padding(value: string);
        /**
         * @en Background color of the label.
         * @zh 文本标签的背景颜色。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @en Border color of the label.
         * @zh 文本标签的边框颜色。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @en Stroke width of the text stroke.
         * @zh 文本描边的宽度（以像素为单位），默认值为0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Color of the text stroke.
         * @zh 文本描边的颜色。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Supporting html syntax.
         * @zh 是否富文本，支持html语法
         */
        get html(): boolean;
        set html(value: boolean);
        /**
         * @en Whether to use UBB syntax to parse text.
         * @zh 是否使用UBB语法解析文本。
         */
        get ubb(): boolean;
        set ubb(value: boolean);
        /**
         * @en The maximum width of the text box. If the text content exceeds this width, it will wrap automatically. Set to 0 to disable this limit.
         * @zh 文本最大宽度，当文本达到最大宽度时，会自动换行，设置为0则此限制不生效。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en Sets whether the text content adapts to the container size.
         * Possible values: "yes" (both text width and height adapt), "height" (only text height adapts), "no" (does not adapt).
         * @zh 设置文本内容是否自适应容器大小
         * 可选值："yes"（文本宽度和高度自适应）、"height"（仅文本高度自适应）、"no"（不自适应）
         */
        get fitContent(): LabelFitContent;
        set fitContent(value: LabelFitContent);
        /**
         * @en An instance of the basic text object.
         * @zh 基础文本对象（Text）的实例。
         */
        get textField(): Text;
        /**
         * @en The overflow property of the text, determining how overflow text is handled.
         * Possible values: visible, hidden, scroll, shrink, ellipsis.
         * visible: The text is not constrained by the text width and height, and all text is visible.
         * hidden: Text beyond the width and height is cut off, providing the best performance.
         * scroll: The part of the text that exceeds the width and height is hidden, and can be scrolled to view.
         * shrink: The text automatically adjusts its size to fit within the width and height, always fully visible.
         * ellipsis: When the text exceeds the width and height, the last few characters are replaced with an ellipsis, indicating that there is more content.
         * @zh 文本的溢出属性，决定超出文本如何被处理。
         * 值为: 可见 visible、隐藏 hidden、滚动 scroll、自动收缩 shrink、显示省略号 ellipsis。
         * 作用：
         * 可见，表示文本不受文本宽高约束全部可见；
         * 隐藏，超过文本宽高就会被裁切掉，性能最好；
         * 滚动，表示超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域；
         * 自动收缩，表示文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内；
         * 显示省略号，表示当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容。
         */
        get overflow(): string;
        set overflow(value: string);
        /**
         * @en Text decoration style of the text, specifically whether it is underlined.
         * @zh 文本是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en Color of the text underline.
         * @zh 文本下划线的颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        /**
         * @en Text decoration style of the text, specifically whether it is underlined.
         * @zh 文本是否显示下划线。
         */
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * @en Color of the text underline.
         * @zh 文本下划线的颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Whether the text ignores language localization.
         * @zh 文本是否忽略语言本地化。
         */
        get ignoreLang(): boolean;
        set ignoreLang(value: boolean);
        /**
         * @en Whether single character rendering is enabled. Enable this if the text content changes frequently, such as an increasing number, to prevent inefficient use of cache.
         * @zh 是否启用单个字符渲染。如果文字内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存
         */
        get singleCharRender(): boolean;
        set singleCharRender(value: boolean);
        /**
         * @en Text template variables.
         * When set to true, templateVars is set to an empty object;
         * When set to false, templateVars is set to null;
         * When set to a value of type Record<string, any>, templateVars is set to the provided value.
         * @zh 文本模板变量对象
         * 为 true 时，将 templateVars 设置为空对象;
         * 为 false 时，将 templateVars 设置为 null;
         * 为 Record<string, any> 类型时，将 templateVars 设置为传入值（value）;
         */
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        /**
         * @en Sets a template variable in the text field, used for dynamic text replacement.
         * @param name The key name of the template variable to set.
         * @param value The value corresponding to the key name of the template variable.
         * @return This label instance.
         * @zh 设置模板变量对象对应的键名与值，用于动态文本替换。
         * @param name 要设置的模板变量对象的键名。
         * @param value 模板变量对象键名对应的值。
         * @return 当前标签实例。
         */
        setVar(name: string, value: any): Label;
        /** @ignore */
        constructor(text?: string);
        protected _onPostLayout(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected createChildren(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @ignore
         */
        size(width: number, height: number): this;
        set_dataSource(value: any): void;
    }
    /**
     * @zh LayoutBox 是一个布局容器类。
     * @en LayoutBox is a layout container class.
     */
    class LayoutBox extends Box {
        protected _space: number;
        protected _align: string;
        protected _itemChanged: boolean;
        /**
         * @zh 自适应模式 - 无
         * @en AUTO_SIZE_NONE - No adaptive mode.
         */
        static readonly AUTO_SIZE_NONE: string;
        /**
         * @zh 自适应模式 - 宽高适配
         * @en AUTO_SIZE_BOTH - Both width and height are adaptive.
         */
        static readonly AUTO_SIZE_BOTH: string;
        /** 排序和布局时是否跳过隐藏（不可见）的子节点。 */
        protected _skipHidden: boolean;
        /** 自适应模式, 默认值为 AUTO_SIZE_NONE。*/
        protected _autoSizeMode: string;
        /**
         * @zh 子对象的间隔。
         * @en The space between child objects.
         */
        get space(): number;
        set space(value: number);
        /**
         * @zh 子对象对齐方式。
         * @en The alignment of child objects.
         */
        get align(): string;
        set align(value: string);
        /**
         * @zh 排序和布局时是否跳过隐藏（不可见）的子节点。
         * @en Whether to skip hidden (invisible) items during sorting and layout.
         */
        get skipHidden(): boolean;
        set skipHidden(value: boolean);
        protected _setItemChanged(): void;
        /**
         * @zh 改变子对象的布局。
         * @en Change the layout of child objects.
         */
        protected changeItems(): void;
        /**
         * @zh 计算包含间距的总大小（宽或高）
         * @param totalChildSize 子项总大小（宽或高）
         * @param count 子项数量
         * @returns 包含间距的总大小（宽或高）
         * @en Calculate the total size with spacing.
         * @param totalChildSize The total size of child items.
         * @param count The number of child items.
         * @returns The total size with spacing.
         */
        protected _calcSizeWithSpace(totalChildSize: number, count: number): number;
        private onResize;
        /**
         * @ignore
         */
        protected _childChanged(child?: Sprite): void;
        /**
         * @zh 刷新布局
         * @en Refresh
         */
        refresh(): void;
    }
    /**
     * @en The List control can display a list of items. The default is a vertical list. The list can be customized through the UI editor.
     * - Event.RENDER: When rendering the unit item object of a list, it is dispatched.
     * - change event: When the selectedIndex property of an object changes, it is dispatched.
     * @zh List 控件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。
     * - Event.RENDER事件: 渲染列表的单元项对象时调度。
     * - change事件: 当对象的 selectedIndex 属性发生变化时调度。
     * @blueprintInheritable
     */
    class List extends Box {
        /**
         * @en The processor executed when changing the selection of a List. (Default return parameters: Item index(index:int))
         * @zh 改变 List 的选择项时执行的处理器。(默认返回参数： 项索引（index:int）)。
         */
        selectHandler: Handler | null;
        /**
         * @en Cell rendering processor(Default return parameters  cell:UIComponent,index:int)
         * @zh 单元格渲染处理器(默认返回参数cell:UIComponent,index:int)。
         */
        renderHandler: Handler | null;
        /**
         * @en Cell Mouse Event Processor(Default return parameters  e:Event,index:int)
         * @zh 单元格鼠标事件处理器(默认返回参数e:Event,index:int)。
         */
        mouseHandler: Handler | null;
        /**
         * @en Specify whether it is selectable. If the value is true, you can choose; Otherwise, you cannot choose.
         * @zh 指定是否可以选择。若值为 true，则可以选择；否则不可以选择。
         * @default false
         */
        selectEnable: boolean;
        /**
         * @en The maximum number of pages for pagination.
         * @zh 最大分页数。
         */
        totalPage: number;
        /**
         * @en Disable scrollbar stop.
         * @zh 禁用滚动条停止。
         */
        disableStopScroll: boolean;
        protected _content: Box;
        protected _scrollBar: ScrollBar | null;
        protected _itemRender: any;
        protected _repeatX: number;
        protected _repeatY: number;
        protected _repeatX2: number;
        protected _repeatY2: number;
        protected _spaceX: number;
        protected _spaceY: number;
        protected _cells: UIComponent[];
        protected _array: any[] | null;
        protected _startIndex: number;
        protected _selectedIndex: number;
        protected _page: number;
        protected _isVertical: boolean;
        protected _cellSize: number;
        protected _cellOffset: number;
        protected _isMoved: boolean;
        protected _createdLine: number;
        protected _cellChanged: boolean;
        protected _offset: Point;
        protected _usedCache: string | null;
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        private _preLen;
        /**
         * @en Determines whether the content is cached for performance optimization.
         * Setting this property to true can greatly improve performance if the data source is small and there are no animations within the list.
         * @zh 是否缓存内容。如果数据源较少，并且列表内无动画，设置此属性为 true 能大大提高性能。
         */
        cacheContent: boolean;
        /**
         * @en The current page number of the list.
         * @zh 列表的当前页码。
         */
        get page(): number;
        set page(value: number);
        /**
         * @en The total number of items in the list.
         * @zh 列表的数据总个数。
         */
        get length(): number;
        /**
         * @en The collection of cells in the list.
         * @zh 单元格集合。
         */
        get cells(): UIComponent[];
        /**
         * @en If the elastic effect is enabled.
         * @zh 是否开启橡皮筋效果。
         */
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        /**
         * @en The caching mode for the list.
         * @zh 列表的缓存模式。
         */
        set cacheAs(value: string);
        /**
         * @en The caching mode of the list.
         * @zh 列表的缓存模式。
         */
        get cacheAs(): string;
        /**
         * @en Reference to the content container Box component of the List component.
         * @zh List 组件所包含的内容容器 Box 组件的引用。
         */
        get content(): Box;
        /**
         * @en Scrollbar type. Options include:
          - ScrollType.None (0): No scrollbar
          - ScrollType.Horizontal (1): Horizontal scrollbar.
          - Others: such as ScrollType.Vertical (2) indicates a vertical scrollbar
         * @zh 滚动条类型。可选值包括：
         * - ScrollType.None（0）：无滚动条
         * - ScrollType.Horizontal（1）：水平方向滚动条。
         * - 其它：如 ScrollType.Vertical（2） 表示垂直方向滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @en The skin of the vertical scroll bar.
         * @zh 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin of the horizontal scroll bar.
         * @zh 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en The reference to the ScrollBar component contained within the List component.
         * @zh List 组件所包含的 ScrollBar 组件的引用。
         */
        get scrollBar(): ScrollBar | null;
        set scrollBar(value: ScrollBar | null);
        /**
         * @en The cell renderer for the List component.
         * value:  The value can be a cell class object or a UI JSON description.
         * @zh 单元格渲染器。
         * 取值：单元格类对象 或 UI的JSON描述。
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * @en The number of cells displayed horizontally.
         * @zh 水平方向显示的单元格数量。
         */
        get repeatX(): number;
        set repeatX(value: number);
        /**
         * @en The number of cells displayed vertically.
         * @zh 垂直方向显示的单元格数量。
         */
        get repeatY(): number;
        set repeatY(value: number);
        /**
         * @en The horizontal spacing between cells in pixels.
         * @zh 水平方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceX(): number;
        set spaceX(value: number);
        /**
         * @en The vertical spacing between cells in pixels.
         * @zh 垂直方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceY(): number;
        set spaceY(value: number);
        /**
         * @en Represents the index of the currently selected item. Changing the selectedIndex value will cause the list to re-render.
         * @zh 表示当前选择的项索引。selectedIndex值更改会引起列表重新渲染。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en List data source
         * @zh 列表数据源。
         */
        get array(): any[];
        set array(value: any[]);
        /**
         * @en The data source of the currently selected cell.
         * @zh 当前选中的单元格数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * @en The currently selected cell object.
         * @zh 当前选择的单元格对象。
         */
        get selection(): UIComponent;
        set selection(value: UIComponent);
        /**
         * @en The start index of the currently displayed list of cells.
         * @zh 当前显示的单元格列表的开始索引。
         */
        get startIndex(): number;
        set startIndex(value: number);
        protected createChildren(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        private _getOneCell;
        private _createItems;
        /**@internal */
        _afterInited(): void;
        private _bindData;
        protected _sizeChanged(): void;
        protected _setCellChanged(): void;
        private onScrollStart;
        private onScrollEnd;
        protected createItem(): UIComponent;
        /**
         * @internal
         * 更改单元格的信息。
         * 在此销毁、创建单元格，并设置单元格的位置等属性。相当于此列表内容发送改变时调用此函数。
         */
        protected changeCells(): void;
        /**
         * @en Adds a cell to the list.
         * @param cell The cell object to be added.
         * @zh 添加单元格。
         * @param cell 需要添加的单元格对象。
         */
        protected addCell(cell: UIComponent): void;
        /**
         * @en Handles mouse events for cells.
         * @param e The event object.
         * @zh 单元格的鼠标事件侦听处理函数。
         * @param e 事件对象。
         */
        protected onCellMouse(e: Event): void;
        /**
         * @en Changes the visual state of a cell.
         * @param cell The cell object.
         * @param visible Indicates whether the cell should be visible.
         * @param index The cell's property index value.
         * @zh 改变单元格的可视状态。
         * @param cell 单元格对象
         * @param visible 是否显示。
         * @param index 单元格的属性 index 值。
         */
        protected changeCellState(cell: UIComponent, visible: boolean, index: number): void;
        /**
         * @en Event handler for the scrollbar's Event.CHANGE event.
         * @zh 滚动条的 Event.CHANGE 事件侦听处理函数。
         */
        protected onScrollBarChange(e?: Event | null): void;
        private posCell;
        /**
         * @en Changes the selection state of the cells.
         * @zh 改变单元格的选择状态。
         */
        protected changeSelectStatus(): void;
        /**
         * @en Renders the list of cells.
         * @param from The start index to begin rendering from.
         * @param to The end index to stop rendering. If not provided, it renders to the end of the list.
         * @zh 渲染单元格列表。
         * @param from 渲染开始的索引。
         * @param to 停止渲染的结束索引。如果没有提供，它将渲染到列表末尾。
         */
        protected renderItems(from?: number, to?: number): void;
        /**
         * @en Renders a single cell.
         * @param cell The cell object that needs to be rendered.
         * @param index The index of the cell.
         * @zh 渲染一个单元格。
         * @param cell 需要渲染的单元格对象。
         * @param index 单元格索引。
         */
        protected renderItem(cell: UIComponent, index: number): void;
        protected commitMeasure(): void;
        /**
         * @en Updates the data source without refreshing the entire list, only increasing the scroll length.
         * @param array The data source to update.
         * @zh 更新数据源，不刷新list，只增加滚动长度。
         * @param array 数据源。
         */
        updateArray(array: any[]): void;
        /**
         * @en Called after deserialization to perform additional setup.
         * @zh 反序列化后调用以执行额外的设置。
         */
        onAfterDeserialize(): void;
        /**
         * @en Initializes cell information.
         * @zh 初始化单元格信息。
         */
        initItems(): void;
        /**
         * @en Sets the size of the viewable area.
         * The viewable area is defined by a rectangle with the top-left corner at (0,0) and the specified width and height.
         * @param width The width of the viewable area.
         * @param height The height of the viewable area.
         * @zh 设置可视区域大小。
         * 以（0，0，width参数，height参数）组成的矩形区域为可视区域。
         * @param width 可视区域宽度。
         * @param height 可视区域高度。
         */
        setContentSize(width: number, height: number): void;
        /**
         * @en Sets the data source for the component, overriding the base class's method to handle different data types.
         * @param value The new data source.
         * @zh 设置数据源，覆盖基类方法以处理不同类型的数据。
         * @param value 新的数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Refreshes the list data source.
         * @zh 刷新列表数据源。
         */
        refresh(): void;
        /**
         * @en Get the cell data source.
         * @param index The index of the cell.
         * @zh 获取单元格数据源。
         * @param index 单元格索引。
         */
        getItem(index: number): any;
        /**
         * @en Changes the data source of a cell at a specified index.
         * @param index The index of the cell.
         * @param source The data source for the cell.
         * @zh 修改单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        changeItem(index: number, source: any): void;
        /**
         * @en Sets the data source for a cell at a specified index.
         * @param index The cell index.
         * @param source The data source for the cell.
         * @zh 设置单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        setItem(index: number, source: any): void;
        /**
         * @en Adds a new data source to the cell list.
         * @param source The data source to add.
         * @zh 添加单元格数据源。
         * @param source 数据源。
         */
        addItem(source: any): void;
        /**
         * @en Adds a new data source to the cell list at a specified index.
         * @param source The data source to add.
         * @param index The index at which to insert the data source.
         * @zh 添加单元格数据源到对应的数据索引处。
         * @param source 单元格数据源。
         * @param index 索引。
         */
        addItemAt(source: any, index: number): void;
        /**
         * @en Deletes a data source from the cell list by its index.
         * @param index The index of the data source to delete.
         * @zh 通过数据源索引删除单元格数据源。
         * @param index 需要删除的数据源索引值。
         */
        deleteItem(index: number): void;
        /**
         * @en Gets the cell object by its visible index.
         * @param index The visible index of the cell.
         * @return The cell object.
         * @zh 通过可视单元格索引，获取单元格。
         * @param index 可视单元格索引。
         * @return 单元格对象。
         */
        getCell(index: number): UIComponent | null;
        /**
         * @en Scrolls the list so that the cell corresponding to the specified data index becomes the first visible item in the list.
         * @param index The index of the cell in the data list.
         * @zh 滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。
         * @param index 单元格在数据列表中的索引。
         */
        scrollTo(index: number): void;
        /**
         * @en Scrolls the list with tweening to make the cell corresponding to the specified data index the first visible item in the list.
         * @param index The index of the cell in the data list.
         * @param time The duration of the tweening effect in milliseconds.
         * @param complete An optional callback function to call when the tweening completes.
         * @zh 缓动滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。
         * @param index 单元格在数据列表中的索引。
         * @param time	缓动时间。
         * @param complete	缓动结束回调.
         */
        tweenTo(index: number, time?: number, complete?: Handler | null): void;
        /**
         * @en Destroys the instance and its child elements.
         * @param destroyChild Specifies whether to destroy child elements.
         * @zh 销毁实例及其子元素。
         * @param destroyChild 指定是否销毁子元素。
         */
        destroy(destroyChild?: boolean): void;
        /** @internal @blueprintEvent */
        List_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @en Panel is a panel container class.
     * @zh Panel 是一个面板容器类。
     * @blueprintInheritable
     */
    class Panel extends Box {
        protected _content: Box;
        protected _vScrollBar: VScrollBar;
        protected _hScrollBar: HScrollBar;
        protected _scrollChanged: boolean;
        protected _usedCache: string;
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        /**
         * @en Creates an instance of Panel, and sets the width and height of it.
         * @zh 创建一个`Panel`实例，属性 `width` 和 `height` 的默认值均为 100。
         */
        constructor();
        /**
         * @en Destroy this object.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁此对象。
         * @param destroyChild 是否同时销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
        protected createChildren(): void;
        /** @internal */
        _panelChildChanged(child: Sprite): void;
        private changeScroll;
        protected _sizeChanged(): void;
        /**
         * @en Get the width of the content area in pixels.
         * @zh 获取内容区域宽度（以像素为单位）。
         */
        get contentWidth(): number;
        /**
         * @en Get the height of the content area in pixels.
         * @zh 获取内容区域高度（以像素为单位）。
         */
        get contentHeight(): number;
        /**
         * @en Sets the width and height of the content (in pixels).
         * @param width The width.
         * @param height The height.
         * @zh 设置内容的宽度、高度（以像素为单位）。
         * @param width 宽度。
         * @param height 高度。
         */
        private setContentSize;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en Scroll bar type. The range of values is 0-3.
         * ScrollType.None(0): Does not display any scrollbars
         * ScrollType.Horizontal(1):Displays only the horizontal scrollbar
         * ScrollType.Vertical(2): Displays only the vertical scrollbar
         * ScrollType.Both(3):  Displays both horizontal and vertical scrollbars
         * @zh 滚动条类型。取值范围0-3。
         * ScrollType.None(0): 不显示任何滚动条
         * ScrollType.Horizontal(1): 仅显示水平滚动条
         * ScrollType.Vertical(2): 仅显示垂直滚动条
         * ScrollType.Both(3): 同时显示水平和垂直滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        private createHScrollBar;
        private createVScrollBar;
        /**
         * @en The skin of the vertical scrollbar.
         * @zh 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin of the horizontal scrollbar.
         * @zh 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en The vertical scrollbar object.
         * @zh 垂直方向滚动条对象。
         */
        get vScrollBar(): ScrollBar;
        /**
         * @en The horizontal scrollbar object.
         * @zh 水平方向滚动条对象。
         */
        get hScrollBar(): ScrollBar;
        /**
         * @en Get the content container object.
         * @zh 获取内容容器对象。
         */
        get content(): Sprite;
        /**
         * @en Event.MOUSE_DOWN event handler for the scrollbar.
         * @param scrollBar The scrollbar object.
         * @zh 滚动条的 Event.MOUSE_DOWN 事件侦听处理函数。
         * @param scrollBar 滚动条对象。
         */
        protected onScrollBarChange(scrollBar: ScrollBar): void;
        /**
         * @en Scroll the content container to the specified position of the vertical and horizontal scrollbars.
         * @param x The value of the `value` property of the horizontal scrollbar.
         * @param y The value of the `value` property of the vertical scrollbar.
         * @zh 滚动内容容器至设定的垂直、水平方向滚动条位置。
         * @param x 水平方向滚动条属性value值。滚动条位置数字。
         * @param y 垂直方向滚动条属性value值。滚动条位置数字。
         */
        scrollTo(x?: number, y?: number): void;
        /**
         * @en Refresh the scroll content.
         * @zh 刷新滚动内容。
         */
        refresh(): void;
        get cacheAs(): string;
        set cacheAs(value: string);
        /**
         * @en Whether to enable the elastic effect.
         * @zh 是否开启橡皮筋效果。
         */
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        private onScrollStart;
        private onScrollEnd;
        protected _setScrollChanged(): void;
    }
    /**
     * @en The `ProgressBar` component displays the loading progress of content.
     * change event is dispatched when the value changes.
     * @zh `ProgressBar` 组件用于显示内容的加载进度。
     * change事件用于值发生改变后调度。
     * @blueprintInheritable
     */
    class ProgressBar extends UIComponent {
        protected _bg: Image;
        protected _bar: Image;
        protected _skin: string;
        protected _value: number;
        /**
         * @en The handler function that is called when the value of the `ProgressBar` instance's `value` property changes.The progress value. Default to return the `value` property.
         * @zh 当 `ProgressBar` 实例的 `value` 属性发生变化时的函数处理器。默认返回参数 `value` 属性（进度值）。
         */
        changeHandler: Handler;
        /**
         * @en The skin of the progress bar.
         * @zh 进度条的皮肤资源路径。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en The current progress value, range from 0 to 1.
         * @zh 当前的进度量，取值范围为 0 到 1 之间。
         */
        get value(): number;
        set value(num: number);
        /**
         * @en The progress bar object.
         * @zh 进度条对象。
         */
        get bar(): Image;
        /**
         * @en The background bar object.
         * @zh 进度背景条对象。
         */
        get bg(): Image;
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @ignore
         * @en creates an instance of ProgressBar.
         * @param skin The skin URL.
         * @zh 创建一个 ProgresBar 的实例。
         * @param skin 皮肤地址。
         */
        constructor(skin?: string);
        protected createChildren(): void;
        /**@internal */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @en Changes the progress value.
         * @zh 更改进度值的显示。
         */
        protected changeValue(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en Sets the data source for the component.
         * @param value The data source to set. If it's a number or string, it will be converted to a number and set as the component's value.
         * @zh 设置组件的数据源。
         * @param value 要设置的数据源。如果是数字或字符串，将被转换为数字并设置为组件的值。
         */
        set_dataSource(value: any): void;
        /**
         * @en Destroys the component and its child elements.
         * @param destroyChild Whether to destroy child elements. Default is true.
         * @zh 销毁组件及其子元素。
         * @param destroyChild 是否销毁子元素。默认为 true。
         */
        destroy(destroyChild?: boolean): void;
        /** @internal @blueprintEvent */
        ProgressBar_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en The Radio control allows users to select one option from a mutually exclusive set of choices.
     * Choosing an unselected member of a Radio group will unselect the currently selected `Radio` control within that group.
     * @zh Radio 控件使用户可在一组互相排斥的选择中做出一种选择。
     * 用户一次只能选择 Radio 组中的一个成员。选择未选中的组成员将取消选择该组中当前所选的 Radio 控件。
     * @blueprintInheritable
     */
    class Radio extends Button {
        protected _value: any;
        /**
         * @en The optional user-defined value associated with the Radio.
         * @zh Radio 关联的可选用户定义值。
         */
        get value(): any;
        set value(obj: any);
        /**
         * @en creates an instance of Radio.
         * @param skin The path of the skin to be used for the Radio.
         * @param label The text label to be displayed next to the Radio.
         * @zh 创建一个 Radio 实例。
         * @param skin Radio 的皮肤路径。
         * @param label 显示在 Radio 旁边的文本标签。
         */
        constructor(skin?: string, label?: string);
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en Preinitializes the Radio component by setting properties before initialization.
         * @zh 在初始化前对 Radio 组件进行预初始化，设置相关属性。
         */
        protected preinitialize(): void;
        /**
         * @en Initializes the Radio component, creating text and setting text properties.
         * @zh 初始化 Radio 组件，创建文本并设置文本属性。
         */
        protected initialize(): void;
        /**
         * @en The click event handler for the Radio object.
         * @param e The event object.
         * @zh 对象的Event.CLICK事件侦听处理函数。
         * @param e 事件对象。
         */
        protected onClick(e: Event): void;
        protected changeClips(): void;
    }
    /**
     * @en The RadioGroup control defines a group of mutually exclusive Radio controls, such that only one Radio control can be selected at a time by the user.
     * `change` event is dispatched when the selectedIndex property of a Group instance changes.
     * @zh RadioGroup 控件定义一组 Radio 控件，这些控件相互排斥；因此，用户每次只能选择一个 Radio 控件。
     * `change`事件用于当Group的selectedIndex属性发生变化时调度。
     */
    class RadioGroup extends UIGroup {
        /** @internal */
        constructor();
        protected createItem(skin: string, label: string): Sprite;
        /**
         * @zh 设置节点宽高是否自适应文本内容，一旦适应后，文本对齐设置将无效。
         * - true（文本宽度和高度自适应）
         * - false （不自适应）
         * @en sets whether the node width and height adapts to the text content. Once adapted, the text alignment settings will be invalid.
         * - true (both text width and height adapt)
         * - false (does not adapt)
         */
        get fitContent(): boolean;
        set fitContent(value: boolean);
        /**
         * @zh 文本标签固定的宽高，不自动适应文本内容时，并且宽高值大于0，该功能才会生效。
         * @en The fixed width and height of the text label. This feature will only take effect when the text content is not automatically adapted. The width and height values must be greater than 0.
         */
        get labelFixedSize(): Vector2;
        set labelFixedSize(value: Vector2);
    }
    /**
     * @en The `ScaleBox` is a container that automatically scales its content to fit the stage size while maintaining the original aspect ratio.
     * @zh `ScaleBox` 是一个自适应缩放容器，容器设置大小后，容器大小始终保持舞台大小，子内容按照原始最小宽高比缩放。
     */
    class ScaleBox extends Box {
        private _oldW;
        private _oldH;
        private onResize;
        /**
         * @ignore
         * @en Called when the container is enabled. Adds a resize event listener to the stage.
         * @zh 容器启用时调用。为舞台添加调整大小事件监听器。
         */
        onEnable(): void;
        /**
         * @ignore
         * @en Called when the container is disabled. Removes the resize event listener from the stage.
         * @zh 容器禁用时调用。从舞台移除调整大小事件监听器。
         */
        onDisable(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
    }
    /**
     * @zh ScrollBar 组件是一个滚动条组件。
     * 当数据太多以至于显示区域无法容纳时，最终用户可以使用 ScrollBar 组件控制所显示的数据部分。
     * 滚动条由四部分组成：两个箭头按钮、一个轨道和一个滑块。
     * - `start` 事件在滚动条开始滑动时调度。
     * - `end` 事件在滚动条滑动结束时调度。
     * - `change` 事件在滚动条滑块位置发生变化时调度。
     * @en The `ScrollBar` component is a scrollbar component.
     * When there is too much data to fit in the display area, the end user can use the `ScrollBar` component to control the portion of data being displayed.
     * A scrollbar consists of four parts: two arrow buttons, a track, and a thumb (slider).
     * - `start` event dispatched when the scrollbar starts to slide.
     * - `end` event dispatched when the scrollbar stops sliding.
     * - `change` event dispatched when the scrollbar thumb position changes.
     */
    class ScrollBar extends UIComponent {
        /**
         * @zh 设置全局的滚动速度变化曲线函数，默认为 sineOut
         * @en Sets the global easing function for scrolling speed changes.
         * @blueprintIgnore
         */
        static easeFunction: (t: number, b: number, c: number, d: number) => number;
        /**
         * @zh 滚动衰减系数，用于当用户手指/鼠标松开后，滚动条内容滚动的惯性衰减速度。
         * 例如，当用户快速向上滑动背包列表时，松手后列表继续滑动一段距离再慢慢停下来。
         * @en The ratio of scroll decay.
         */
        rollRatio: number;
        /**
         * @zh 滚动变化时回调，回传value参数。
         * @en Callback when scrolling changes, return value parameter.
         */
        changeHandler: Handler;
        /**
         * @zh 是否缩放滑动条的大小，默认值为true。
         * @en Indicates whether to scale the size of the scrollbar, default is true.
         */
        scaleBar: boolean;
        /**
         * @zh 一个布尔值，指定是否在无需滚动时自动隐藏滚动条，默认值为false。
         * @en A boolean value that specifies whether to automatically hide the scrollbar when it is not in use, default is false.
         */
        autoHide: boolean;
        /**
         * @zh 橡皮筋效果极限距离，0表示没有橡皮筋效果。
         * @en The limit distance for the rubber band effect, 0 means no rubber band effect.
         */
        elasticDistance: number;
        /**
         * @zh 橡皮筋回弹时间，单位为毫秒。
         * @en The time in milliseconds for the rubber band effect to rebound.
         */
        elasticBackTime: number;
        /**
         * @zh 上按钮。
         * @en The up button.
         */
        upButton: Button;
        /**
         * @zh 下按钮。
         * @en The down button.
         */
        downButton: Button;
        /**
         * @zh 滑动条。
         * @en slider.
         */
        slider: Slider;
        /**
         * @zh 顶部移动限制。当达到此限制时，会触发 'dragTopLimit' 事件。
         * 它可以与 `stopMoveLimit()` 方法结合使用，以便开发者执行动态数据更新和其他操作。
         * @en The top movement limit for the scrollbar. When this limit is reached, the 'dragTopLimit' event is dispatched.
         * This can be used in conjunction with the `stopMoveLimit()` method to allow developers to perform dynamic data updates and other operations.
         */
        topMoveLimit: number;
        /**
         * @zh 底部移动限制。当达到此限制时，会触发 'dragBottomLimit' 事件。
         * 它可以与 `stopMoveLimit()` 方法结合使用，以便开发者执行动态数据更新和其他操作。
         * @en The bottom movement limit for the scrollbar. When this limit is reached, the 'dragBottomLimit' event is dispatched.
         * This can be used in conjunction with the `stopMoveLimit()` method to allow developers to perform dynamic data updates and other operations.
         */
        bottomMoveLimit: number;
        /**
         * @zh 确定在调用 'stopMoveLimit' 方法时是否禁止内容的拖拽。
         * @en Determines whether dragging of the content is disabled when the 'stopMoveLimit' method is called.
         */
        disableDrag: boolean;
        protected _showButtons: boolean;
        protected _scrollSize: number;
        protected _skin: string;
        protected _thumbPercent: number;
        protected _target: Sprite;
        protected _lastPoint: Point;
        protected _lastOffset: number;
        protected _checkElastic: boolean;
        protected _isElastic: boolean;
        protected _value: number;
        protected _hide: boolean;
        protected _clickOnly: boolean;
        protected _offsets: any[];
        protected _touchScrollEnable: boolean;
        protected _mouseWheelEnable: boolean;
        /**
         * @en creates an instance of ScrollBar.
         * @param skin The address of the skin resource.
         * @zh 创建一个 ScrollBar 实例。
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string);
        destroy(destroyChild?: boolean): void;
        /**
         * @zh 创建 ScrollBar 的子元素，例如滑块和按钮。
         * @en Creates the child elements of the ScrollBar, such as the slider and buttons.
         */
        protected createChildren(): void;
        /**
         * @zh 初始化 ScrollBar，为滑块和按钮设置适当的事件监听器。
         * @en Initializes the ScrollBar, setting up the slider and buttons with appropriate event listeners.
         */
        protected initialize(): void;
        /**
         * @zh 滑块值改变时的事件处理函数。
         * @en The change event handler for the slider when its value changes.
         */
        protected onSliderChange(): void;
        /**
         * @zh 向上和向下按钮的 Event.MOUSE_DOWN 事件侦听处理函数。
         * @en The mouse down event handler for the up and down buttons.
         */
        protected onButtonMouseDown(e: Event): void;
        protected startLoop(isUp: boolean): void;
        protected slide(isUp: boolean): void;
        /**
         * @zh 舞台的 Event.MOUSE_DOWN 事件侦听处理函数。
         * @param e 事件对象。
         * @en The mouse up event handler for the stage.
         * @param e The event object.
         */
        protected onStageMouseUp(e: Event): void;
        /**
         * @zh 滚动条的皮肤纹理路径。
         * @en the skin of the scrollbar.
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @zh 异步设置滚动条及其组件的皮肤。
         * @param url 要设置的皮肤的 URL。
         * @en Asynchronously sets the skin for the scrollbar and its components.
         * @param url The URL of the skin to be set.
         */
        _setSkin(url: string): Promise<void>;
        /**
         * @zh 皮肤加载完成时调用。
         * @en Called when the skin is loaded.
         */
        protected _skinLoaded(): void;
        /**
         * @zh 更改滚动条的显示状态，包括按钮的可见性和滑动条的位置
         * @en Adjust the scroll bar's display state, including the visibility of the buttons and the position of the slider
         */
        protected changeScrollBar(): void;
        protected _sizeChanged(): void;
        private resetPositions;
        protected resetButtonPosition(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        /**
         * @zh 设置滚动条信息。
         * @param min 滚动条最小位置值。
         * @param max 滚动条最大位置值。
         * @param value 滚动条当前位置值。
         * @en Sets the information for the scrollbar.
         * @param min The minimum position value of the scrollbar.
         * @param max The maximum position value of the scrollbar.
         * @param value The current position value of the scrollbar.
         */
        setScroll(min: number, max: number, value?: number): void;
        /**
         * @zh 最大滚动位置的数字。
         * @en the numeric value representing the maximum scroll position.
         */
        get max(): number;
        set max(value: number);
        /**
         * @zh 最小滚动位置的数字。
         * @en the numeric value representing the minimum scroll position.
         */
        get min(): number;
        set min(value: number);
        /**
         * @zh 当前滚动位置的数字。
         * @en the numeric value representing the current scroll position.
         */
        get value(): number;
        set value(v: number);
        /**
         * @zh 滚动条是否为垂直滚动。如果值为true，则为垂直滚动，否则为水平滚动。
         * @en Indicates whether the scrollbar is vertical. If true, the scrollbar is vertical; otherwise, it is horizontal.
         */
        get isVertical(): boolean;
        set isVertical(value: boolean);
        /**
         * @zh 纹理的九宫格数据。
         * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
         * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
         * 值以逗号分隔。例如："6,6,6,6,1"。
         * @en The size grid of the texture.
         * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
         * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
         * The values are separated by commas. For example: "6,6,6,6,1".
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @zh 按下滚动条轨道时页面滚动的最小单位
         * @en The minimum unit for page scrolling when the scrollbar track is pressed.
         */
        get scrollSize(): number;
        set scrollSize(value: number);
        set_dataSource(value: any): void;
        /**
         * @zh 滑条长度比例，值为：（0-1）。
         * @en Slider length ratio, with a value between 0 and 1.
         */
        get thumbPercent(): number;
        set thumbPercent(value: number);
        /**
         * @zh 滚动的对象。
         * @en the target object of the scrollbar.
         */
        get target(): Sprite;
        set target(value: Sprite);
        /**
         * @zh 是否隐藏滚动条，设置为 true 时，不显示滚动条，但可以正常滚动，默认为 false。
         * @en Determines whether the scrollbar is hidden. If true, the scrollbar is not displayed, but scrolling functions remain active. Default is false.
         */
        get hide(): boolean;
        set hide(value: boolean);
        /**
         * @zh 是否显示向上和向下的按钮，默认值为 true，表示显示。
         * @en Specifies whether the up and down buttons are displayed. Default is true.
         */
        get showButtons(): boolean;
        set showButtons(value: boolean);
        /**
         * @zh 是否启用触摸滚动，默认值为 true，表示启用。
         * @en Specifies whether touch scrolling is enabled. Default is true.
         */
        get touchScrollEnable(): boolean;
        set touchScrollEnable(value: boolean);
        /**
         * @zh 是否启用鼠标滚轮滚动，默认值为 true，表示启用。
         * @en Specifies whether mouse wheel scrolling is enabled. Default is true.
         */
        get mouseWheelEnable(): boolean;
        set mouseWheelEnable(value: boolean);
        protected onTargetMouseWheel(e: Event): void;
        isLockedFun: Function;
        protected onTargetMouseDown(e: Event): void;
        /**
         * @zh 强制拖拽滚动条；
         * 常规情况下只能是按住滚动条本身才可以拖拽，如果需要在滚动条对象之外进行强制拖拽，则可以通过调用此方法来实现。
         * 例如，当鼠标持续按住滚动条之外的某个按钮对象时，调用了该方法，然后进行滑动，也可以实现按住滚动条对象滑动的效果。
         * @en Forces a drag action on the scrollbar.
         * Normally, dragging can only be done by holding the scrollbar itself. If you need to force drag outside the scrollbar object, you can achieve this by calling this method.
         * For example, if the mouse is continuously held on a button object outside the scrollbar and this method is called, then sliding the mouse will have the same effect as dragging the scrollbar.
         */
        startDragForce(): void;
        private cancelDragOp;
        /**
         * @zh 当滚动条向下拖拽超过其限制时调用的函数。
         * @en Function to be called when the scrollbar is dragged down past its limit.
         */
        triggerDownDragLimit: Function;
        /**
         * @zh 当滚动条向上拖拽超过其限制时调用的函数。
         * @en Function to be called when the scrollbar is dragged up past its limit.
         */
        triggerUpDragLimit: Function;
        /**
         * @zh 暂停滚动的重载方法
         * @en Overloading method for pausing scrolling
         */
        stopMoveLimit: Function;
        private checkTriggers;
        /**
         * @zh 获取滚动条在移动过程中使用的最后偏移量。
         * @en Gets the last offset value used during the scrollbar's movement.
         */
        get lastOffset(): number;
        /**
         * @zh 滚动条的强制缓动移动。
         * @param lastOffset 从该偏移量位置开始缓动移动。
         * @en Starts a forced tweening (animated) movement for the scrollbar.
         * @param lastOffset The offset to start the tweening movement from.
         */
        startTweenMoveForce(lastOffset: number): void;
        protected loop(): void;
        protected onStageMouseUp2(e: Event): void;
        private elasticOver;
        protected tweenMove(maxDistance: number): void;
        /**
         * @zh 停止滑动。
         * @en Stops the scrolling action.
         */
        stopScroll(): void;
        /**
         * @zh 滑动条刻度值的最小变动单位，默认值为1。
         * @en The minimum increment unit for the slider tick value, with a default value of 1.
         */
        get tick(): number;
        set tick(value: number);
        /**
         * @zh 恢复到正常的弹性缓动效果。
         * @en Restores the scrollbar to its normal elastic bounce-back motion.
         */
        backToNormal(): void;
        private _backToNormal;
        /** @internal @blueprintEvent */
        ScrollBar_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.START]: () => void;
            [Event.END]: () => void;
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en The Slider control allows users to select a value by moving a slider between the end points of the track.
     * The current value of the slider is determined by the relative position of the slider between the end points of the slider (corresponding to the minimum and maximum values of the slider).
     * The slider allows values at specific intervals between the minimum and maximum values. The slider can also display its current value using a data tip.
     * - `changed` event is dispatched when the movement of the slider is completed (when the user releases the mouse).
     * - `change` event is dispatched when the movement of the slider.
     * @zh 使用 Slider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * 滑块的当前值由滑块端点（对应于滑块的最小值和最大值）之间滑块的相对位置确定。
     * 滑块允许最小值和最大值之间特定间隔内的值。滑块还可以使用数据提示显示其当前值。
     * - `changed`事件用于移动滑块位置完成（用户鼠标抬起）后调度。
     * - `change`事件用于移动滑块位置时调度。
     */
    class Slider extends UIComponent {
        /**
         * @en Get a reference to the Label component contained within the Slider component.
         * @zh 获取 Slider 组件所包含的 Label 组件的引用。
         * @blueprintIgnore
         */
        static label: Label;
        /**
         * @en Data change handler.
         * The default callback parameter is the slider position property value: Number.
         * @zh 数据变化处理器。
         * 默认回调参数为滑块位置属性 value 的属性值：Number。
         */
        changeHandler: Handler;
        /**
         * @en Whether it is vertical sliding. The default value is true, indicating vertical direction; false indicates horizontal direction.
         * @zh 是否为垂直滑动。默认值为true，表示垂直方向，false为水平方向。
         */
        isVertical: boolean;
        /**
         * @en A Boolean value that indicates whether to display labels.defalut value is true.
         * @zh 是否显示标签。默认值为true。
         */
        showLabel: boolean;
        /**
         * @en A Boolean value that indicates whether to display the progress bar.
         * @zh 是否显示进度条。
         */
        protected _showProgress: boolean;
        protected _allowClickBack: boolean;
        protected _max: number;
        protected _min: number;
        protected _tick: number;
        protected _value: number;
        protected _skin: string;
        protected _bg: Image;
        protected _progress: Image;
        protected _bar: Button;
        protected _tx: number;
        protected _ty: number;
        protected _maxMove: number;
        protected _globalSacle: Point;
        /**
         * @en Creates an instance of Slider.
         * @param skin The skin.
         * @zh 创建一个Silder实例。
         * @param skin 皮肤纹理。
         */
        constructor(skin?: string);
        destroy(destroyChild?: boolean): void;
        protected createChildren(): void;
        protected initialize(): void;
        protected onBarMouseDown(e: Event): void;
        protected showValueText(): void;
        protected hideValueText(): void;
        private mouseUp;
        private mouseMove;
        protected sendChangeEvent(type?: string): void;
        /**
         * @en The skin of the slider.
         * @zh 滑块的皮肤纹理。
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @en A Boolean value that indicates whether to display the progress bar.
         * @zh 是否显示进度条。
         */
        get showProgress(): boolean;
        set showProgress(value: boolean);
        /** @ignore */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * @en Set the position information of the slider.
         * @zh 设置滑块的位置信息。
         */
        protected setBarPoint(): void;
        protected measureWidth(): number;
        protected measureHeight(): number;
        protected _sizeChanged(): void;
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Set the information of the slider.
         * @param min The minimum value of the slider.
         * @param max The maximum value of the slider.
         * @param value The current value of the slider.
         * @zh 设置滑动条的信息。
         * @param min 滑块的最小值。
         * @param max 滑块的最大值。
         * @param value 滑块的当前值。
         */
        setSlider(min: number, max: number, value?: number): void;
        /**
         * @en The minimum increment unit for each change in the slider tick value. The default value is 1.
         * @zh 滑滑动条刻度值每次最小变动的单位。默认值为1
         */
        get tick(): number;
        set tick(value: number);
        /**
         * @en Change the position value of the slider.
         * @zh 改变滑块的位置值。
         */
        changeValue(): void;
        /**
         * @en The number indicating the highest position of slider. The default value is 100.
         * @zh 滑动条最高位置的数字。默认值为 100。
         */
        get max(): number;
        set max(value: number);
        /**
         * @en The number indicating the lowest position of slider. The default value is 0.
         * @zh 滑动条最低位置的数字。默认值为 0。
         */
        get min(): number;
        set min(value: number);
        /**
         * @en The number indicating the current slider position.
         * @zh 滑动条当前滑块位置的数字。
         */
        get value(): number;
        set value(num: number);
        /**
         * @en A Boolean value that specifies whether to allow changing the value property of the Slider by clicking the slider.
         * @zh 是否允许通过点击滑动条改变 Slider 的 value 属性值。
         */
        get allowClickBack(): boolean;
        set allowClickBack(value: boolean);
        /**
         * @en The Event.MOUSE_DOWN event handler of the slider.
         * @zh 滑动条的 Event.MOUSE_DOWN 事件侦听处理函数。
         */
        protected onBgMouseDown(e: Event): void;
        set_dataSource(value: any): void;
        /**
         * @en The reference of the slider button.
         * @zh 滑块按钮的引用。
         */
        get bar(): Button;
        /** @internal @blueprintEvent */
        Slider_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.CHANGED]: () => void;
        };
    }
    /**
     * @en The `Styles` class defines common style properties used by components.
     * @zh Styles 定义了组件常用的样式属性。
     */
    class Styles {
        /**
         * @en Default nine-slice grid information.
         * @zh 默认九宫格信息。
         */
        static defaultSizeGrid: any[];
        /**
         * @en The color of the label text.
         * @zh 标签颜色。
         */
        static labelColor: string;
        /**
         * @en The padding of the label, in pixels. Defined as [top, right, bottom, left].
         * @zh 标签的边距，格式为 [上边距，右边距，下边距，左边距]。
         */
        static labelPadding: any[];
        /**
         * @en The padding of the input label, in pixels. Defined as [top, right, bottom, left].
         * @zh 输入框标签的边距，格式为 [上边距，右边距，下边距，左边距]。
         */
        static inputLabelPadding: any[];
        /**
         * @en The number of state skins for a button, which supports 1, 2, or 3 states values.
         * @zh 按钮皮肤的状态数，支持1,2,3三种状态值。
         */
        static buttonStateNum: number;
        /**
         * @en The colors of the button label. Defined as [upColor, overColor, downColor].
         * @zh 按钮标签颜色，格式为 [upColor, overColor, downColor]。
         */
        static buttonLabelColors: any[];
        /**
         * @en The colors of the combo box. Defined as [overBgColor, overLabelColor, outLabelColor, borderColor, bgColor].
         * @zh 下拉框项颜色，格式为 [overBgColor, overLabelColor, outLabelColor, borderColor, bgColor]。
         */
        static comboBoxItemColors: any[];
        /**
         * @en The minimum size of the scrollbar thumb, in pixels.
         * @zh 滚动条的最小值。
         */
        static scrollBarMinNum: number;
        /**
         * @en The delay time before initiating continuous scrolling when a button is held down.
         * @zh 长按按钮后，等待时间使其可激活连续滚动。
         */
        static scrollBarDelayTime: number;
    }
    enum ScrollType {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Both = 3
    }
    /**
     * @en The Tab component is used to define tab button groups.
     * The default value of ths property selectedIndex is -1.
     * @zh Tab 组件用来定义选项卡按钮组。
     * 属性selectedIndex 的默认值为-1。
     * @blueprintInheritable
     */
    class Tab extends UIGroup {
        constructor();
        protected createItem(skin: string, label: string): Sprite;
    }
    /**
     * @en The TextArea class is used to create a multi-line text area display object for displaying and inputting text.
     * @zh TextArea 类用于创建多行的文本域显示对象，以显示和输入文本。
     * @blueprintInheritable
     */
    class TextArea extends TextInput {
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        protected _vScrollBar: VScrollBar;
        protected _hScrollBar: HScrollBar;
        /**
         * @en Scroll bar type. The range of values is 0-3.
         * - ScrollType.None(0): Does not display any scrollbars
         * - ScrollType.Horizontal(1):Displays only the horizontal scrollbar
         * - ScrollType.Vertical(2): Displays only the vertical scrollbar
         * - ScrollType.Both(3):  Displays both horizontal and vertical scrollbars
         * @zh 滚动条类型。取值范围0-3。
         * - ScrollType.None(0): 不显示任何滚动条
         * - ScrollType.Horizontal(1): 仅显示水平滚动条
         * - ScrollType.Vertical(2): 仅显示垂直滚动条
         * - ScrollType.Both(3): 同时显示水平和垂直滚动条
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * @en The vertical scrollbar instance.
         * @zh 垂直滚动条实例。
         */
        get vScrollBar(): VScrollBar;
        /**
         * @en The horizontal scrollbar instance.
         * @zh 水平滚动条实例。
         */
        get hScrollBar(): HScrollBar;
        /**
         * @en The maximum vertical scroll value.
         * @zh 最大垂直滚动值。
         */
        get maxScrollY(): number;
        /**
         * @en The vertical scroll position.
         * @zh 垂直滚动位置。
         */
        get scrollY(): number;
        /**
         * @en The maximum horizontal scroll value.
         * @zh 最大水平滚动值。
         */
        get maxScrollX(): number;
        /**
         * @en The horizontal scroll position.
         * @zh 当前的水平滚动位置。
         */
        get scrollX(): number;
        /**
         * @en The skin for the vertical scrollbar.
         * @zh 垂直方向滚动条的皮肤 。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * @en The skin for the horizontal scrollbar.
         * @zh 水平方向滚动条的皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * @en Creates an instance of TextArea.
         * @param text Text content string.
         * @zh 创建一个TextArea实例。
         * @param text 文本内容字符串。
         */
        constructor(text?: string);
        protected _onPostLayout(): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected initialize(): void;
        private createHScrollBar;
        private createVScrollBar;
        protected onVBarChanged(e: Event): void;
        protected onHBarChanged(e: Event): void;
        private changeScroll;
        /**
         * @en Scroll to a certain position
         * @zh 滚动到某个位置。
         */
        scrollTo(y: number): void;
        /**
         * @en Destroys the instance.
         * @param destroyChild Whether to destroy child elements as well. Defaults to true.
         * @zh 销毁实例。
         * @param destroyChild 是否同时销毁子元素，默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The TextInput class is used to create an input text display object.
     * - Event.INPUT event: When the input text after dispatching.
     * - Event.ENTER event: When the input box presses enter key after dispatching.
     * - Event.FOCUS event: When the input box gets focus.
     * - Event.BLUR event: When the input box loses focus.
     * @zh TextInput类用于创建输入文本显示对象。
     * - Event.INPUT事件：当输入文本后调度。
     * - Event.ENTER事件：当输入框内敲回车键后调度。
     * - Event.FOCUS事件：当输入框获得焦点时调度。
     * - Event.BLUR事件：当输入框失去焦点时调度。
     * @blueprintInheritable
     */
    class TextInput extends Label {
        protected _skin: string;
        /** @internal */
        _graphics: AutoBitmap;
        /** @internal */
        _tf: Input;
        /**
         * @en The URL of the skin for the TextInput UIComponent.
         * @zh TextInput组件的皮肤地址。
         */
        get skin(): string;
        set skin(value: string);
        /**
          * @en The size grid of the texture.
          * The size grid is a 3x3 division of the texture, allowing it to be scaled without distorting the corners and edges.
          * The array contains five values representing the top, right, bottom, and left margins, and whether to repeat the fill (0: no repeat, 1: repeat).
          * The values are separated by commas. For example: "6,6,6,6,1".
          * @zh 纹理的九宫格数据。
          * 九宫格是一种将纹理分成3x3格的方式，使得纹理缩放时保持角和边缘不失真。
          * 数组包含五个值，分别代表上边距、右边距、下边距、左边距以及是否重复填充（0：不重复填充，1：重复填充）。
          * 值以逗号分隔。例如："6,6,6,6,1"。
          */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @en Whether it is a text area.
         * True means it is a text area, otherwise it is not.
         * @zh 是否是文本域。
         * 值为true表示当前是文本域，否则不是文本域。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * @en whether it is editable.
         * @zh 是否可编辑。
         */
        get editable(): boolean;
        set editable(value: boolean);
        /**
         * @en The pattern that restricts the input.
         * @zh 限制输入的字符。
         */
        get restrict(): string;
        set restrict(pattern: string);
        /**
         * @en The prompt text of the input.
         * @zh 输入框的提示文本。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @en The prompt color of the input.
         * @zh 输入框的提示文字颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @en The maximum number of characters allowed in the input.
         * @zh 输入框允许的最大字符数。
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * @en The focus state of the input.
         * @zh 输入框的焦点状态。
         */
        get focus(): boolean;
        set focus(value: boolean);
        /**
         * @en The type of the input box. Refer to the HTML5 input tag for types.
         * Common types include:
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         * @zh 输入框的类型。可参照HTML5的input标签。
         * 常用标签例如：
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         */
        get type(): string;
        set type(value: string);
        /**
         * @en Constructor method
         * @param text Text content.
         * @zh 构造方法
         * @param text 文本内容。
         */
        constructor(text?: string);
        /** @internal */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(source: any): void;
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        protected createChildren(): void;
        protected initialize(): void;
        /**
         * @en Select the text in the input box
         * @zh 选中输入框内的文本。
         */
        select(): void;
        /**
         * @en Sets the start and end index of the selected text within the input field.
         * @param startIndex The index of the first selected character.
         * @param endIndex The index of the character following the last selected character.
         * @zh 在输入字段内设置选中文本的起始和结束索引。
         * @param startIndex 选中文本的光标起始位置。
         * @param endIndex 选中文本的光标结束位置。
         */
        setSelection(startIndex: number, endIndex: number): void;
        /** @internal @blueprintEvent */
        TextInput_bpEvent: {
            [Event.INPUT]: () => void;
            [Event.ENTER]: () => void;
            [Event.FOCUS]: () => void;
            [Event.BLUR]: () => void;
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @en Mouse Tip Management Class
     * @zh 鼠标提示管理类
     */
    class TipManager extends UIComponent {
        /**
         * @en X-axis offset of the tooltip
         * @zh 提示框X轴偏移量
         */
        static offsetX: number;
        /**
         * @en Y-axis offset of the tooltip
         * @zh 提示框Y轴偏移量
         */
        static offsetY: number;
        /**
         * @en Text color of the tooltip
         * @zh 提示文本颜色
         */
        static tipTextColor: string;
        /**
         * @en Background color of the tooltip
         * @zh 提示框背景颜色
         */
        static tipBackColor: string;
        /**
         * @en Delay before showing the tooltip
         * @zh 显示提示框前的延迟时间
         */
        static tipDelay: number;
        private _tipBox;
        private _tipText;
        private _defaultTipHandler;
        /**
         * @en Default mouse prompt function
         * @zh 默认鼠标提示函数
         */
        get defaultTipHandler(): Function;
        set defaultTipHandler(value: Function);
        /** @ignore @blueprintIgnore */
        constructor();
        private _onStageHideTip;
        private _onStageShowTip;
        private _showTip;
        private _onStageMouseDown;
        private _onStageMouseMove;
        private _showToStage;
        private _showDefaultTip;
        /**
         * @en Closes all tooltips and removes event listeners related to mouse actions.
         * @zh 关闭所有鼠标提示并移除与鼠标动作相关的事件监听器。
         */
        closeAll(): void;
        /**
         * @en Displays a tooltip Sprite on the stage.
         * @param tip The Sprite object to be displayed as a tooltip.
         * @zh 显示对象提示条的显示。
         * @param tip 要显示的提示条精灵对象。
         */
        showDislayTip(tip: Sprite): void;
    }
    /**
     * @en The `Tree` UI component allows users to view hierarchical data arranged in an expandable tree format.
     * @zh `Tree` UI组件使用户可以查看排列为可扩展树的层次结构数据。
     * @blueprintInheritable
     */
    class Tree extends Box {
        protected _list: List;
        protected _source: any[];
        protected _renderHandler: Handler;
        protected _spaceLeft: number;
        protected _spaceBottom: number;
        protected _keepStatus: boolean;
        /**
         * @en Determines whether to maintain the previous open state after the data source changes. The default value is true.
         * - true: Maintain the previous open state.
         * - false: Do not maintain the previous open state.
         * @zh 数据源发生变化后，是否保持之前打开状态，默认为true。
         * - true：保持之前打开状态。
         * - false：不保持之前打开状态。
         */
        get keepStatus(): boolean;
        set keepStatus(value: boolean);
        /**
         * @en The list data source, including only the data of currently visible nodes.
         * @zh 列表数据源，只包含当前可视节点数据。
         */
        get array(): any[];
        set array(value: any[]);
        /**
         * @en The data source containing all node data.
         * @zh 数据源，全部节点数据。
         */
        get source(): any[];
        /**
         * @en The `List` instance contained within this object.
         * @zh 此对象包含的 `List` 实例对象。
         */
        get list(): List;
        /**
         * @en The cell renderer for the List instance contained in this object.
         * Possible values:
         * Cell class object.
         * JSON description of the UI.
         * @zh 此对象包含的List实例的单元格渲染器。
         * 取值：
         * 单元格类对象。
         *  UI 的 JSON 描述。
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * @en The skin of the scroll bar.
         * @zh 滚动条皮肤。
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**
         * @en The scroll bar.
         * @zh 滚动条。
         */
        get scrollBar(): ScrollBar;
        /**
         * @en Handler for cell mouse events. Default returns parameters (e:Event,index:int).
         * @zh 单元格鼠标事件处理器。默认返回参数（e:Event,index:int）。
         */
        get mouseHandler(): Handler;
        set mouseHandler(value: Handler);
        /**
         * @en The render handler for the `Tree` instance.
         * @zh `Tree` 实例的渲染处理器。
         */
        get renderHandler(): Handler;
        set renderHandler(value: Handler);
        /**
         * @en The left indentation distance in pixels.
         * @zh 左侧缩进距离（以像素为单位）。
         */
        get spaceLeft(): number;
        set spaceLeft(value: number);
        /**
         * @en The space between each item in pixels.
         * @zh 每一项之间的间隔距离（以像素为单位）。
         */
        get spaceBottom(): number;
        set spaceBottom(value: number);
        /**
         * @en The index of the currently selected item.
         * @zh 表示当前选择的项索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The data source of the currently selected item.
         * @zh 当前选中的项对象的数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * @en The data source in XML structure.
         * @zh XML 结构的数据源。
         */
        set xml(value: XML);
        /**
         * @en The value of the `path` property of the selected tree node item.
         * @zh 表示选择的树节点项的 `path` 属性值。
         */
        get selectedPath(): string;
        /**
         * @en Creats an instance of `Tree`.
         * The `width` and `height` properties are both set to 200 in the `Tree` constructor.
         * @zh 创建一个 `Tree` 实例。
         * 在`Tree`构造函数中设置属性width、height的值默认都为200。
         */
        constructor();
        protected createChildren(): void;
        /**
         * @en this object contains the List instance's Event.CHANGE event listener function.
         * @zh 此对象包含的List实例的Event.CHANGE事件侦听处理函数。
         */
        protected onListChange(e?: Event): void;
        /**
         * @en Get the data source collection.
         * @zh 获取数据源集合。
         */
        protected getArray(): any[];
        /**
         * @en Get item object's depth.
         * @zh 获取项对象的深度。
         */
        protected getDepth(item: any, num?: number): number;
        /**
         * @en Get item object's parent open status.
         * @zh 获取项对象的上一级的打开状态。
         */
        protected getParentOpenStatus(item: any): boolean;
        /**
         * @en Renders a item object.
         * @param cell a item object.
         * @param index item's index.
         * @zh 渲染一个项对象。
         * @param cell 一个项对象。
         * @param index 项的索引。
         */
        protected renderItem(cell: Box, index: number): void;
        private onArrowClick;
        /**
         * @en parse data source of XML type.
         * @zh 解析并处理XML类型的数据源。
         */
        protected parseXml(xml: XML, source: any[], nodeParent: any, isRoot: boolean): void;
        /**
         * @en Handle the open state of the data items.
         * @zh 处理数据项的打开状态。
         */
        protected parseOpenStatus(oldSource: any[], newSource: any[]): void;
        /**
         * @en Determine whether the two item objects have the same parent node in the tree structure.
         * @param item1 Item object.
         * @param item2 Item object.
         * @returns If the parent node is the same, the value of true. Otherwise, false.
         * @zh 判断两个项对象在树结构中的父节点是否相同。
         * @param item1 项对象。
         * @param item2 项对象。
         * @returns 如果父节点相同值为true，否则值为false。
         */
        protected isSameParent(item1: any, item2: any): boolean;
        /**
         * @en Retrieve the value of a specified key from the data source.
         * @zh 获取数据源中指定键名的值。
         */
        private getFilterSource;
        /**
         * @en Set the open state of an item object by index.
         * @param index The item index.
         * @param isOpen Whether the item is open.
         * @zh 设置指定项索引的项对象的打开状态。
         * @param index 项索引。
         * @param isOpen 是否处于打开状态。
         */
        setItemState(index: number, isOpen: boolean): void;
        /**
         * @en Refresh the list.
         * @zh 刷新项列表。
         */
        fresh(): void;
        /**
         * @en Set the data source.
         * @param value The data source.
         * @zh 设置数据源。
         * @param value The data source.
         */
        set_dataSource(value: any): void;
        /**
         * @en Update the list to show items with the specified key name.
         * @param key The key name.
         * @zh 更新项列表，显示指定键名的数据项。
         * @param key 键名。
         */
        filter(key: string): void;
        /**
         * @en Destroy the object.
         * @param destroyChild Whether to destroy the child objects as well.
         * @zh 销毁对象。
         * @param destroyChild 是否销毁子对象。
         */
        destroy(destroyChild?: boolean): void;
        /** @internal @blueprintEvent */
        Tree_bpEvent: {
            [Event.CHANGE]: () => void;
        };
    }
    /**
     * @en UIComponent is the base class of UI Component.
     * Life cycle: preinitialize > createChildren > initialize > constructor of component
     * @zh UIComponent 是UI组件类的基类。
     * 生命周期：preinitialize > createChildren > initialize > 组件构造函数
     */
    class UIComponent extends Sprite {
        /**
         * @en The data source of the UIComponent.
         * @zh UI组件的数据源。
         */
        protected _dataSource: any;
        /**
         * @en Mouse hover prompt
         * @zh 鼠标悬停提示
         */
        protected _toolTip: any;
        /**
         * @en Disabled
         * @zh 禁用
         */
        protected _disabled: boolean;
        /**
         * @en Grayed out
         * @zh 变灰
         */
        protected _gray: boolean;
        /**
         * @en Relative layout component
         * @zh 相对布局组件
         */
        protected _widget: Widget;
        /**
        * @en The vertical distance in pixels from the top edge of the component to the top edge of its parent.
        * This property is used for relative layout, which means the component's position is always relative to its parent's top edge.
        * @zh 组件顶边距离父节点顶边的垂直距离（以像素为单位）。
        * 此属性用于相对布局,意味着组件的位置始终相对于父节点的顶部边缘。
        */
        get top(): number;
        set top(value: number);
        /**
         * @en The vertical distance in pixels from the bottom edge of the component to the bottom edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's bottom edge.
         * @zh 组件底边距离父节点底边的垂直距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的底部边缘。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @en The horizontal distance in pixels from the left edge of the component to the left edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's left edge.
         * @zh 组件左边距离父节点左边的水平距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的左侧边缘。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The horizontal distance in pixels from the right edge of the component to the right edge of its parent.
         * This property is used for relative layout, which means the component's position is always relative to its parent's right edge.
         * @zh 组件右边距离父节点右边的水平距离（以像素为单位）。
         * 此属性用于相对布局,意味着组件的位置始终相对于父节点的右侧边缘。
         */
        get right(): number;
        set right(value: number);
        /**
         * @en The distance in pixels from the center axis of this object in the horizontal direction to the center line of the parent container in the horizontal direction.
         * @zh 在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * @en The distance in pixels from the center axis of this object in the vertical direction to the center line of the parent container in the vertical direction.
         * @zh 在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。
         */
        get centerY(): number;
        set centerY(value: number);
        /**
         * @en Data assignment, control UI display logic by assigning UI.
         * Simple assignment will change the default properties of the component, and curly braces can be used to assign any property of the component.
         * @zh 数据源赋值，通过对UI赋值来控制UI显示逻辑。
         * 简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。
         * @example
           //Default property assignment
           dataSource = {label1: "Label changed", checkbox1: true};//(Change the text property value of label1, change the selected property of checkbox1).
           //Any property assignment
           dataSource = {label2: {text:"Label changed",size:14}, checkbox2: {selected:true,x:10}};
         */
        get dataSource(): any;
        set dataSource(value: any);
        /**
         * @en Mouse hover prompt.
         * It can be assigned as text `String` or function `Handler` to implement custom style mouse prompts and parameter carrying, etc.
         * @zh 鼠标悬停提示。
         * 可以赋值为文本`String`或函数`Handler`，用来实现自定义样式的鼠标提示和参数携带等。
         * @example
         * private var _testTips:TestTipsUI = new TestTipsUI();
         * private function testTips():void {
           //Simple mouse prompt
         * btn2.toolTip = "This is a mouse tip&lt;b&gt;Bold&lt;/b&gt;&lt;br&gt;New line";
           //Custom mouse prompt
         * btn1.toolTip = showTips1;
           //Custom mouse prompt with parameters
         * clip.toolTip = new Handler(this,showTips2, ["clip"]);
         * }
         * private function showTips1():void {
         * _testTips.label.text = "This is button[" + btn1.label + "]";
         * tip.addChild(_testTips);
         * }
         * private function showTips2(name:String):void {
         * _testTips.label.text = "This is " + name;
         * tip.addChild(_testTips);
         * }
         */
        get toolTip(): any;
        set toolTip(value: any);
        /**
         * @en Whether it is grayed out.
         * @zh 是否变灰。
         */
        get gray(): boolean;
        set gray(value: boolean);
        /**
         * @en Whether the page is disabled, it will turn gray and disable the mouse when set to true.
         * @zh 是否禁用页面，设置为true后，会变灰并且禁用鼠标。
         */
        get disabled(): boolean;
        set disabled(value: boolean);
        /**
         * @en The constructor function that is called when creating a new instance of the UIComponent.
         * It calls a series of initialization methods in sequence. Subclasses inheriting from this class can override these methods directly to implement their own initialization logic.
         * If these initialization methods are not needed, `createChildren` can be set to `false` to skip them and reduce unnecessary overhead.
         * @param createChildren Whether to execute the initialization methods, default is true.
         * @zh 创建UI组件新实例时调用的构造函数。
         * 它将依次调用一系列初始化方法。继承该类的子类可以直接重写这些方法,实现自己的初始化逻辑。
         * 如果不需要这些初始化方法,可以将 `createChildren` 设置为 `false`,以跳过它们并减少不必要的开销。
         * @param createChildren 是否执行子对象初始化方法,默认为 true。
         * @blueprintIgnore
         */
        constructor(createChildren?: boolean);
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @en Callback function when the component size changes.
         * @zh 组件尺寸变化时的回调函数。
         */
        protected _sizeChanged(): void;
        /**
        * @en Callback when a child node changes.
        * @param child The child node that has changed.
        * @zh 子节点发生变化时的回调。
        * @param child 发生变化的子节点。
        */
        protected _childChanged(child?: Sprite): void;
        /**
         * @en Get the layout style of the object. Please do not modify this object directly.
         * @zh 获取对象的布局样式。请不要直接修改此对象。
         */
        private _getWidget;
        /**
         * @en Pre-initialization.
         * Subclasses can set and modify default property values in this function.
         * @zh 预初始化。
         * 子类可在此函数内设置、修改属性默认值。
         */
        protected preinitialize(): void;
        /**
         * @en Create and add UIComponent child nodes.
         * Subclasses can create and add child nodes in this function.
         * @zh 创建并添加UI组件的子节点。
         * 子类可在此函数内创建并添加子节点。
         */
        protected createChildren(): void;
        /**
         * @en UIComponent initialization.
         * Child objects have been created at this point and can be modified.
         * @zh UI组件初始化。
         * 在此子对象已被创建，可以对子对象进行修改。
         */
        protected initialize(): void;
        /**
         * @en The actual display area width of the object (in pixels).
         * @zh 显示对象的实际显示区域宽度（以像素为单位）。
         */
        protected measureWidth(): number;
        /**
         * @en Immediately execute the delayed call function that affects the width and height measurement.
         * Use the 'runCallLater' function to immediately execute the delayed running function that affects the width and height measurement (set using 'callLater').
         * @zh 立即执行影响宽高度量的延迟调用函数。
         * 使用 'runCallLater' 函数，立即执行影响宽高度量的延迟运行函数(使用 'callLater' 设置延迟执行函数)。
         */
        protected commitMeasure(): void;
        /**
         * @en The actual display area height of the object (in pixels).
         * @zh 显示对象的实际显示区域高度（以像素为单位）。
         */
        protected measureHeight(): number;
        /**
         * @en The event handler for the 'Event.MOUSE_OVER' event, triggered when the mouse enters the component (the node object to which the component belongs).
         * When the 'toolTip' property is set, this method is invoked to dispatch the 'UIEvent.SHOW_TIP' event with the '_toolTip' property as the parameter.
         * @param e The event object.
         * @zh 'Event.MOUSE_OVER' 事件的事件处理程序,在鼠标进入组件(组件所属的节点对象)时触发。
         * 当 'toolTip' 属性被设置时,该方法会被调用以派发 'UIEvent.SHOW_TIP' 事件,并将 '_toolTip' 属性作为参数传递。
         * @param e 事件对象。
         */
        private onMouseOver;
        /**
         * @en The event handler for the 'Event.MOUSE_OUT' event, triggered when the mouse leaves the component (the node object to which the component belongs).
         * When the 'toolTip' property is set, this method is invoked to dispatch the 'UIEvent.HIDE_TIP' event with the '_toolTip' property as the parameter.
         * @param e The event object.
         * @zh 'Event.MOUSE_OUT' 事件的事件处理程序,在鼠标离开组件(组件所属的节点对象)时触发。
         * 当 'toolTip' 属性被设置时,该方法会被调用以派发 'UIEvent.HIDE_TIP' 事件,并将 '_toolTip' 属性作为参数传递。
         * @param e 事件对象。
         */
        private onMouseOut;
        /**
         * @en Get the top margin of the object.
         * @zh 获取对象的上边距。
         */
        get_top(): number;
        /**
         * @en Set the top margin of the object.
         * @param value The top margin value.
         * @zh 设置对象的上边距。
         * @param value 上边距的值。
         */
        set_top(value: number): void;
        /**
         * @en Get the bottom margin of the object.
         * @zh 获取对象的下边距。
         */
        get_bottom(): number;
        /**
         * @en Set the bottom margin of the object.
         * @param value The bottom margin value.
         * @zh 设置对象的下边距。
         * @param value 下边距的值。
         */
        set_bottom(value: number): void;
        /**
         * @en Get the data source of the object.
         * @zh 获取对象的数据源。
         */
        get_dataSource(): any;
        /**
         * @en Set the data source of the object.
         * @param value The data source.
         * @zh 设置对象的数据源。
         * @param value 数据源。
         */
        set_dataSource(value: any): void;
        /**
         * @en Recalculate and update the layout of the object.
         * This method will reset the horizontal and vertical layout of the object based on the `_widget` property.
         * It will calculate the position and size of the object according to the layout rules specified by the `_widget` property,
         * such as `left`, `right`, `top`, `bottom`, `centerX`, and `centerY`.
         * @zh 重新计算并更新对象的布局。
         * 这个方法将根据 `_widget` 属性重置对象的水平和垂直布局。
         * 它会根据 `_widget` 属性指定的布局规则,如 `left`、`right`、`top`、`bottom`、`centerX` 和 `centerY`,计算对象的位置和大小。
         */
        freshLayout(): void;
        /**
         * @en Destroy the object.
         * @param destroyChild Whether to destroy child nodes, default is true.
         * @zh 销毁对象。
         * @param destroyChild 是否销毁子节点,默认为 true。
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * @en The UIEvent class is used to define the event types of UI component classes.
     * @zh UIEvent 类用来定义UI组件类的事件类型。
     */
    enum UIEvent {
        /**
         * @en Display prompt information.
         * @zh 显示提示信息。
         */
        SHOW_TIP = "showtip",
        /**
         * @en Hide prompt information.
         * @zh 隐藏提示信息。
         */
        HIDE_TIP = "hidetip"
    }
    /**
     * @en UIGroup is an item collection control that can be automatically laid out.
     * The default item object for UIGroup is a Button class instance.
     * UIGroup is the base class for Tab and RadioGroup.
     * @zh UIGroup 是一个可以自动布局的项集合控件。
     * UIGroup 的默认项对象为 Button 类实例。
     * UIGroup是 Tab 和 RadioGroup 的基类。
     * @blueprintInheritable
     */
    class UIGroup extends Box {
        protected _items: ISelect[];
        protected _selectedIndex: number;
        protected _skin: string;
        protected _direction: string;
        protected _space: number;
        protected _stateNum: number;
        protected _lineWrap: boolean;
        protected _lineSpace: number;
        protected _labels: string;
        protected _labelColors: string;
        protected _labelStrokeColor: string;
        protected _strokeColors: string;
        protected _labelStroke: number;
        protected _labelSize: number;
        protected _labelBold: boolean;
        protected _labelPadding: string;
        protected _labelAlign: string;
        protected _labelVAlign: string;
        protected _labelChanged: boolean;
        protected _labelOverflow: string;
        protected _fitContent: boolean;
        protected _labelFixedSize: Vector2;
        private _labelFont;
        /**
         * @zh 改变 Group 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。
         * @en The processor executed when changing the selection of the Group, (Default return parameter: item index (index: int)).
         */
        selectHandler: Handler;
        /**
         * @zh 表示当前选择的项索引。默认值为-1。
         * @en Indicates the index of the currently selected item. The default value is -1.
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @zh 纹理皮肤URL。
         * @en The URL of the skin for the UIComponent.
         */
        get skin(): string;
        set skin(value: string);
        /**
         * @zh 标签集合字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         * @en The labels string, separated by commas, such as "item0,item1,item2,item3,item4,item5".
         */
        get labels(): string;
        set labels(value: string);
        /**
         * @zh 标签文本溢出模式。
         * - hidden: 默认值，隐藏超出部分，超出部分被裁切。
         * - visible: 超出部分可见，不裁切。
         * @en The text overflow mode for the label.
         * - hidden: The default value. The overflow part is hidden and clipped.
         * - visible: The overflow part is visible and not clipped.
         */
        get labelOverflow(): string;
        set labelOverflow(value: string);
        /**
         * @zh 组件的标签颜色字符串。
         * @en The label colors string for the component.
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * @zh 标签水平对齐模式。
         * - left: 居左对齐。
         * - center: 居中对齐。
         * - right: 居右对齐。
         * @en The text alignment mode.
         * - left: Left alignment.
         * - center: Center alignment.
         * - right: Right alignment.
         */
        get labelAlign(): string;
        set labelAlign(value: string);
        /**
         * @zh 标签垂直对齐模式。
         * - top: 顶部对齐。
         * - middle: 居中对齐。
         * - bottom: 底部对齐。
         * @en The vertical alignment mode for the label.
         * - top: Top alignment.
         * - middle: Middle alignment.
         * - bottom: Bottom alignment.
         */
        get labelVAlign(): string;
        set labelVAlign(value: string);
        /**
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         * @en The stroke width (in pixels) for the label.
         * The default value is 0, indicating no stroke.
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）;
         * @en The stroke color for the label, represented as a string.
         * The default color is "#000000" (black).
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * @zh 各个状态下的描边颜色
         * @en The stroke colors in various states.
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * @zh 按钮文本标签的字体大小。
         * @en The font size of the button's text label.
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * @zh 按钮的状态值，以数字表示，默认为3态。
         * @en The number of states the button has, represented as a number. The default is 3 states.
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @zh 按钮文本标签是否为粗体字。
         * @en Whether the button's text label is bold.
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * @zh 按钮文本标签的字体名称，以字符串形式表示。
         * @en The font name of the button's text label, represented as a string.
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * @zh 按钮文本标签的边距。
         * 格式："上边距,右边距,下边距,左边距"。
         * @en The padding of the button's text label.
         * Format: "Top,Right,Bottom,Left".
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * @zh 布局方向。 默认值为"horizontal"。
         * 取值：
         * "horizontal"：表示水平布局。
         * "vertical"：表示垂直布局。
         * @en The layout direction. The default value is "horizontal".
         * Possible values:
         * "horizontal": Indicates a horizontal layout.
         * "vertical": Indicates a vertical layout.
         */
        get direction(): string;
        set direction(value: string);
        /**
     * @en Whether to enable automatic line wrapping when items exceed the container size.
     * Default is false (no wrapping).
     * @zh 是否开启自动换行，当子项超出容器尺寸时自动换行。
     * 默认为 false（不换行）。
     */
        get lineWrap(): boolean;
        set lineWrap(value: boolean);
        /**
         * @zh 换行开启时，行与行之间的间距。
         * - 当 direction 为 "horizontal" 时，表示垂直间距（行间距）。
         * - 当 direction 为 "vertical" 时，表示水平间距（列间距）。
         * 默认值为 10。
         * @en The spacing between lines when wrap is enabled.
         * - If direction is "horizontal", this value indicates the vertical spacing (row spacing).
         * - If direction is "vertical", this value indicates the horizontal spacing (column spacing).
         * Default is 10.
         */
        get lineSpace(): number;
        set lineSpace(value: number);
        /**
         * @zh 项对象们之间的间隔（以像素为单位）。
         * @en The space between items in pixels.
         */
        get space(): number;
        set space(value: number);
        /**
         * @zh 项对象们的存放数组。
         * @en The array where the item objects are stored.
         */
        get items(): ISelect[];
        /**
         * @zh 当前选择的项对象。
         * @en The currently selected item object.
         */
        get selection(): ISelect;
        set selection(value: ISelect);
        /**
         * @zh 创建一个 UIGroup 的实例。
         * @param labels 标签集字符串，以逗号分隔，例如 "item0,item1,item2,item3,item4,item5"。
         * @param skin 皮肤。
         * @en Creates an instance of UIGroup.
         * @param labels A string of labels separated by commas, e.g., "item0,item1,item2,item3,item4,item5".
         * @param skin The skin.
         */
        constructor(labels?: string, skin?: string);
        /**
         * @override
         */
        protected preinitialize(): void;
        /**
         * @internal
         * @en 2.0 parsing will call
         * @zh 2.0解析会调用
         */
        _afterInited(): void;
        /** @internal */
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        protected _setLabelChanged(): void;
        /**
         * @zh 项对象的点击事件侦听处理函数，用于设置当前选择的项索引
         * @param index 项索引。
         * @en The item object's click event listener function, used to set the current selected item index.
         * @param index The item index.
         */
        protected itemClick(index: number): void;
        /**
         * @zh 创建一个项显示对象。
         * @param skin 项对象的皮肤路径。
         * @param label 项对象的文本标签。
         * @en Creates an item display object.
         * @param skin The skin path for the item object.
         * @param label The text label for the item object.
         */
        protected createItem(skin: string, label: string): Sprite;
        /**
         * @zh 更改项对象的属性值。
         * @en Change the property value of an item object.
         */
        protected changeLabels(): void;
        protected commitMeasure(): void;
        /**
         * @zh 通过对象的索引设置项对象的 `selected`属性值。
         * @param index 需要设置的项对象的索引。
         * @param selected 表示项对象的选中状态。
         * @en Sets the `selected`property value of an item object by its index.
         * @param index The index of the item object to be set.
         * @param selected Indicates the selected state of the item object.
         */
        protected setSelect(index: number, selected: boolean): void;
        /**
         * @en Destroys this instance.
         * @param destroyChild Whether to destroy the child components.
         * @zh 销毁此实例。
         * @param destroyChild 是否销毁子组件。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @zh 添加一个项对象。
         * @param item 需要添加的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 direction 和 space 属性计算item的位置。
         * @returns 返回添加的项对象的索引ID。
         * @en Adds an item object.
         * @param item The item object to be added.
         * @param autoLayout Whether to automatically layout the item. If true, the position of the item will be calculated based on the direction and space properties.
         * @returns returns the index ID of this item object.
         */
        addItem(item: ISelect, autoLayout?: boolean): number;
        /**
         * @zh 删除一个项对象。
         * @param item 需要删除的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 direction 和 space 属性计算item的位置。
         * @en Removes an item object.
         * @param item The item object to be added.
         * @param autoLayout Whether to automatically layout the item. If true, the position of the item will be calculated based on the direction and space properties. Default is true.
         */
        delItem(item: ISelect, autoLayout?: boolean): void;
        /**
         * @zh 反序列化后调用此方法。
         * @en This method is called after deserialization of this instance.
         */
        onAfterDeserialize(): void;
        /**
         * @zh 初始化项对象们。
         * @en Initializes the item objects.
         */
        initItems(): void;
        /**
         * @zh 设置此组件的数据源。
         * @en Sets the data source for this component.
         */
        set_dataSource(value: any): void;
        /** @internal @blueprintEvent */
        UIGroup_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en The `UIUtils` class is a collection of text utility functions.
     * @zh `UIUtils` 是文本工具集。
     */
    class UIUtils {
        private static _funMap;
        /**
         * @en Fill an array with a string and return a copy of the array.
         * @param arr The source array.
         * @param str A string of comma-separated values, such as "p1,p2,p3,p4".
         * @param type If the value is not null, it indicates the type of the newly added value.
         * @returns The filled array.
         * @zh 用字符串填充数组，并返回数组副本。
         * @param arr 源数组对象。
         * @param str 用逗号连接的字符串。如"p1,p2,p3,p4"。
         * @param type 如果值不为null，则填充的是新增值得类型。
         * @returns 填充后的数组。
         */
        static fillArray(arr: any[], str: string, type?: typeof Number | typeof String): any[];
        /**
         * @en Get the function expression based on the string.
         * @param value The string value.
         * @returns The function expression.
         * @zh 根据字符串，返回函数表达式。
         * @param value 字符串值。
         * @return 函数表达式。
         */
        static getBindFun(value: string): Function;
    }
    /**
     * @zh VBox 是一个垂直布局容器类。
     * @en VBox is a vertical layout container class.
     * @blueprintInheritable
     */
    class VBox extends LayoutBox {
        /**
         * @zh 无对齐。
         * @en No alignment.
         */
        static readonly NONE: string;
        /**
         * @zh 左对齐。
         * @en Left aligned.
         */
        static readonly LEFT: string;
        /**
         * @zh 居中对齐。
         * @en Center alignment.
         */
        static readonly CENTER: string;
        /**
         * @zh 右对齐。
         * @en Right aligned.
         */
        static readonly RIGHT: string;
        /**
         * @zh 自适应模式 - 仅高适配
         * @en AUTO_SIZE_HEIGHT - Height adaptive only.
         */
        static readonly AUTO_SIZE_HEIGHT: string;
        /**
         * @zh 兼容以前的changeItems逻辑，是否在发生变动时，使用 sortItem 排序所有item。
         * @en Compatible with previous changeItems logic, whether to use sortItem to sort all items when changes occur.
        */
        isSortItem: boolean;
        /**
         * @zh 自适应模式。
         * - none：无自适应模式。
         * - both：宽高自适应模式。
         * - height：高度自适应模式。
         * @en Adaptive mode.
         * - none: No adaptive mode.
         * - both: Both width and height are adaptive.
         * - height: Height adaptive.
         */
        get autoSizeMode(): string;
        set autoSizeMode(value: string);
        /**
         * @ignore
         */
        protected _transChanged(kind: TransformKind): void;
        /**
         * @zh 排序项目列表。可通过重写改变默认排序规则。
         * @param items  项目列表。
         * @en Sort the item list. Default sorting rules can be changed by overriding.
         * @param items The item list.
         */
        private sortItem;
        protected changeItems(): void;
    }
    /**
     * @deprecated
     * @en The View class represents a view component.
     * - In LayaAir 2.x, View inherited from the Scene class. However, in 3.x, Scene represents a broader concept encompassing both 2D and 3D. Therefore, in 3.x, understanding Scene as just a 2D scene view node is not appropriate. Scene has been retained for compatibility purposes, but the concept of a scene should be understood as encompassing both 2D and 3D scene data files.
     * @zh View 是一个视图类。
     * - 在 LayaAir 2.x 里，View 继承自 Scene 类，但在 3.x 里，Scene 是一个 2D+3D 的场景概念，所以在 3.x 里，把 Scene 类理解为场景是不合理的。Scene 是为了兼容而保留的 2D 场景视图节点，请忽略引擎中的 Scene 概念，场景概念统一理解为包含了 2D 与 3D 的场景数据文件。
     */
    class View extends Scene {
        /**
         * @en Compatible with older versions.
         * @zh 兼容老版本
         */
        static uiMap: any;
        /**
         * @en Compatible with older versions.Registers UI configuration information. For example, it registers a page with the path "test/TestPage", where the UI content is a JSON generated by the IDE.
         * @param url The path to the UI.
         * @param json The UI content in JSON format.
         * @zh 兼容老版本，注册UI配置信息。比如注册一个路径为"test/TestPage"的页面，UI内容是IDE生成的json
         * @param url		UI的路径
         * @param json	UI内容
         */
        static regUI(url: string, json: any): void;
        /**@internal */
        _watchMap: any;
        /**
         * @en The data source.
         * @zh 数据源。
         */
        protected _dataSource: any;
        /** @ignore */
        constructor();
        /** @ignore */
        protected createChildren(): void;
        changeData(key: string): void;
        /**
             * @en The actual display area width of the object (in pixels).
             * @zh 显示对象的实际显示区域宽度（以像素为单位）。
             */
        protected measureWidth(): number;
        /**
         * @en The actual display area height of the object (in pixels).
         * @zh 显示对象的实际显示区域高度（以像素为单位）。
         */
        protected measureHeight(): number;
        /**
         * @en Sets the data source for the control and updates the child components accordingly.
         * @param value The new data source to be set.
         * @zh 设置控件的数据源，并相应地更新子组件。
         * @param value 要设置的新数据源。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The ViewStack class is used for the View Stack class, which is used for setting and processing the display of views.
     * @zh ViewStack 类用于视图堆栈类，用于视图的显示等设置处理。
     * @blueprintInheritable
     */
    class ViewStack extends Box {
        /**@internal */
        protected _items: any[];
        /**@internal */
        protected _setIndexHandler: Handler;
        /**@internal */
        protected _selectedIndex: number;
        /**
         * @en The index of the current view.
         * @zh 当前视图的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en The currently selected item object.
         * @zh 当前选中的项对象。
         */
        get selection(): Node;
        set selection(value: Node);
        /**
         * @en Index setting processor.
         * Default callback parameters: index:int
         * @zh 索引设置处理器。
         * 默认回调参数：index:int
         */
        get setIndexHandler(): Handler;
        set setIndexHandler(value: Handler);
        /**
         * @en The array of view items.
         * @zh 视图集合数组。
         */
        get items(): any[];
        /** @ignore */
        constructor();
        /**
         * @en Sets the `selected` property value of an item object by its index.
         * @param index The index of the object to be set.
         * @param selected Indicates the selected state of the object.
         * @zh 通过对象的索引设置项对象的 `selected` 属性值。
         * @param index 需要设置的对象的索引。
         * @param selected 表示对象的选中状态。
         */
        protected setSelect(index: number, selected: boolean): void;
        /**
         * 设置属性<code>selectedIndex</code>的值。
         * @param index 选中项索引值。
         */
        protected setIndex(index: number): void;
        /**
         * @en Sets the view items in batch.
         * @param views An array of view objects to be set.
         * @zh 批量设置视图对象。
         * @param views 视图对象数组。
         */
        setItems(views: any[]): void;
        /**
         * @en Adds a view to the ViewStack.Sets the name property of the view object to facilitate identification.
         * @param view The view object to be added.
         * @zh 添加视图对象到 ViewStack，并设置此视图对象的 `name` 属性。
         * @param view 需要添加的视图对象。
         */
        addItem(view: Node): void;
        /**
         * @en This method is called after the object has been deserialized, and it initializes the view items.
         * @zh 反序列化后调用此方法，用以初始化视图项。
         */
        onAfterDeserialize(): void;
        _afterInited(): void;
        /**
         * @en Initialize the collection of view objects.
         * @zh 初始化视图对象集合。
         */
        initItems(): void;
        /**
         * @en Sets the data source for the ViewStack, updating the selectedIndex or properties accordingly.
         * @zh 为 ViewStack 设置数据源，相应地更新 selectedIndex 或属性。
         */
        set_dataSource(value: any): void;
    }
    /**
     * @en The vertical scrollbar (VScrollBar) is used to scroll and view all content in the vertical direction when there is too much data to fit in the display area.
     * @zh 垂直滚动条（VScrollBar）用于垂直方向因数据过多而超出显示区域时滚动查看全部内容。
     */
    class VScrollBar extends ScrollBar {
    }
    /**
     * @en A VSlider control allows the user to select a value by moving the slider thumb between the endpoints of the slider track. The VSlider control is oriented vertically. The slider track extends from bottom to top, and the label is positioned on the left and right sides of the track.
     * @zh 使用 VSlider 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。VSlider 控件采用垂直方向。滑块轨道从下往上扩展，而标签位于轨道的左右两侧。
     * @blueprintInheritable
     */
    class VSlider extends Slider {
    }
    enum ButtonStatus {
        Up = 0,
        Down = 1,
        Over = 2,
        SelectedOver = 3,
        Disabled = 4,
        SelectedDisabled = 5
    }
    enum AlignType {
        Left = 0,
        Center = 1,
        Right = 2,
        None = 3
    }
    enum VAlignType {
        Top = 0,
        Middle = 1,
        Bottom = 2,
        None = 3
    }
    enum LayoutChangedReason {
        Size = 0,
        Pos = 1,
        Visible = 2,
        Hierarchy = 3
    }
    enum ButtonMode {
        Common = 0,
        Check = 1,
        Radio = 2
    }
    enum ButtonDownEffect {
        None = 0,
        Dark = 1,
        UpScale = 2,
        DownScale = 3
    }
    enum TextFitContent {
        None = 0,
        Both = 1,
        Height = 2
    }
    enum LayoutType {
        None = 0,
        SingleColumn = 1,
        SingleRow = 2,
        FlowX = 3,
        FlowY = 4
    }
    enum StretchMode {
        None = 0,
        Stretch = 1,
        ResizeToFit = 2
    }
    enum SelectionMode {
        None = 0,
        Single = 1,
        Multiple = 2,
        MultipleBySingleClick = 3,
        Disabled = 4
    }
    enum LoaderFitMode {
        None = 0,
        Fill = 1,
        Contain = 2,
        Cover = 3,
        CoverWidth = 4,
        CoverHeight = 5
    }
    enum ProgressTitleType {
        Percent = 0,
        ValueAndMax = 1,
        Value = 2,
        Max = 3
    }
    enum ScrollDirection {
        Vertical = 0,
        Horizontal = 1,
        Both = 2
    }
    enum ScrollTouchEffect {
        Default = 0,
        On = 1,
        Off = 2
    }
    enum ScrollBounceBackEffect {
        Default = 0,
        On = 1,
        Off = 2
    }
    enum ScrollBarDisplay {
        Default = 0,
        Always = 1,
        OnOverflow = 2,
        OnScroll = 3,
        OnOverflowAndScroll = 4,
        Hidden = 5
    }
    enum PopupDirection {
        Auto = 0,
        Up = 1,
        Down = 2
    }
    enum TreeClickToExpandType {
        None = 0,
        SingleClick = 1,
        DoubleClick = 2
    }
    enum RelationType {
        Width = 1,
        Height = 2,
        Left_Left = 3,
        Left_Center = 4,
        Left_Right = 5,
        Center_Center = 6,
        Right_Left = 7,
        Right_Center = 8,
        Right_Right = 9,
        Top_Top = 10,
        Top_Middle = 11,
        Top_Bottom = 12,
        Middle_Middle = 13,
        Bottom_Top = 14,
        Bottom_Middle = 15,
        Bottom_Bottom = 16,
        LeftExt_Left = 17,
        LeftExt_Right = 18,
        RightExt_Left = 19,
        RightExt_Right = 20,
        TopExt_Top = 21,
        TopExt_Bottom = 22,
        BottomExt_Top = 23,
        BottomExt_Bottom = 24,
        Size = 100,
        Pos = 101,
        CenterAndMiddle = 102
    }
    /**
     * @en Controller class manages a set of pages, allowing for selection and change notifications.
     * @zh 控制器类管理一组页面，允许选择和更改通知。
     */
    class Controller extends EventDispatcher {
        private _selectedIndex;
        private _previousIndex;
        private _pages;
        /** @readonly */
        owner: GWidget;
        /** @readonly */
        name: string;
        /**
         * @en Indicates whether the controller is currently changing.
         * @zh 指示控制器当前是否正在更改。
         */
        readonly changing: boolean;
        /**
         * @internal
         */
        _refs: Set<ControllerRef>;
        /** @ignore @blueprintIgnore */
        constructor();
        /**
         * @en Pages of the controller.
         * @zh 控制器的页面。
         */
        get pages(): Array<string>;
        set pages(value: Array<string>);
        /**
         * @en The number of pages in the controller.
         * @zh 控制器中的页面数量。
         */
        get numPages(): number;
        set numPages(value: number);
        /**
         * @en Adds a new page to the controller.
         * @param name The name of the new page. If not provided, an empty string will be used.
         * @zh 向控制器添加一个新页面。
         * @param name 新页面的名称。如果未提供，将使用空字符串。
         */
        addPage(name?: string): this;
        /**
         * @en Index of the currently selected page.
         * @zh 当前选中页面的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en Name of the currently selected page.
         * @zh 当前选中页面的名称。
         */
        get selectedPage(): string;
        set selectedPage(value: string);
        /**
         * @en Index of the previously selected page.
         * @zh 上一个选中页面的索引。
         */
        get previousIndex(): number;
        /**
         * @en Index of the opposite page. ie. If the current index is 0, the opposite index will be 1, else if the current index is greate than 0, the opposite index will be 0.
         * @zh 相反页面的索引。即如果当前索引为0，则相反索引为1；如果当前索引大于0，则相反索引为0。
         */
        set oppositeIndex(value: number);
        /** @internal @blueprintEvent */
        Controller_bpEvent: {
            [Event.CHANGED]: () => void;
        };
    }
    /** @ignore */
    class ControllerRef {
        private _target;
        private _name;
        private _inst;
        private _inited;
        /** @internal */
        onChanged: (initiator: Controller) => void;
        constructor(target: GWidget, name: string);
        constructor(inst: Controller);
        get target(): GWidget;
        get name(): string;
        get inst(): Controller;
        get selectedIndex(): number;
        set selectedIndex(value: number);
        get selectedPage(): string;
        set selectedPage(value: string);
        get previousIndex(): number;
        set oppositeIndex(value: number);
        release(): void;
        validate(): void;
        private _reload;
        private _check;
    }
    /**
     * @en The DragDropManager class is used to manage drag-and-drop operations in the UI.
     * @zh DragDropManager 类用于管理 UI 中的拖放操作。
     * @blueprintable
     */
    class DragDropManager {
        /**
         * @en A loader used to display a drag image.
         * @zh 用于显示一个拖动图像的加载器。
         */
        readonly agent: GLoader;
        /**
         * @en The default width of the drag image.
         * @zh 拖动图像的默认宽度。
         */
        iconWidth: number;
        /**
         * @en The default height of the drag image.
         * @zh 拖动图像的默认高度。
         */
        iconHeight: number;
        private _source;
        private _rt;
        private static _inst;
        /**
         * @en Gets the singleton instance of DragDropManager.
         * @zh 获取 DragDropManager 的单例实例。
         */
        static get inst(): DragDropManager;
        /** @ignore @blueprintIgnore */
        constructor();
        /**
         * @en Indicates whether any object is currently dragging.
         * @zh 表示当前是否有对象正在拖动。
         */
        get dragging(): boolean;
        /**
         * @en Starts dragging an object. The object is not actually dragged, but a drag image is displayed. You can specify an icon resource or pass a sprite, in which case a screenshot is generated to create the image.
         * @param source The source object to be dragged as a icon.
         * @param icon The icon resource to be used as the drag image.
         * @param data (Optional) The data to be passed to the event handler.
         * @param iconWidth (Optional) The width of the drag image. Defaults to `iconWidth`.
         * @param iconHeight (Optional) The height of the drag image. Defaults to `iconHeight`.
         * @zh 开始拖动一个对象，对象并不会实际并拖动，而是显示一个拖动图像，这个图像可以通过制定一个图标资源，也可以传入一个sprite，这时会通过截图的方式生成一个图像。
         * @param source 要拖动的源对象。
         * @param icon 用作拖动图像的图标资源。
         * @param data （可选）要传递给事件处理程序的数据。
         * @param iconWidth （可选）拖动图像的宽度。默认为 `iconWidth`。
         * @param iconHeight （可选）拖动图像的高度。默认为 `iconHeight`。
         */
        start(source: Sprite, icon: string, data: any, iconWidth?: number, iconHeight?: number): void;
        /**
         * @en Starts dragging an object. The object is not actually dragged, but a drag image is displayed. You can specify an icon resource or pass a sprite, in which case a screenshot is generated to create the image.
         * @param source The source object to be dragged as a icon.
         * @param iconSource The sprite whose snapshot will be used as the drag image icon resource.
         * @param data (Optional) The data to be passed to the event handler.
         * @param iconWidth (Optional) The width of the drag image. Defaults to `iconWidth`.
         * @param iconHeight (Optional) The height of the drag image. Defaults to `iconHeight`.
         * @zh 开始拖动一个对象，对象并不会实际并拖动，而是显示一个拖动图像，这个图像可以通过制定一个图标资源，也可以传入一个sprite，这时会通过截图的方式生成一个图像。
         * @param source 要拖动的源对象。
         * @param iconSource 将用此Sprite的快照作为拖动图像的图标资源。
         * @param data （可选）要传递给事件处理程序的数据。
         * @param iconWidth （可选）拖动图像的宽度。默认为 `iconWidth`。
         * @param iconHeight （可选）拖动图像的高度。默认为 `iconHeight`。
         */
        start(source: Sprite, iconSource: Sprite, data: any, iconWidth?: number, iconHeight?: number): void;
        /**
         * @en Cancels the current drag operation.
         * @zh 取消当前的拖动操作。
         */
        stop(): void;
        private _dragEnd;
    }
    /**
     * @en GBox is a container widget that uses a layout to arrange its children.
     * @zh GBox 是一个容器小部件，使用布局来排列其子元素。
     * @blueprintInheritable
     */
    class GBox extends GWidget {
        protected _layout: ILayout;
        constructor(layoutClass?: new (...args: any[]) => ILayout);
        /**
         * @en The layout used by this GBox to arrange its children.
         * @zh 此 GBox 用于排列其子元素的布局。
         */
        get layout(): ILayout;
        /**
         * @en Sets the flag indicating that the layout has changed.
         * @param reason The reason for the layout change, if any.
         * @zh 设置标志，指示布局已更改。
         * @param reason 布局更改的原因（如果有的话）。
         */
        setLayoutChangedFlag(reason?: LayoutChangedReason): void;
        protected _sizeChanged(changeByLayout?: boolean): void;
        /** @internal @blueprintEvent */
        GBox_bpEvent: {
            [UIEvent.ContentSizeChanged]: () => void;
        };
    }
    const ButtonPageAlternatives: Record<number, ButtonStatus>;
    /**
     * @en GButton is a button widget that can display a title and an icon, and supports different modes such as common, check, and radio.
     * @zh GButton 是一个按钮小部件，可以显示标题和图标，并支持不同的模式，如常规、复选和单选。
     * @blueprintInheritable
     */
    class GButton extends GLabel {
        private _mode;
        private _selected;
        private _titleStr;
        private _iconStr;
        private _selectedTitleStr;
        private _selectedIconStr;
        private _sound;
        private _soundVolumeScale;
        private _buttonController;
        private _selectedController;
        private _selectedPage;
        private _changeStateOnClick;
        private _downEffect;
        private _scaleEffect;
        private _down;
        private _over;
        constructor();
        /** @ignore */
        destroy(): void;
        /**
         * @en The title of the button.
         * @zh 按钮的标题。
         */
        get title(): string;
        set title(value: string);
        /**
         * @en The title of the button when it is selected.
         * @zh 按钮被选中时的标题。
         */
        get selectedTitle(): string;
        set selectedTitle(value: string);
        /**
         * @en The icon of the button.
         * @zh 按钮的图标。
         */
        get icon(): string;
        set icon(value: string);
        /**
         * @en The icon of the button when it is selected.
         * @zh 按钮被选中时的图标。
         */
        get selectedIcon(): string;
        set selectedIcon(value: string);
        /**
         * @en The effect applied when the button is pressed down.
         * @zh 按钮按下时应用的效果。
         */
        get downEffect(): ButtonDownEffect;
        set downEffect(value: ButtonDownEffect);
        /**
         * @en The sound played when the button is clicked.
         * @zh 按钮点击时播放的声音。
         */
        get sound(): string;
        set sound(value: string);
        /**
         * @en The volume scale for the sound played when the button is clicked.
         * @zh 按钮点击时播放的声音的音量缩放。
         */
        get soundVolumeScale(): number;
        set soundVolumeScale(value: number);
        /**
         * @en Indicates whether the button is currently selected.
         * @zh 按钮当前是否被选中。
         */
        get selected(): boolean;
        set selected(value: boolean);
        /**
         * @en The mode of the button, which can be Common, Check, or Radio.
         * @zh 按钮的模式，可以是 Common、Check 或 Radio。
         */
        get mode(): ButtonMode;
        set mode(value: ButtonMode);
        /**
         * @en The button can be linked to a controller, so when the button state changes, the controller's selected state will also change, and vice versa.
         * @zh 按钮可以联动一个控制器，当按钮状态改变时，控制器的选中状态也会随之改变。 反之亦然。
         */
        get selectedController(): ControllerRef;
        set selectedController(value: ControllerRef);
        /**
         * @en When the selected controller is on this page, the button will be selected.
         * @zh 当选中控制器处于此页面时，按钮将被选中。
         */
        get selectedPage(): number;
        set selectedPage(value: number);
        /**
         * @en When the button is clicked, whether to automatically change the selected state. Default is true.
         * @zh 当按钮被点击时，是否自动改变选中状态。默认是true。
         */
        get changeStateOnClick(): boolean;
        set changeStateOnClick(value: boolean);
        /** @ignore */
        get mouseEnabled(): boolean;
        set mouseEnabled(value: boolean);
        /**
         * @en Simulates a click on the button, optionally applying a down effect and triggering a click call.
         * @param downEffect Whether to apply a down effect when simulating the click. Default is false.
         * @param clickCall Whether to trigger the click event after the down effect. Default is true.
         * @returns
         */
        fireClick(downEffect?: boolean, clickCall?: boolean): void;
        protected setState(page: ButtonStatus): void;
        protected setCurrentState(): void;
        protected _controllersChanged(): void;
        protected _onPartChanged(which: string): void;
        private selectChanged;
        private _rollover;
        private _rollout;
        private _btnTouchBegin;
        private _btnTouchEnd;
        private _removeFromStage;
        private _click;
        private _rightClick;
        /** @internal @blueprintEvent */
        GButton_bpEvent: {
            [Event.CHANGED]: () => void;
        };
    }
    /**
     * @en GComboBox is a dropdown list that allows users to select an item from a list of options.
     * @zh GComboBox 是一个下拉列表，允许用户从选项列表中选择一个项目。
     * @blueprintInheritable
     */
    class GComboBox extends GLabel {
        /**
         * @en The direction in which the popup dropdown will appear.
         * @zh 弹出下拉列表将出现的方向。
         */
        popupDirection: PopupDirection;
        /**
         * @en The number of items visible in the dropdown list.
         * @zh 下拉列表中可见的项目数量。
         */
        visibleItemCount: number;
        private _items;
        private _icons;
        private _values;
        private _dropdownRes;
        private _itemsUpdated;
        private _selectedIndex;
        private _buttonController;
        private _selectedController;
        private _dropdown;
        private _list;
        private _down;
        private _over;
        constructor();
        /**
         * @en The list of items in the dropdown.
         * @zh 下拉列表中的项目列表。
         */
        get items(): string[];
        set items(value: string[]);
        /**
         * @en The list of icons corresponding to the items in the dropdown.
         * @zh 下拉列表中项目对应的图标列表。
         */
        get icons(): string[];
        set icons(value: string[]);
        /**
         * @en The list of values corresponding to the items in the dropdown.
         * @zh 下拉列表中项目对应的值列表。
         */
        get values(): string[];
        set values(value: string[]);
        /**
         * @en The index of the currently selected item in the dropdown.
         * @zh 当前选中下拉列表项目的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(val: number);
        /**
         * @en The value of the currently selected item in the dropdown.
         * @zh 当前选中下拉列表项目的值。
         */
        get value(): string;
        set value(val: string);
        /**
         * @en The prefab resource used for the dropdown.
         * @zh 用于下拉列表的预制资源。
         */
        get dropdownRes(): Prefab;
        set dropdownRes(value: Prefab);
        /**
         * @en The dropdown widget that displays the list of items.
         * @zh 显示项目列表的下拉精灵。
         */
        get dropdown(): GWidget;
        /**
         * @zh 控制器可以与下拉框联动，当下拉框选择发生改变时，控制器也同时跳转到相同索引的页面。反之亦然，如果控制器跳转到某个页面，那么下拉框也同时选定相同索引的项目。
         * @en The controller that can be linked with the dropdown. When the selection in the dropdown changes, the controller will also jump to the same index page, and vice versa. If the controller jumps to a certain page, the dropdown will also select the item at the same index.
         */
        get selectedController(): ControllerRef;
        set selectedController(value: ControllerRef);
        /** @ignore */
        destroy(): void;
        /**
         * @en This method is automatically called to update the dropdown list when it is popped up.
         * @zh 下拉列表弹出时，会自动调用这个方法更新下拉列表。
         */
        updateList(): void;
        private createDropdown;
        protected _controllersChanged(): void;
        private selectChanged;
        protected setState(page: number): void;
        protected setCurrentState(): void;
        protected showDropdown(): void;
        private _updateDropDown;
        private _popupWinClosed;
        private _clickItem;
        private _rollover;
        private _rollout;
        private _mousedown;
        private _mouseup;
        /** @internal @blueprintEvent */
        GComboBox_bpEvent: {
            [Event.CHANGED]: () => void;
            [UIEvent.Popup]: () => void;
        };
    }
    class Gear {
        protected _owner: GWidget;
        protected _controller: ControllerRef;
        protected _propPath: string;
        protected _tweenCfg: GearTweenConfig;
        /** @internal */
        _tween: Tween;
        /** @internal */
        _propPathArr: string[];
        values: Record<number, any>;
        static disableAllTweenEffect: boolean;
        constructor();
        get owner(): GWidget;
        set owner(value: GWidget);
        get controller(): ControllerRef;
        set controller(value: ControllerRef);
        get propPath(): string;
        set propPath(value: string);
        get tween(): GearTweenConfig;
        set tween(value: GearTweenConfig);
        protected onChanged(initiator: Controller): void;
        protected getValue(page: number): any;
        protected compareValue(value: any, value2: any): boolean;
        protected doTween(obj: any, key: string, oldValue: any, newValue: any): void;
        protected runGear(initiator: Controller): void;
    }
    class GearNumber extends Gear {
    }
    class GearString extends Gear {
    }
    class GearBool extends Gear {
    }
    class GearColor extends Gear {
    }
    class GearStrColor extends Gear {
        protected doTween(obj: any, key: string, oldValue: string, newValue: string): void;
    }
    class GearHexColor extends Gear {
        protected doTween(obj: any, key: string, oldValue: number, newValue: number): void;
    }
    class GearDisplay extends Gear {
        private _pages;
        private _flag;
        private _condition;
        constructor();
        get pages(): Array<number>;
        set pages(value: Array<number>);
        get condition(): number;
        set condition(value: number);
        protected runGear(initiator: Controller): void;
        static check(owner: GWidget, cc?: Controller, allowDelay?: boolean): void;
        static checkAll(cc: Controller): void;
    }
    class GearTweenConfig {
        enabled: boolean;
        easeType: EaseType;
        duration: number;
        delay: number;
    }
    /**
     * @en GImage is a widget that displays an image resource.
     * @zh GImage 是一个显示图像资源的小部件。
     * @blueprintInheritable
     */
    class GImage extends GWidget {
        private _src;
        private _color;
        private _autoSize;
        private _loadId;
        private _renderer;
        constructor();
        /**
         * @en The source URL of the image resource.
         * @zh 图像资源的源 URL。
         */
        get src(): string;
        set src(value: string);
        /**
         * @en The texture of the image.
         * @zh 图像的纹理。
         */
        get texture(): Texture;
        set texture(value: Texture);
        /**
         * @en The mesh factory used for customizing the mesh of the image.
         * @zh 用于自定义图像网格的网格工厂。
         */
        get mesh(): IMeshFactory;
        set mesh(value: IMeshFactory);
        /** @ignore */
        get icon(): string;
        set icon(value: string);
        /**
         * @en Whether to use the original size of the resource.
         * @zh 是否使用资源的原始大小。
         */
        get autoSize(): boolean;
        set autoSize(value: boolean);
        /**
         * @en The color of the object.
         * @zh 对象的颜色。
         */
        get color(): string;
        set color(value: string);
        protected onLoaded(tex: Texture, loadID: number): void;
        private onTextureReload;
        protected _sizeChanged(changeByLayout?: boolean): void;
        /** @ignore */
        destroy(): void;
        /** @internal @blueprintEvent */
        GImage_bpEvent: {
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en GLabel is a widget that displays a text label and an icon.
     * @zh GLabel 是一个显示文本标签和图标的小部件。
     * @blueprintInheritable
     */
    class GLabel extends GWidget {
        protected _titleWidget: WidgetRef;
        protected _iconWidget: WidgetRef;
        /**
         * @en Title of the label.
         * @zh 标签的标题。
         */
        get title(): string;
        set title(value: string);
        /** @ignore */
        get text(): string;
        set text(value: string);
        /**
         * @en Icon of the label.
         * @zh 标签的图标。
         */
        get icon(): string;
        set icon(value: string);
        /**
         * @en Color of the title text.
         * @zh 标题文本的颜色。
         */
        get titleColor(): string;
        set titleColor(value: string);
        /**
         * @en Font size of the title text.
         * @zh 标题文本的字体大小。
         */
        get titleFontSize(): number;
        set titleFontSize(value: number);
        /**
         * @en The widget that displays the title text.
         * @zh 显示标题文本的小部件。
         */
        get titleWidget(): GWidget;
        set titleWidget(val: GWidget);
        /**
         * @en The widget that displays the icon.
         * @zh 显示图标的小部件。
         */
        get iconWidget(): GWidget;
        set iconWidget(val: GWidget);
        protected _onPartChanged(which: string): void;
        /**
         * @en Finds the first text widget in the label hierarchy.
         * @return The first text widget found, or null if none exists.
         * @zh 在标签层次结构中查找第一个文本小部件。
         * @returns 找到的第一个文本小部件，如果不存在则返回 null。
         */
        findTextWidget<T extends GTextField | GTextInput>(): T | null;
    }
    /**
     * @en GList is a widget that displays a list of items, allowing for item rendering and selection.
     * @zh GList 是一个显示项目列表的小部件，允许进行项目渲染和选择。
     * @blueprintInheritable
     */
    class GList extends GPanel {
        /**
         * @en The function used to render each item in the list.
         * @zh 用于渲染列表中每个项目的函数。
         */
        itemRenderer: (index: number, item: any) => void;
        /**
         * @en The function used to provide the template resource for each item in the list.
         * @zh 用于提供列表中每个项目的模板资源的函数。
         */
        itemProvider: (index: number) => string;
        protected _layout: IListLayout;
        private _pool;
        /** @internal */
        _templateNode: GWidget;
        constructor();
        /** @ignore */
        destroy(): void;
        /** @ignore */
        get layout(): IListLayout;
        /**
         * @en The template resource used for items in the list.
         * @zh 列表中项目使用的模板资源。
         */
        get itemTemplate(): Prefab;
        set itemTemplate(value: Prefab);
        /**
         * @en Built-in object pool functionality for GList.
         * @zh GList内建对象池功能。
         */
        get itemPool(): WidgetPool;
        /**
         * @zh 从对象池中取出一个子项对象。
         * @param url 资源地址，如果不传则使用默认的对象池资源。
         * @return 返回一个 GWidget 对象。
         * @en Get a child object from the pool.
         * @param url The resource URL, if not provided, the default pool resource will be used.
         * @returns A GWidget object.
         */
        getFromPool(url?: string): GWidget;
        /**
         * @en Return an object to the pool.
         * @param obj The GWidget object to return.
         * @zh 将一个对象返回到对象池中。
         * @param obj 要返回的 GWidget 对象。
         */
        returnToPool(obj: GWidget): void;
        /**
         * @en Add an item from the pool to the list.
         * @param url The resource URL of the item to add. If not provided, the default pool resource will be used.
         * @returns A GWidget object that has been added to the list.
         * @zh 从对象池中添加一个项目到列表中。
         * @param url 项目的资源地址，如果不传则使用默认的对象池资源。
         * @returns 返回一个已添加到列表中的 GWidget 对象。
         */
        addItemFromPool(url?: string): GWidget;
        /**
         * @en Remove a child at the specified index and return it to the pool.
         * @param index The index of the child to remove.
         * @zh 移除指定索引处的子项并将其返回到对象池。
         * @param index 要移除的子项的索引。
         */
        removeChildToPoolAt(index: number): void;
        /**
         * @en Remove a specific child from the list and return it to the pool.
         * @param child The child widget to remove.
         * @zh 从列表中移除特定的子项并将其返回到对象池。
         * @param child 要移除的子项小部件。
         */
        removeChildToPool(child: GWidget): void;
        /**
         * @en Remove a range of children from the list and return them to the pool.
         * @param beginIndex The starting index of the range to remove. Defaults to 0.
         * @param endIndex The ending index of the range to remove. If not provided, it will remove all children from the beginning index to the end of the list.
         * @zh 从列表中移除一系列子项并将它们返回到对象池。
         * @param beginIndex 要移除的范围的起始索引。
         * @param endIndex 要移除的范围的结束索引。如果未提供，将从起始索引移除到列表末尾的所有子项。
         */
        removeChildrenToPool(beginIndex?: number, endIndex?: number): void;
        /**
         * @en The number of items in the list. If the list not virtual, this is the number of children, else it is the number of items in the data source.
         * @zh 列表中的项目数量。如果列表不是虚拟的，则为子项的数量，否则为数据源中的项目数量。
         */
        get numItems(): number;
        set numItems(value: number);
        /**
         * @en Resize the list to fit the number of items and minimum size.
         * @param itemCount The number of items to fit in the list. If not provided, it will use the current number of items.
         * @param minSize The minimum size of the list. If not provided, it will use the current size of the list.
         * @zh 调整列表大小以适应项目数量和最小大小。
         * @param itemCount 要适应列表中的项目数量。如果未提供，将使用当前的项目数量。
         * @param minSize 列表的最小大小。如果未提供，将使用列表的当前大小。
         */
        resizeToFit(itemCount?: number, minSize?: number): void;
        /**
         * @en If the list is a virtual list, this function can convert the child index to the index in the data list.
         * @param index The index of the child in the list.
         * @returns The index of the item in the data list.
         * @zh 如果列表是虚拟列表，这个函数可以将孩子索引转换到数据列表中的索引。
         * @param index 列表中子项的索引。
         * @returns 数据列表中项目的索引。
         */
        childIndexToItemIndex(index: number): number;
        /**
         * @en If the list is a virtual list, this function can convert the item index in the data list to the child index.
         * @param index The index of the item in the data list.
         * @returns The index of the child in the list.
         * @zh 如果列表是虚拟列表，这个函数可以将数据列表中的项目索引转换为子项索引。
         * @param index 数据列表中项目的索引。
         * @returns 列表中子项的索引。
         */
        itemIndexToChildIndex(index: number): number;
        /**
         * @en Refresh the virtual list.
         * @zh 刷新虚拟列表。
         */
        refreshVirtualList(): void;
        /**
         * @en Set the list to be a virtual list.
         * @zh 设置列表为虚拟列表。
         */
        setVirtual(): void;
        /**
         * @en Set the list to be virtual list, and has loop behavior.
         * @zh 设置列表为虚拟列表，并具有循环行为。
         */
        setVirtualAndLoop(): void;
        private _setVirtual;
        /** @ignore @blueprintIgnore */
        onAfterDeserialize(): void;
        /** @internal */
        _buildInitItems(): void;
    }
    /**
     * @en GLoader is a widget that displays an image or animation resource.
     * @zh GLoader 是一个显示图像或动画资源的小部件。
     * @blueprintInheritable
     */
    class GLoader extends GWidget {
        private _src;
        private _align;
        private _valign;
        private _fitMode;
        private _shrinkOnly;
        private _color;
        private _frame;
        private _autoPlay;
        private _loop;
        private _updatingLayout;
        private _content;
        private _srcWidth;
        private _srcHeight;
        private _loadId;
        private _renderer;
        private _ani;
        constructor();
        /**
         * @en The source URL of the image or animation resource.
         * @zh 图像或动画资源的源 URL。
         */
        get src(): string;
        set src(value: string);
        /** @ignore */
        get icon(): string;
        set icon(value: string);
        /**
         * @en The alignment of the content within the loader.
         * @zh 加载器内内容的对齐方式。
         */
        get align(): AlignType;
        set align(value: AlignType);
        /**
         * @en The vertical alignment of the content within the loader.
         * @zh 加载器内内容的垂直对齐方式。
         */
        get valign(): VAlignType;
        set valign(value: VAlignType);
        /**
         * @en The fit mode of the loader, which determines how the content is scaled to fit the loader's size.
         * @zh 加载器的适配模式，决定内容如何缩放以适应加载器的大小。
         */
        get fitMode(): LoaderFitMode;
        set fitMode(value: LoaderFitMode);
        /**
         * @en Whether to only shrink the content to fit the loader's size, without enlarging it.
         * @zh 是否仅缩小内容以适应加载器的大小，而不放大它。
         */
        get shrinkOnly(): boolean;
        set shrinkOnly(value: boolean);
        /**
         * @en The color applied to the content of the loader.
         * @zh 应用于加载器内容的颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en The FrameAnimation component used for animations.
         * @zh 用于动画的 FrameAnimation 组件。
         */
        get ani(): FrameAnimation | null;
        /**
         * @en The index of the current frame in the animation.
         * @zh 动画当前帧的索引。
         */
        get frame(): number;
        set frame(value: number);
        /**
        * @en Whether to auto-play, default is false. If set to true, the animation will automatically play after being created and added to the stage.
        * @zh 是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
        */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Whether to loop playback. Default is true.
         * @zh 是否循环播放。默认为 true。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en The texture of the image.
         * @zh 图像的纹理。
         */
        get texture(): Texture;
        set texture(value: Texture);
        /**
         * @en The mesh factory used for customizing the mesh of the image.
         * @zh 用于自定义图像网格的网格工厂。
         */
        get mesh(): IMeshFactory;
        set mesh(value: IMeshFactory);
        get material(): Material;
        set material(value: Material);
        protected loadContent(): void;
        protected onLoaded(value: Texture | AtlasResource, loadID: number): void;
        private onTextureReload;
        protected clearContent(): void;
        protected updateLayout(): void;
        protected _sizeChanged(): void;
        /** @ignore */
        destroy(): void;
        /** @internal @blueprintEvent */
        GLoader_bpEvent: {
            [Event.LOADED]: () => void;
        };
    }
    /**
     * @en GMovieClip is a widget that displays a frame animation, allowing for playback control and customization.
     * @zh GMovieClip 是一个显示帧动画的小部件，允许进行播放控制和自定义。
     * @blueprintInheritable
     */
    class GMovieClip extends GWidget {
        /**
         * @en The FrameAnimation component used for the movie clip.
         * @zh 用于电影剪辑的 FrameAnimation 组件。
         */
        readonly comp: FrameAnimation;
        private _color;
        constructor();
        /**
         * @en The source URL of the animation resource.
         * @zh 动画资源的源 URL。
         */
        get src(): string;
        set src(value: string);
        /** @ignore */
        get icon(): string;
        set icon(value: string);
        /**
         * @en Whether to use the original size of the resource.
         * @zh 是否使用资源的原始大小。
         */
        get autoSize(): boolean;
        set autoSize(value: boolean);
        /**
         * @en The color of the object.
         * @zh 对象的颜色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en The index of the current frame in the animation.
         * @zh 动画当前帧的索引。
         */
        get frame(): number;
        set frame(value: number);
        /**
         * @en Whether the animation is currently playing.
         * @zh 动画是否正在播放。
         */
        get isPlaying(): boolean;
        /**
        * @en Whether to auto-play, default is false. If set to true, the animation will automatically play after being created and added to the stage.
        * @zh 是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
        */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * @en Whether to loop playback. Default is true.
         * @zh 是否循环播放。默认为 true。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en Playback speed.
         * @zh 播放速率。
         */
        get timeScale(): number;
        set timeScale(value: number);
        protected _sizeChanged(changeByLayout?: boolean): void;
    }
    /**
     * @en GPanel is a container widget that supports clipping and scrolling, allowing for a flexible layout of its children.
     * @zh GPanel 是一个支持裁剪和滚动的容器小部件，允许其子元素灵活布局。
     * @blueprintInheritable
     */
    class GPanel extends GBox {
        private _clipping;
        private _scroller;
        private _maskContainer;
        protected _selection: ISelection;
        constructor(layoutClass?: new (...args: any[]) => ILayout, selectionClass?: new (...args: any[]) => ISelection);
        /**
         * @en The scroller component used for scrolling the panel's content.
         * @zh 用于滚动面板内容的滚动组件。
         */
        get scroller(): IScroller;
        set scroller(value: IScroller);
        /**
         * @en The selection component used for managing the selection state of items in the panel.
         * @zh 用于管理面板中项目选择状态的选择组件。
         */
        get selection(): ISelection;
        /**
         * @en The index of the currently selected item in the panel.
         * @zh 面板中当前选定项目的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @en Whether the panel is clipping its content.
         * @zh 面板是否裁剪其内容。
         */
        get clipping(): boolean;
        set clipping(value: boolean);
        /**
         * @en The viewport width of the panel, which is the width of the visible area.
         * @zh 面板的视口宽度，即可见区域的宽度。
         */
        get viewWidth(): number;
        set viewWidth(value: number);
        /**
         * @en The viewport height of the panel, which is the height of the visible area.
         * @zh 面板的视口高度，即可见区域的高度。
         */
        get viewHeight(): number;
        set viewHeight(value: number);
        /**
         * @en The widget under the touch point.
         * @zh 在触摸点下的小部件。
         */
        get touchItem(): GWidget;
        protected _sizeChanged(changeByLayout?: boolean): void;
        /** @internal */
        _panelChildChanged(child: Sprite): void;
        /** @ignore */
        destroy(): void;
        /** @internal @blueprintEvent */
        GPanel_bpEvent: {
            [Event.CHANGED]: () => void;
            [UIEvent.ClickItem]: (item: GButton) => void;
            [UIEvent.Scroll]: () => void;
            [UIEvent.ScrollEnd]: () => void;
            [UIEvent.PullDownRelease]: () => void;
            [UIEvent.PullUpRelease]: () => void;
        };
    }
    /**
     * @en GProgressBar is a widget that displays a progress bar.
     * @zh GProgressBar 是一个显示进度条的小部件。
     * @blueprintInheritable
     */
    class GProgressBar extends GWidget {
        private _hBar;
        private _vBar;
        private _titleWidget;
        private _min;
        private _max;
        private _value;
        private _titleType;
        private _reverse;
        private _barMaxWidth;
        private _barMaxHeight;
        private _barMaxWidthDelta;
        private _barMaxHeightDelta;
        private _barStartX;
        private _barStartY;
        private _tween;
        constructor();
        /**
         * @en The type of title displayed on the progress bar.
         * @zh 进度条上显示的标题类型。
         */
        get titleType(): ProgressTitleType;
        set titleType(value: ProgressTitleType);
        /**
         * @en Minimum value of the progress bar.
         * @zh 进度条的最小值。
         */
        get min(): number;
        set min(value: number);
        /**
         * @en Maximum value of the progress bar.
         * @zh 进度条的最大值。
         */
        get max(): number;
        set max(value: number);
        /**
         * @en Current value of the progress bar.
         * @zh 进度条的当前值。
         */
        get value(): number;
        set value(value: number);
        /**
         * @en Tweens the value of the progress bar to a target value over a specified duration.
         * @param value The target value to tween to.
         * @param duration The duration of the tween in milliseconds.
         * @return Returns a Tween instance that can be used to control the tween animation.
         * @zh 使用缓动改变进度条的值。
         * @param value 目标值。
         * @param duration 缓动持续时间（毫秒）。
         * @return 返回一个 Tween 实例，可以用于控制缓动动画。
         */
        tweenValue(value: number, duration: number): Tween;
        protected update(newValue: number): void;
        private updateTitle;
        private setFillAmount;
        /** @internal */
        _onConstruct(inPrefab?: boolean): void;
        /** @ignore */
        _setup(hBar: GWidget, vBar: GWidget, titleWidget: GWidget, reverse: boolean): void;
        protected _sizeChanged(): void;
    }
    /**
     * @en GRoot is the root widget of the application, managing modal layers, popups, and windows.
     * @zh GRoot 是应用程序的根小部件，管理模态层、
     */
    class GRoot extends GWidget {
        private _modalLayer;
        private _modalWaitPane;
        private _popupMgr;
        /**
         * @en The layer index for the GRoot, used to ensure it is rendered above other 2D elements.
         * @zh GRoot 的层索引，用于确保它在其他 2D 元素之上渲染。
         */
        static LAYER: number;
        /**
         * @en The singleton instance of GRoot.
         * @zh GRoot 的单例实例。
         */
        static get inst(): GRoot;
        /** @ignore @blueprintIgnore */
        constructor();
        /**
         * @en The PopupManager instance used for managing popups in the GRoot.
         * @zh GRoot 中用于管理弹出窗口的 PopupManager 实例。
         */
        get popupMgr(): PopupManager;
        /**
         * @en Displays a window in the GRoot. Generally, you do not need to call this method directly, but rather use GWindow.show() method.
         * @param win The target window.
         * @zh 在 GRoot 中显示一个窗口。一般不需要直接调用这个方法，而是直接使用GWindow.show()方法。
         * @param win 目标窗口。
         */
        showWindow(win: GWindow): void;
        /**
         * @en Hides a window in the GRoot. Generally, you do not need to call this method directly, but rather use GWindow.hide() method.
         * @param win The window to hide.
         * @zh 在 GRoot 中隐藏一个窗口。一般不需要直接调用这个方法，而是直接使用GWindow.hide()方法。
         * @param win 要隐藏的窗口。
         */
        hideWindow(win: GWindow): void;
        /**
         * @en Immediately hides a window in the GRoot without any animation, and will not call GWindow.onHide. Generally, you do not need to call this method directly.
         * @param win The window to hide.
         * @zh 立即隐藏 GRoot 中的窗口，不带任何动画，也不会调用GWindow.onHide。一般不需要直接调用这个方法。
         * @param win 要隐藏的窗口。
         */
        hideWindowImmediately(win: GWindow): void;
        /**
         * @en Brings a window to the front in the GRoot, ensuring it is the topmost window.
         * @param win The window to bring to the front.
         * @zh 将一个窗口置于 GRoot 的最前面，确保它是最上层的窗口。
         * @param win 要置于最前面的窗口。
         */
        bringToFront(win: GWindow): void;
        /**
         * @en Displays a modal waiting pane in the GRoot, which blocks user interaction with other elements.
         * @param msg Optional message to display in the modal waiting pane.
         * @zh 在 GRoot 中显示一个模态等待面板，阻止用户与其他元素的交互。
         * @param msg 可选的消息，在模态等待面板中显示。
         */
        showModalWait(msg?: string): void;
        /**
         * @en Closes the modal waiting pane in the GRoot, allowing user interaction with other elements.
         * @zh 关闭 GRoot 中的模态等待面板，允许用户与其他元素交互。
         */
        closeModalWait(): void;
        /**
         * @en Closes all windows in the GRoot except for modal windows.
         * @zh 关闭 GRoot 中的所有窗口，除了模态窗口。
         */
        closeAllExceptModals(): void;
        /**
         * @en Closes all windows in the GRoot, including modal windows.
         * @zh 关闭 GRoot 中的所有窗口，包括模态窗口。
         */
        closeAllWindows(): void;
        /**
         * @en Gets the topmost window in the GRoot.
         * @returns The topmost GWindow instance, or null if no windows are present.
         * @zh 获取 GRoot 中最上层的窗口。
         * @returns 最上层的 GWindow 实例，如果没有窗口则返回 null。
         */
        getTopWindow(): GWindow | null;
        /**
         * @en The modal layer used to block user interaction with other elements when a modal window is displayed.
         * @zh 用于在显示模态窗口时阻止用户与其他元素交互的模态层。
         */
        get modalLayer(): GWidget;
        /**
         * @en Indicates whether there is a modal window currently displayed in the GRoot.
         * @zh 指示 GRoot 中是否有模态窗口当前显示。
         */
        get hasModalWindow(): boolean;
        /**
         * @en Indicates whether a modal waiting pane is currently displayed in the GRoot.
         * @zh 指示 GRoot 中是否有模态等待面板当前显示。
         */
        get modalWaiting(): boolean;
        /**
         * @en Displays a popup in the GRoot, which can be positioned relative to a target widget or in a specific direction.
         * @param popup The popup widget to display.
         * @param target Optional target widget to position the popup relative to. If not provided, the popup will be positioned at the mouse position.
         * @param dir Optional direction in which to display the popup. If not provided, the default direction will be used.
         * @zh 在 GRoot 中显示一个弹出窗口，可以相对于目标小部件定位或在特定方向上显示。
         * @param popup 要显示的弹出窗口小部件。
         * @param target 可选的目标小部件，用于相对于其定位弹出窗口。如果未提供，则弹出窗口将定位在鼠标位置。
         * @param dir 可选的方向，用于显示弹出窗口。如果未提供，则使用默认方向。
         */
        showPopup(popup: GWidget, target?: GWidget, dir?: PopupDirection): void;
        /**
         * @en Toggles the visibility of a popup in the GRoot. If the popup is already displayed, it will be hidden; otherwise, it will be shown.
         * @param popup The popup widget to toggle.
         * @param target Optional target widget to position the popup relative to. If not provided, the popup will be positioned at the mouse position.
         * @param dir Optional direction in which to display the popup. If not provided, the default direction will be used.
         * @returns Returns true if the popup was shown, false if it was hidden.
         * @zh 弹出或收起一个弹出窗口小部件。如果弹出窗口已经显示，则将其隐藏；否则，将其显示。
         * @param popup 要切换的弹出窗口小部件。
         * @param target 可选的目标小部件，用于相对于其定位弹出窗口。如果未提供，则弹出窗口将定位在鼠标位置。
         * @param dir 可选的方向，用于显示弹出窗口。如果未提供，则使用默认方向。
         * @return 如果弹出窗口被显示则返回 true，如果被隐藏则返回 false。
         */
        togglePopup(popup: GWidget, target?: GWidget, dir?: PopupDirection): boolean;
        /**
         * @en Hides a popup in the GRoot. If no popup is specified, it will hide the topmost popup.
         * @param popup Optional popup widget to hide. If not provided, the topmost popup will be hidden.
         * @zh 在 GRoot 中隐藏一个弹出窗口。如果未指定弹出窗口，则将隐藏最上层的弹出窗口。
         * @param popup 可选的弹出窗口小部件。如果未提供，则隐藏最上层的弹出窗口。
         */
        hidePopup(popup?: GWidget): void;
        /**
         * @en Whether there are any popups currently displayed in the GRoot.
         * @zh GRoot 中是否有任何弹出窗口当前显示。
         */
        get hasAnyPopup(): boolean;
        /** @internal */
        adjustModalLayer(): void;
    }
    /**
     * @en GScrollBar is a widget that provides a scroll bar interface for scrolling content.
     * @zh GScrollBar 是一个提供滚动内容的滚动条界面的小部件。
     * @blueprintInheritable
     */
    class GScrollBar extends GWidget {
        private _gripButton;
        private _arrowButton1;
        private _arrowButton2;
        private _bar;
        private _target;
        private _vertical;
        private _scrollPerc;
        private _fixedGripSize;
        private _dragOffset;
        private _gripDragging;
        constructor();
        /** @ignore */
        setOwner(target: IScroller, vertical: boolean): void;
        setDisplayPerc(value: number): void;
        setScrollPerc(val: number): void;
        get minSize(): number;
        get gripDragging(): boolean;
        get fixedGripSize(): boolean;
        set fixedGripSize(value: boolean);
        /** @internal */
        _onConstruct(inPrefab?: boolean): void;
        /** @ignore */
        _setup(arrowButton1: GWidget, arrowButton2: GWidget, bar: GWidget, grip: GWidget): void;
        private _gripTouchBegin;
        private _gripTouchMove;
        private _gripTouchEnd;
        private _arrowButton1Click;
        private _arrowButton2Click;
        private _barTouchBegin;
    }
    /**
     * @en GSlider is a widget that provides a slider interface for selecting a value within a range.
     * @zh GSlider 是一个提供滑块界面的小部件，用于在范围内选择值。
     * @blueprintInheritable
     */
    class GSlider extends GWidget {
        /**
         * @en Whether the slider changes value when clicked on the bar.
         * @zh 是否在点击滑块条时更改值。
         */
        changeOnClick: boolean;
        /**
         * @en Whether the slider can be dragged to change its value.
         * @zh 是否可以拖动滑块以更改其值。
         */
        canDrag: boolean;
        private _hBar;
        private _vBar;
        private _gripButton;
        private _titleWidget;
        private _min;
        private _max;
        private _value;
        private _titleType;
        private _reverse;
        private _wholeNumbers;
        private _barMaxWidth;
        private _barMaxHeight;
        private _barMaxWidthDelta;
        private _barMaxHeightDelta;
        private _clickPos;
        private _clickPercent;
        private _barStartX;
        private _barStartY;
        constructor();
        /**
         * @en The type of title displayed on the slider.
         * @zh 滑块上显示的标题类型。
         */
        get titleType(): ProgressTitleType;
        set titleType(value: ProgressTitleType);
        /**
         * @en If true, the slider will only stop at integer positions when dragged by the user, meaning the slider's value will always be an integer.
         * @zh 如果为true，则当滑动条被用户滑动时，最后只会停止在整数位置上，也就是滑动条的值始终是整数。
         */
        get wholeNumbers(): boolean;
        set wholeNumbers(value: boolean);
        /**
         * @en Minimum value of the slider.
         * @zh 滑块的最小值。
         */
        get min(): number;
        set min(value: number);
        /**
         * @en Maximum value of the slider.
         * @zh 滑块的最大值。
         */
        get max(): number;
        set max(value: number);
        /**
         * @en Current value of the slider.
         * @zh 滑块的当前值。
         */
        get value(): number;
        set value(value: number);
        protected update(): void;
        private updateWithPercent;
        private updateTitle;
        /** @internal */
        _onConstruct(inPrefab?: boolean): void;
        /** @ignore */
        _setup(hBar: GWidget, vBar: GWidget, grip: GWidget, title: GWidget, reverse: boolean): void;
        protected _sizeChanged(): void;
        private _gripTouchBegin;
        private _gripTouchMove;
        private _barTouchBegin;
        /** @internal @blueprintEvent */
        GSlider_bpEvent: {
            [Event.CHANGED]: (e: Event) => void;
        };
    }
    /**
     * @en GTextField is a widget that displays text with various formatting options, including font, size, color, alignment, and more.
     * @zh GTextField 是一个显示文本的小部件，支持多种格式选项，包括字体、大小、颜色、对齐方式等。
     * @blueprintInheritable
     */
    class GTextField extends GWidget {
        /**
         * @en The Text component used for rendering the text.
         * @zh 用于渲染文本的 Text 组件。
         */
        readonly textIns: Text;
        private _fitContent;
        private _fitFlag;
        constructor();
        /**
         * @en The width of the text in pixels.
         * @zh 文本的宽度，以像素为单位。
         */
        get textWidth(): number;
        /**
         * @en The height of the text in pixels.
         * @zh 文本的高度，以像素为单位。
         */
        get textHeight(): number;
        /**
         * @en The current content string of the text.
         * @zh 当前文本的内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The font name of the text, represented as a string.
         * The default value is "Arial", which can be set through Config.defaultFont.
         * If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
         * @zh 文本的字体名称，以字符串形式表示。
         * 默认值为："Arial"，可以通过Config.defaultFont设置默认字体。
         * 如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Specifies the font size of the text in pixels.
         * The default is 20 pixels, which can be set through Config.defaultFontSize.
         * @zh 指定文本的字体大小（以像素为单位）。
         * 默认为20像素，可以通过 Config.defaultFontSize 设置默认大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en Represents the color value of the text. The default color can be set through Text.defaultColor.
         * The default value is black.
         * @zh 表示文本的颜色值。可以通过 Text.defaultColor 设置默认颜色。
         * 默认值为黑色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Specifies whether the text is bold.
         * The default value is false, which means bold is not used. If the value is true, the text is bold.
         * @zh 指定文本是否为粗体字。
         * 默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Indicates whether the text using this text format is italic.
         * The default value is false, which means italic is not used. If the value is true, the text is italic.
         * @zh 表示使用此文本格式的文本是否为斜体。
         * 默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Represents the horizontal alignment of the text.
         * Possible values:
         * - "left": Left-aligned.
         * - "center": Center-aligned.
         * - "right": Right-aligned.
         * @zh 表示文本的水平显示方式。
         * 取值：
         * - "left"： 居左对齐显示。
         * - "center"： 居中对齐显示。
         * - "right"： 居右对齐显示。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Represents the vertical alignment of the text.
         * Possible values:
         * - "top": Top-aligned.
         * - "middle": Middle-aligned.
         * - "bottom": Bottom-aligned.
         * @zh 表示文本的垂直显示方式。
         * 取值：
         * - "top"： 居顶部对齐显示。
         * - "middle"： 居中对齐显示。
         * - "bottom"： 居底部对齐显示。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en Alignment of images and text in mixed content. Possible values are top, middle, bottom.
         * @zh 图文混排时图片和文字的对齐方式。可选值是 top, middle, bottom。
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @en Indicates whether the text automatically wraps, default is false.
         * If true, the text will automatically wrap; otherwise, it will not.
         * @zh 表示文本是否自动换行，默认为 false。
         * 若值为 true，则自动换行；否则不自动换行。
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * @en The way text content fits.
         * @zh 文本内容适应方式。
         */
        get fitContent(): TextFitContent;
        set fitContent(value: TextFitContent);
        /**
         * @en Vertical line spacing in pixels.
         * @zh 垂直行间距（以像素为单位）。
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Margin information.
         * Data format: [top margin, right margin, bottom margin, left margin] (margins in pixels).
         * @zh 边距信息。
         * 数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        get padding(): number[];
        set padding(value: number[]);
        /**
         * @en Stroke width in pixels.
         * The default value is 0, which means no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Stroke color, represented as a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Specifies the behavior when text exceeds the text area.
         * Values: visible, hidden, scroll, shrink, ellipsis.
         * Effects:
         * - visible: All text is visible regardless of text width and height constraints.
         * - hidden: Text exceeding width and height will be clipped, best for performance.
         * - scroll: Parts exceeding width and height are hidden, can be controlled by scrolling.
         * - shrink: Text size automatically adjusts to fit within the width and height.
         * - ellipsis: When text exceeds width and height, last few characters are replaced with ellipsis.
         * @zh 指定文本超出文本域后的行为。
         * 值为：可见visible、隐藏hidden、滚动scroll、自动收缩shrink、显示省略号ellipsis。
         * 作用：
         * - 可见：文本不受文本宽高约束全部可见。
         * - 隐藏：超过文本宽高就会被裁切掉，性能最好。
         * - 滚动：超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域。
         * - 自动收缩：文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内。
         * - 显示省略号：当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容。
         */
        get overflow(): string;
        set overflow(value: string);
        /**
         * @en Whether to display underline.
         * @zh 是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en The color of the underline. If null, it uses the font color.
         * @zh 下划线的颜色。如果为null，则使用字体颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        /**
         * @en Whether to display strikethrough.
         * @zh 是否显示删除线。
         */
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * @en The color of the strikethrough. If null, it uses the font color.
         * @zh 删除线的颜色。如果为null，则使用字体颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Whether rich text is enabled, supporting HTML syntax.
         * @zh 是否启用富文本，支持HTML语法。
         */
        get html(): boolean;
        set html(value: boolean);
        /**
         * @en Whether UBB syntax parsing is enabled for text.
         * @zh 是否启用UBB语法解析文本。
         */
        get ubb(): boolean;
        set ubb(value: boolean);
        /**
         * @en The maximum width allowed for text. When text reaches this width, it will automatically wrap. Set to 0 to disable this limit.
         * @zh 文本允许的最大宽度。当文本达到这个宽度时，将自动换行。设置为0则此限制不生效。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en Whether single character rendering is enabled. Enable this if the text content changes frequently, such as an increasing number, to prevent inefficient use of cache.
         * @zh 是否启用单个字符渲染。如果文字内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存
         */
        get singleCharRender(): boolean;
        set singleCharRender(value: boolean);
        /**
         * @en Text Template
         * @zh 文本模板
         */
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        /**
         * @en Set the value of a template variable.
         * @param name The name of the template variable.
         * @param value The value to set.
         * @returns The current Text instance.
         * @zh 设置模板值。
         * @param name 模板名
         * @param value 值
         * @returns 当前 Text 实例。
         */
        setVar(name: string, value: any): this;
        /**
         * @ignore
         */
        size(width: number, height: number): this;
        /**
         * @en Typeset the text, applying any changes made to the text formatting.
         * @zh 对文本进行排版，应用对文本格式的任何更改。
         */
        typeset(): this;
        /** @ignore */
        protected _transChanged(kind: TransformKind): void;
        /** @ignore */
        protected _onPostLayout(): void;
        /** @internal @blueprintEvent */
        GTextField_bpEvent: {
            [Event.LINK]: (href: string) => void;
        };
    }
    /**
     * @en GTextInput is a widget that provides a text input field with various formatting options.
     * @zh GTextInput 是一个提供文本输入字段的小部件，支持多种格式选项。
     * @blueprintInheritable
     */
    class GTextInput extends GWidget {
        /**
         * @en The Text component used for rendering the text.
         * @zh 用于渲染文本的 Text 组件。
         */
        readonly textIns: Input;
        constructor();
        /**
         * @en The current content string of the text.
         * @zh 当前文本的内容字符串。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The font name of the text, represented as a string.
         * The default value is "Arial", which can be set through Config.defaultFont.
         * If the runtime system cannot find the specified font, it will render the text with the system default font, which may cause display anomalies. (Usually, it displays normally on computers, but may display abnormally on some mobile devices due to the lack of the set font.)
         * @zh 文本的字体名称，以字符串形式表示。
         * 默认值为："Arial"，可以通过Config.defaultFont设置默认字体。
         * 如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
         */
        get font(): string;
        set font(value: string);
        /**
         * @en Specifies the font size of the text in pixels.
         * The default is 20 pixels, which can be set through Config.defaultFontSize.
         * @zh 指定文本的字体大小（以像素为单位）。
         * 默认为20像素，可以通过 Config.defaultFontSize 设置默认大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en Represents the color value of the text. The default color can be set through Text.defaultColor.
         * The default value is black.
         * @zh 表示文本的颜色值。可以通过 Text.defaultColor 设置默认颜色。
         * 默认值为黑色。
         */
        get color(): string;
        set color(value: string);
        /**
         * @en Specifies whether the text is bold.
         * The default value is false, which means bold is not used. If the value is true, the text is bold.
         * @zh 指定文本是否为粗体字。
         * 默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @en Indicates whether the text using this text format is italic.
         * The default value is false, which means italic is not used. If the value is true, the text is italic.
         * @zh 表示使用此文本格式的文本是否为斜体。
         * 默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @en Represents the horizontal alignment of the text.
         * Possible values:
         * - "left": Left-aligned.
         * - "center": Center-aligned.
         * - "right": Right-aligned.
         * @zh 表示文本的水平显示方式。
         * 取值：
         * - "left"： 居左对齐显示。
         * - "center"： 居中对齐显示。
         * - "right"： 居右对齐显示。
         */
        get align(): string;
        set align(value: string);
        /**
         * @en Represents the vertical alignment of the text.
         * Possible values:
         * - "top": Top-aligned.
         * - "middle": Middle-aligned.
         * - "bottom": Bottom-aligned.
         * @zh 表示文本的垂直显示方式。
         * 取值：
         * - "top"： 居顶部对齐显示。
         * - "middle"： 居中对齐显示。
         * - "bottom"： 居底部对齐显示。
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @en Vertical line spacing in pixels.
         * @zh 垂直行间距（以像素为单位）。
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @en Margin information.
         * Data format: [top margin, right margin, bottom margin, left margin] (margins in pixels).
         * @zh 边距信息。
         * 数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。
         */
        get padding(): number[];
        set padding(value: number[]);
        /**
         * @en Whether to display underline.
         * @zh 是否显示下划线。
         */
        get underline(): boolean;
        set underline(value: boolean);
        /**
         * @en The color of the underline. If null, it uses the font color.
         * @zh 下划线的颜色。如果为null，则使用字体颜色。
         */
        get underlineColor(): string;
        set underlineColor(value: string);
        /**
         * @en Whether to display strikethrough.
         * @zh 是否显示删除线。
         */
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        /**
         * @en The color of the strikethrough. If null, it uses the font color.
         * @zh 删除线的颜色。如果为null，则使用字体颜色。
         */
        get strikethroughColor(): string;
        set strikethroughColor(value: string);
        /**
         * @en Stroke width in pixels.
         * The default value is 0, which means no stroke.
         * @zh 描边宽度（以像素为单位）。
         * 默认值0，表示不描边。
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @en Stroke color, represented as a string.
         * The default value is "#000000" (black).
         * @zh 描边颜色，以字符串表示。
         * 默认值为 "#000000"（黑色）。
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * @en Whether it is a text area.
         * True means it is a text area, otherwise it is not.
         * @zh 是否是文本域。
         * 值为true表示当前是文本域，否则不是文本域。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * @en whether it is editable.
         * @zh 是否可编辑。
         */
        get editable(): boolean;
        set editable(value: boolean);
        /**
         * @en The pattern that restricts the input.
         * @zh 限制输入的字符。
         */
        get restrict(): string;
        set restrict(pattern: string);
        /**
         * @en The prompt text of the input.
         * @zh 输入框的提示文本。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @en The prompt color of the input.
         * @zh 输入框的提示文字颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @en The maximum number of characters allowed in the input.
         * @zh 输入框允许的最大字符数。
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * @en The type of the input box. Refer to the HTML5 input tag for types.
         * Common types include:
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         * @zh 输入框的类型。可参照HTML5的input标签。
         * 常用标签例如：
         * - text
         * - password
         * - email
         * - number
         * - date
         * - time
         */
        get type(): string;
        set type(value: string);
        /**
         * @en Activates the input box.
         * @zh 激活输入框。
         */
        focus(): void;
        /**
         * @en Deactivates the input box.
         * @zh 取消激活输入框。
         */
        blur(): void;
        /** @ignore */
        protected _transChanged(kind: TransformKind): void;
        /** @internal @blueprintEvent */
        GTextInput_bpEvent: {
            [Event.CHANGE]: () => void;
            [Event.INPUT]: () => void;
            [Event.ENTER]: () => void;
            [Event.FOCUS]: () => void;
            [Event.BLUR]: () => void;
        };
    }
    /**
     * @en GTree is a widget that displays a hierarchical tree structure, allowing for item rendering and selection.
     * @zh GTree 是一个显示分层树结构的小部件，允许进行项目渲染和选择。
     * @blueprintInheritable
     */
    class GTree extends GPanel {
        /**
         * @en The function used to render each tree node.
         * @zh 用于渲染每个树节点的函数。
         */
        treeNodeRender: (node: GTreeNode, obj: any) => void;
        /**
         * @en The function called when a tree node is about to expand or collapse.
         * @zh 当树节点即将展开或折叠时调用的函数。
         */
        treeNodeWillExpand: (node: GTreeNode, expanded: boolean) => void;
        /**
         * @en The root node of the tree.
         * @zh 树的根节点。
         */
        readonly rootNode: GTreeNode;
        /**
         * @en The indent for each level. As the depth of the tree node increases, it indents to the right by the specified pixel distance. For example, if the indent is 15 pixels and the tree node is at level 3, the total indent will be 15 * 3 = 45 pixels.
         * @zh 每级缩进。树节点的深度每增加一级，向右缩进的像素距离。例如，如果每级缩进是15像素，树节点的层级是3级，那么树节点的缩进是15*3=45像素。
         */
        indent: number;
        /**
         * @en Whether to scroll to the expanded node when it is expanded.
         * @zh 是否在展开节点时滚动到该节点。
         */
        scrollToViewOnExpand: boolean;
        private _pool;
        _selection: ITreeSelection;
        constructor();
        /**
         * @en The selection component used for managing the selection state of items in the tree.
         * @zh 用于管理树中项目选择状态的选择组件。
         */
        get selection(): ITreeSelection;
        /**
         * @en Whether to automatically expand or collapse the folder node when clicking on it.
         * @zh 点击文件夹节点时是否自动展开或者折叠这个这个节点。
         */
        get clickToExpand(): TreeClickToExpandType;
        set clickToExpand(value: TreeClickToExpandType);
        /**
         * @en The template resource used for items in the tree.
         * @zh 树中项目使用的模板资源。
         */
        get itemTemplate(): Prefab;
        set itemTemplate(value: Prefab);
        /**
         * @en Built-in object pool functionality for GTree.
         * @zh GTree内建对象池功能。
         */
        get itemPool(): WidgetPool;
        /**
         * @en Expands all child folder nodes of the specified folder node or the root node if none is specified.
         * @param folderNode The folder node to expand. If not specified, the root node will be used.
         * @zh 展开指定文件夹节点的所有子文件夹节点，如果未指定，则使用根节点。
         */
        expandAll(folderNode?: GTreeNode): void;
        /**
         * @en Collapses all child folder nodes of the specified folder node or the root node if none is specified.
         * @param folderNode The folder node to collapse. If not specified, the root node will be used.
         * @zh 折叠指定文件夹节点的所有子文件夹节点，如果未指定，则使用根节点。
         * @param folderNode 要折叠的文件夹节点。如果未指定，则使用根节点。
         */
        collapseAll(folderNode?: GTreeNode): void;
        private createCell;
        /** @internal */
        _afterInserted(node: GTreeNode): void;
        private getInsertIndexForNode;
        /** @internal */
        _afterRemoved(node: GTreeNode): void;
        /** @internal */
        _afterExpanded(node: GTreeNode, byEvent?: boolean): void;
        /** @internal */
        _afterCollapsed(node: GTreeNode, byEvent?: boolean): void;
        /** @internal */
        _afterMoved(node: GTreeNode): void;
        private getFolderEndIndex;
        private checkChildren;
        private hideFolderNode;
        private removeNode;
        /** @ignore @blueprintIgnore */
        onAfterDeserialize(): void;
        /** @internal */
        _buildInitItems(): void;
    }
    /**
     * @en Represents a node in a tree structure.
     * @zh 表示树结构中的一个节点。
     */
    class GTreeNode {
        /**
         * @en The data associated with this tree node.
         * @zh 与此树节点关联的数据。
         */
        data: any;
        private _parent;
        private _children;
        private _expanded;
        private _level;
        private _indentLevel;
        private _addIndent;
        private _tree;
        private _cell;
        private _indentObj;
        private _resURL;
        private _leafController;
        private _isFolder;
        private _expandCtrler;
        /**
         * @en The function called when the node is expanded or collapsed.
         * @zh 当节点被展开或折叠时调用的函数。
         */
        onExpanded?: (expand: boolean) => void;
        /** @internal */
        _cellFromPool: boolean;
        constructor(isFolder?: boolean, resURL?: string, addIndent?: number);
        /**
         * @en The expanded state of the node.
         * @zh 节点的展开状态。
         */
        get expanded(): boolean;
        set expanded(value: boolean);
        /** @internal */
        _setExpanded(value: boolean, byEvent?: boolean): void;
        /**
         * @en Indicates whether this node is a folder.
         * @zh 指示此节点是否为文件夹。
         */
        get isFolder(): boolean;
        set isFolder(value: boolean);
        /**
         * @en Additional indentation level for this node.
         * @zh 此节点的额外缩进级别。
         */
        get addIndent(): number;
        set addIndent(value: number);
        /**
         * @en The parent node of this tree node.
         * @zh 此树节点的父节点。
         */
        get parent(): GTreeNode;
        /**
         * @en The text content of the tree node.
         * @zh 树节点的文本内容。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The icon associated with the tree node.
         * @zh 与树节点关联的图标。
         */
        get icon(): string;
        set icon(value: string);
        /**
         * @en The display widget for this tree node.
         * @zh 此树节点的显示小部件。
         */
        get cell(): GWidget;
        set cell(value: GWidget);
        /**
         * @en Create a widget for this tree node.
         * @param tree If the tree node is not yet part of a tree, you can pass the tree instance to create the widget.
         * @zh 为此树节点创建一个小部件。
         * @param tree 如果树节点尚未属于任何树，可以传递树实例来创建小部件。
         */
        createCell(tree?: GTree): void;
        /**
         * @en The level of this tree node in the tree hierarchy.
         * @zh 此树节点在树层次结构中的级别。
         */
        get level(): number;
        /**
         * @en Add a child node to this tree node.
         * @param child The child node to add.
         * @returns The added child node.
         * @zh 向此树节点添加一个子节点。
         * @param child 要添加的子节点。
         * @returns 添加的子节点。
         */
        addChild(child: GTreeNode): GTreeNode;
        /**
         * @en Add a child node at a specific index.
         * @param child The child node to add.
         * @param index The index at which to add the child node. If the index is equal to the number of children, the child will be added at the end.
         * @returns The added child node.
         * @zh 在特定索引处添加一个子节点。
         * @param child 要添加的子节点。
         * @param index 要添加子节点的索引。如果索引等于子节点的数量，则子节点将被添加到末尾。
         * @returns 添加的子节点
         */
        addChildAt(child: GTreeNode, index: number): GTreeNode;
        /**
         * @en Remove a specific child node from this tree node.
         * @param child The child node to remove.
         * @returns The removed child node.
         * @zh 从此树节点中移除特定的子节点。
         * @param child 要移除的子节点。
         * @returns 被移除的子节点。
         */
        removeChild(child: GTreeNode): GTreeNode;
        /**
         * @en Remove a child node at a specific index.
         * @param index The index of the child node to remove.
         * @returns The removed child node.
         * @zh 从此树节点中移除指定索引处的子节点。
         * @param index 要移除的子节点的索引。
         * @returns 被移除的子节点。
         */
        removeChildAt(index: number): GTreeNode;
        /**
         * @en Remove a range of children from this tree node.
         * @param beginIndex The starting index of the range to remove. Defaults to 0
         * @param endIndex The ending index of the range to remove. If not provided, it will remove all children from the beginning index to the end of the list.
         * @zh 从此树节点中移除一系列子节点。
         * @param beginIndex 要移除的范围的起始索引。默认为0。
         * @param endIndex 要移除的范围的结束索引。如果未提供，将从起始索引移除到列表末尾的所有子节点。
         */
        removeChildren(beginIndex?: number, endIndex?: number): void;
        /**
         * @en Get the child node at a specific index.
         * @param index The index of the child node to retrieve.
         * @returns The child node at the specified index.
         * @zh 获取指定索引处的子节点。
         * @param index 要检索的子节点的索引。
         * @returns 指定索引处的子节点。
         */
        getChildAt(index: number): GTreeNode;
        /**
         * @en Get the index of a specific child node.
         * @param child The child node to find the index of.
         * @returns The index of the specified child node, or -1 if not found.
         * @param child 要查找索引的子节点。
         * @returns 指定子节点的索引，如果未找到则返回-1。
         */
        getChildIndex(child: GTreeNode): number;
        /**
         * @en Get the previous sibling node of this tree node.
         * @returns The previous sibling node, or null if this is the first child or has no parent.
         * @zh 获取此树节点的前一个兄弟节点。
         * @returns 前一个兄弟节点，如果这是第一个子节点或没有父节点，则返回null。
         */
        getPrevSibling(): GTreeNode | null;
        /**
         * @en Get the next sibling node of this tree node.
         * @returns The next sibling node, or null if this is the last child or has no parent.
         * @zh 获取此树节点的下一个兄弟节点。
         * @returns 下一个兄弟节点，如果这是最后一个子节点或没有父节点，则返回null。
         */
        getNextSibling(): GTreeNode | null;
        /**
         * @en Get the last visible descendant node of this tree node.
         * @returns The last visible descendant node, or null if there are no visible descendants.
         * @zh 获取此树节点的最后一个可见子孙节点。
         * @returns 最后一个可见子孙节点，如果没有可见子孙节点，则返回null。
         */
        getLastVisibleDecendant(): GTreeNode | null;
        private findLastVisibleChild;
        /**
         * @en Set the index of a child node within this tree node.
         * @param child The child node whose index is to be set.
         * @param index The new index for the child node. If the index is less than 0, it will be set to 0; if greater than the number of children, it will be set to the number of children.
         * @zh 设置此树节点中子节点的索引。
         * @param child 要设置索引的子节点。
         * @param index 子节点的新索引。如果索引小于0，则设置为0；如果大于子节点数量，则设置为子节点数量。
         */
        setChildIndex(child: GTreeNode, index: number): void;
        /**
         * @en Swap the positions of two child nodes within this tree node.
         * @param child1 The first child node to swap.
         * @param child2 The second child node to swap.
         * @zh 在此树节点中交换两个子节点的位置。
         * @param child1 第一个要交换的子节点。
         * @param child2 第二个要交换的子节点。
         */
        swapChildren(child1: GTreeNode, child2: GTreeNode): void;
        /**
         * @en Swap the positions of two child nodes at specific indices within this tree node.
         * @param index1 The index of the first child node to swap.
         * @param index2 The index of the second child node to swap.
         * @zh 在此树节点中交换两个子节点在特定索引处的位置。
         * @param index1 第一个要交换的子节点的索引。
         * @param index2 第二个要交换的子节点的索引。
         */
        swapChildrenAt(index1: number, index2: number): void;
        /**
         * @en The number of child nodes under this tree node.
         * @zh 此树节点下的子节点数量。
         */
        get numChildren(): number;
        /**
         * @en The list of child nodes under this tree node.
         * @returns A read-only array of child nodes.
         * @zh 此树节点下的子节点列表。
         * @returns 一个只读的子节点数组。
         */
        get children(): ReadonlyArray<GTreeNode>;
        /**
         * @en Expand this tree node and all its parent nodes up to the root.
         * @zh 展开此树节点及其所有父节点直到根节点。
         */
        expandToRoot(): void;
        /**
         * @en The tree that this node belongs to.
         * @zh 此节点所属的树。
         */
        get tree(): GTree;
        /** @internal */
        _setTree(value: GTree): void;
        private _expandedStateChanged;
        private _cellMouseDown;
        private _clickExpandButton;
    }
    /**
     * @en GWidget is the base class for all UI widgets in the New UI system.
     * @zh GWidget 是新 UI 系统中所有 UI 小部件的基类。
     * @blueprintInheritable
     */
    class GWidget extends Sprite {
        /**
         * @en The data associated with this widget, which can be used to store custom information.
         * @zh 与此小部件关联的数据，可用于存储自定义信息。
         */
        data: any;
        /**
         * @en The tree node associated with this widget.
         * @zh 与此小部件关联的树节点。
         */
        readonly treeNode: GTreeNode;
        private _tooltips;
        private _grayed;
        private _background;
        private _draggable;
        private _controllers;
        private _controllerCount;
        private _gears;
        private _relations;
        private _forceSizeFlag;
        /** @internal */
        _rawWidth: number;
        /** @internal */
        _rawHeight: number;
        /** @internal */
        _deltaWidth: number;
        /** @internal */
        _deltaHeight: number;
        /** @ignore */
        _giveWidth: number;
        /** @ignore */
        _giveHeight: number;
        /** @ignore */
        sourceWidth: number;
        /** @ignore */
        sourceHeight: number;
        /** @internal */
        static _defaultRoot: GRoot;
        constructor();
        /**
         * @en The leftmost x-coordinate of the widget, calculated based on the anchor point.
         * @zh 小部件最左侧的 x 坐标，根据锚点计算。
         */
        get left(): number;
        set left(value: number);
        /**
         * @en The topmost y-coordinate of the widget, calculated based on the anchor point.
         * @zh 小部件最上方的 y 坐标，根据锚点
         */
        get top(): number;
        set top(value: number);
        /**
         * @en Sets the position of the widget based on its anchor point.
         * @param xv The x-coordinate to set.
         * @param yv The y-coordinate to set.
         * @zh 根据锚点设置小部件的位置。
         * @param xv 要设置的 x 坐标.
         * @param yv 要设置的 y 坐标.
         */
        setLeftTop(xv: number, yv: number): void;
        /**
         * @en Centers the widget within the specified target or its parent.
         * If no target is specified, it will center within the parent or stage.
         * @param target The target widget or scene to center within. If not provided, it defaults to the parent or stage.
         * @returns Returns the current GWidget instance for method chaining.
         * @zh 在指定的目标或其父级中居中小部件。
         * 如果未指定目标，则默认在父级或舞台中居中。
         * @param target 要在其中居中的目标小部件或场景。如果未提供，则默认为父级或舞台。
         * @returns 返回当前的 GWidget 实例，以便进行方法链调用。
         */
        center(target?: GWidget): this;
        /** @ignore @blueprintIgnore */
        pos(x: number, y: number): this;
        /** @ignore @blueprintIgnore */
        size(wv: number, hv: number, changeByLayout?: boolean): this;
        /**
         * @en Makes the widget fill the entire size of the specified target or its parent.
         * If no target is specified, it will fill the parent or stage.
         * @param target The target widget to fill. If not provided, it defaults to the parent node, or the default root node (GRoot) if the scene node also does not exist.
         * @param constraints Whether to add Size constraints. Default is false.
         * @returns Returns the current GWidget instance for method chaining.
         * @zh 使小部件填充指定目标或其父级的整个大小。
         * 如果未指定目标，则默认填充父级或舞台。
         * @param target 要填充的目标小部件。如果未提供，则使用父级节点，如果父级节点不存在，则使用默认根节点（GRoot)。
         * @param constraints 是否添加Size关联。默认为false。
         * @returns 返回当前的 GWidget 实例，以便进行方法链调用。
         */
        makeFullSize(target?: GWidget, constraints?: boolean): this;
        /**
         * @en Indicates whether the widget is grayed out.
         * @zh 指示小部件是否被灰显。
         */
        get grayed(): boolean;
        set grayed(value: boolean);
        /**
         * @en Indicates whether the widget is enabled.
         * @zh 指示小部件是否启用。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /** @internal */
        get internalVisible(): boolean;
        /** @internal */
        set internalVisible(value: boolean);
        /**
         * @en The tooltips text displayed when the mouse hovers over the widget.
         * @zh 鼠标悬停在小部件上时显示的工具提示文本。
         */
        get tooltips(): string;
        set tooltips(value: string);
        private _rollOver;
        private _rollOut;
        /**
         * @en The text content of the widget.
         * @zh 小部件的文本内容。
         */
        get text(): string;
        set text(value: string);
        /**
         * @en The icon of the widget.
         * @zh 小部件的图标。
         */
        get icon(): string;
        set icon(value: string);
        /**
         * @en The background graphics command of the widget.
         * @zh 小部件的背景图形命令。
         */
        get background(): IGraphicsCmd;
        set background(value: IGraphicsCmd);
        /**
         * @en Indicates whether the widget can be dragged.
         * @zh 指示小部件是否可以被拖动。
         */
        get draggable(): boolean;
        set draggable(value: boolean);
        /**
         * @en The relations of the widget, which define how it relates to other widgets or scenes.
         * @zh 小部件的关系，定义它与其他小部件或场景的关系。
         */
        get relations(): Array<Relation>;
        /** @internal */
        set relations(value: Array<Relation>);
        /** @internal */
        _addRelations(value: Array<Relation>): void;
        /**
         * @en Adds a relation to the widget.
         * @param target The target widget or scene to relate to.
         * @param type The type of relation to add, such as size, position, etc.
         * @param percent Optional. If true, the relation is treated as a percentage of the target's size.
         * @returns Returns the current GWidget instance for method chaining.
         * @zh 向小部件添加关联。
         * @param target 要关联的目标小部件或场景。
         * @param type 要添加的关系类型，例如大小、位置等。
         * @param percent 可选。如果为 true，则将关系视为目标大小的百分比。
         * @returns 返回当前的 GWidget 实例，以便进行方法链调用。
         */
        addRelation(target: GWidget | Scene, type: RelationType, percent?: boolean): this;
        /**
         * @en Removes a relation from the widget.
         * @param target The target widget or scene to remove the relation from.
         * @param type The type of relation to remove, such as size, position, etc.
         * @returns Returns the current GWidget instance for method chaining.
         * @zh 从小部件中移除关联。
         * @param target 要从中移除关联的目标小部件或场景。
         * @param type 要移除的关系类型，例如大小、位置等。
         * @returns 返回当前的 GWidget 实例，以便进行方法链调用。
         */
        removeRelation(target: GWidget | Scene, type: RelationType): this;
        /**
         * @en Clears all relations of the widget.
         * @returns Returns the current GWidget instance for method chaining.
         * @zh 清除小部件的所有关联。
         * @returns 返回当前的 GWidget 实例，以便进行方法链调用。
         */
        clearRelations(): this;
        /**
         * @en The controllers of the widget.
         * @zh 小部件的控制器。
         */
        get controllers(): Readonly<Record<string, Controller>>;
        /**
         * @en The number of controllers associated with the widget.
         * @zh 与小部件关联的控制器数量。
         */
        get controllerCount(): number;
        /** @internal */
        set controllers(value: Readonly<Record<string, Controller>>);
        /**
         * @en Adds a new controller to the widget.
         * @param name The name of the controller to add.
         * @param pageCount Optional. The number of pages in the controller. If not provided, it defaults to 0.
         * @returns Returns the newly created Controller instance.
         * @zh 向小部件添加一个新的控制器。
         * @param name 要添加的控制器的名称。
         * @param pageCount 可选。控制器中的页面数量。如果未提供，则默认为为 0。
         * @returns 返回新创建的 Controller 实例。
         */
        addController(name: string, pageCount?: number): Controller;
        /**
         * @en Gets a controller by its name.
         * @param name The name of the controller to retrieve.
         * @returns The Controller instance associated with the specified name, or null if not found.
         * @zh 根据名称获取控制器。
         * @param name 要检索的控制器的名称。
         * @returns 与指定名称关联的 Controller 实例，如果未找到则返回 null。
         */
        getController(name: string): Controller | null;
        /**
         * @en Sets the current page of a controller by its name.
         * @param controllerName The name of the controller whose page is to be set.
         * @param pageName The name of the page to set as the current page.
         * @zh 根据名称设置控制器的当前页面。
         * @param controllerName 要设置页面的控制器名称。
         * @param pageName 要设置为当前页面的页面名称。
         */
        setPage(controllerName: string, pageName: string): void;
        /**
         * @en Sets the current page of a controller by its index.
         * @param controllerName The name of the controller whose page is to be set.
         * @param pageIndex The index of the page to set as the current page.
         * @zh 根据索引设置控制器的当前页面。
         * @param controllerName 要设置页面的控制器名称。
         * @param pageIndex 要设置为当前页面的页面索引。
         */
        setPage(controllerName: string, pageIndex: number): void;
        protected _controllersChanged(): void;
        /**
         * @en The gears of the widget.
         */
        get gears(): Array<Gear>;
        /** @internal */
        set gears(value: Array<Gear>);
        /** @internal */
        _addGears(value: Array<Gear>): void;
        /**
         * @en Adds a new gear to the widget.
         * @param value The gear to add to the widget.
         * @zh 向小部件添加一个新的齿轮。
         * @param value 要添加到小部件的齿轮。
         */
        addGear(value: Gear): void;
        /**
         * @en Removes a gear from the widget.
         * @param value The gear to remove from the widget.
         * @zh 从小部件中移除一个齿轮。
         * @param value 要从小部件中移除的齿轮。
         */
        removeGear(value: Gear): void;
        /**
         * @en Registers a click event listener for the widget. It is a shorthand for `on(Event.CLICK, thisObj, listener, args)`.
         * @param listener The function to be called when the click event occurs.
         * @zh 为小部件注册一个点击事件监听器。它是 `on(Event.CLICK, thisObj, listener, args)` 的简写。
         * @param listener 当点击事件发生时要调用的函数。
         * @blueprintIgnore
         */
        onClick(listener: Function): void;
        /**
         * @en Registers a click event listener for the widget. It is a shorthand for `on(Event.CLICK, thisObj, listener, args)`.
         * @param caller The context in which the listener function will be called.
         * @param listener The function to be called when the click event occurs.
         * @param args Optional. An array of arguments to be passed to the listener function when the event is triggered.
         * @zh 为小部件注册一个点击事件监听器。它是 `on(Event.CLICK, thisObj, listener, args)` 的简写。
         * @param caller 监听器函数将被调用的上下文。
         * @param listener 当点击事件发生时要调用的函数。
         * @param args 可选。一个数组，包含在事件触发时要传递给监听器函数的参数。
         * @blueprintIgnore
         */
        onClick(caller: any, listener: Function, args?: any[]): void;
        /**
         * @en Unregisters a click event listener for the widget. It is a shorthand for `off(Event.CLICK, caller, listener)`.
         * @param listener The function that was registered to handle the click event.
         * @zh 为小部件取消注册一个点击事件监听器。它是 `off(Event.CLICK, caller, listener)` 的简写。
         * @param listener 处理点击事件的函数。
         * @blueprintIgnore
         */
        offClick(listener: Function): void;
        /**
         * @en Unregisters a click event listener for the widget. It is a shorthand for `off(Event.CLICK, caller, listener)`.
         * @param caller The context in which the listener function was called.
         * @param listener The function that was registered to handle the click event.
         * @zh 为小部件取消注册一个点击事件监听器。它是 `off(Event.CLICK, caller, listener)` 的简写。
         * @param caller 监听器函数被调用的上下文。
         * @param listener 处理点击事件的函数。
         * @blueprintIgnore
         */
        offClick(caller: any, listener: Function): void;
        /** @ignore */
        destroy(): void;
        protected _sizeChanged(changeByLayout?: boolean): void;
        protected _childChanged(child?: Sprite): void;
        /** @ignore */
        _processVisible(): boolean;
        /**
         * @en Sets the layout changed flag for the widget.
         * @param reason Optional. The reason for the layout change, such as size, position, etc.
         * @zh 设置小部件的布局更改标志。
         * @param reason 可选。布局更改的原因，例如大小、位置等。
         */
        setLayoutChangedFlag(reason?: LayoutChangedReason): void;
        /** @internal */
        _onConstruct(inPrefab?: boolean): void;
        /**
         * @en Called when the widget is constructed.
         * This method is invoked after the widget is created and its properties are initialized.
         * @zh 当小部件被构造时调用。
         * 此方法在小部件创建并初始化其属性后调用。
         * @blueprintIgnore
         */
        onConstruct(): void;
        /** @ignore @blueprintIgnore */
        onAfterDeserialize(): void;
    }
    /**
     * @en GWindow is a widget that provides a window interface for displaying content.
     * @zh GWindow 是一个提供窗口界面的小部件，用于显示内容。
     * @blueprintInheritable
     */
    class GWindow extends GWidget {
        /**
         * @en Whether the window should be brought to the front when clicked.
         * @zh 是否在点击时将窗口带到前面。
         */
        bringToFontOnClick: boolean;
        private _contentPane;
        private _modalWaitPane;
        private _closeButton;
        private _dragArea;
        private _contentArea;
        private _frame;
        private _modal;
        private _inited;
        private _loading;
        private _requestingCmd;
        constructor();
        /**
         * @en The content pane of the window, which contains the main content to be displayed.
         * @zh 窗口的内容面板，包含要显示的主要内容。
         */
        get contentPane(): GWidget;
        set contentPane(value: GWidget);
        /**
         * @en The frame of the window.
         * @zh 窗口的框架。
         */
        get frame(): GWidget;
        /**
         * @en The button used to close the window.
         * @zh 用于关闭窗口的按钮。
         */
        get closeButton(): GWidget;
        set closeButton(value: GWidget);
        /**
         * @en The area of the window that can be dragged to move the window.
         * @zh 窗口中可以拖动以移动窗口的区域。
         */
        get dragArea(): GWidget;
        set dragArea(value: GWidget);
        /**
         * @en The area of the window that contains the main content.
         * @zh 窗口中包含主要内容的区域。
         */
        get contentArea(): GWidget;
        set contentArea(value: GWidget);
        /**
         * @en Shows the window, bringing it to the front if it is already displayed.
         * @zh 显示窗口，如果窗口已经显示，则将其带到前面
         */
        show(): void;
        /**
         * @en Hides the window, removing it from the display.
         * @zh 隐藏窗口，将其从显示中移除。
         */
        hide(): void;
        /**
         * @en Hides the window immediately without any animation.
         * @zh 立即隐藏窗口，不进行任何动画。
         */
        hideImmediately(): void;
        /**
         * @en Toggles the visibility of the window. If it is currently displayed, it will be hidden; if it is hidden, it will be shown.
         * @zh 切换窗口的可见性。如果当前显示，则隐藏；如果隐藏，则显示。
         */
        toggleStatus(): void;
        /**
         * @en Checks if the window is currently displayed.
         * @zh 检查窗口当前是否显示。
         */
        get isShowing(): boolean;
        /**
         * @en Checks if the window is the topmost window in the display hierarchy.
         * @zh 检查窗口是否是显示层次结构中的最上层窗口
         */
        get isTop(): boolean;
        /**
         * @en Indicates whether the window is modal, meaning it blocks interaction with other windows until it is closed.
         * @zh 指示窗口是否为模态窗口，即在关闭之前阻止与其他窗口的交互。
         */
        get modal(): boolean;
        set modal(val: boolean);
        /**
         * @en Brings the window to the front of the display list, making it the topmost window.
         * @zh 将窗口带到显示列表的前面，使其成为最上层窗口。
         */
        bringToFront(): void;
        /**
         * @en Shows a modal waiting pane, which blocks interaction with the window until it is closed.
         * @param requestingCmd Optional command ID that can be used to close the modal wait pane.
         * @zh 显示一个模态等待面板，在关闭之前阻止与窗口的交互。
         * @param requestingCmd 可选的命令ID，可用于关闭模态等待面板。
         */
        showModalWait(requestingCmd?: number): void;
        protected layoutModalWaitPane(): void;
        /**
         * @en Closes the modal wait pane if it is currently displayed.
         * @param requestingCmd Optional command ID that must match the one used to show the modal wait pane.
         * @zh 如果模态等待面板当前显示，则关闭它。
         * @param requestingCmd 可选的命令ID，必须与用于显示模态等待面板的命令ID匹配。
         */
        closeModalWait(requestingCmd?: number): boolean;
        /**
         * @en Checks if the modal wait pane is currently displayed.
         * @zh 检查模态等待面板当前是否显示。
         */
        get modalWaiting(): boolean;
        /**
         * @en Initializes the window. This method is called when the window is first shown.
         * It can be overridden to perform custom initialization logic.
         * @returns A promise that resolves when the initialization is complete.
         * @zh 初始化窗口。此方法在窗口首次显示时调用。
         * 可以重写此方法以执行自定义初始化逻辑。
         * @returns 一个在初始化完成时解析的 Promise。
         * @blueprintEvent
         */
        protected onInit(): void | Promise<void>;
        /**
         * @en Called when the window is shown. This method can be overridden to perform actions when the window becomes visible.
         * @zh 当窗口显示时调用。可以重写此方法以在窗口变为可见时执行操作。
         * @blueprintEvent
         */
        protected onShown(): void;
        /**
         * @en Called when the window is hidden. This method can be overridden to perform actions when the window is no longer visible.
         * @zh 当窗口隐藏时调用。可以重写此方法以在窗口不再可见时执行操作。
         * @blueprintEvent
         */
        protected onHide(): void;
        /**
         * @en Performs the show animation for the window. This method can be overridden to implement custom show animations.
         * @zh 执行窗口的显示动画。可以重写此方法以实现自定义显示动画。
         */
        protected doShowAnimation(): void;
        /**
         * @en Performs the hide animation for the window. This method can be overridden to implement custom hide animations.
         * @zh 执行窗口的隐藏动画。可以重写此方法以实现自定义隐藏动画。
         */
        protected doHideAnimation(): void;
        /** @ignore */
        destroy(): void;
        protected closeEventHandler(): void;
        private _onShown;
        private _onHidden;
        private _winTouchBegin;
        private _dragStart;
    }
    /** @ignore */
    class ImageRenderer {
        _meshFactory: IMeshFactory;
        _color: Color;
        _tex: Texture;
        _onReload: Function;
        private _owner;
        private _drawCmd;
        constructor(owner: Sprite);
        destroy(): void;
        setTexture(value: Texture): void;
        setMesh(value: IMeshFactory): void;
        setColor(value: string): void;
        private onTextureReload;
        private createCmd;
    }
    /**
     * @en Interface for Scroller component.
     * @zh Scroller 组件接口。
     */
    interface IScroller {
        /**
         * @en The owner panel of the scroller.
         * @zh Scroller 的拥有者面板。
         */
        get owner(): GPanel;
        set owner(value: GPanel);
        /**
         * @en The horizontal scroll bar of the scroller.
         * @zh Scroller 的水平滚动条。
         */
        get hScrollBar(): GScrollBar;
        get vScrollBar(): GScrollBar;
        /**
         * @en The header widget of the scroller.
         * @zh Scroller 的页头部件。
         */
        get header(): GWidget;
        /**
         * @en The footer widget of the scroller.
         * @zh Scroller 的页尾部件。
         */
        get footer(): GWidget;
        /**
         * @en The horizontal scroll bar resource.
         * @zh 水平滚动条资源。
         */
        get hScrollBarRes(): Prefab;
        set hScrollBarRes(value: Prefab);
        /**
         * @en The vertical scroll bar resource.
         * @zh 垂直滚动条资源。
         */
        get vScrollBarRes(): Prefab;
        set vScrollBarRes(value: Prefab);
        /**
         * @en The header resource.
         * @zh 页头资源。
         */
        get headerRes(): Prefab;
        set headerRes(value: Prefab);
        /**
         * @en The footer resource.
         * @zh 页尾资源。
         */
        get footerRes(): Prefab;
        set footerRes(value: Prefab);
        /**
         * @en The direction of the scroller.
         * @zh Scroller 的方向。
         */
        get direction(): ScrollDirection;
        set direction(value: ScrollDirection);
        /**
         * @en The display mode of the scroll bar. The global default value can be set through `UIConfig2.defaultScrollBarDisplay`.
         * @zh 滚动条的显示模式。全局的默认值可以通过`UIConfig2.defaultScrollBarDisplay`设置。
         */
        get barDisplay(): ScrollBarDisplay;
        set barDisplay(value: ScrollBarDisplay);
        /**
         * @en Whether the scroll bar is on the left side.
         * @zh 滚动条是否在左侧。
         */
        get barOnLeft(): boolean;
        set barOnLeft(value: boolean);
        /**
         * @en Whether the scroll bar is floating. Floating scroll bars do not occupy viewport space.
         * @zh 滚动条是否浮动。浮动的滚动条不占用视口空间。
         */
        get barFloating(): boolean;
        set barFloating(value: boolean);
        /**
         * @en The margin around the scroll bar.
         * @zh 滚动条周围的边距。
         */
        get barMargin(): Array<number>;
        set barMargin(value: Array<number>);
        /**
         * @en The bounce back effect of the scroller. Default value can be set globally through `UIConfig2.defaultScrollBounceEffect`.
         * @zh Scroller 的回弹效果。全局的默认值可以通过`UIConfig2.defaultScrollBounceEffect`设置。
         */
        get bouncebackEffect(): ScrollBounceBackEffect;
        set bouncebackEffect(value: ScrollBounceBackEffect);
        /**
         * @en The touch effect of the scroller. Default value can be set globally through `UIConfig2.defaultScrollTouchEffect`.
         * @zh Scroller 的触摸效果。全局的默认值可以通过`UIConfig2.defaultScrollTouchEffect`设置。
         */
        get touchEffect(): ScrollTouchEffect;
        set touchEffect(value: ScrollTouchEffect);
        /**
         * @en The touch effect for buttons in the scroller. Default value can be set globally through `UIConfig2.touchEffectButton`.
         * @zh 用于触摸拖动的鼠标按键，开启了touchEffect后有效。 0-左键，1-中键，2-右键。
         */
        get touchEffectButton(): number;
        set touchEffectButton(value: number);
        /**
         * @en Whether the scroller is in page mode.
         * @zh Scroller 是否处于分页模式。
         */
        get pageMode(): boolean;
        set pageMode(value: boolean);
        /**
         * @en The step size for scrolling when using the mouse wheel. The global default value can be set through `UIConfig2.defaultScrollStep`.
         * @zh 当使用鼠标滚轮滚动时，每次滚动的距离。全局的默认值可以通过`UIConfig2.defaultScrollStep`设置。
         */
        set step(value: number);
        get step(): number;
        /**
         * @en Whether to snap to the nearest item when scrolling.
         * @zh 滚动时是否对齐到最近的项。
         */
        get snapToItem(): boolean;
        set snapToItem(value: boolean);
        /**
         * @en Whether to disable inertia scrolling.
         * @zh 是否禁用惯性滚动。
         */
        get inertiaDisabled(): boolean;
        set inertiaDisabled(value: boolean);
        /**
         * @en Whether to disable padding mask. Generally, the viewport does not include the padding area set around it, meaning that the empty space around the container will also be clipped. If needed, this option can be checked to prevent clipping of the empty space around the container.
         * @zh 禁用裁剪边缘。一般情况下，视口不包括边缘设置的部分，也即是容器设置四周的留空部分也会被裁剪。如果需要，可以勾选这个选项，使容器四周的留空部分不被裁剪。
         */
        get paddingMaskDisabled(): boolean;
        set paddingMaskDisabled(value: boolean);
        /**
         * @en Whether to disable mouse wheel scrolling.
         * @zh 禁用鼠标滚轮滚动。
         */
        get mouseWheelDisabled(): boolean;
        set mouseWheelDisabled(value: boolean);
        /**
         * @en The deceleration rate of the scroller. The global default value can be set through `UIConfig2.defaultScrollDecelerationRate`.
         * @zh Scroller 的减速率。全局的默认值可以通过`UIConfig2.defaultScrollDecelerationRate`设置。
         */
        get decelerationRate(): number;
        set decelerationRate(value: number);
        /**
         * @en The percentage of the scroller's position in the x-direction. The value ranges from 0 to 1.
         * @zh Scroller 在 x 方向上的位置百分比。值范围是0到1。
         */
        get percX(): number;
        set percX(value: number);
        /**
         * @en Sets the percentage of the scroller's position in the x-direction.
         * @param value The percentage value, ranging from 0 to 1.
         * @param ani Whether to animate the change.
         * @zh 设置 Scroller 在 x 方向上的位置百分比。
         * @param value 百分比值，范围是0到1。
         * @param ani 是否使用动画过渡。
         */
        setPercX(value: number, ani?: boolean): void;
        /**
         * @en The percentage of the scroller's position in the y-direction. The value ranges from 0 to 1.
         * @zh Scroller 在 y 方向上的位置百分比。值范围是0到1。
         */
        get percY(): number;
        set percY(value: number);
        /**
         * @en Sets the percentage of the scroller's position in the y-direction.
         * @param value The percentage value, ranging from 0 to 1.
         * @param ani Whether to animate the change.
         * @zh 设置 Scroller 在 y 方向上的位置百分比。
         * @param value 百分比值，范围是0到1。
         * @param ani 是否使用动画过渡。
         */
        setPercY(value: number, ani?: boolean): void;
        /**
         * @en The x-coordinate of the top-left corner of the scroller's content.
         * @zh Scroller 内容的左上角 x 坐标。
         */
        get posX(): number;
        set posX(value: number);
        /**
         * @en Sets the x-coordinate of the top-left corner of the scroller's content.
         * @param value The x-coordinate value.
         * @param ani Whether to animate the change.
         * @zh 设置 Scroller 内容的左上角 x 坐标。
         * @param value x 坐标值。
         * @param ani 是否使用动画过渡。
         */
        setPosX(value: number, ani?: boolean): void;
        /**
         * @en The y-coordinate of the top-left corner of the scroller's content.
         * @zh Scroller 内容的左上角 y 坐标。
         */
        get posY(): number;
        set posY(value: number);
        /**
         * @en Sets the y-coordinate of the top-left corner of the scroller's content.
         * @param value The y-coordinate value.
         * @param ani Whether to animate the change.
         * @zh 设置 Scroller 内容的左上角 y 坐标。
         * @param value y 坐标值。
         * @param ani 是否使用动画过渡。
         */
        setPosY(value: number, ani?: boolean): void;
        /**
         * @en If the scroller is in page mode, returns the index of the current page in the x-direction.
         * @zh 如果 Scroller 处于分页模式，则返回水平方向上当前页的索引。
         */
        get pageX(): number;
        set pageX(value: number);
        /**
         * @en If the scroller is in page mode, sets the index of the current page in the y-direction.
         * @zh 如果 Scroller 处于分页模式，则设置垂直方向上当前页的索引。
         */
        get pageY(): number;
        set pageY(value: number);
        /**
         * @en Sets the index of the current page in the x-direction.
         * @param value The page index value.
         * @param ani Whether to animate the change.
         */
        setPageX(value: number, ani?: boolean): void;
        /**
         * @en Sets the index of the current page in the y-direction.
         * @param value The page index value.
         * @param ani Whether to animate the change.
         */
        setPageY(value: number, ani?: boolean): void;
        /**
         * @en The number of pages in the x-direction.
         * @zh Scroller 在水平方向上的页数。
         */
        get pageCountX(): number;
        /**
         * @en The number of pages in the y-direction.
         * @zh Scroller 在垂直方向上的页数。
         */
        get pageCountY(): number;
        /**
         * @en The width of the content area.
         * @zh Scroller 内容区域的宽度。
         */
        get contentWidth(): number;
        /**
         * @en The height of the content area.
         * @zh Scroller 内容区域的高度。
         */
        get contentHeight(): number;
        /**
         * @en The width of the viewport.
         * @zh Scroller 视口的宽度。
         */
        get viewWidth(): number;
        /**
         * @en The height of the viewport.
         * @zh Scroller 视口的高度。
         */
        get viewHeight(): number;
        /**
         * @en Sets the size of the viewport.
         * @param width The width of the viewport.
         * @param height The height of the viewport.
         * @zh 设置 Scroller 视口的大小。
         * @param width 视口的宽度。
         * @param height 视口的高度。
         */
        setViewSize(width: number, height: number): void;
        /**
         * @en Whether the scrolling has reached the bottom-most position.
         * @zh 是否已滚动到最底。
         */
        get isBottomMost(): boolean;
        /**
         * @en Whether the scrolling has reached the right-most position.
         * @zh 是否已滚动到最右侧。
         */
        get isRightMost(): boolean;
        /**
         * @en When no bounce occurs, the value is the same as posX; when a bounce occurs, posX is constrained between 0 and overlapSize.x, while scrollingPosX returns the actual position value.
         * @zh 当没有发生回弹时，返回值和posX一致；当发生回弹时，posX会被限制在0和overlapSize.x之间，而scrollingPosX会返回真实的位置值。
         */
        get scrollingPosX(): number;
        /**
         * @en When no bounce occurs, the value is the same as posY; when a bounce occurs, posY is constrained between 0 and overlapSize.y, while scrollingPosY returns the actual position value.
         * @zh 当没有发生回弹时，返回值和posY一致；当发生回弹时，posY会被限制在0和overlapSize.y之间，而scrollingPosY会返回真实的位置值。
         */
        get scrollingPosY(): number;
        /**
         * @en Scrolls to the top of the content area.
         * @param ani Whether to animate the scroll action.
         * @zh 滚动到内容区域的顶部。
         * @param ani 是否使用动画过渡。
         */
        scrollTop(ani?: boolean): void;
        /**
         * @en Scrolls to the bottom of the content area.
         * @param ani Whether to animate the scroll action.
         * @zh 滚动到内容区域的底部。
         * @param ani 是否使用动画过渡。
         */
        scrollBottom(ani?: boolean): void;
        /**
         * @en Scrolls up once, with the step size controlled by the ratio parameter.
         * @param ratio The ratio of the step size, ranging from 0 to 1, with a default value of 1. The base is the value of the `step` property, and if in page mode, the base is the height of the page.
         * @param ani Whether to use an animated transition, default is false.
         * @zh 向上滚动一次，步长由ratio参数控制。
         * @param ratio 步长的比例，范围是0到1，默认值为1。基数是`step`属性的值，如果在分页模式，则基数为页面的高度。
         * @param ani 是否使用动画过渡，默认值为false。
         */
        scrollUp(ratio?: number, ani?: boolean): void;
        /**
         * @en Scrolls down once, with the step size controlled by the ratio parameter.
         * @param ratio The ratio of the step size, ranging from 0 to 1, with a default value of 1. The base is the value of the `step` property    , and if in page mode, the base is the height of the page.
         * @param ani Whether to use an animated transition, default is false.
         * @zh 向下滚动一次，步长由ratio参数控制。
         * @param ratio 步长的比例，范围是0到1，默认值为1。基数是`step`属性的值，如果在分页模式，则基数为页面的高度。
         * @param ani 是否使用动画过渡，默认值为false。
         */
        scrollDown(ratio?: number, ani?: boolean): void;
        /**
         * @en Scrolls to the left once, with the step size controlled by the ratio parameter.
         * @param ratio The ratio of the step size, ranging from 0 to 1, with a default value of 1. The base is the value of the `step` property, and if in page mode, the base is the width of the page.
         * @param ani Whether to use an animated transition, default is false.
         * @zh 向左滚动一次，步长由ratio参数控制。
         * @param ratio 步长的比例，范围是0到1，默认值为1。基数是`step`属性的值，如果在分页模式，则基数为页面的宽度。
         * @param ani 是否使用动画过渡，默认值为false.
         */
        scrollLeft(ratio?: number, ani?: boolean): void;
        /**
         * @en Scrolls to the right once, with the step size controlled by the ratio parameter.
         * @param ratio The ratio of the step size, ranging from 0 to 1, with a default value of 1. The base is the value of the `step` property, and if in page mode, the base is the width of the page.
         * @param ani Whether to use an animated transition, default is false.
         * @zh 向右滚动一次，步长由ratio参数控制。
         * @param ratio 步长的比例，范围是0到1，默认值为1。基数是`step`属性的值，如果在分页模式，则基数为页面的宽度。
         * @param ani 是否使用动画过渡，默认值为false。
         */
        scrollRight(ratio?: number, ani?: boolean): void;
        /**
         * @en Scrolls to a specific target widget, with an option to animate the scroll action.
         * @param target The target widget to scroll to.
         * @param ani Whether to animate the scroll action, default is false.
         * @param setFirst If true, sets the target as the first child in view.
         * @zh 滚动到指定的目标部件，可以选择是否使用动画过渡。
         * @param target 要滚动到的目标部件。
         * @param ani 是否使用动画过渡，默认值为false。
         * @param setFirst 如果为true，则将目标设置为视图中的第一个子项。
         */
        scrollTo(target: GWidget, ani?: boolean, setFirst?: boolean): void;
        /**
         * @en Scrolls to a specific target rectangle, with an option to animate the scroll action.
         * @param target The target rectangle to scroll to.
         * @param ani Whether to animate the scroll action, default is false.
         * @param secondTarget If not null, sets it as the first child in view.
         * @zh 滚动到指定的目标矩形，可以选择是否使用动画过渡。
         * @param target 要滚动到的目标矩形。
         * @param ani 是否使用动画过渡，默认值为false。
         * @param secondTarget 如果不为空，则将它设置为视图中的第一个子项。
         */
        scrollTo(target: GWidget, ani?: boolean, secondTarget?: GWidget): void;
        /**
         * @en Scrolls to a specific target rectangle, with an option to animate the scroll action.
         * @param target The target rectangle to scroll to.
         * @param ani Whether to animate the scroll action, default is false.
         * @param setFirst If true, sets the target as the first child in view.
         * @zh 滚动到指定的目标矩形，可以选择是否使用动画过渡。
         * @param target 要滚动到的目标矩形。
         * @param ani 是否使用动画过渡，默认值为false。
         * @param setFirst 如果为true，则将目标设置为视图中的第一个子项。
         */
        scrollTo(target: Rectangle, ani?: boolean, setFirst?: boolean): void;
        /**
         * @en Scrolls to a child with specific index, with an option to animate the scroll action.
         * @param target The index of the child to scroll to.
         * @param ani Whether to animate the scroll action, default is false.
         * @param setFirst If true, sets the target as the first child in view.
         * @zh 滚动到指定索引的子项，可以选择是否使用动画过渡。
         * @param target 要滚动到的子项索引。
         * @param ani 是否使用动画过渡，默认值为false。
         * @param setFirst 如果为true，则将目标设置为视图中的第一个子项。
         */
        scrollTo(target: number, ani?: boolean, setFirst?: boolean): void;
        /**
         * @en Checks if a specific child widget is currently in view.
         * @param obj The child widget to check.
         * @returns Returns true if the child widget is in view, otherwise false.
         * @zh 检查指定的子部件是否在视图中。
         * @param obj 要检查的子部件。
         * @returns 如果子部件在视图中，则返回true，否则返回false。
         */
        isChildInView(obj: GWidget): boolean;
        /**
         * @en Gets the index of the first child widget that is currently in view.
         * @returns Returns the index of the first child widget in view, or -1 if no child is in view.
         * @zh 获取当前在视图中的第一个子部件的索引。
         * @returns 返回视图中第一个子部件的索引，如果没有子部件在视图中，则返回 -1。
         */
        getFirstChildInView(): number;
        /**
         * @en Whether the scroller is currently being dragged.
         * @returns Returns true if the scroller is being dragged, otherwise false.
         * @zh Scroller 是否正在被拖动。
         * @returns 如果 Scroller 正在被拖动，则返回 true，否则返回 false。
         */
        get isDragged(): boolean;
        /**
         * @en Cancels the current dragging operation.
         * @zh 取消当前的拖动操作。
         */
        cancelDragging(): void;
        /**
         * @en Locks the header widget, keeping it visible and fixed at the top during scrolling.
         * @param size The size of the header.
         * @zh 锁定页头部件，即使其显示，并在滚动时保持在顶部。
         * @param size 页头的大小。
         */
        lockHeader(size: number): void;
        /**
         * @en Locks the footer widget, keeping it visible and fixed at the bottom during scrolling.
         * @param size The size of the footer.
         * @zh 锁定页尾部件，即使其显示，并在滚动时保持在底部。
         * @param size 页尾的大小。
         */
        lockFooter(size: number): void;
        /** @internal */
        destroy(): void;
        /** @internal */
        _loop: number;
        /** @internal */
        _setDefaultDirection(): void;
        /** @internal */
        _ownerSizeChanged(): void;
        /** @internal */
        _ownerContentSizeChanged(): void;
        /** @internal */
        _shouldCheckOverflow(): number;
        /** @internal */
        _changeContentSizeOnScrolling(deltaWidth: number, deltaHeight: number, deltaPosX: number, deltaPosY: number): void;
        /** @internal */
        _updateScrollBarVisible(): void;
        /** @internal */
        _processClipping(): void;
        /** @internal */
        createHzScrollBar(force?: boolean): void;
        /** @internal */
        createVtScrollBar(force?: boolean): void;
    }
    interface ILayout {
        /**
         * @en The type of the layout.
         * @zh 布局的类型。
         */
        get type(): LayoutType;
        set type(value: LayoutType);
        /**
         * @en This option is only effective for FlowY layout type. If set to a value greater than 0, a new column will only be started when the number of items in each column reaches the specified value.
         * @zh 这个选项只对FlowY布局类型布局有效。如果设置了大于0的值，则每列的数量到达设定的值才会开启新的一列。
         */
        get rows(): number;
        set rows(value: number);
        /**
         * @en This option is only effective for FlowX layout type. If set to a value greater than 0, a new row will only be started when the number of items in each row reaches the specified value.
         * @zh 这个选项只对FlowX布局类型布局有效。如果设置了大于0的值，则每行的数量到达设定的值才会开启新的一行。
         */
        get columns(): number;
        set columns(value: number);
        /**
         * @en The gap between rows.
         * @zh 行间距。
         */
        get rowGap(): number;
        set rowGap(value: number);
        /**
         * @en The gap between columns.
         * @zh 列间距。
         */
        get columnGap(): number;
        set columnGap(value: number);
        /**
         * @zh 设定容器内部四个方向的留空。四个元素依次为[上，右，下，左]。
         * @en Set the padding for the four directions inside the container. The four elements are in the order of [UP, RIGHT, DOWN, LEFT].
         */
        get padding(): Array<number>;
        set padding(value: Array<number>);
        /**
         * @en The alignment of the layout.
         * @zh 布局的对齐方式。
         */
        get align(): AlignType;
        set align(value: AlignType);
        /**
         * @en The vertical alignment of the layout.
         * @zh 布局的垂直对齐方式。
         */
        get valign(): VAlignType;
        set valign(value: VAlignType);
        /**
         * @en The horizontal stretch mode of the layout.
         * @zh 在水平方向上的缩放操作。
         */
        get stretchX(): StretchMode;
        set stretchX(value: StretchMode);
        /**
         * @en The vertical stretch mode of the layout.
         * @zh 在垂直方向上的缩放操作。
         */
        get stretchY(): StretchMode;
        set stretchY(value: StretchMode);
        /**
         * @en The stretch parameters for the horizontal direction.
         * @zh 水平方向上的拉伸参数。
         */
        get stretchParamsX(): Array<StretchParam>;
        /**
         * @en The stretch parameters for the vertical direction.
         * @zh 垂直方向上的拉伸参数。
         */
        get stretchParamsY(): Array<StretchParam>;
        /**
         * @en If set to true, when an item is not visible (visible=false), it will not reserve space for it during layout, meaning the layout will ignore this item; if unchecked, it will reserve space for this item, resulting in a blank placeholder.
         * @zh 如果设置为true，当某个item不可见时（visible=false），布局时不会为他留位置，也就是排版时会忽略这个item；如果不勾选，则会为这个item保留位置，显示效果就是一个空白的占位。
         */
        get foldInvisibles(): boolean;
        set foldInvisibles(value: boolean);
        /**
         * @en The minimum size for child nodes. When automatically adjusting the size of child nodes based on layout parameters, it will not be smaller than this value. For example, if set to 30 and a node requires a width of 10 during layout, the final width of the node will be set to 30.
         * @zh 当根据布局参数自动改变子节点的大小时，不会小于这里设置的值。例如，如果这里设置了30，并且一个节点在排列时要求宽度为10，则节点最后的宽度会被设置为30。
         */
        get minChildSize(): number;
        set minChildSize(value: number);
        /**
         * @en Page mode.
         * @zh 分页模式。
         */
        get pageMode(): boolean;
        set pageMode(value: boolean);
        /**
         * @en The width of the view area.
         * @zh 视口区域的宽度。
         */
        get viewWidth(): number;
        set viewWidth(value: number);
        /**
         * @en The height of the view area.
         * @zh 视口区域的高度。
         */
        get viewHeight(): number;
        set viewHeight(value: number);
        /**
         * @en The width of the content area.
         * @zh 内容区域的宽度。
         */
        get contentWidth(): number;
        set contentWidth(value: number);
        /**
         * @en The height of the content area.
         * @zh 内容区域的高度。
         */
        get contentHeight(): number;
        set contentHeight(value: number);
        /**
         * @en Get the snapping position of the layout.
         * @param xValue The horizontal coordinate of the snapping position.
         * @param yValue The vertical coordinate of the snapping position.
         * @param xDir The horizontal direction of the snapping position, positive for right and negative for left.
         * @param yDir The vertical direction of the snapping position, positive for down and negative for up.
         * @param resultPoint The point object to store the result, if not provided, a new Point object will be created.
         * @returns The snapping position as a Point object.
         * @zh 获取对齐位置。
         * @param xValue 对齐位置的水平坐标。
         * @param yValue 对齐位置的垂直坐标。
         * @param xDir 对齐位置的水平方向，正数表示右移或者下移，负数表示左移或者上移。
         * @param yDir 对齐位置的垂直方向，正数表示下移或者右移，负数表示上移或者左移。
         * @param resultPoint 用于存储结果的点对象，如果未提供，将创建一个新的 Point 对象。
         * @returns 返回对齐位置的 Point 对象。
         */
        getSnappingPosition(xValue: number, yValue: number, xDir: number, yDir: number, resultPoint?: Point): Point;
        /**
         * @en Resize the container to fit specified child count and minimum size.
         * @param childCount The number of children to fit in the container.
         * @param minSize The minimum size for the container.
         * @zh 调整容器大小以适应指定的子节点数量和最小尺寸。
         * @param childCount 要适应容器的子节点数量。
         * @param minSize 容器的最小尺寸。
         */
        resizeToFit(childCount?: number, minSize?: number): void;
        /**
         * @en Notify the layout that any changes have occurred that require a layout update.
         * @param reason The reason for the layout change.
         * @zh 通知布局发生了任何需要更新布局的更改。
         * @param reason 布局更改的原因。
         */
        setChangedFlag(reason?: LayoutChangedReason): void;
        /**
         * @en Refresh the layout if necessary.
         * @param force Whether to force a refresh even if no changes have occurred.
         * @zh 如果需要，刷新布局。
         * @param force 是否强制刷新，即使没有发生更改。
         */
        refresh(force?: boolean): void;
        /** @internal */
        setContentSize(aw: number, ah: number): void;
        /** @internal */
        _disabled: boolean;
    }
    interface IListLayout extends ILayout {
        /**
         * @en Set the list item count.
         * If the list is not virtual, specified number of items will be created.
         * If the list is virtual, only items in view will be created.
         * @zh 设置列表项数量。
         * 如果列表不是虚拟的，将创建指定数量的项。
         * 如果列表是虚拟的，则只会创建视图中的项。
        */
        get numItems(): number;
        set numItems(value: number);
        /**
         * @en The virtual list automatically measures the size of child items for layout, but you can also manually set the size of child items.
         * @zh 虚拟列表会自动测量子项的大小用于排版。但也可以手动设置子项的大小。
         */
        get itemSize(): Point;
        set itemSize(value: Point);
        /**
         * @en Maps the index of the display object in the virtual list to the index of the data item.
         * @zh 虚拟列表中将显示对象的索引映射到数据项的索引。
         */
        childIndexToItemIndex(index: number): number;
        /**
         * @en Maps the index of the data item to the index of the display object.
         * @zh 数据项的索引映射到显示对象的索引。
         */
        itemIndexToChildIndex(index: number): number;
        /**
         * @en Gets the rectangle area of the data item at the specified index.
         * @zh 获取指定索引的数据项的矩形区域。
         */
        getRectByItemIndex(index: number): Rectangle;
        /**
         * @en Refresh the virtual list. Generally, there is no need to call this manually.
         * @zh 刷新虚拟列表。一般不需要手动调用。
         */
        refreshVirtualList(): void;
        /** @internal */
        _setVirtual(loop: boolean): void;
        /** @internal */
        readonly _virtual: boolean;
    }
    class Layout implements ILayout {
        protected _owner: GBox;
        protected _type: LayoutType;
        protected _rows: number;
        protected _columns: number;
        protected _rowGap: number;
        protected _columnGap: number;
        protected _stretchX: StretchMode;
        protected _stretchY: StretchMode;
        protected _pageMode: boolean;
        protected _layoutChanged: boolean;
        protected _padding: Array<number>;
        protected _align: AlignType;
        protected _valign: VAlignType;
        protected _foldInvisibles: boolean;
        protected _stretchParamsX: Array<StretchParam>;
        protected _stretchParamsY: Array<StretchParam>;
        protected _minChildSize: number;
        protected _childSizeChangedFlag: boolean;
        protected _contentWidth: number;
        protected _contentHeight: number;
        protected _refreshing: boolean;
        _disabled: boolean;
        constructor(owner: GBox);
        get type(): LayoutType;
        set type(value: LayoutType);
        get rows(): number;
        set rows(value: number);
        get columns(): number;
        set columns(value: number);
        get rowGap(): number;
        set rowGap(value: number);
        get columnGap(): number;
        set columnGap(value: number);
        get padding(): Array<number>;
        set padding(value: Array<number>);
        get align(): AlignType;
        set align(value: AlignType);
        get valign(): VAlignType;
        set valign(value: VAlignType);
        get stretchX(): StretchMode;
        set stretchX(value: StretchMode);
        get stretchY(): StretchMode;
        set stretchY(value: StretchMode);
        get stretchParamsX(): Array<StretchParam>;
        /** @internal */
        private set stretchParamsX(value);
        get stretchParamsY(): Array<StretchParam>;
        /** @internal */
        set stretchParamsY(value: Array<StretchParam>);
        get foldInvisibles(): boolean;
        set foldInvisibles(value: boolean);
        get minChildSize(): number;
        set minChildSize(value: number);
        get pageMode(): boolean;
        set pageMode(value: boolean);
        /**
         * dir正数表示右移或者下移，负数表示左移或者上移
         */
        getSnappingPosition(xValue: number, yValue: number, xDir: number, yDir: number, resultPoint?: Point): Point;
        setChangedFlag(reason?: LayoutChangedReason): void;
        refresh(force?: boolean): void;
        get viewWidth(): number;
        set viewWidth(value: number);
        get viewHeight(): number;
        set viewHeight(value: number);
        get contentWidth(): number;
        get contentHeight(): number;
        setContentSize(aw: number, ah: number): void;
        resizeToFit(childCount?: number, minSize?: number): void;
        protected applyNone(): void;
        private applyFlowX;
        private applyFlowY;
        protected getLayoutChildren(data: TempData): number;
        protected checkStretchParams(src: Array<StretchParam>, data: TempData): StretchParam[];
        protected handleStrecth(size: number, count: number, gap: number, params: Array<StretchParam>, sourceSizes: Array<number>, outSizes?: Array<number>): void;
        protected static refreshAllLayouts(caller?: GWidget): void;
    }
    class TempData {
        children: Array<GWidget>;
        invisibles: Array<number>;
        invisibleCnt: number;
        stretchParams: Array<StretchParam>;
        posx: Array<number>;
        posy: Array<number>;
        width: Array<number>;
        swidth: Array<number>;
        height: Array<number>;
        sheight: Array<number>;
    }
    class ListLayout extends Layout {
        _owner: GList;
        _virtual: boolean;
        _loop: boolean;
        _realNumItems: number;
        _lineItemCnt: number;
        _lineItemCnt2: number;
        _items: Array<ItemInfo>;
        private _numItems;
        private _itemSize;
        private _firstIndex;
        private _changed;
        private _eventLocked;
        private _itemInfoVer;
        private _itemSizes;
        private _offsetX;
        private _offsetY;
        get numItems(): number;
        set numItems(value: number);
        get itemSize(): Point;
        set itemSize(value: Point);
        /** @internal */
        _setVirtual(loop: boolean): void;
        childIndexToItemIndex(index: number): number;
        itemIndexToChildIndex(index: number): number;
        private shouldSnapToNext;
        getSnappingPosition(xValue: number, yValue: number, xDir: number, yDir: number, resultPoint?: Point): Point;
        getRectByItemIndex(index: number): Rectangle;
        setChangedFlag(reason?: LayoutChangedReason): void;
        refresh(force?: boolean): void;
        /** @internal */
        _checkVirtualList(): void;
        refreshVirtualList(): void;
        private getColumns;
        private getRows;
        private _refreshVirtualList;
        private _scrolled;
        private getIndexOnPos1;
        private getIndexOnPos2;
        private getIndexOnPos3;
        private getIndexOnPos4;
        private handleScroll;
        private handleScroll1;
        private handleScroll2;
        private handleScroll3;
        private handleScroll4;
    }
    interface ItemInfo {
        width: number;
        height: number;
        obj?: GWidget;
        flag: number;
        selected?: boolean;
    }
    /**
     * @blueprintIgnore
     */
    class PopupManager {
        private _owner;
        private _popupStack;
        private _justClosedPopups;
        private _tooltipWin;
        private _defaultTooltipWin;
        constructor(owner: GRoot);
        showPopup(popup: GWidget, target?: GWidget, dir?: PopupDirection): void;
        validatePopupPosition(popup: GWidget, target: GWidget, dir: PopupDirection, offsetX?: number, offsetY?: number): void;
        togglePopup(popup: GWidget, target?: GWidget, dir?: PopupDirection): boolean;
        hidePopup(popup?: GWidget): void;
        get hasAnyPopup(): boolean;
        isPopupJustClosed(popup: GWidget): boolean;
        private closePopup;
        showTooltips(msg: string, delay?: number): void;
        showTooltipsWin(tooltipWin: GWidget, delay?: number): void;
        private _doShowTooltips;
        hideTooltips(): void;
        checkPopups(): void;
        private _touchBegin;
    }
    /**
     * @blueprintable
     */
    class PopupMenu extends EventDispatcher {
        visibleItemCount: number;
        hideOnClickItem: boolean;
        autoSize: boolean;
        protected _content: GWidget;
        protected _list: GList;
        protected _initWidth: number;
        protected _seperatorRes: string;
        constructor(res?: string, seperatorRes?: string);
        destroy(): void;
        addItem(caption: string, callback?: Function, target?: any): GWidget;
        addItemAt(caption: string, index: number, callback?: Function, target?: any): GWidget;
        private createItem;
        addSeperator(index?: number): void;
        getItemName(index: number): string;
        setItemText(name: string, caption: string): void;
        setItemVisible(name: string, visible: boolean): void;
        setItemGrayed(name: string, grayed: boolean): void;
        setItemCheckable(name: string, checkable: boolean): void;
        setItemChecked(name: string, checked: boolean): void;
        isItemChecked(name: string): boolean;
        removeItem(name: string): boolean;
        clearItems(): void;
        get itemCount(): number;
        get contentPane(): GWidget;
        get list(): GList;
        show(target?: GWidget, dir?: PopupDirection, parentMenu?: PopupMenu): void;
        hide(): void;
        private _clickItem;
        /** @internal @blueprintEvent */
        PopupMenu_bpEvent: {
            [UIEvent.Popup]: () => void;
        };
    }
    class Relation {
        private _owner;
        private _target;
        private _data;
        private _tx;
        private _ty;
        private _tw;
        private _th;
        /** @internal */
        _sw: number;
        /** @internal */
        _sh: number;
        /** @internal */
        _isDisabled: boolean;
        constructor();
        get owner(): GWidget;
        set owner(value: GWidget);
        set target(value: GWidget | Scene);
        get target(): GWidget | Scene;
        get data(): Array<number>;
        set data(value: Array<number>);
        add(type: RelationType, percent: boolean): void;
        remove(type: RelationType): void;
        private setTarget;
        private unsetTarget;
        applyOnSelfResized(): void;
        private applyOnPosChanged;
        private applyOnSizeChanged;
        private posChanged;
        private sizeChanged;
        private instReload;
    }
    class Scroller implements IScroller {
        private _owner;
        private _layout;
        private _container;
        private _maskContainer;
        private _dir;
        private _step;
        private _decelerationRate;
        private _barMargin;
        private _barDisplay;
        private _barDisplay2;
        private _barOnLeft;
        private _barFloating;
        private _touchEffect;
        private _touchEffect2;
        private _bouncebackEffect;
        private _bouncebackEffect2;
        private _touchEffectButton;
        private _snapToItem;
        private _mouseWheelDisabled;
        private _pageMode;
        private _inertiaDisabled;
        private _paddingMaskDisabled;
        private _hScrollBarRes;
        private _vScrollBarRes;
        private _footerRes;
        private _headerRes;
        private _vScrollNone;
        private _hScrollNone;
        private _needRefresh;
        private _refreshBarAxis;
        private _xPos;
        private _yPos;
        private _viewSize;
        private _contentSize;
        private _overlapSize;
        private _pageSize;
        private _containerPos;
        private _beginTouchPos;
        private _slidingPoints;
        private _isHoldAreaDone;
        private _aniFlag;
        private _headerLockedSize;
        private _footerLockedSize;
        private _refreshEventDispatching;
        private _dragged;
        private _hover;
        private _cachedScrollRect;
        private _tweening;
        private _tweenTime;
        private _tweenDuration;
        private _tweenStart;
        private _tweenChange;
        private _hScrollBar;
        private _vScrollBar;
        private _header;
        private _footer;
        /** @internal */
        _loop: number;
        constructor();
        get owner(): GPanel;
        set owner(value: GPanel);
        destroy(): void;
        get hScrollBar(): GScrollBar;
        get vScrollBar(): GScrollBar;
        get header(): GWidget;
        get footer(): GWidget;
        get hScrollBarRes(): Prefab;
        set hScrollBarRes(value: Prefab);
        get vScrollBarRes(): Prefab;
        set vScrollBarRes(value: Prefab);
        get headerRes(): Prefab;
        set headerRes(value: Prefab);
        get footerRes(): Prefab;
        set footerRes(value: Prefab);
        get direction(): ScrollDirection;
        set direction(value: ScrollDirection);
        get barDisplay(): ScrollBarDisplay;
        set barDisplay(value: ScrollBarDisplay);
        get barOnLeft(): boolean;
        set barOnLeft(value: boolean);
        get barFloating(): boolean;
        set barFloating(value: boolean);
        get barMargin(): Array<number>;
        set barMargin(value: Array<number>);
        get bouncebackEffect(): ScrollBounceBackEffect;
        set bouncebackEffect(value: ScrollBounceBackEffect);
        get touchEffect(): ScrollTouchEffect;
        set touchEffect(value: ScrollTouchEffect);
        get touchEffectButton(): number;
        set touchEffectButton(value: number);
        get pageMode(): boolean;
        set pageMode(value: boolean);
        set step(value: number);
        get step(): number;
        get snapToItem(): boolean;
        set snapToItem(value: boolean);
        get inertiaDisabled(): boolean;
        set inertiaDisabled(value: boolean);
        get paddingMaskDisabled(): boolean;
        set paddingMaskDisabled(value: boolean);
        get mouseWheelDisabled(): boolean;
        set mouseWheelDisabled(value: boolean);
        get decelerationRate(): number;
        set decelerationRate(value: number);
        get isDragged(): boolean;
        get percX(): number;
        set percX(value: number);
        setPercX(value: number, ani?: boolean): void;
        get percY(): number;
        set percY(value: number);
        setPercY(value: number, ani?: boolean): void;
        get posX(): number;
        set posX(value: number);
        setPosX(value: number, ani?: boolean): void;
        get posY(): number;
        set posY(value: number);
        setPosY(value: number, ani?: boolean): void;
        get contentWidth(): number;
        get contentHeight(): number;
        get viewWidth(): number;
        get viewHeight(): number;
        setViewSize(width: number, height: number): void;
        get pageX(): number;
        set pageX(value: number);
        get pageY(): number;
        set pageY(value: number);
        setPageX(value: number, ani?: boolean): void;
        setPageY(value: number, ani?: boolean): void;
        get pageCountX(): number;
        get pageCountY(): number;
        get isBottomMost(): boolean;
        get isRightMost(): boolean;
        get scrollingPosX(): number;
        get scrollingPosY(): number;
        scrollTop(ani?: boolean): void;
        scrollBottom(ani?: boolean): void;
        scrollUp(ratio?: number, ani?: boolean): void;
        scrollDown(ratio?: number, ani?: boolean): void;
        scrollLeft(ratio?: number, ani?: boolean): void;
        scrollRight(ratio?: number, ani?: boolean): void;
        private getRect;
        scrollTo(target: GWidget, ani?: boolean, setFirst?: boolean): void;
        scrollTo(target: GWidget, ani?: boolean, secondTarget?: GWidget): void;
        scrollTo(rect: Rectangle, ani?: boolean, setFirst?: boolean): void;
        scrollTo(childIndex: number, ani?: boolean, setFirst?: boolean): void;
        isChildInView(obj: GWidget): boolean;
        getFirstChildInView(): number;
        cancelDragging(): void;
        _setDefaultDirection(): void;
        createVtScrollBar(force?: boolean): void;
        createHzScrollBar(force?: boolean): void;
        private createHeader;
        private createFooter;
        lockHeader(size: number): void;
        lockFooter(size: number): void;
        _shouldCheckOverflow(): number;
        _processClipping(): void;
        _ownerSizeChanged(): void;
        private onSizeChanged;
        _ownerContentSizeChanged(): void;
        _changeContentSizeOnScrolling(deltaWidth: number, deltaHeight: number, deltaPosX: number, deltaPosY: number): void;
        private onContentSizeChanged;
        private posChanged;
        private refresh;
        private refresh2;
        private _touchBegin;
        private _touchMove;
        private _touchEnd;
        private _mouseWheel;
        private _rollOver;
        private _rollOut;
        private updateScrollBarPos;
        _updateScrollBarVisible(): void;
        private updateScrollBarVisible2;
        private _barTweenComplete;
        private getLoopPartSize;
        private loopCheckingCurrent;
        private loopCheckingTarget;
        private loopCheckingTarget2;
        private loopCheckingNewPos;
        private alignPosition;
        private alignByPage;
        private updateTargetAndDuration;
        private fixDuration;
        private startTween;
        private killTween;
        private checkRefreshBar;
        private tweenUpdate;
        private runTween;
    }
    interface ISelection {
        /**
         * @en The selection mode of the selection.
         * @zh 选择的模式。
         */
        mode: SelectionMode;
        /**
         * @en Scroll the item into view when it is selected.
         * @zh 选择时滚动到视图中。
         */
        scrollItemToViewOnClick: boolean;
        /**
         * @en The currently selected item.
         * @zh 当前选中的项。
         */
        get index(): number;
        set index(value: number);
        /**
         * @en The currently selected items.
         * @param out An optional array to store the selected items.
         * @returns The currently selected items.
         * @zh 当前选中的项。
         * @param out 可选的数组，用于存储选中的项。
         * @returns 返回当前选中的项。
         */
        get(out?: number[]): number[];
        /**
         * @en Add an item to the selection.
         * @param index The index of the item to add.
         * @param scrollItToView Whether to scroll the item into view.
         * @zh 添加一个项到选择中。
         * @param index 要添加的项的索引。
         * @param scrollItToView 是否将该项滚动到视图中。
         */
        add(index: number, scrollItToView?: boolean): void;
        /**
         * @en Remove an item from the selection.
         * @param index The index of the item to remove.
         * @zh 从选择中移除一个项。
         * @param index 要移除的项的索引。
         */
        remove(index: number): void;
        /**
         * @en Clear the selection.
         * @zh 清除选择。
         */
        clear(): void;
        /**
         * @en Select all items.
         * @zh 选择所有项。
         */
        selectAll(): void;
        /**
         * @en Invert the selection.
         * @zh 反选。
         */
        selectReverse(): void;
        /**
         * @en Enable or disable focus events.
         * @param enabled Whether to enable focus events.
         * @zh 启用或禁用焦点事件。
         * @param enabled 是否启用焦点事件。
         */
        enableFocusEvents(enabled: boolean): void;
        /**
         * @en Enable or disable arrow key navigation.
         * @param enabled Whether to enable arrow key navigation.
         * @param keySelectEvent The event name to trigger when an item is selected using arrow keys.
         * @zh 启用或禁用箭头键导航。
         * @param enabled 是否启用箭头键导航。
         * @param keySelectEvent 使用箭头键选择项时触发的事件名称。
         */
        enableArrowKeyNavigation(enabled: boolean, keySelectEvent?: string): void;
        /** @ignore @blueprintIgnore */
        handleClick(item: GWidget, evt: Event): void;
        /** @ignore @blueprintIgnore */
        handleArrowKey(dir: number): number;
        /** @internal */
        destroy(): void;
        /** @internal */
        _refresh(): void;
    }
    interface ITreeSelection extends ISelection {
        /**
         * @en Whether to automatically expand or collapse the folder node when clicking on it.
         * @zh 点击文件夹节点时是否自动展开或者折叠这个这个节点。
         */
        get clickToExpand(): TreeClickToExpandType;
        set clickToExpand(value: TreeClickToExpandType);
        /**
         * @en Get the currently selected node.
         * @zh 获取当前选中的节点。
         */
        getSelectedNode(): GTreeNode;
        /**
         * @en Get the currently selected nodes.
         * @param out An optional array to store the selected nodes.
         * @returns The currently selected nodes.
         * @zh 获取当前选中的节点列表。
         * @param out 可选的数组，用于存储选中的节点。
         * @returns 返回当前选中的节点列表。
         */
        getSelectedNodes(out?: Array<GTreeNode>): Array<GTreeNode>;
        /**
         * @en Select a node in the tree.
         * @param node The node to select.
         * @param scrollItToView Whether to scroll the selected node into view.
         * @zh 选择树中的节点。
         * @param node 要选择的节点。
         * @param scrollItToView 是否将选中的节点滚动到视图中
         */
        selectNode(node: GTreeNode, scrollItToView?: boolean): void;
        /**
         * @en Unselect a node in the tree.
         * @param node The node to unselect.
         * @zh 取消选择树中的节点。
         * @param node 要取消选择的节点。
         */
        unselectNode(node: GTreeNode): void;
    }
    class ListSelection extends Selection {
        _owner: GList;
        _layout: ListLayout;
        constructor(owner: GList);
        get index(): number;
        set index(value: number);
        get(out?: number[]): number[];
        add(index: number, scrollItToView?: boolean): void;
        remove(index: number): void;
        clear(): void;
        protected clearExcept(g: GWidget): void;
        selectAll(): void;
        selectReverse(): void;
        handleClick(item: GButton, evt: Event): void;
        handleArrowKey(dir: number): number;
    }
    class Selection implements ISelection {
        scrollItemToViewOnClick: boolean;
        allowSelectByRightClick: boolean;
        protected _owner: GPanel;
        protected _mode: SelectionMode;
        protected _lastIndex: number;
        protected _triggerFocusEvents: boolean;
        protected _keyEvent: string;
        protected _controller: ControllerRef;
        constructor(owner: GPanel);
        get mode(): SelectionMode;
        set mode(value: SelectionMode);
        get index(): number;
        set index(value: number);
        get controller(): ControllerRef;
        set controller(value: ControllerRef);
        get(out?: number[]): number[];
        add(index: number, scrollItToView?: boolean): void;
        remove(index: number): void;
        clear(): void;
        protected clearExcept(g: GWidget): void;
        selectAll(): void;
        selectReverse(): void;
        enableFocusEvents(enabled: boolean): void;
        private handleFocus;
        handleClick(item: GButton, evt: Event): void;
        enableArrowKeyNavigation(enabled: boolean, keySelectEvent?: string): void;
        private _keydown;
        handleArrowKey(dir: number): number;
        private selectChanged;
        private syncController;
        _refresh(): void;
        destroy(): void;
    }
    class TreeSelection extends Selection implements ITreeSelection {
        _owner: GTree;
        private _clickToExpand;
        /** @internal */
        _expandedStatusInEvt: boolean;
        get clickToExpand(): TreeClickToExpandType;
        set clickToExpand(value: TreeClickToExpandType);
        getSelectedNode(): GTreeNode;
        getSelectedNodes(out?: Array<GTreeNode>): Array<GTreeNode>;
        selectNode(node: GTreeNode, scrollItToView?: boolean): void;
        unselectNode(node: GTreeNode): void;
        handleClick(item: GButton, evt: Event): void;
        handleArrowKey(dir: number): number;
    }
    /**
     * @en StretchParam is a class that defines stretch parameters for layout.
     * @zh StretchParam 是一个定义布局拉伸参数的类。
     */
    class StretchParam {
        /**
         * @en The ratio of stretch.
         * @zh 拉伸的比例。
         */
        ratio: number;
        /**
         * @en The priority of the stretch.
         * @zh 拉伸的优先级。
         */
        priority: number;
        /**
         * @en The minimum size for the stretch.
         * @zh 拉伸的最小尺寸。
         */
        min: number;
        /**
         * @en The maximum size for the stretch.
         * @zh 拉伸的最大尺寸。
         */
        max: number;
        /**
         * @en Whether the size is fixed.
         * @zh 是否固定大小。
         */
        fixed: boolean;
        /** @ignore */
        setRatio(value: number): this;
        /** @ignore */
        setPriority(value: number): this;
        /** @ignore */
        setLimit(min: number, max: number): this;
        /** @ignore */
        setFixed(): this;
    }
    /** @ignore */
    class TranslationsLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<Translations>;
    }
    type I18nTextInfo = {
        sid?: string;
        key?: string;
        text: string;
    };
    /**
     * @en Translations is a class that provides internationalization (i18n) support for applications.
     * @zh Translations 是一个为应用程序提供国际化 (i18n) 支持的类。
     */
    class Translations extends Resource {
        private _id2;
        private _t;
        private _lngs;
        private _fallbackLng;
        /**
         * @zh 获取或设置当前的国际化提供者。默认是一个简单的实现，如果需要高级功能，可以安装i18next，并设置到此属性。
         * @en Gets or sets the current i18n provider. The default is a simple implementation. If you need advanced features, you can install i18next and set it to this property.
         * @example
         * ```typescript
         * import i18next from "i18next";
         *
         * await i18next.init({...});
         *
         * Laya.Translations.provider = i18next;
         * ```
         */
        static provider: i18n;
        /** @internal */
        static _allInsts: Map<string, Translations>;
        /**
         * @en Gets the Translations instance by its ID.
         * @param id The ID of the Translations instance.
         * @returns The Translations instance associated with the given ID, or null if not found.
         * @zh 通过 ID 获取 Translations 实例。
         * @param id The ID of the Translations instance.
         * @returns 与给定 ID 关联的 Translations 实例，如果未找到则返回 null。
         */
        static getById(id: string): Translations | null;
        /**
         * @en Creates a new Translations instance with the specified ID and optional fallback language.
         * @param id The ID for the new Translations instance.
         * @param fallbackLng The fallback language to use if the specified language is not available.
         * @returns A new Translations instance.
         * @zh 创建一个新的 Translations 实例，指定 ID 和可选的回退语言。
         * @param id 新 Translations 实例的 ID。
         * @param fallbackLng 如果指定的语言不可用，则使用的回退语言。
         * @returns 一个新的 Translations 实例。
         */
        static create(id: string, fallbackLng?: string): Translations;
        /**
         * @en Translates the given text.
         * @param text The text to translate, which can be in the format "i18n:sid:key|text" or "i18n:key|text".
         * @param options Optional parameters for translation, such as variables to replace in the text.
         * @returns The translated text.
         * @zh 翻译给定的文本。
         * @param text 要翻译的文本，可以是 "i18n:sid:key|text" 或 "i18n:key|text" 格式。
         * @param options 可选的翻译参数，例如要替换文本中的变量。
         * @returns 翻译后的文本。
         */
        static translate(text: string, options?: Record<string, any>): string;
        /**
         * @en Decodes an i18n text string into its components.
         * @param text The i18n text string to decode, which should be in the format "i18n:sid:key|text" or "i18n:key|text".
         * @param out Optional output object to store the decoded information. If not provided, a new object will be created.
         * @returns An object containing the decoded information, with properties `sid`, `key`, and `text`.
         * @zh 将 i18n 文本字符串解码为其组件。
         * @param text 要解码的 i18n 文本字符串，应该是 "i18n:sid:key|text" 或 "i18n:key|text" 格式。
         * @param out 可选的输出对象，用于存储解码的信息。如果未提供，将创建一个新对象。
         * @returns 包含解码信息的对象，具有 `sid`、`key` 和 `text` 属性。
         */
        static decodeI18nText(text: string, out?: I18nTextInfo): I18nTextInfo;
        /**
         * @en Encodes an i18n text object into a string.
         * @param info The i18n text information object containing `sid`, `key`, and `text` properties.
         * @param newText Optional new text to replace the existing text in the i18n text object. If not provided, the existing text will be used.
         * @returns A string in the format "i18n:sid:key|text" or "i18n:key|text", depending on whether `sid` is present.
         * @zh 将 i18n 文本对象编码为字符串。
         * @param info 包含 `sid`、`key` 和 `text` 属性的 i18n 文本信息对象。
         * @param newText 可选的新文本，用于替换 i18n 文本对象中的现有文本。如果未提供，将使用现有文本。
         * @returns 格式为 "i18n:sid:key|text" 或 "i18n:key|text" 的字符串，具体取决于是否存在 `sid`。
         */
        static encodeI18nText(info: I18nTextInfo, newText?: string): string;
        protected constructor(id: string, fallbackLng?: string);
        /**
         * @en Gets the ID of this Translations instance.
         * @zh 获取此 Translations 实例的 ID。
         */
        get id(): number;
        /**
         * @en Sets the content for a specific language in this Translations instance.
         * @param lng The language code for which the content is being set. If not provided, the current language of the i18n provider will be used.
         * @param content The content to set for the specified language, which should be an object containing key-value pairs for translations.
         * @returns The Translations instance itself for method chaining.
         * @zh 为此 Translations 实例设置特定语言的内容。
         * @param lng 要设置内容的语言代码。如果未提供，将使用 i18n 提供者的当前语言。
         * @param content 要为指定语言设置的内容，应该是一个包含翻译键值对的对象。
         * @returns Translations 实例本身，以便进行方法链调用。
         */
        setContent(lng: string, content: any): this;
        /**
         * @en Translates the given name using the current language and options.
         * @param name The name of the translation key to look up. It can be a simple key or a namespaced key in the format "namespace:key".
         * @param defaultValue Optional default value to return if the translation key is not found. If provided, it will be returned as a fallback.
         * @returns The translated string. If the translation key is not found, the default value will be returned if provided, otherwise the key itself will be returned.
         * @zh 使用当前语言和选项翻译给定的名称。
         * @param name 要查找的翻译键的名称。可以是简单键或格式为 "namespace:key" 的命名空间键。
         * @param defaultValue 可选的默认值，如果未找到翻译键，将返回该默认值。如果提供，将作为后备返回。
         * @returns 翻译后的字符串。如果未找到翻译键，将返回默认值（如果提供），否则返回键本身
         */
        t(name: string, defaultValue?: string): string;
        /**
         * @en Translates the given name using the current language and options.
         * @param name The name of the translation key to look up. It can be a simple key or a namespaced key in the format "namespace:key".
         * @param options Optional parameters for translation, such as variables to replace in the text.
         * @returns The translated string. If the translation key is not found, the default value will be returned if provided, otherwise the key itself will be returned.
         * @zh 使用当前语言和选项翻译给定的名称。
         * @param name 要查找的翻译键的名称。可以是简单键或格式为 "namespace:key" 的命名空间键。
         * @param options 可选的翻译参数，例如要替换文本中的变量。
         * @returns 翻译后的字符串。如果未找到翻译键，将返回默认值（如果提供），否则返回键本身。
         */
        t(name: string, options: Record<string, any>): string;
        /**
         * @en Translates the given name using the current language and options.
         * @param name The name of the translation key to look up. It can be a simple key or a namespaced key in the format "namespace:key".
         * @param defaultValue Optional default value to return if the translation key is not found. If provided, it will be returned as a fallback.
         * @param options Optional parameters for translation, such as variables to replace in the text.
         * @returns The translated string. If the translation key is not found, the default value will be returned if provided, otherwise the key itself will be returned.
         * @zh 使用当前语言和选项翻译给定的名称。
         * @param name 要查找的翻译键的名称。可以是简单键或格式为 "namespace:key" 的命名空间键。
         * @param defaultValue 可选的默认值，如果未找到翻译键，将返回该默认值。如果提供，将作为后备返回。
         * @param options 可选的翻译参数，例如要替换文本中的变量。
         * @returns 翻译后的字符串。如果未找到翻译键，将返回默认值（如果提供），否则返回键本身。
         */
        t(name: string, defaultValue: string, options: Record<string, any>): string;
        protected _disposeResource(): void;
    }
    /**
     * @blueprintable
     */
    class UIConfig2 {
        /**
         * @en Resource using in Window.ShowModalWait for locking the window.
         * @zh 在Window.ShowModalWait中使用的资源，用于锁定窗口。
         */
        static windowModalWaiting: string;
        /**
         * @en Resource using in GRoot.ShowModalWait for locking the screen.
         * @zh 在GRoot.ShowModalWait中使用的资源，用于锁定屏幕。
         */
        static globalModalWaiting: string;
        /**
         * @en When a modal window is in front, the background becomes dark.
         * @zh 当模态窗口在前面时，背景变暗。
         */
        static modalLayerColor: string;
        /**
         * @en Default horizontal scrollbar resource.
         * @zh 默认水平滚动条资源。
         */
        static horizontalScrollBar: string;
        /**
         * @en Default horizontal scrollbar resource.
         * @zh 默认水平滚动条资源。
         */
        static verticalScrollBar: string;
        /**
         * @en Scrolling step in pixels
         * @zh 滚动步长（以像素为单位）
         */
        static defaultScrollStep: number;
        /**
         * @en Deceleration ratio of scrollview when its in touch dragging.
         * @zh 滚动视图在触摸拖动时的减速比率。
         */
        static defaultScrollDecelerationRate: number;
        /**
         * @en Default scrollbar display mode. Recommened visible for Desktop and Auto for mobile.
         * @zh 默认滚动条显示模式。推荐桌面使用Visible，移动端使用Auto。
         */
        static defaultScrollBarDisplay: number;
        /**
         * @en Allow dragging the content to scroll. Recommeded true for mobile.
         * @zh 允许拖动内容进行滚动。推荐在移动端使用true。
         */
        static defaultScrollTouchEffect: boolean;
        /**
         * @en The "rebound" effect in the scolling container. Recommeded true for mobile.
         * @zh 滚动容器中的“回弹”效果。推荐在移动端使用true。
         */
        static defaultScrollBounceEffect: boolean;
        /**
         * @en When the scroll container is set to "snap to item", this is the threshold for determining which item to snap to.
         * @zh 当滚动容器设置为“贴近ITEM”时，判定贴近到哪一个ITEM的滚动距离阀值。
         */
        static defaultScrollSnappingThreshold: number;
        /**
         * @en When the scroll container is set to "page mode", this is the threshold for determining which page to scroll to.
         * @zh 当滚动容器设置为“页面模式”时，判定翻到哪一页的滚动距离阀值。
         */
        static defaultScrollPagingThreshold: number;
        /**
         * @en Resources for PopupMenu.
         * @zh 弹出菜单的资源。
         */
        static popupMenu: string;
        /**
         * @en Resources for seperator of PopupMenu.
         * @zh 弹出菜单分隔符的资源。
         */
        static popupMenuSeperator: string;
        /**
         * @en Resources for tooltips.
         * @zh 工具提示的资源。
         */
        static tooltipsWidget: string;
        /**
         * @en Default delay in milliseconds before showing tooltips.
         * @zh 显示工具提示之前的默认延迟（以毫秒为单位）。
         */
        static defaultTooltipsShowDelay: number;
        /**
         * @en Max items displayed in combobox without scrolling.
         * @zh 下拉框中不滚动时显示的最大项目数。
         */
        static defaultComboBoxVisibleItemCount: number;
        /**
         * @en Pixel offsets of finger to trigger scrolling.
         * @zh 触发滚动的手指像素偏移量。
         */
        static touchScrollSensitivity: number;
        /**
         * @en Pixel offsets of finger to trigger dragging.
         * @zh 触发拖动的手指像素偏移量。
         */
        static touchDragSensitivity: number;
        /**
         * @en Pixel offsets of mouse pointer to trigger dragging.
         * @zh 鼠标指针触发拖动的像素偏移量。
         */
        static clickDragSensitivity: number;
        /**
         * @en When click the window, brings to front automatically.
         * @zh 点击窗口时自动将其置于前面。
         */
        static bringWindowToFrontOnClick: boolean;
    }
    /** @blueprintable */
    enum UIEvent {
        /**
         * @en A container with a layout, when the content size of the container changes, the container will emit this event.
         * @zh 一个具有布局的容器，当容器的内容大小发生改变时，容器会发出该事件。
         */
        ContentSizeChanged = "content_size_changed",
        /**
         * @en When the controller list changes, this event will be triggered
         * @zh 当控制器列表发生变化时，会触发该事件
         */
        ControllersChanged = "controllers_changed",
        /**
         * @en When the scroll container scrolls, this event will be triggered
         * @zh 在滚动容器滚动时，会发出此事件
         */
        Scroll = "scroll",
        /**
         * @en When the scroll container scrolls end, this event will be triggered
         * @zh 当滚动容器滚动结束时，会发出此事件
         */
        ScrollEnd = "scroll_end",
        /**
         * @en 'pull_down_release' is emitted when the user releases the touch at the end of the pull-down refresh
         * @zh 'pull_down_release' 事件在下拉刷新结束时被触发
         */
        PullDownRelease = "pull_down_release",
        /**
         * @en 'pull_up_release' is emitted when the user releases the touch at the end of the pull-up refresh
         * @zh 'pull_up_release' 事件在上拉刷新结束时被触发
         */
        PullUpRelease = "pull_up_release",
        /**
         * @en 'click_item' is emitted when the user clicks the list item
         * @zh 'click_item' 事件在用户点击列表项目时被触发
         */
        ClickItem = "click_item",
        /**
         * @en 'popup' is emitted when a popup menu or a drop-down list is displayed
         * @zh 'popup' 事件在显示弹出菜单或下拉列表时被触发
         */
        Popup = "popup",
        /**
         * @en  'instance_reload' is emitted when the instance is reloaded
         * @zh  'instance_reload' 事件在实例重新加载时被触发
         */
        InstanceReload = "instance_reload"
    }
    /**
     * @ignore @blueprintable
     */
    class UIPackage {
        static createButton(): GButton;
        static createRadio(): GButton;
        static createCheckBox(): GButton;
        static createProgressBar(): GProgressBar;
        static createSliderH(): GSlider;
        static createSliderV(): GSlider;
        static createTextInput(): GTextInput;
        static createTextArea(): GTextInput;
        static createComboBox(): GComboBox;
        /** @internal */
        static _init(): Promise<void>;
    }
    /** @ignore */
    class WidgetPool {
        private _items;
        private _count;
        private _defaultRes;
        private _defaultRuntime;
        private _createOptions;
        constructor();
        clear(): void;
        get count(): number;
        get defaultRes(): Prefab;
        set defaultRes(value: Prefab);
        get defaultRuntime(): Function;
        set defaultRuntime(value: Function);
        take(url?: string): GWidget;
        recover(obj: GWidget): void;
    }
    /** @ignore */
    class WidgetRef {
        p: GWidget;
        private _callback;
        static create(oldVal: WidgetRef, target: GWidget, callback: () => void): WidgetRef;
        constructor(val: GWidget, callback: () => void);
        destroy(): void;
        private _reload;
    }
    /**
     * @en A utility class for Base64 encoding and decoding operations.
     * @zh Base64 编码和解码操作的实用工具类。
     */
    class Base64Tool {
        /**
         * @en The character set used for Base64 encoding.
         * @zh 用于 Base64 编码的字符集。
         */
        static chars: string;
        /**
         * @en Regular expression for validating Base64 encoded strings, including data URIs.
         * @zh 用于验证 Base64 编码字符串（包括数据 URI）的正则表达式。
         */
        static reg: RegExp;
        /**
         * @en Regular expression for matching the header of a data URI.
         * @zh 用于匹配数据 URI 头部的正则表达式。
         */
        static reghead: RegExp;
        /**
         * @en Use a lookup table to find the index.
         * @zh 使用查找表查找索引。
         */
        static lookup: Uint8Array;
        /**
         * @en Initializes the lookup table for Base64 decoding.
         * @zh 初始化用于 Base64 解码的查找表。
         */
        static init(): void;
        /**
         * @en Determines if a string is a base64 encoded string.
         * @param str The string to check.
         * @zh 判断字符串是否是 base64 编码的字符串。
         * @param str 需要检查的字符串。
         */
        static isBase64String(str: string): boolean;
        /**
         * @en Encodes an ArrayBuffer to a base64 string.
         * @param arraybuffer The ArrayBuffer to encode.
         * @zh 对 ArrayBuffer 进行编码，返回 base64 字符串。
         * @param arraybuffer 需要编码的 ArrayBuffer。
         */
        static encode(arraybuffer: ArrayBuffer): string;
        /**
         * @en Decodes a base64 string to an ArrayBuffer.
         * @param base64 The base64 string to decode.
         * @zh 对 base64 字符串进行解码，返回 ArrayBuffer。
         * @param base64 需要解码的 base64 字符串。
         */
        static decode(base64: string): ArrayBuffer;
    }
    /**
     * @en Browser is a browser proxy class. Encapsulate some of the features provided by the browser and native JavaScript.
     * @zh Browser 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
     * @blueprintable
     */
    class Browser {
        /**
         * @en Browser proxy information.
         * @zh 浏览器代理信息。
         * @readonly
         */
        static userAgent: string;
        /**
         * @en Indicates whether the current environment is a mobile device, including iOS and Android devices.
         * @zh 表示当前环境是否为移动设备，包括 iOS 和 Android 设备。
         * @readonly
         */
        static onMobile: boolean;
        /**
         * @en Indicates whether the current environment is within an iOS device.
         * @zh 表示当前环境是否在 IOS 设备内。
         * @readonly
         */
        static onIOS: boolean;
        /**
         * @en Indicates whether the current environment is a Mac device.
         * @zh 表示当前环境是否为 Mac 设备。
         * @readonly
         */
        static onMac: boolean;
        /**
         * @en Indicates whether the current environment is within an iPhone.
         * @zh 表示当前环境是否在 iPhone 内。
         * @readonly
         */
        static onIPhone: boolean;
        /**
         * @en Indicates whether the current environment is within an iPad.
         * @zh 表示当前环境是否在 iPad 内。
         * @readonly
         */
        static onIPad: boolean;
        /**
         * @en Indicates whether the current environment is within an Android device.
         * @zh 表示当前环境是否在 Android 设备内。
         * @readonly
         */
        static onAndroid: boolean;
        /**
         * @en Indicates whether the current environment is within an OpenHarmonyOS device.
         * @zh 表示当前环境是否在 OpenHarmonyOS 设备内。
         * @readonly
         */
        static onOpenHarmonyOS: boolean;
        /**
         * @en Indicates whether the current environment is within a Windows Phone device.
         * @zh 表示当前环境是否在 Windows Phone 设备内。
         * @readonly
         */
        static onWP: boolean;
        /**
         * @en Indicates whether the current environment is within the QQ browser.
         * @zh 表示当前环境是否在 QQ 浏览器内。
         * @readonly
         */
        static onQQBrowser: boolean;
        /**
         * @en Indicates whether the current environment is within the mobile QQ or QQ browser.
         * @zh 表示当前环境是否在移动 QQ 或 QQ 浏览器内。
         * @readonly
         */
        static onMQQBrowser: boolean;
        /**
         * @en Indicates whether the current environment is within Safari.
         * @zh 表示当前环境是否在 Safari 内。
         * @readonly
         */
        static onSafari: boolean;
        /**
         * @en Indicates whether the current environment is within Chrome.
         * @zh 表示当前环境是否在 Chrome 内。
         * @readonly
         */
        static onChrome: boolean;
        /**
         * @en Indicates whether the current environment is within the Internet Explorer browser.
         * @zh 表示当前环境是否在 Internet Explorer 浏览器内。
         * @readonly
         */
        static onIE: boolean;
        /**
         * @en Indicates whether the current environment is within WeChat.
         * @zh 表示当前环境是否在微信内。
         * @readonly
         */
        static onWeiXin: boolean;
        /**
         * @en Indicates whether the current environment is a PC.
         * @zh 表示当前环境是否为 PC。
         * @readonly
         */
        static onPC: boolean;
        /**
         * @deprecated
         */
        static onMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a WeChat mini-game.
         * @zh 表示当前环境是否是微信小游戏。
         * @readonly
         */
        static onWXMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Baidu mini-game.
         * @zh 表示当前环境是否是百度小游戏。
         * @readonly
         */
        static onBDMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Xiaomi mini-game.
         * @zh 表示当前环境是否是小米小游戏。
         * @readonly
         */
        static onKGMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is an OPPO mini-game.
         * @zh 表示当前环境是否是 OPPO 小游戏。
         * @readonly
         */
        static onQGMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a VIVO mini-game.
         * @zh 表示当前环境是否是 vivo 小游戏。
         * @readonly
         */
        static onVVMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is an Alipay mini-game.
         * @zh 表示当前环境是否是支付宝小游戏。
         * @readonly
         */
        static onAlipayMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a QQ mini-game on mobile.
         * @zh 表示当前环境是否是手机 QQ 小游戏。
         * @readonly
         */
        static onQQMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a BILIBILI mini-game.
         * @zh 表示当前环境是否是 BILIBILI 小游戏。
         * @readonly
         */
        static onBLMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a TikTok (Douyin) mini-game.
         * @zh 表示当前环境是否是抖音小游戏。
         * @readonly
         */
        static onTTMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Huawei mini-game.
         * @zh 表示当前环境是否是华为快游戏。
         * @readonly
         */
        static onHWMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is a Taobao mini-game.
         * @zh 表示当前环境是否是淘宝小游戏。
         * @readonly
         */
        static onTBMiniGame: boolean;
        /**
         * @en Indicates whether the current environment is the Firefox browser.
         * @zh 表示当前环境是否是 Firefox 浏览器。
         * @readonly
         */
        static onFirefox: boolean;
        /**
         * @en Indicates whether the current environment is the Edge browser.
         * @zh 表示当前环境是否是 Edge 浏览器。
         * @readonly
         */
        static onEdge: boolean;
        /**
         * @en Indicates whether the current environment is running on LayaAir Native Runtime.
         * @zh 表示当前环境是否运行在 LayaAir Native Runtime。
         * @readonly
         */
        static onLayaRuntime: boolean;
        /**
         * @en Indicates whether the current environment is running in a development tool.
         * @zh 表示当前环境是否运行在开发工具中。
         * @readonly
         */
        static onDevTools: boolean;
        /**
         * @en The actual platform type, OnMobile and others are determined through UserAgent, which may be faked.
         * @zh 真实平台类型，onMobile等是通过UserAgent判断，可能具有欺骗性
         * @readonly
         */
        static platform: number;
        /**
         * @en The readable name of the platform.
         * @zh 平台的可读名称。
         * @readonly
         */
        static platformName: string;
        /**
         * @en PC platform.
         * @zh PC 平台。
         */
        static readonly PLATFORM_PC = 0;
        /**
         * @en Android platform.
         * @zh Android 平台。
         */
        static readonly PLATFORM_ANDROID = 1;
        /**
         * @en iOS platform.
         * @zh iOS 平台。
         */
        static readonly PLATFORM_IOS = 2;
        /**
         * @en Indicates whether the environment supports touch input.
         * @zh 表示环境是否支持触摸输入。
         * @readonly
         */
        static isTouchDevice: boolean;
        /**
         * @en Indicates whether the environment supports high-performance mode on iOS devices.
         * @zh 表示环境是否支持 iOS 设备的高性能模式。
         * @readonly
         */
        static isIOSHighPerformanceMode: boolean;
        /**
         * @en Indicates whether the environment supports high-performance+ mode on iOS devices.
         * @zh 表示环境是否支持 iOS 设备的高性能+模式。
         * @readonly
         */
        static isIOSHighPerformanceModePlus: boolean;
        /**
         * @en Indicates whether the environment supports DOM.
         * @zh 表示环境是否支持 DOM。
         * @readonly
         */
        static isDomSupported: boolean;
        /**
         * @en The version of the system.
         * @zh 系统版本。
         * @readonly
         */
        static systemVersion: string;
        /**
         * @en The version of the Platform SDK.
         * @zh 平台 SDK 版本。
         * @readonly
         */
        static SDKVersion: string;
        /**
         * @en The global canvas.
         * @zh 全局画布。
         * @readonly
         */
        static mainCanvas: HTMLCanvas;
        /**
         * @en The global offscreen canvas, used primarily for measuring text and obtaining image data.
         * @zh 全局离屏画布，主要用来测量文本和获取图像数据。
         * @readonly
         */
        static canvas: HTMLCanvas;
        /**
         * @en The rendering context of the global offscreen canvas.
         * @zh 全局离屏画布上绘图的环境。
         * @readonly
         */
        static context: CanvasRenderingContext2D;
        /**
         * @en The loaded bundles.
         * @zh 已载入的脚本集。
         * @blueprintIgnore
         */
        static readonly bundles: Map<string, any>;
        /**
         * @readonly
         */
        static window: Window & typeof globalThis;
        /**
         * @readonly
         */
        static document: Document;
        private static _clientWidth;
        private static _clientHeight;
        /**
         * @en Creates a native browser element of the specified type.
         * @param tagName The type of node to create.
         * @return A reference to the created node object.
         * @zh 创建指定类型的浏览器原生节点。
         * @param tagName 要创建的节点类型。
         * @return 创建的节点对象的引用。
         * @blueprintIgnore
         */
        static createElement<K extends keyof HTMLElementTagNameMap>(tagName: K): HTMLElementTagNameMap[K];
        /**
         * @deprecated
         */
        static getElementById(id: string): any;
        /**
         * @deprecated
         */
        static removeElement(ele: any): void;
        /**
         * @en Gets the current timestamp in milliseconds since the epoch. It is equivalent to `performance.now()`.
         * @zh 获取浏览器当前时间戳，单位为毫秒。等同于 `performance.now()`。
         */
        static now(): number;
        /**
         * @en The viewport width of the browser window.
         * The method analyzes the browser information to determine the width, with a priority given to `window.innerWidth` (includes scrollbar width) > `document.body.clientWidth` (does not include scrollbar width).
         * If the former is 0 or undefined, the latter is chosen.
         * @zh 浏览器窗口的可视宽度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，
         * 如果前者为 0 或未定义，则选择后者。
         */
        static get clientWidth(): number;
        /**
         * @en Sets the viewport width of the browser window.
         * @zh 设置浏览器窗口的可视宽度。
         * @blueprintIgnore
         */
        static set clientWidth(value: number);
        /**
         * @en The viewport height of the browser window.
         * The method analyzes the browser information to determine the height, with a priority given to `window.innerHeight` (includes scrollbar height) > `document.body.clientHeight` (excluding scrollbar height) > `document.documentElement.clientHeight` (both do not include scrollbar height).
         * If the former is 0 or undefined, it falls back to the latter.
         * @zh 浏览器窗口的可视高度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight，
         * 如果前者为 0 或未定义，则选择后者。
         */
        static get clientHeight(): number;
        /**
         * @en Sets the viewport height of the browser window.
         * @zh 设置浏览器窗口的可视高度。
         * @blueprintIgnore
         */
        static set clientHeight(value: number);
        /**
         * @en The physical width of the browser window, taking into account the device pixel ratio.
         * @zh 浏览器窗口的物理宽度，考虑了设备像素比。
         */
        static get width(): number;
        /**
         * @en The physical height of the browser window, taking into account the device pixel ratio.
         * @zh 浏览器窗口的物理高度，考虑了设备像素比。
         */
        static get height(): number;
        /**
         * @en The device pixel ratio of the current environment.
         * @zh 当前环境的设备像素比。
         */
        static get pixelRatio(): number;
        /**
         * @en The canvas container that holds the canvas element, facilitating control over the canvas.
         * @zh 用来存放画布元素的容器，方便对画布进行控制。
         */
        static get container(): HTMLElement;
        /**
         * @en Gets the value of a URL parameter.
         * @param name The name of the parameter.
         * @return The value of the parameter.
         * @zh 获取 URL 参数的值。
         * @param name 参数的名称。
         * @return 参数的值。
         */
        static getQueryString(name: string): string;
        /**
         * @en Dynamically loads a JavaScript library from the specified source.
         * @zh 从指定源动态加载 JavaScript 库。
         */
        static loadLib(src: string, async?: boolean): Promise<void>;
    }
    /**
     * @en The Byte class provides methods and properties for optimizing the reading, writing, and handling of binary data. The Byte class is suitable for advanced developers who need to access data at the byte level.
     * @zh Byte 类提供用于优化读取、写入以及处理二进制数据的方法和属性。Byte 类适用于需要在字节层访问数据的高级开发人员。
     */
    class Byte {
        /**
         * @en Host byte order, which represents the two different sequences in which a CPU can store data: little-endian and big-endian. Use getSystemEndian to obtain the byte order of the current system.
         * BIG_ENDIAN byte order: The lower address stores, the higher bits of the value, and the higher address stores the lower bits. It is sometimes referred to as network byte order.
         * LITTLE_ENDIAN byte order: The lower address stores, the lower bits of the value, and the higher address stores the higher bits.
         * @zh 主机字节序，是 CPU 存放数据的两种不同顺序：小端字节序和大端字节序。使用 getSystemEndian 获取当前系统的字节序。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN： 小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         */
        static readonly BIG_ENDIAN: string;
        /**
         * @en Host byte order, which represents the two different sequences in which a CPU can store data: little-endian and big-endian. Use getSystemEndian to obtain the byte order of the current system.
         * LITTLE_ENDIAN byte order: The lower address stores the lower bits of the value, and the higher address stores the higher bits.
         * BIG_ENDIAN byte order: The lower address stores the higher bits of the value, and the higher address stores the lower bits. It is sometimes referred to as network byte order.
         * @zh 主机字节序，是 CPU 存放数据的两种不同顺序：小端字节序和大端字节序。使用 getSystemEndian 获取当前系统的字节序。
         * LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         */
        static readonly LITTLE_ENDIAN: string;
        /** 是否为小端数据。*/
        protected _xd_: boolean;
        protected _allocated_: number;
        protected _d_: DataView;
        protected _u8d_: Uint8Array;
        protected _pos_: number;
        protected _length: number;
        private static _sysEndian;
        /**
         * @en Get the byte order of the current host.
         * The host byte order refers to the two different sequences in which a CPU stores data, which includes little-endian and big-endian.
         * BIG_ENDIAN: Big-endian byte order, where the lower address stores the higher bits of the value, and the higher address stores the lower bits. It is sometimes also called network byte order.
         * LITTLE_ENDIAN: Little-endian byte order, where the lower address stores the lower bits of the value, and the higher address stores the higher bits.
         * @returns The byte order of the current system.
         * @zh 获取当前主机的字节序。
         * 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。
         * BIG_ENDIAN：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         * @return 当前系统的字节序。
         */
        static getSystemEndian(): string;
        /**
         * @en Constructor method.
         * @param data Specifies the number of elements for initialization, or a TypedArray object or ArrayBuffer object for initialization. If null, allocate a certain amount of memory in advance. When available space is not enough, use this part of the memory first, and reallocate the required memory if it is still not enough.
         * @zh 构造方法
         * @param data 用于指定初始化的元素数目，或者用于初始化的TypedArray对象、ArrayBuffer对象。如果为 null ，则预分配一定的内存空间，当可用空间不足时，优先使用这部分内存，如果还不够，则重新分配所需内存。
         */
        constructor(data?: any);
        /**
         * @en The ArrayBuffer data of this object, which contains only the valid data part.
         * @zh 此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
         */
        get buffer(): ArrayBuffer;
        /**
         * @en Gets the ArrayBuffer reference of this object.
         * @zh 获取此对象的 ArrayBuffer 引用。
         */
        get rawBuffer(): ArrayBuffer;
        /**
         * @en The byte order of the `Byte` instance. Possible values are `BIG_ENDIAN` or `LITTLE_ENDIAN`.
         * The host byte order is one of two sequences used by the CPU to store data, which includes little-endian and big-endian byte orders.The current system's byte order can be obtained using `getSystemEndian`.
         * `BIG_ENDIAN`: Big-endian byte order, where the lower memory address stores the higher-order bits of a number, and is sometimes referred to as network byte order.
         * `LITTLE_ENDIAN`: Little-endian byte order, where the lower memory address stores the lower-order bits of a number.
         * @zh `Byte` 实例的字节序。取值为 `BIG_ENDIAN` 或 `LITTLE_ENDIAN`。
         * 主机字节序是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。可以通过 `getSystemEndian` 获取当前系统的字节序。
         * BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
         * LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
         */
        get endian(): string;
        set endian(value: string);
        /**
         * @en The length of the `Byte` object, measured in bytes.
         * When setting the length to a value greater than the current length, the byte array is right-padded with zeros. If the length is set to a value less than the current length, the byte array is truncated.
         * If the length to be set exceeds the current allocated memory space, the memory is reallocated to the larger of either the new length or twice the current allocated length, and the original data is copied to the new memory space. If the length to be set is less than the current allocated memory space, the memory is reallocated to the new length, and the original data is truncated from the beginning to fit the new length.
         * @zh `Byte` 对象的长度（以字节为单位）。
         * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。
         * 如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。
         */
        set length(value: number);
        get length(): number;
        private _resizeBuffer;
        /**
         * @en Commonly used to parse a byte stream in a fixed format.
         * First, read a `Uint16` value from the current byte offset of the byte stream, and then read a string of this length.
         * @returns The read string.
         * @zh 常用于解析固定格式的字节流。
         * 先从字节流的当前字节偏移位置处读取一个 `Uint16` 值，然后以此值为长度，读取此长度的字符串。
         * @return 读取的字符串
         */
        readString(): string;
        private readTypedArray;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Float32Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Float32Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Float32Array` 对象并返回此对象。
         * @param start 开始位置。
         * @param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return 读取的 Float32Array 对象。
         */
        readFloat32Array(start: number, len: number): Float32Array;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates a `Uint8Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Uint8Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Uint8Array` 对象并返回此对象。
         * @param start 开始位置。
         * @param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return 读取的 Uint8Array 对象。
         */
        readUint8Array(start: number, len: number): Uint8Array;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates an `Int8Array` object from the data.
         * @param start The starting position.
         * @param len The number of bytes to read. If the length to be read exceeds the readable range, only the values within the readable range are returned.
         * @returns The read `Int8Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Int8Array` 对象并返回此对象。
         * @param start 开始位置。
         * @param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return 读取的 Int8Array 对象。
         */
        readInt8Array(start: number, len: number): Int8Array;
        /**
         * @en Reads a number of bytes specified by the `len` parameter from the byte stream starting at the position indicated by the `start` parameter, and creates an `Int16Array` object from the data.
         * @param start The byte offset from the start of the stream to begin reading.
         * @param len The number of bytes to read. Only values within the readable range are returned if the length exceeds the range.
         * @returns The created `Int16Array` object.
         * @zh 从字节流中 `start` 参数指定的位置开始，读取 `len` 参数指定的字节数的数据，用于创建一个 `Int16Array` 对象并返回此对象。
         * @param start	开始读取的字节偏移量位置。
         * @param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return 读取的 Uint8Array 对象。
         */
        readInt16Array(start: number, len: number): Int16Array;
        /**
         * @en Reads a 32-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 32-bit floating-point number.
         * @zh 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
         * @return 单精度（32 位）浮点数。
         */
        readFloat32(): number;
        /**
         * @en Reads a 64-bit floating-point number from the current position in the byte stream using IEEE 754 format.
         * @returns The 64-bit floating-point number.
         * @zh 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
         * @return 双精度（64 位）浮点数。
         */
        readFloat64(): number;
        /**
         * @en Writes an IEEE 754 single-precision (32-bit) floating point number to the byte stream at the current position.
         * @param value The single-precision (32-bit) floating point number to be written.
         * @zh 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
         * @param value 需要写入的单精度（32 位）浮点数。
         */
        writeFloat32(value: number): void;
        /**
         * @en Writes an IEEE 754 double-precision (64-bit) floating point number to the byte stream at the current position.
         * @param value  The double-precision (64-bit) floating point number to be written.
         * @zh 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
         * @param value  需要写入的双精度（64 位）浮点数。
         */
        writeFloat64(value: number): void;
        /**
         * @en Reads an Int32 value from the current position in the byte stream.
         * @returns The Int32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int32 值。
         * @returns 读取的 Int32 值。
         */
        readInt32(): number;
        /**
         * @en Reads a Uint32 value from the current position in the byte stream.
         * @returns The Uint32 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
         * @returns 读取的 Uint32 值。
         */
        readUint32(): number;
        /**
         * @en Writes the specified Int32 value to the byte stream at the current position.
         * @param value The Int32 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
         * @param value 需要写入的 Int32 值。
         */
        writeInt32(value: number): void;
        /**
         * @en Writes the specified Uint32 value to the byte stream at the current position.
         * @param value The Uint32 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入 Uint32 值。
         * @param value 需要写入的 Uint32 值。
         */
        writeUint32(value: number): void;
        /**
         * @en Reads an Int16 value from the current byte offset in the byte stream.
         * @returns The Int16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Int16 值。
         * @returns 读取的 Int16 值。
         */
        readInt16(): number;
        /**
         * @en Reads a Uint16 value from the current byte offset in the byte stream.
         * @returns The Uint16 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
         * @returns 读取的 Uint16 值。
         */
        readUint16(): number;
        /**
         * @en Writes the specified Uint16 value to the byte stream at the current byte offset.
         * @param value The Uint16 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
         * @param value 需要写入的 Uint16 值。
         */
        writeUint16(value: number): void;
        /**
         * @en Writes the specified Int16 value to the byte stream at the current byte offset.
         * @param value The Int16 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
         * @param value 需要写入的 Int16 值。
         */
        writeInt16(value: number): void;
        /**
         * @en Reads a Uint8 value from the current byte offset in the byte stream.
         * @returns The Uint8 value that was read.
         * @zh 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
         * @returns 读取的 Uint8 值。
         */
        readUint8(): number;
        /**
         * @en Writes the specified Uint8 value to the byte stream at the current byte offset.
         * @param value The Uint8 value to be written.
         * @zh 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
         * @param value 需要写入的 Uint8 值。
         */
        writeUint8(value: number): void;
        /**
         * @internal
         * @en Reads six values using getFloat32() and returns a Matrix object created from those values.
         * @returns The Matrix object that was created.
         * @zh 使用 getFloat32() 读取六个值，并创建返回一个 Matrix 对象。
         * @returns 创建的 Matrix 对象。
         */
        _getMatrix(): Matrix;
        /**
         * @internal
         * @en Reads six values using getFloat32() and returns a Matrix object created from those values.
         * @returns The Matrix object that was created.
         * @zh 使用 getFloat32() 读取六个值，并创建返回一个 Matrix 对象。
         * @returns 创建的 Matrix 对象。
         */
        _readMatrix(): Matrix;
        /**
         * 读取指定长度的 UTF 型字符串。
         * @param len 需要读取的长度。
         * @return 读取的字符串。
         */
        private _rUTF;
        /**
         * @en Reads a string of the specified length.
         * @param len The length of the string to read.
         * @returns The string of the specified length.
         * @zh 读取指定长度的字符串。
         * @param len 要读取的字符串的长度。
         * @returns 指定长度的字符串。
         */
        readCustomString(len: number): string;
        /**
         * @en The current position of the Byte object's read/write pointer (in bytes).
         * When reading, the next read operation will start at this position. When writing, the next write operation will start at this position.
         * @zh Byte对象的读写指针的当前位置（以字节为单位）。
         * 下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
         */
        get pos(): number;
        set pos(value: number);
        /**
         * @en The number of bytes available to read from the current position to the end of the byte stream.
         * @zh 从当前位置到字节流末尾可读取的数据的字节数。
         */
        get bytesAvailable(): number;
        /**
         * @en Clears the content of the byte array and resets the length and pos properties to 0. Calling this method will release the memory occupied by the Byte instance.
         * @zh 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
         */
        clear(): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. Similar to the writeUTF() method, but writeUTFBytes() does not prefix the string with a 16-bit length word.
         * The corresponding reading method is getUTFBytes.
         * @param value The string to write.
         * @zh 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字节为字符串添加前缀。
         * 对应的读取方法为： getUTFBytes 。
         * @param value 要写入的字符串。
         */
        writeUTFBytes(value: string): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. First, the length of the UTF-8 string in bytes is written (as a 16-bit integer), followed by the bytes representing the string characters.
         * The corresponding reading method is getUTFString.
         * @param value The string value to write.
         * @zh 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
         * 对应的读取方法为： getUTFString 。
         * @param value 要写入的字符串值。
         */
        writeUTFString(value: string): void;
        /**
         * @en Writes a UTF-8 string to the byte stream. First, the length of the UTF-8 string in bytes is written (as a 32-bit integer), followed by the bytes representing the string characters.
         * @param value The string value to write.
         * @zh 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 32 位整数），然后写入表示字符串字符的字节。
         * @param value 要写入的字符串值。
         */
        writeUTFString32(value: string): void;
        /**
         * @en Reads a UTF-8 string.
         * @returns The read string.
         * @zh 读取 UTF-8 字符串。
         * @returns 读取的字符串。
         */
        readUTFString(): string;
        /**
         * @en Reads a UTF-8 string that was written with the writeUTFString32() method.
         * @zh 读取由 writeUTFString32() 方法写入的 UTF-8 字符串。
         */
        readUTFString32(): string;
        /**
         * @en Reads a string that must have been written with the writeUTFBytes method.
         * @param len The length of the buffer to read. If set to -1, all data in the buffer will be read.
         * @returns The read string.
         * @zh 读字符串，必须是 writeUTFBytes 方法写入的字符串。
         * @param len 要读的buffer长度，默认将读取缓冲区全部数据。如果设置为 -1，则读取缓冲区中的所有数据。
         * @returns 读取的字符串。
         */
        readUTFBytes(len?: number): string;
        /**
         * @en Writes a byte to the byte stream. Only the lower 8 bits of the parameter are used. The higher 24 bits are ignored.
         * @param value The byte to write (0-255).
         * @zh 在字节流中写入一个字节。只使用参数的低 8 位。忽略高 24 位。
         * @param value 要写入的字节（0-255）。
         */
        writeByte(value: number): void;
        /**
         * @en Reads a signed byte from the byte stream. The return value is in the range of -128 to 127.
         * @returns An integer between -128 and 127.
         * @zh 从字节流中读取带符号的字节。返回值的范围是从 -128 到 127。
         * @returns 介于 -128 和 127 之间的整数。
         */
        readByte(): number;
        protected _ensureWrite(lengthToEnsure: number): void;
        /**
         * @en Writes a byte sequence from the specified arraybuffer object into the byte stream, starting at the offset and with the specified length.
         * If the length parameter is omitted, the default length of 0 is used, and the method writes the entire buffer from the offset, if the offset is also omitted, the entire buffer is written.
         * The function will throw an exception if the offset or length is less than 0.
         * @param arraybuffer The ArrayBuffer object to write from.
         * @param offset The offset index of the ArrayBuffer object (in bytes).
         * @param length The length to write from the ArrayBuffer object into the Byte object (in bytes).
         * @zh 将指定 arraybuffer 对象中的以 offset 为起始偏移量，length 为长度的字节序列写入字节流。
         * 如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。
         * 如果 offset 或 length 小于0，本函数将抛出异常。
         * @param arraybuffer 需要写入的 Arraybuffer 对象。
         * @param offset Arraybuffer 对象的索引的偏移量（以字节为单位）。
         * @param length 从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）。
         */
        writeArrayBuffer(arraybuffer: ArrayBufferLike, offset?: number, length?: number): void;
        /**
         * @en Reads an ArrayBuffer of the specified length from the byte stream.
         * @param length The length of the ArrayBuffer to read.
         * @zh 读取ArrayBuffer数据，长度由参数指定。
         * @param length 要读取的ArrayBuffer的长度。
         */
        readArrayBuffer(length: number): ArrayBuffer;
        /** @deprecated */
        __getBuffer(): ArrayBuffer;
        /** @deprecated */
        getByte(): number;
        /** @deprecated */
        getUint8(): number;
        /** @deprecated */
        getInt16(): number;
        /** @deprecated */
        getUint16(): number;
        /** @deprecated */
        getInt32(): number;
        /** @deprecated */
        getUint32(): number;
        /** @deprecated */
        getFloat32(): number;
        /** @deprecated */
        getFloat64(): number;
        /** @deprecated */
        getUint8Array(start: number, len: number): Uint8Array;
        /** @deprecated */
        getInt16Array(start: number, len: number): Int16Array;
        /** @deprecated */
        getFloat32Array(start: number, len: number): Float32Array;
        /** @deprecated */
        getUTFString(): string;
        /** @deprecated */
        getString(): string;
        /** @deprecated */
        getCustomString(len: number): string;
        /** @deprecated */
        getUTFBytes(len?: number): string;
    }
    /**
     * @en The ClassUtils is a utility class for class operations.
     * @zh ClassUtils 是一个类工具的类。
     */
    class ClassUtils {
        static _classMap: Record<string, any>;
        static _runtimeMap: Record<string, Function>;
        /**
         * @en Registers a class mapping for easy retrieval during class reflection.
         * @param className The name or alias for the class mapping.
         * @param classDef The full name of the class or a reference to the class.
         * @zh 注册 Class 映射，方便在类反射时获取。
         * @param className 映射的名字或者别名。
         * @param classDef 类的全名或者类的引用，全名比如："laya.Sprite"。
         */
        static regClass(className: string, classDef: any): void;
        /**
         * @en Returns the class object based on the class name.
         * @param className The class name (e.g., "laya.display.Sprite") or a registered alias (e.g., "Sprite").
         * @return The class object.
         * @zh 根据类名返回类对象。
         * @param className 类名（比如 "laya.display.Sprite"）或者注册的别名（比如 "Sprite"）。
         * @return 类对象。
         */
        static getClass(className: string): any;
        /**
         * @en Registers a runtime class.
         * @param url The url of the prefab.
         * @param cls The class definition.
         * @zh 动态注册一个runtime类。
         * @param url prefab的url。
         * @param cls 类定义。
         */
        static regRuntime(url: string, cls: Function): void;
        /**
         * @en Get runtime class by prefab url.
         * @param url The url of the prefab.
         * @returns The class definition.
         * @zh 通过 prefab url 获取 runtime 类。
         * @param url prefab的url。
         * @return 类定义。
         */
        static getRuntime(url: string): Function;
    }
    /**
     * @en The ColorUtils is a class for color value processing.
     * @zh ColorUtils 是一个用于处理颜色值的类。
     */
    class ColorUtils {
        private static _SAVE;
        private static _SAVE_SIZE;
        /**
         * @en An array representing the color in RGBA format, Value range 0-1
         * @zh 以 RGBA 格式表示颜色的数组，取值范围0-1
         */
        arrColor: number[];
        /**
         * @en The string representation of the color value.
         * @zh 字符串型颜色值。
         */
        strColor: string;
        /**
         * @en The uint representation of the color value.
         * @zh uint 型颜色值。
         */
        numColor: number;
        /**
         * @internal
        */
        _drawStyle: any;
        /**
         * @en Constructor method.
         * @param value The color value, which can be a string (e.g., "#ff0000") or a hexadecimal color (e.g., 0xff0000).
         * @zh 构造方法
         * @param value 颜色值，可以是字符串（例如 "#ff0000"）或16进制颜色值（例如 0xff0000）。
         */
        constructor(value: string | number);
        /**
         * @en Clears the cache if it gets too large.
         * @zh 如果缓存太大，则清理缓存。
         */
        private static _initSaveMap;
        /**
         * @en Creates and returns an instance of the Color class based on the specified color value.
         * @param value The color value, which can be a string (e.g., "#ff0000") or a hexadecimal color (e.g., 0xff0000).
         * @returns An instance of the Color class.
         * @zh 根据指定的颜色值创建并返回一个 Color 类的实例，可以是字符串（例如 "#ff0000"）或16进制颜色值（例如 0xff0000）。
         * @param value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
         * @returns Color 类的一个实例。
         */
        static create(value: string | number): ColorUtils;
    }
    /**
     * @en Delegate class for managing and invoking callbacks
     * This class provides functionality to add, remove, and invoke callback functions.
     * It supports one-time callbacks and can manage callbacks with different targets and arguments.
     * @zh Delegate类，用于管理和调用回调函数
     * 这个类提供了添加、移除和调用回调函数的功能。
     * 它支持一次性回调，并且可以管理具有不同目标对象和参数的回调函数。
     */
    class Delegate {
        private _flag;
        private _items;
        constructor();
        /**
         * @en Add a callback function
         * @param callback The callback function
         * @param target The target object of the callback
         * @param args Arguments for the callback
         * @zh 添加回调函数
         * @param callback 回调函数
         * @param target 回调函数的目标对象
         * @param args 回调函数的参数
         */
        add(callback: Function, target?: any, args?: any[]): void;
        /**
         * @en Add a callback function that will only be executed once
         * @param callback The callback function
         * @param target The target object of the callback
         * @param args Arguments for the callback
         * @zh 添加只执行一次的回调函数
         * @param callback 回调函数
         * @param target 回调函数的目标对象
         * @param args 回调函数的参数
         */
        once(callback: Function, target?: any, args?: any[]): void;
        /**
         * @en Remove a callback function
         * @param callback The callback function to remove
         * @param target The target object of the callback
         * @zh 移除回调函数
         * @param callback 要移除的回调函数
         * @param target 回调函数的目标对象
         */
        remove(callback: Function, target?: any): void;
        /**
         * @en Clear all callback functions
         * @zh 清除所有回调函数
         */
        clear(): void;
        /**
          * @en Clear all callback functions for a specific target
          * @param target The target object
          * @zh 清除指定目标对象的所有回调函数
          * @param target 目标对象
          */
        clearForTarget(target: any): void;
        /**
         * @en Get the number of callback functions
         * @zh 获取回调函数的数量
         */
        get count(): number;
        /**
         * @en Invoke all callback functions
         * @param args Arguments for the invocation
         * @zh 调用所有回调函数
         * @param args 调用参数
         */
        invoke(...args: any[]): void;
    }
    /**
     * @en The `DragSupport` class is a touch sliding control.
     * @zh `DragSupport` 类是触摸滑动控件。
     * @blueprintable
     */
    class DragSupport {
        /**
         * @en The object being dragged.
         * @zh 被拖动的对象。
         */
        readonly target: Sprite;
        /**
         * @en The damping ratio for easing.
         * @zh 缓动衰减系数。
         */
        ratio: number;
        /**
         * @en The maximum offset per frame.
         * @zh 单帧最大偏移量。
         */
        maxOffset: number;
        /**
         * @en The area within which dragging is restricted. Its coordinates are in the coordinate space of the target's parent node.
         * @zh 拖动限制范围。它的坐标是在target的父节点的坐标空间。
         */
        area: Rectangle;
        /**
         * @en Indicates whether the dragging has inertia.
         * @zh 表示拖动是否有惯性。
         */
        hasInertia: boolean;
        /**
         * @en The maximum elastic distance.
         * @zh 橡皮筋最大值。
         */
        elasticDistance: number;
        /**
         * @en The time for elastic back in milliseconds.
         * @zh 橡皮筋回弹时间，单位为毫秒。
         */
        elasticBackTime: number;
        /**
         * @en Indicates whether to automatically start dragging when the mouse is pressed.
         * @zh 表示鼠标按下时是否自动开始拖拽。
         */
        autoStart: boolean;
        private _testing;
        private _dragging;
        private _touchId;
        private _elasticRateX;
        private _elasticRateY;
        private _points;
        private _tween;
        private _data;
        /** @blueprintIgnore */
        constructor(owner: Sprite);
        get dragging(): boolean;
        /**
         * @en Start dragging.
         * @param data (Optional) The data to be passed to the event handler.
         * @zh 开始拖拽。
         * @param data (可选) 要传递给事件处理程序的数据。
         */
        start(data?: any): void;
        private reset;
        /**
         * @en Stop dragging
         * @zh 停止拖拽。
         */
        stop(): void;
        private onMouseDown;
        private onMouseMove;
        private onMouseUp;
        private moveTarget;
        private checkArea;
        /**
         * 橡皮筋效果检测。
         */
        private checkElastic;
        private tweenMove;
        private clear;
        /**
         *
         * @param points
         * @param max
         * @returns
         * @blueprintIgnore
         */
        static computeVelocity(points: Array<number>, max?: number): Readonly<Point>;
    }
    class NotImplementedError extends Error {
        constructor();
    }
    class OutOfRangeError extends Error {
        constructor(index: number);
    }
    class NotReadableError extends Error {
        constructor();
    }
    /**
     * @en The error return information format is different on each platform. Here is a common way to get the error message.
     * @param err The error object.
     * @return The error message.
     * @zh 在各个平台上，错误的返回信息格式不一样，这里提供一个通用的方式获取错误信息。
     * @param err 错误对象。
     * @return 错误信息。
     */
    function getErrorMsg(err: any): string;
    /**
     * @en Set the font format and parse the fontInfo.
     * @zh 设置字体格式与解析字体模型。
     */
    class FontInfo {
        private static _cache;
        /**
         * @en Parses a font string into a FontInfo object.
         * @param font The font string to parse.
         * @zh 解析字体字符串为 FontInfo 对象。
         * @param font 要解析的字体字符串
         */
        static parse(font: string): FontInfo;
        /**@internal */
        _font: string;
        /**@internal */
        _family: string;
        /**@internal */
        _size: number;
        /**@internal */
        _italic: boolean;
        /**@internal */
        _bold: boolean;
        constructor(font: string | null);
        /**
         * @en Sets the font format based on the given value string.
         * @param value The font value string to set.
         * @zh 根据给定的值字符串设置字体格式。
         * @param value 要设置的字体值字符串。
         */
        setFont(value: string): void;
    }
    /**
     * @en The HalfFloatUtils class is used to create the HalfFloat tool.
     * @zh HalfFloatUtils 类用于创建HalfFloat工具。
     */
    class HalfFloatUtils {
        /**
         * @internal
         */
        static __init__(): void;
        /**
         * @en round a number to a half float number bits.
         * @param num The number to round.
         * @zh 将数字四舍五入到最接近的半浮点数。
         * @param num 要舍入的数字。
         */
        static roundToFloat16Bits(num: number): number;
        /**
         * @en Converts a half-precision floating-point number in bits to a JavaScript number.
         * @param float16bits  half float number bits
         * @zh 将半精度浮点数的位转换为 JavaScript 数字。
         * @param float16bits 半精度浮点数
         */
        static convertToNumber(float16bits: number): number;
    }
    /**
     * @en The `Handler` class is an event handler class.
     * It is recommended to create a `Handler` object from the object pool using the `Handler.create()` method to reduce the overhead of object creation. When a `Handler` object is no longer needed, it can be recovered to the object pool using `Handler.recover()`. Do not use this object after recovery, as doing so may lead to unpredictable errors.
     * Note: Since mouse events also use this object pool, improper recovery and invocation may affect the execution of mouse events.
     * @zh Handler 是事件处理器类。
     * 推荐使用 Handler.create() 方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover() 将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。
     * 注意：由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。
     * @blueprintIgnore
     */
    class Handler {
        private static _pool;
        private static _gid;
        /**
         * @en The scope of the object (this).
         * @zh 执行域(this)。
         */
        caller: Object | null;
        /**
         * @en The handling method.
         * @zh 处理方法。
         */
        method: Function | null;
        /**
         * @en Arguments passed to the handler method.
         * @zh 参数。
         */
        args: any[] | null;
        /**
         * @en Indicates whether the handler should be executed only once. If true, the handler will be recovered after execution.After recycling, it will be reused, default to false.
         * @zh 表示是否只执行一次。如果为true，回调后执行recover()进行回收。回收后会被再利用，默认为false
         */
        once: boolean;
        protected _id: number;
        /**
         * @en Constructor method.
         * @param caller The execution context.
         * @param method The handling function.
         * @param args Function arguments.
         * @param once Whether it should be executed only once.
         * @zh 构造方法
         * @param caller 执行域。
         * @param method 处理函数。
         * @param args 函数参数。
         * @param once 是否只执行一次。
         */
        constructor(caller?: Object | null, method?: Function | null, args?: any[] | null, once?: boolean);
        /**
         * @en Sets the specified property values for this object.
         * @param caller The scope of the object (this).
         * @param method The callback method.
         * @param args The arguments to be passed to the method.
         * @param once Whether the handler should be executed only once. If true, the handler will be recovered after execution.
         * @returns Returns the handler itself.
         * @zh 设置此对象的指定属性值。
         * @param caller 执行域(this)。
         * @param method 回调方法。
         * @param args 携带的参数。
         * @param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
         * @returns 返回 handler 本身。
         */
        setTo(caller: any, method: Function | null, args: any[] | null, once?: boolean): Handler;
        /**
         * @en Executes the handler.
         * @zh 执行处理器。
         */
        run(): any;
        /**
         * @en Executes the handler with additional data.
         * @param data Additional callback data, can be a single data or an Array (as multiple arguments).
         * @zh 执行处理器，并携带额外数据。
         * @param data 附加的回调数据，可以是单个数据或者数组（作为多参）。
         */
        runWith(data: any): any;
        /**
         * @en Clears the references of the object.
         * @zh 清理对象引用。
         */
        clear(): Handler;
        /**
         * @en Clears the handler and recovers it to the Handler object pool.
         * @zh 清理并回收到 Handler 对象池内。
         */
        recover(): void;
        /**
         * @en Creates a Handler from the object pool. By default, the handler will execute once and then be recovered immediately. If automatic recovery is not desired, set the `once` parameter to false.
         * @param caller The scope of the object (this).
         * @param method The callback method.
         * @param args The arguments to be passed to the callback method.
         * @param once Whether the handler should be executed only once. If true, the handler will be recovered after execution.
         * @returns Return the created handler instance.
         * @zh 从对象池内创建一个 Handler，默认会执行一次并立即回收。如果不需要自动回收，设置 `once` 参数为 false。
         * @param caller 执行域(this)。
         * @param method 回调方法。
         * @param args 回调方法的参数。
         * @param once 是否只执行一次，如果为true，回调后执行 recover() 进行回收，默认为true。
         * @return 返回创建的handler实例。
         */
        static create(caller: any, method: Function | null, args?: any[] | null, once?: boolean): Handler;
    }
    /**
     * @en The `HitArea` class represents a mouse click area that can be defined by a series of vector shapes for clickable and non-clickable regions (currently only supports circles, rectangles, and polygons).
     * @zh `HitArea` 类表示一个鼠标点击区域，可以通过一系列矢量图形定义为可点击和非可点击区域（目前仅支持圆形、矩形和多边形）。
     * @blueprintable
     */
    class HitArea implements IHitArea {
        /**
         * @internal
         */
        _hit: Graphics;
        /**
         * @internal
         */
        _unHit: Graphics;
        /**
         * @en Checks whether the object contains a specified point.
         * @param x The x-coordinate of the point (horizontal position).
         * @param y The y-coordinate of the point (vertical position).
         * @param sp The Sprite object that contains the point.
         * @returns true if the object contains the specified point; otherwise false.
         * @zh 检测对象是否包含指定的点。
         * @param x 点的 X 轴坐标值（水平位置）。
         * @param y 点的 Y 轴坐标值（垂直位置）。
         * @param sp 包含该点的 Sprite 对象。
         * @returns 如果包含指定的点，则值为 true；否则为 false。
         * @blueprintIgnore
         */
        contains(x: number, y: number, sp: Sprite): boolean;
        /**
         * @en Moves the hit area to a new position.
         * @param x The new x-coordinate of the hit area.
         * @param y The new y-coordinate of the hit area.
         * @param hit Whether to move the hit area.
         * @param unhit Whether to move the unhit area.
         * @zh 将命中区域移动到新位置。
         * @param x 新的 x 轴坐标位置。
         * @param y 新的 y 轴坐标位置。
         * @param hit 是否移动命中区域。
         * @param unhit 是否移动未命中区域。
         */
        moveTo(x: number, y: number, hit: boolean, unhit: boolean): void;
        private static _isHitGraphic;
        private static _isHitCmd;
        /**
         * @en The Graphics object that defines the clickable area.(currently only supports circles, rectangles, and polygons).
         * @zh 定义可点击区域的 Graphics 对象。（目前只支持圆形，矩形，多边形）
         */
        get hit(): Graphics;
        set hit(value: Graphics);
        /**
         * @en The Graphics object that defines the non-clickable area,(currently only supports circles, rectangles, and polygons).
         * @zh 定义不可点击区域的 Graphics 对象。（目前只支持圆形，矩形，多边形）
         */
        get unHit(): Graphics;
        set unHit(value: Graphics);
        /**
         * @en Called after deserialization.
         * @zh 序列化后调用。
         * @internal
         */
        onAfterDeserialize(): void;
    }
    /**
     * @en IClone resource cloning interface.
     * @zh IClone 资源克隆接口。
     */
    interface IClone {
        clone(): any;
        cloneTo(destObject: any): void;
    }
    interface IHitArea {
        /**
         * @en Checks whether the object contains a specified point.
         * @param x The x-coordinate of the point (horizontal position).
         * @param y The y-coordinate of the point (vertical position).
         * @param sp The Sprite object that contains the point.
         * @returns true if the object contains the specified point; otherwise false.
         * @zh 检测对象是否包含指定的点。
         * @param x 点的 X 轴坐标值（水平位置）。
         * @param y 点的 Y 轴坐标值（垂直位置）。
         * @param sp 包含该点的 Sprite 对象。
         * @returns 如果包含指定的点，则值为 true；否则为 false。
         * @blueprintIgnore
         */
        contains(x: number, y: number, sp: Sprite): boolean;
    }
    /**
     * @en JsonBin class provides methods for parsing and writing binary JSON-like data.
     * @zh JsonBin类提供了用于解析和写入二进制JSON数据的方法。
     */
    class JsonBin {
        /**
         * @en Checks if the given ArrayBuffer contains JSONBin data.
         * @param data The ArrayBuffer to be checked.
         * @returns True if the data is identified as JSONBin data, false otherwise.
         * @zh 检查给定的ArrayBuffer是否包含JsonBin数据。
         * @param data 要检查的ArrayBuffer。
         * @returns 如果数据被识别为JsonBin数据则返回true，否则返回false。
         */
        static isJsonBin(data: ArrayBufferLike): boolean;
        /**
         * @en Parses the given ArrayBuffer as JSONBin data.
         * @param data The ArrayBuffer to be parsed.
         * @param createObjWithClass An optional function to create objects with class information
         * @return The parsed data as an object. If parsing fails, returns null.
         * @zh 将给定的ArrayBuffer解析为JsonBin数据。
         * @param data 要解析的ArrayBuffer。
         * @param createObjWithClass 可选的函数，用于创建带有类信息的对象。
         * @returns 解析后的数据作为一个对象。如果解析失败，则返回null。
         */
        static parse(data: ArrayBufferLike, createObjWithClass?: Function): any;
        /**
         * @en Serializes the given object into a binary format and returns the resulting buffer.
         * @param o The object to be serialized.
         * @param enableClass A flag indicating whether to include class information (default is false).
         * @returns The serialized object as an ArrayBuffer.
         * @zh 将给定对象序列化为二进制格式并返回生成的缓冲区。
         * @param o 要序列化的对象。
         * @param enableClass 一个标志，指示是否包含类信息（默认值为false）。
         * @returns 作为ArrayBuffer的序列化对象。
         */
        static write(o: any, enableClass?: boolean): ArrayBuffer;
    }
    /**
     * @deprecated Uses JsonBin
     */
    class JsonBinRead {
        /**
         * @en The singleton instance of the JsonBinRead class.
         * @zh JsonBinRead类的单例实例。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of the JsonBinRead class. If it doesn't exist, creates a new one.
         * @returns The singleton instance of the JsonBinRead class.
         * @zh 获取JsonBinRead类的单例实例。如果不存在，则创建一个新的实例。
         * @returns JsonBinRead类的单例实例。
         */
        static get instance(): JsonBinRead;
        /**
         * @en Checks if the given ArrayBuffer contains JSONBin data.
         * @param data The ArrayBuffer to be checked.
         * @returns True if the data is identified as JSONBin data, false otherwise.
         * @zh 检查给定的ArrayBuffer是否包含JsonBin数据。
         * @param data 要检查的ArrayBuffer。
         * @returns 如果数据被识别为JsonBin数据则返回true，否则返回false。
         */
        static IsJsonbin(data: ArrayBuffer): boolean;
        /**
         * @en Parses the given ArrayBuffer as JSONBin data. If it's not in the expected JSONBin format,
         *      tries to parse it as a regular JSON string.
         * @param value The ArrayBuffer to be parsed.
         * @returns The parsed data as an object. If parsing fails, returns null.
         * @zh 将给定的ArrayBuffer解析为JsonBin数据。如果不是预期的JsonBin格式，
         *      则尝试将其作为常规JSON字符串进行解析。
         * @param value 要解析的ArrayBuffer。
         * @returns 解析后的数据作为一个对象。如果解析失败，则返回null。
         */
        static parse(value: ArrayBuffer): any;
        /**
         * @en Reads binary JSON data from the given ArrayBuffer and parses it into an object.
         *      It first initializes some internal state, determines the format based on a marker in the buffer, creates a keyMap for decoding, and then uses the _readOne method to start parsing the data. It also measures and may log the parsing time if it exceeds a certain threshold.
         * @param data The ArrayBuffer containing the binary JSON data to be read.
         * @param createObjWithClass A function used to create objects with specific classes during the parsing process (optional).
         * @returns The parsed object. If the data format is not recognized, it returns null.
         * @zh 从给定的ArrayBuffer中读取二进制JSON数据并将其解析为对象。
         *      它首先初始化一些内部状态，根据缓冲区中的标记确定格式，创建用于解码的键映射，然后使用_readOne方法开始解析数据。如果解析时间超过一定阈值，它还会测量并可能记录解析时间。
         * @param data 包含要读取的二进制JSON数据的ArrayBuffer。
         * @param createObjWithClass 在解析过程中用于创建具有特定类的对象的函数（可选）。
         * @returns 解析后的对象。如果数据格式无法识别，则返回null。
         */
        read(data: ArrayBuffer, createObjWithClass?: Function): any;
    }
    /**
     * @deprecated Uses JsonBin
     */
    class JsonBinWrite {
        /**
         * @en The singleton instance of the JsonBinWrite class.
         * @zh JsonBinWrite类的单例实例。
         */
        private static _instance;
        /**
         * @en Gets the singleton instance of the JsonBinWrite class. If it doesn't exist, creates a new one.
         * @returns The singleton instance of the JsonBinWrite class.
         * @zh 获取JsonBinWrite类的单例实例。如果不存在，则创建一个新的实例。
         * @returns JsonBinWrite类的单例实例。
         */
        static get instance(): JsonBinWrite;
        /**
         * @en Serializes the given object into a binary format and returns the resulting buffer.
         * @param o The object to be serialized.
         * @param enableClass A flag indicating whether to include class information (default is false).
         * @returns The serialized object as an ArrayBuffer.
         * @zh 将给定对象序列化为二进制格式并返回生成的缓冲区。
         * @param o 要序列化的对象。
         * @param enableClass 一个标志，指示是否包含类信息（默认值为false）。
         * @returns 作为ArrayBuffer的序列化对象。
         */
        write(o: any, enableClass?: boolean): ArrayBuffer;
    }
    /**
     * @en The `Mouse` class is used to control the style of the mouse cursor.
     * @zh `Mouse` 类用于控制鼠标光标的样式。
     * @blueprintable
     */
    class Mouse {
        private static _cursor;
        private static _hidden;
        /**
         * @en Sets the style of the mouse cursor.
         * @param value The cursor style string.
         * For example: auto | move | no-drop | col-resize | all-scroll | pointer | not-allowed | row-resize | crosshair | progress | e-resize | ne-resize | default | text | n-resize | nw-resize | help | vertical-text | s-resize | se-resize | inherit | wait | w-resize | sw-resize
         * @zh 设置鼠标样式
         * @param value 光标样式字符串。
         * 例如：auto | move | no-drop | col-resize | all-scroll | pointer | not-allowed | row-resize | crosshair | progress | e-resize | ne-resize | default | text | n-resize | nw-resize | help | vertical-text | s-resize | se-resize | inherit | wait | w-resize | sw-resize
         */
        static set cursor(value: string);
        /**
         * @en The current style of the mouse cursor.
         * @zh 当前鼠标光标的样式。
         */
        static get cursor(): string;
        /**
         * @en Hides the mouse cursor.
         * @zh 隐藏鼠标光标。
         */
        static hide(): void;
        /**
         * @en Shows the mouse cursor.
         * @zh 显示鼠标光标。
         */
        static show(): void;
    }
    /**
     * @en A utility class for parsing JSON strings.
     * @zh 用于解析 JSON 字符串的实用工具类。
     */
    class ParseJSON {
        static parse(str: string): any;
        private static findIndex;
        private static finCurrObj;
        private static formatVal;
        private static len;
        private static ret;
        private static currStr;
        private static currArr;
        private static cobj;
        /**type为0代表没有找到任何状态，1为当前在寻找key，2为当前在寻找val */
        private static type;
        private static finCurrStr;
        private static parseStart;
    }
    /**
     * @en The `Pool` class is an object pooling class used for storing and reusing objects.
     * Reasonable use of the object pool can effectively reduce the overhead of object creation, avoid frequent garbage collection, and thus optimize the smoothness of the game.
     * @zh `Pool` 是对象池类，用于对象的存储和复用。
     * 合理使用对象池可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。
     */
    interface IPool<T> {
        take(...argArray: T extends {
            init(...args: infer P): any;
        } ? P : [
        ]): T;
        recover(element: T | Array<T>): void;
    }
    class Pool {
        private static _CLSID;
        private static POOLSIGN;
        private static _poolDic;
        /**
         * @en Get the object pool based on the object type signature.
         * @param sign The object type signature.
         * @returns The object pool.
         * @zh 根据对象类型标识字符获取对象池。
         * @param sign 对象类型标识字符。
         * @returns 对象池。
         */
        static getPoolBySign(sign: string): any[];
        /**
         * @en Clear the objects in the object pool.
         * @param sign The object type signature.
         * @zh 清除对象池中的对象。
         * @param sign 对象类型标识字符。
         */
        static clearBySign(sign: string): void;
        /**
         * @en Put the object into the object pool of the corresponding type signature.
         * @param sign The object type signature.
         * @param item The object.
         * @zh 将对象放到对应类型标识的对象池中。
         * @param sign 对象类型标识字符。
         * @param item 对象。
         */
        static recover(sign: string, item: any): void;
        /**
         * @en Recover by class name if the class has one, if not, do not recover.
         * @param instance The instance of the class.
         * @zh 根据类名进行回收，如果类有类名才进行回收，没有则不回收。
         * @param instance 类的具体实例。
         */
        static recoverByClass(instance: any): void;
        /**
         * 返回类的唯一标识
         */
        private static _getClassSign;
        /**
         * @en Create an object by class.
         * @param cls The class for creating the object.
         * @zh 根据类创建对象。
         * @param cls 用于创建对象的类。
         */
        static createByClass<T>(cls: new () => T): T;
        /**
         * @en Get an object instance of a certain type from the object pool.
         * If there is no object of this type in the pool, a new object will be created and returned.
         * @param sign The object type signature.
         * @param cls The class used to create the object of this type.
         * @returns An object of the specified type.
         * @zh 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。
         * 如果对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。
         * @param sign 对象类型标识字符。
         * @param cls 用于创建该类型对象的类。
         * @returns 此类型标识的一个对象。
         */
        static getItemByClass<T>(sign: string, cls: new () => T): T;
        /**
         * @en Get an object instance of a certain type from the object pool using a creation function.
         * If there is no object of this type in the pool, a new object will be created using the function and returned.
         * @param sign The object type signature.
         * @param createFun The function used to create the object of this type.
         * @param caller The `this` context for the creation function.
         * @returns An object of the specified type.
         * @zh 根据传入的对象类型标识字符和创建函数，获取对象池中此类型标识的一个对象实例。
         * 如果对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。
         * @param sign 对象类型标识字符。
         * @param createFun 用于创建该类型对象的方法。
         * @param caller this对象。
         * @returns 此类型标识的一个对象。
         */
        static getItemByCreateFun(sign: string, createFun: Function, caller?: any): any;
        /**
         * @en Get an object from the object pool by the object type signature. If there is no object of this type in the pool, return null.
         * @param sign The object type signature.
         * @returns An object of the specified type or null if none is available.
         * @zh 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null。
         * @param sign 对象类型标识字符。
         * @returns 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null。
         */
        static getItem(sign: string): any;
        /**
         * @en Create an object pool.
         * @param type The class used to create the object of this type.
         * @param init The initialization function for the object.
         * @param reset The reset function for the object.
         * @returns An object pool.
         * @zh 创建对象池。
         * @param type 用于创建该类型对象的类。
         * @param init 对象的初始化函数。
         * @param reset 对象的重置函数。
         * @returns 对象池。
         */
        static createPool<T>(type: new () => T, init?: (obj: T, ...args: any[]) => void, reset?: (obj: T) => void): IPool<T>;
        /**
         * @en Create an object pool.
         * @param create The function used to create the object of this type.
         * @param init The initialization function for the object.
         * @param reset The reset function for the object.
         * @returns An object pool.
         * @zh 创建对象池。
         * @param create 用于创建该类型对象的方法。
         * @param init 对象的初始化函数。
         * @param reset 对象的重置函数。
         * @returns 对象池。
         */
        static createPool2<T>(create: () => T, init?: (obj: T, ...args: any[]) => void, reset?: (obj: T) => void): IPool<T>;
    }
    /**
     * @en The `SingletonList` class is designed to implement a singleton queue.
     * @zh SingletonList 类用于实现单例队列。
     */
    class SingletonList<T> {
        /**
         * @en [Read-only] The array storing the elements of the queue.
         * @zh [只读] 存储队列元素的数组。
         */
        elements: Array<T>;
        /**
         * @en [Read-only] The current length of the queue.
         * @zh [只读] 队列的当前长度。
         */
        length: number;
        /**
         * @en Adds an element to the list if it is not already present.
         * @param element The element to add.
         * @zh 如果元素尚未存在于列表中，则添加该元素。
         * @param element 要添加的元素。
         */
        add(element: T): void;
        /**
         * @en Adds all elements from another SingletonList to this list.
         * @param list The SingletonList containing elements to add.
         * @zh 将另一个 SingletonList 中的所有元素添加到此列表中。
         * @param list 要添加元素的 SingletonList。
         */
        addList(list: SingletonList<T>): void;
        /**
         * @en Finds the index of an element in the list.
         * @param element The element to find.
         * @zh 在列表中查找元素的索引。
         * @param element 要查找的元素。
         */
        indexof(element: T): number;
        /**
         * @en Removes an element from the list.
         * @param element The element to remove.
         * @zh 从列表中移除一个元素。
         * @param element 要移除的元素。
         */
        remove(element: T): void;
        /**
         * @en Clears the list, removing all elements.
         * @zh 清除列表，移除所有元素。
         */
        clear(): void;
        /**
         * @en Trims the elements array to match the current length of the list.
         * @zh 将元素数组的长度调整为与列表的当前长度相匹配。
         */
        clean(): void;
        cloneTo(out: SingletonList<T>): void;
        /**
         * @en Destroys the list by nullifying the elements array.
         * @zh 通过将元素数组置为 null 来销毁列表。
         */
        destroy(): void;
    }
    class FastSinglelist<T> extends SingletonList<T> {
        add(element: T): void;
    }
    /**
     * @en The SpriteUtils class provides utility methods for working with Sprite objects in LayaAir.
     * @zh SpriteUtils 类提供了用于处理 LayaAir 中的 Sprite 对象的实用方法。
     * @blueprintable
     */
    class SpriteUtils {
        /**
         * @en Returns the smallest rectangular area object composed of two points on the stage coordinate system for the given display object Sprite.
         * @param sprite The display object Sprite.
         * @param x0 The X-axis coordinate of the first point.
         * @param y0 The Y-axis coordinate of the first point.
         * @param x1 The X-axis coordinate of the second point.
         * @param y1 The Y-axis coordinate of the second point.
         * @param out The rectangle object to be returned. If not provided, a new rectangle object will be created.
         * @return The rectangle object Rectangle composed of the two points on the stage coordinate system.
         * @zh 根据传入的显示对象 Sprite 和此显示对象上的两个点，返回这两点在舞台坐标系上组成的最小矩形区域对象。
         * @param sprite 显示对象 Sprite。
         * @param x0 点一的 X 轴坐标。
         * @param y0 点一的 Y 轴坐标。
         * @param x1 点二的 X 轴坐标。
         * @param y1 点二的 Y 轴坐标。
         * @param out 返回的矩形对象。如果不提供，则创建一个新的矩形对象。
         * @return 两个点在舞台坐标系组成的矩形对象 Rectangle。
         * @blueprintIgnore
         */
        static getGlobalRecByPoints(sprite: Sprite, x0: number, y0: number, x1: number, y1: number, out?: Rectangle): Rectangle;
        /**
         * @en Calculates the global coordinates and scaling values of the specified Sprite display object, and returns a object containing the calculated X and Y coordinates as well as the scaleX and scaleY values.
         * @param sprite The Sprite object to calculate.
         * @returns The object with the calculated values.
         * @zh 计算传入的显示对象 Sprite 在全局坐标系中的坐标和缩放值，返回一个对象，存放计算出的坐标 X 值、Y 值、ScaleX 值和 ScaleY 值。
         * @param sprite Sprite 对象。
         * @return 包含计算出的坐标 X 值、Y 值、ScaleX 值和 ScaleY 值的对象。
         * @blueprintIgnore
         */
        static getGlobalPosAndScale(sprite: Sprite): {
            x: number;
            y: number;
            scaleX: number;
            scaleY: number;
        };
        /**
         * @en Retrieves the transform of a specified area relative to the top-left corner of the window.
         * @param coordinateSpace The coordinate space, must not be a Stage reference.
         * @param x The x coordinate relative to the `coordinateSpace`.
         * @param y The y coordinate relative to the `coordinateSpace`.
         * @returns An object containing the transformed x, y coordinates, and scale factor.
         * @zh 获取指定区域内相对于窗口左上角的transform。
         * @param coordinateSpace	坐标空间，不能是Stage引用
         * @param x 相对于coordinateSpace的x坐标
         * @param y 相对于coordinateSpace的y坐标
         * @returns 包含转换后的x、y坐标以及缩放因子的对象
         * @blueprintIgnore
         */
        static getTransformRelativeToWindow(coordinateSpace: Sprite, x: number, y: number): {
            x: number;
            y: number;
            scaleX: number;
            scaleY: number;
        };
        /**
         * @en Make a DOM element fit within a specific area of the stage.
         * @param dom The reference to the DOM element.
         * @param coordinateSpace The coordinate space. It should not be a reference to Stage.
         * @param x The x coordinate relative to the coordinateSpace.
         * @param y The y coordinate relative to the coordinateSpace.
         * @param width The width of the area.
         * @param height The height of the area.
         * @zh 使DOM元素适应舞台内指定区域。
         * @param dom DOM元素引用
         * @param coordinateSpace 坐标空间，不能是Stage引用
         * @param x 相对于coordinateSpace的x坐标
         * @param y 相对于coordinateSpace的y坐标
         * @param width 宽度
         * @param height 高度
         * @blueprintIgnore
         */
        static fitDOMElementInArea(dom: any, coordinateSpace: Sprite, x: number, y: number, width: number, height: number): void;
        /**
         * @en Converts a rectangle from local coordinates to global coordinates.
         * @param sp The Sprite object whose local rectangle is to be converted.
         * @param rect The local rectangle to be converted.
         * @param out An optional Rectangle object to store the result. If not provided, a new Rectangle object will be created.
         * @returns The converted rectangle in global coordinates.
         * @zh 将矩形从本地坐标转换为全局坐标。
         * @param sp 要转换本地矩形的 Sprite 对象。
         * @param rect 要转换的本地矩形。
         * @param out 可选的 Rectangle 对象，用于存储结果。如果未提供，将创建一个新的 Rectangle 对象。
         * @returns 转换结果。
         */
        static localToGlobalRect(sp: Sprite, rect: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @en Converts a rectangle from global coordinates to local coordinates.
         * @param sp The Sprite object whose global rectangle is to be converted.
         * @param rect The global rectangle to be converted.
         * @param out An optional Rectangle object to store the result. If not provided, a new Rectangle object will be created.
         * @returns The converted rectangle in local coordinates.
         * @zh 将矩形从全局坐标转换为本地坐标。
         * @param sp 要转换全局矩形的 Sprite 对象。
         * @param rect 要转换的全局矩形。
         * @param out 可选的 Rectangle 对象，用于存储结果。如果未提供，将创建一个新的 Rectangle 对象。
         * @returns 转换结果。
         */
        static globalToLocalRect(sp: Sprite, rect: Rectangle, out?: Rectangle): Rectangle;
        /**
         * @en Transforms a rectangle from the local coordinate space of a Sprite to another target coordinate space.
         * @param sp The Sprite object whose local rectangle is to be transformed.
         * @param rect The local rectangle to be transformed.
         * @param targetSpace The target Sprite object representing the coordinate space to which the rectangle should be transformed. If not provided, the transformation will be done in the global coordinate space.
         * @param out An optional Rectangle object to store the result. If not provided, a new Rectangle object will be created.
         * @returns The transformed rectangle in the target coordinate space.
         * @zh 将矩形从 Sprite 的本地坐标空间转换为另一个目标坐标空间。
         * @param sp 要转换本地矩形的 Sprite 对象。
         * @param rect 要转换的本地矩形。
         * @param targetSpace 目标 Sprite 对象，表示矩形应转换到的坐标空间。如果未提供，则转换将在全局坐标空间中进行。
         * @returns 转换结果。
         */
        static transformRect(sp: Sprite, rect: Rectangle, targetSpace?: Sprite, out?: Rectangle): Rectangle;
        /**
         * @en Retrieves the rectangle that bounds the sprite, based on the sprite's own coordinate space.
         * @param sprite The Sprite object for which to retrieve the bounding rectangle.
         * @param sizeOnly If true, only the size of the sprite is considered, ignoring the graphics and children. Default is true.
         * @param out An optional Rectangle object to store the result. If not provided, a new Rectangle object will be created.
         * @returns A Rectangle object representing the bounding rectangle of the sprite.
         * @zh 获取包含精灵的边界矩形，基于精灵自身的坐标空间。
         * @param sprite 要获取边界矩形的 Sprite 对象。
         * @param sizeOnly 如果为 true，则仅考虑精灵的大小，忽略图形和子对象。默认值为 true。
         * @param out 可选的 Rectangle 对象，用于存储结果。如果未提供，将创建一个新的 Rectangle 对象。
         * @returns 一个 Rectangle 对象，表示精灵的边界矩形。
         */
        static getRect(sprite: Sprite, sizeOnly?: boolean, out?: Rectangle): Rectangle;
        /**
         * @en Sets the position and size of a Sprite based on a given rectangle.
         * @param sprite The Sprite object to set the position and size for.
         * @param rect The rectangle object containing the position and size to set.
         * @zh 根据给定的矩形设置 Sprite 的位置和大小。
         * @param sprite 要设置位置和大小的 Sprite 对象。
         * @param rect 包含要设置的位置和大小的矩形对象。
         */
        static setRect(sprite: Sprite, rect: Readonly<Rectangle>): void;
        /**
         * @en Get the bounding box of the child
         * @param recursive Whether to get the bounding box of the child object recursively
         * @param ignoreInvisibles Whether to ignore invisible objects
         * @param ignoreScale Whether to ignore scaling
         * @param out (Optional) Output object for calculation results
         * @returns Bounding box
         * @zh 获取孩子的包围盒
         * @param recursive 是否递归获取所有子对象的包围盒
         * @param ignoreInvisibles 是否忽略不可见对象
         * @param ignoreScale 是否忽略缩放
         * @param out （可选）计算结果输出对象
         * @returns 包围盒
         */
        static getChildrenBounds(sprite: Sprite, recursive?: boolean, ignoreInvisibles?: boolean, ignoreScale?: boolean, out?: Rectangle): Rectangle;
    }
    /**
     * @en The Stat class is a performance statistics panel that provides real-time updates on various performance metrics.
     * @zh Stat是一个性能统计面板，可以实时更新相关的性能参数。
     */
    class Stat {
        /**
         * @en Defines display elements.
         * @zh 定义显示元素。
         */
        static elements: Array<StatElement>;
        /**
         * @en Current frames per second (FPS).
         * @zh 当前每秒帧数（FPS）。
         */
        static get FPS(): number;
        /**
         * @en Count of rendering loops of the main stage Stage.
         * @zh 主舞台 Stage 的渲染次数计数。
         */
        static loopCount: number;
        /**
         * @en Count of rendering loops of the main stage Stage.
         * @zh 主舞台 Stage 的渲染次数计数。
         */
        static render2DCount: number;
        /**
         * @en Enables or disables shadows.
         * @zh 开启或关闭阴影效果。
         */
        static enableShadow: boolean;
        /**
         * @en Enables or disables multiple light sources.
         * @zh 开启或关闭多光源效果。
         */
        static enableMulLight: boolean;
        /**
         * @en Enables or disables light sources.
         * @zh 开启或关闭光源效果。
         */
        static enableLight: boolean;
        /**
         * @en Enables or disables CMD.
         * @zh 开启或关闭CMD。
         */
        static enableCameraCMD: boolean;
        /**
         * @en Enables or disables post-processing effects.
         * @zh 开启或关闭后期处理效果。
         */
        static enablePostprocess: boolean;
        /**
         * @en Enables or disables skin rendering.
         * @zh 开启或关闭skin渲染。
         */
        static enableSkin: boolean;
        /**
         * @en Enables or disables transparent rendering.
         * @zh 开启或关闭透明渲染。
         */
        static enableTransparent: boolean;
        /**
         * @en Enables or disables particle rendering.
         * @zh 开启或关闭粒子渲染。
         */
        static enableParticle: boolean;
        /**
         * @en Enables or disables animation updates.
         * @zh 开启或关闭动画更新。
         */
        static enableAnimatorUpdate: boolean;
        /**
         * @en Enables or disables physics updates.
         * @zh 开启或关闭物理更新。
         */
        static enablePhysicsUpdate: boolean;
        /**
         * @en Enables or disables MSAA.
         * @zh 开启或关闭 MSAA。
         */
        static enablemsaa: boolean;
        /**
         * @en Enables or disables rendering of opaque objects.
         * @zh 开启或关闭不透明物体渲染。
         */
        static enableOpaque: boolean;
        static _statUIClass: typeof StatUI;
        static _statUI: StatUI;
        private static _show;
        /**
         * @en Displays performance statistics information on the screen.
         * To be effective, it should be called at the very beginning of the application.
         * @param x The X-coordinate position where the statistics should be displayed.
         * @param y The Y-coordinate position where the statistics should be displayed.
         * @param views An optional array of StatUIParams that defines which statistics to display.
         * @zh 在屏幕上显示性能统计信息。
         * 为了有效，它应该在应用程序最开始时调用。
         * @param x 统计信息显示的 X 轴坐标位置。
         * @param y 统计信息显示的 Y 轴坐标位置。
         * @param views 可选的 StatUIParams 数组，定义要显示哪些统计信息。
         */
        static show(x?: number, y?: number, views?: ReadonlyArray<StatElement>): void;
        /**
         * @en Hides the performance statistics information from the screen.
         * @zh 从屏幕上隐藏性能统计信息。
         */
        static hide(): void;
        private static loop;
        /** @internal */
        static render(): void;
    }
    /** @ignore */
    class StatUI {
        _sp: Sprite;
        private _title;
        private _txt;
        private _items;
        private _pass;
        private createUI;
        show(x?: number, y?: number): void;
        update(): void;
        render(): void;
    }
    /**
     * @en The `Timer` class is responsible for time management. It is a singleton and should not be instantiated manually. Access it via `Laya.timer`
     * @zh Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
     */
    class Timer {
        /**@internal */
        static gSysTimer: Timer;
        /**@internal */
        static readonly callLaters: Timer;
        /**@internal */
        static readonly _pool: TimerHandler[];
        /**
         * @en Scale of the clock hand.
         * @zh 时针的缩放比例。
         */
        scale: number;
        /**
         * @en The start time of the current frame.
         * @zh 当前帧的开始时间。
         */
        currTimer: number;
        /**
         * @en The current frame count.
         * @zh 当前的帧数。
         */
        currFrame: number;
        /**
         * @en The time interval between two frames, in milliseconds.
         * @zh 两帧之间的时间间隔，单位毫秒。
         */
        delta: number;
        /**
         * @en The unscaled time interval between two frames, in milliseconds.
         * @zh 两帧之间的时间间隔（不受 scale 影响），单位毫秒。
         */
        unscaledDelta: number;
        private _lastTimer;
        private _map;
        private _handlers;
        private _greedy;
        /**
         * @en Constructor method
         * @param autoActive Whether to automatically activate the timer. If not, you need to call `_update` manually. Default is true.
         * @param greedyMode Whether to use the greedy mode. In the greedy mode, the timer will try to execute the new added handler within `_update`. Default is false.
         * @zh 构造方法
         * @param autoActive 是否自动激活时钟，否则需要手动调用 `_update`。默认为 true。
         * @param greedyMode 是否使用贪婪模式，在贪婪模式下时钟会尝试在 `_update` 内执行新添加的 handler。默认为 false。
         */
        constructor(autoActive?: boolean, greedyMode?: boolean);
        /**
         * @en The time since last frame (unit: milliseconds).
         * @zh 获取最后一帧的时间（单位：毫秒）。
         */
        get totalTime(): number;
        /**
         * @en The frame update handling function.
         * @zh 帧循环处理函数。
         */
        _update(timestamp: number): void;
        private _clearHandlers;
        /** @internal */
        _create(useFrame: boolean, repeat: boolean, delay: number, caller: any, method: Function, args: any[], coverBefore: boolean): TimerHandler;
        /**
         * Executes once after a delay.
         * @param delay The delay time in milliseconds.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时执行一次。
         * @param delay 延迟时间(单位为毫秒)。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
         */
        once(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * Repeatedly executes at intervals.
         * @param delay The interval time in milliseconds.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @param jumpFrame Whether to jump frames. For time-based callbacks, if multiple callbacks can be executed within a given time interval, the engine defaults to executing once for performance reasons. Setting `jumpFrame` to true will allow multiple executions in quick succession.
         * @zh 定时重复执行。
         * @param delay 间隔时间(单位毫秒)。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
         * @param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次。
         */
        loop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * Executes once after a delay in frames.
         * @param delay The delay time in frames.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时执行一次（基于帧率）。
         * @param delay 延迟几帧（单位为帧）。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true。
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * Repeatedly executes at frame intervals.
         * @param delay The interval time in frames.
         * @param caller The scope of the object (this).
         * @param method The callback function to be executed by the timer.
         * @param args The arguments to pass to the callback function.
         * @param coverBefore Whether to overwrite previous delayed execution, default is true.
         * @zh 定时重复执行（基于帧率）。
         * @param delay 间隔几帧（单位为帧）。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         * @param coverBefore 是否覆盖之前的延迟执行，默认为 true。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * @en Return statistical information
         * @zh 返回统计信息
         */
        toString(): string;
        /**
         * @en Cleaning the timer.
         * @param caller The scope of the object (this).
         * @param method Timer callback function.
         * @zh 清理定时器。
         * @param caller 执行域（this）。
         * @param method 定时器回调函数。
         */
        clear(caller: any, method: Function): void;
        /**
         * @en Clears all timers associated with the object.
         * @param caller The scope of the object (this).
         * @zh 清理对象身上的所有定时器。
         * @param caller  执行域(this)。
         */
        clearAll(caller: any): void;
        /**
         * @en Delays the execution.
         * @param caller The scope of the object (this).
         * @param method The timer callback function.
         * @param args The callback arguments.
         * @zh 延迟执行。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param args 回调参数。
         */
        callLater(caller: any, method: Function, args?: any[]): void;
        /**
         * @en Immediately executes the callLater.
         * @param caller The scope of the object (this).
         * @param method The callback function for the timer.
         * @param forceRun Whether to force execution, regardless of whether there is a registered CallLater.
         * @zh 立即执行 callLater。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @param forceRun 是否强制执行，不管是否有注册CallLater.
         */
        runCallLater(caller: any, method: Function, forceRun?: boolean): void;
        /**
         * @en Cancels the execution of callLater.
         * @param caller The scope of the object (this).
         * @param method The callback function for the timer.
         * @zh 取消执行 callLater。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         */
        clearCallLater(caller: any, method: Function): void;
        /**
         * @en Immediately advance the timer, execute it, and then remove it from the queue.
         * @param caller The scope of the object (this).
         * @param method Timer callback function.
         * @return Whether the call was successful.
         * @zh 立即提前执行定时器，执行后从队列中删除。
         * @param caller 执行域(this)。
         * @param method 定时器回调函数。
         * @return 调用是否成功。
         */
        runTimer(caller: any, method: Function): boolean;
        /**
         * @en Pause the clock.
         * @zh 暂停时钟。
         */
        pause(): void;
        /**
         * @en Resume the clock.
         * @zh 恢复时钟。
         */
        resume(): void;
        /**
         * @en Destroy the timer, and clear all events on the timer.
         * @zh 删除定时器，同时清理定时器上的所有事件。
         */
        destroy(): void;
    }
    class TimerHandler {
        /**
         * @en The key of the timer handler.
         * @zh 定时器处理程序的键。
         */
        key: string;
        /**
         * @en Whether the timer should repeat.
         * @zh 定时器是否应该重复。
         */
        repeat: boolean;
        /**
         * @en The delay between executions in milliseconds.
         * @zh 执行之间的延迟，以毫秒为单位。
         */
        delay: number;
        /**
         * @en Whether to use frame-based timing.
         * @zh 是否使用基于帧的计时。
         */
        userFrame: boolean;
        /**
         * @en The execution time of the timer.
         * @zh 定时器的执行时间。
         */
        exeTime: number;
        /**
         * @en The caller object for the timer method.
         * @zh 定时器方法的调用者对象。
         */
        caller: any;
        /**
         * @en The method to be executed by the timer.
         * @zh 定时器要执行的方法。
         */
        method: Function;
        /**
         * @en The arguments to be passed to the timer method.
         * @zh 要传递给定时器方法的参数。
         */
        args: any[];
        /**
         * @en Whether to jump frames.
         * @zh 是否跳帧。
         */
        jumpFrame: boolean;
        /**
         * @en Clear the timer handler by setting its properties to null.
         * @zh 通过将其属性设置为 null 来清除定时器处理程序。
         */
        clear(): void;
        /**
         * @en Run the timer handler method.
         * @param withClear Whether to clear the handler after execution.
         * @zh 运行定时器处理程序方法。
         * @param withClear 是否在执行后清除处理程序。
         */
        run(withClear: boolean): void;
    }
    /**
     * @en Utils is a utility class.
     * @zh Utils 是工具类。
     * @blueprintable
     */
    class Utils {
        /**
         * @en Converts an angle to radians.
         * @param angle The angle value.
         * @returns The radian value.
         * @zh 将角度转换为弧度。
         * @param angle 角度值。
         * @return 返回弧度值。
         * @blueprintPure
         */
        static toRadian(angle: number): number;
        /**
         * @en Converts radians to an angle.
         * @param radian The radian value.
         * @returns The angle value in degrees.
         * @zh 将弧度转换为角度。
         * @param radian 弧度值。
         * @return 返回角度值。
         * @blueprintPure
         */
        static toAngle(radian: number): number;
        /**
         * @deprecated Please use Color.hexToString instead.
         */
        static toHexColor(color: number): string;
        /**
         * @deprecated Please use Color.stringToHex instead.
         */
        static fromStringColor(value: string): number;
        /**
         * @en Assigns a global unique ID for the given target-method pair.
         * @param method The method, it can be a function or a function name.
         * @param target The target. It's optional.
         * @returns A unique ID for the given target-method pair.
         * @zh 为一个target-method对分配一个全局唯一ID。
         * @param method 方法，可以是一个函数或者函数名。
         * @param target 目标对象，可选。
         * @return 分配到的唯一ID。
         * @blueprintIgnore
         */
        static getGID(target: Object | null, method?: Function | string): string;
        /**
         * @private
         * @en Clears the source array and copies the values from the array parameter.
         * @param source The array to be assigned values.
         * @param array The new values to be copied into the source array.
         * @returns The copied source array.
         * @zh 清空 source 数组，并复制 array 数组的值。
         * @param source 需要赋值的数组。
         * @param array 新的数组值。
         * @return 复制后的数据 source 。
         */
        static copyArray(source: any[], array: any[]): any[];
        /**
         * @en Parses a string and returns an integer. Unlike the native JavaScript parseInt, if the string is empty or not a number, this method returns 0 instead of NaN.
         * @param str The string to be parsed.
         * @param radix The radix for parsing the number (between 2 and 36). Defaults to 0, which means decimal. The other values range from 2 to 36. If it starts with "0xX" or "0X", it will be based on 16. If the parameter is not within the above range, this method returns 0.
         * @returns The parsed number.
         * @zh 解析字符串并返回一个整数。与 JavaScript 原生的 parseInt 不同，如果字符串为空或非数字，这里返回 0 而不是 NaN。
         * @param str 要被解析的字符串。
         * @param radix 表示要解析的数字的基数。默认值为0，表示10进制，其他值介于 2 ~ 36 之间。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数不在上述范围内，则此方法返回 0。
         * @return 返回解析后的数字。
         * @blueprintIgnore
         */
        static parseInt(str: string, radix?: number): number;
        /**
         * @en Gets the base name of the file from the specified path, including the extension.
         * @param path The file path.
         * @returns The base name of the file, including the extension.
         * @zh 从指定路径中获取文件名（包含扩展名）。
         * @param path 文件路径。
         * @returns 返回文件名（包含扩展名）。
         * @blueprintPure
         */
        static getBaseName(path: string): string;
        /**
         * @en Gets the base name of the file from the specified path, optionally excluding the extension.
         * @param path The file path.
         * @param withoutExtension Whether to exclude the file extension. Default is false.
         * @returns The base name of the file, optionally excluding the extension.
         * @zh 从指定路径中获取文件名（可选地不包含扩展名）。
         * @param path 文件路径。
         * @param withoutExtension 是否排除文件扩展名。默认值为 false。
         * @returns 返回文件名（可选地不包含扩展名）。
         * @blueprintPure
         */
        static getBaseName(path: string, withoutExtension: boolean): string;
        /**
         * @en Gets the file extension from the specified path and converts it to lowercase. For example, "1. abc" will return abc.
         * @zh 从指定路径获取文件扩展名，并转换为小写字母。例如"1.abc"将返回abc。
         * @blueprintPure
         */
        static getFileExtension(path: string): string;
        /**
         * @en Changes the file extension of the specified path.
         * @param path The file path.
         * @param newExt The new file extension.
         * @param excludeDot Whether to exclude the dot prefix in the new extension. Default is false.
         * @returns The path with the new file extension.
         * @zh 更改指定路径的文件扩展名。
         * @param path 文件路径。
         * @param newExt 新的文件扩展名。
         * @param excludeDot 是否在新扩展中排除点前缀。默认值为false。
         * @returns 具有新文件扩展名的路径。
         */
        static replaceFileExtension(path: string, newExt: string, excludeDot?: boolean): string;
        /**
         * @en Checks if the given string is a valid UUID format.
         * @param str The string to check.
         * @returns True if the string is in UUID format, false otherwise.
         * @zh 判断一个字符串是否是有效的UUID格式。
         * @param str 判断一个字符串是否UUID格式
         * @returns true表示是UUID格式，false表示不是UUID格式
         * @blueprintPure
         */
        static isUUID(str: string): boolean;
        /**
         * @deprecated 请使用uint8ArrayToArrayBufferAsync函数代替
         * @en Converts a RenderTexture to a Base64 encoded string.
         * @param rendertexture The RenderTexture to convert.
         * @returns The converted Base64 string
         * @zh 将RenderTexture转换为Base64
         * @param rendertexture 要转换的RenderTexture
         * @returns 转换后的Base64字符串
         */
        static uint8ArrayToArrayBuffer(rendertexture: RenderTexture | RenderTexture2D): string;
        /**
        * @en Converts a RenderTexture to a Base64 encoded string.
        * @param rendertexture The RenderTexture to convert.
        * @returns A promise that resolves to a Base64 string representing the RenderTexture.
        * @zh 将 RenderTexture 转换为 Base64 编码的字符串。
        * @param rendertexture 要转换的 RenderTexture。
        * @returns 一个 Promise，该 Promise 将解析为表示 RenderTexture 的 Base64 字符串。
        */
        static uint8ArrayToArrayBufferAsync(rendertexture: RenderTexture | RenderTexture2D): Promise<string>;
        /**
         * @en Parses a template string and returns a new string by replacing the placeholders with the specified values.
         * @param template The template string.
         * @param vars The specified values.
         * @returns The new string.
         * @zh 解析模板字符串，并返回一个新字符串，替换占位符为指定值。
         * @param template 模板字符串。
         * @param vars 指定值。
         * @return 新字符串。
         * @blueprintIgnore
         */
        static parseTemplate(template: string, vars: Record<string, any>): string;
        /**
         * @en Sleeps for the specified number of milliseconds.
         * @param timeout The number of milliseconds to sleep.
         * @zh 睡眠指定的毫秒数。
         * @param timeout 睡眠的毫秒数。
         * @blueprintIgnore
         */
        static sleep(timeout: number): Promise<void>;
        /**
         * @en Waits until the specified predicate function returns true or the timeout is reached.
         * @param predicate The function to check the condition.
         * @param timeout The maximum time to wait in milliseconds. If not specified,
         * @zh 等待直到指定的谓词函数返回 true 或超时。
         * @param predicate 检查条件的函数。
         * @param timeout 最大等待时间（毫秒）。如果未指定，则不设置超时。
         */
        static until(predicate: () => boolean, timeout?: number): Promise<void>;
        /**
         * @en Runs a task function for each item in the datas array, allowing a specified number of parallel tasks.
         * @param datas The array of data to process.
         * @param numParallelTasks The maximum number of parallel tasks to run.
         * @param taskFunc The function to run for each item in the datas array. It should return a value or a Promise.
         * @param abortToken An optional token to signal task abortion. If the token's `aborted` property is true, the task will be aborted.
         * @zh 运行任务函数处理 datas 数组中的每个项目，允许指定数量的并行任务。
         * @param datas 要处理的数据数组。
         * @param numParallelTasks 允许运行的最大并行任务数。
         * @param taskFunc 要运行的函数，处理 datas 数组中的每个项目。它应该返回一个值或一个 Promise。
         * @param abortToken 可选的令牌，用于发出任务中止信号。如果令牌的 `aborted` 属性为 true，则任务将被中止。
         */
        static runTasks<T, T2>(datas: Array<T2>, numParallelTasks: number, taskFunc: (data: T2, index: number) => T | Promise<T>, abortToken?: IAbortToken): Promise<T[]>;
        /**
         * @en Runs a task function for each item in the datas array, allowing a specified number of parallel tasks.
         * @param datas The array of data to process.
         * @param checkConcurrency It will be called with the number of tasks to determine if more tasks can be run.
         * @param taskFunc The function to run for each item in the datas array. It should return a value or a Promise.
         * @param abortToken An optional token to signal task abortion. If the token's `aborted` property is true, the task will be aborted.
         * @zh 运行任务函数处理 datas 数组中的每个项目，允许指定数量的并行任务。
         * @param datas 要处理的数据数组。
         * @param checkConcurrency 它将被调用以确定是否可以运行更多任务。
         * @param taskFunc 要运行的函数，处理 datas 数组中的每个项目。它应该返回一个值或一个 Promise。
         * @param abortToken 可选的令牌，用于发出任务中止信号。如果令牌的 `aborted` 属性为 true，则任务将被中止。
         */
        static runTasks<T, T2>(datas: Array<T2>, checkConcurrency: (numTasks: number) => boolean, taskFunc: (data: T2, index: number) => T | Promise<T>, abortToken?: IAbortToken): Promise<T[]>;
        /**
         * @en Runs a task function for each item in the datas array, allowing a specified number of parallel tasks.
         * @param datas The array of data to process.
         * @param numParallelTasks The maximum number of parallel tasks to run.
         * @param taskFunc The function to run for each item in the datas array. It should return a value or a Promise.
         * @param abortToken An optional token to signal task
         * @zh 运行任务函数处理 datas 数组中的每个项目，允许指定数量的并行任务。
         * @param datas 要处理的数据数组。
         * @param numParallelTasks 允许运行的最大并行任务数。
         * @param taskFunc 要运行的函数，处理 datas 数组中的每个项目。它应该返回一个值或一个 Promise。
         * @param abortToken 可选的令牌，用于发出任务中止信号。如果令牌的 `aborted` 属性为 true，则任务将被中止。
         */
        static runAllTasks<T, T2>(datas: Array<T2>, numParallelTasks: number, taskFunc: (data: T2, index: number) => T | Promise<T>, abortToken?: IAbortToken): Promise<PromiseSettledResult<T>[]>;
        /**
         * @en Runs a task function for each item in the datas array, allowing a specified number of parallel tasks.
         * @param datas The array of data to process.
         * @param checkConcurrency it will be called with the number of tasks to determine if more tasks can be run.
         * @param taskFunc The function to run for each item in the datas array. It should return a value or a Promise.
         * @param abortToken An optional token to signal task
         * @zh 运行任务函数处理 datas 数组中的每个项目，允许指定数量的并行任务。
         * @param datas 要处理的数据数组。
         * @param checkConcurrency 它将被调用以确定是否可以运行更多任务。
         * @param taskFunc 要运行的函数，处理 datas 数组中的每个项目。它应该返回一个值或一个 Promise。
         * @param abortToken 可选的令牌，用于发出任务中止信号。如果令牌的 `aborted` 属性为 true，则任务将被中止。
         */
        static runAllTasks<T, T2>(datas: Array<T2>, checkConcurrency: (numTasks: number) => boolean, taskFunc: (data: T2, index: number) => T | Promise<T>, abortToken?: IAbortToken): Promise<PromiseSettledResult<T>[]>;
        /**
         * @en Compares two version strings.
         * @param ver1 The first version string.
         * @param ver2 The second version string.
         * @returns 1 if ver1 > ver2, -1 if ver1 < ver2, 0 if they are equal.
         * @zh 比较两个版本字符串。
         * @param ver1 第一个版本字符串。
         * @param ver2 第二个版本字符串。
         * @returns 如果 ver1 > ver2 返回 1，如果 ver1 < ver2 返回 -1，如果相等返回 0。
         * @blueprintPure
         */
        static compareVersion(ver1: string, ver2: string): 1 | 0 | -1;
        /**
         * @en Determines whether a point is inside a polygon.
         * @param x The x-coordinate of the point.
         * @param y The y-coordinate of the point.
         * @param areaPoints An array of points representing the polygon, where each pair of numbers represents the x and y coordinates of a vertex.
         * @returns True if the point is inside the polygon, false otherwise.
         * @zh 坐标是否在多边形内
         * @param x 点的 x 坐标。
         * @param y 点的 y 坐标。
         * @param areaPoints 一个数组，表示多边形的点，每对数字表示一个顶点的 x 和 y 坐标。
         * @returns 如果点在多边形内返回 true，否则返回 false。
         */
        static testPointInPolygon(x: number, y: number, areaPoints: number[]): boolean;
    }
    interface IAbortToken {
        /**
         * @en Indicates whether the task has been aborted.
         * @zh 指示任务是否已被中止。
         */
        aborted: boolean;
    }
    /**
     * @en Vertex stream is a tool for appending vertices and triangles.
     * @zh 顶点流工具，用于顶点数据和三角形数据的添加。
     * @blueprintIgnore
     */
    class VertexStream {
        /**
         * @en The rectangle of the content. The origin is at the top-left corner.
         * @zh 内容的矩形区域。原点在左上角。
         */
        readonly contentRect: Rectangle;
        /**
         * @en The rectangle of the uv. The origin is at the top-left corner.
         * @zh uv 的矩形区域。原点在左上角。
         */
        readonly uvRect: Rectangle;
        /**
         * @en The default color of the vertices.
         * @zh 顶点的默认颜色。
         */
        readonly color: Color;
        /**
         * @en The main texture.
         * @zh 主贴图。
         */
        readonly mainTex: Texture;
        private _vertices;
        private _uvs;
        private _indices;
        private _colors;
        private _vp;
        private _ip;
        private _vec;
        static readonly pool: IPool<VertexStream>;
        constructor();
        init(mainTex?: Texture): void;
        /**
         * @en Add a vertex.
         * @param x The x coordinate of the vertex.
         * @param y The y coordinate of the vertex.
         * @param color The color of the vertex. If not set, the color will be the default color.
         * @param u The u of the vertex. If not set, the u will be calculated based on the contentRect and uvRect.
         * @param v The v of the vertex. If not set, the v will be calculated based on the contentRect and uvRect.
         * @zh 添加一个顶点。
         * @param x 顶点的 x 坐标。
         * @param y 顶点的 y 坐标。
         * @param color 顶点的颜色。如果不设置，颜色将会是默认颜色。
         * @param u 顶点的 u。如果不设置，u 将根据 contentRect 和 uvRect 计算。
         * @param v 顶点的 v。如果不设置，v 将根据 contentRect 和 uvRect 计算。
         */
        addVert(x: number, y: number, color?: Readonly<Color>, u?: number, v?: number): void;
        /**
         * @en Add a quad. A quad is composed of four vertices.
         * @param rect The rectangle of the quad.
         * @param color The color of the quad. If not set, the color will be the default color.
         * @param uvRect The uvs of the quad. If not set, the uv will be calculated based on the contentRect and uvRect.
         * @zh 添加一个四边形。四边形由四个顶点组成。
         * @param rect 四边形的矩形区域。
         * @param color 四边形的颜色。如果不设置，颜色将会是默认颜色。
         * @param uvRect 四边形的 uvs。如果不设置，uv 将根据 contentRect 和 uvRect 计算。
         */
        addQuad(rect: Readonly<Rectangle>, color?: Readonly<Color>, uvRect?: Readonly<Rectangle>): void;
        /**
         * @en Add a triangle. A triangle is composed of three indices.
         * @param idx0 The first index of the triangle.
         * @param idx1 The second index of the triangle.
         * @param idx2 The third index of the triangle.
         * @zh 添加一个三角形。三角形由三个索引组成。
         * @param idx0 三角形的第一个索引。
         * @param idx1 三角形的第二个索引。
         * @param idx2 三角形的第三个索引。
         */
        addTriangle(idx0: number, idx1: number, idx2: number): void;
        /**
         * @en Add triangles. The triangles are composed of indices.
         * @param indices The indices of the triangles.
         * @zh 添加三角形。三角形由索引组成。
         * @param indices 三角形的索引。
         */
        addTriangles(indices: ReadonlyArray<number>): void;
        /**
         * @en Triangulate the quads.
         * @param baseIndex The index of the first vertex of the first quad. If it is negative, it will be calculated from the end.
         * @zh 将四边形分割成三角形。
         * @param baseIndex 第一个四边形的第一个顶点的索引。如果是负数，则会从末尾计算。
         */
        triangulateQuad(baseIndex: number): void;
        /**
         * @en Get the position of the vertex by index.
         * @param index The index of the vertex. If it is negative, it will be calculated from the end.
         * @returns The position of the vertex.
         * @zh 根据索引获取顶点的位置。
         * @param index 顶点的索引。如果是负数，则会从末尾计算。
         * @returns 顶点的位置。
         */
        getPos(index: number): Readonly<Vector2>;
        /**
         * @en Get the number of vertices.
         * @zh 获取顶点数量。
         */
        get vertCount(): number;
        /**
         * @en Get the vertices typed array.
         * @returns The vertices typed array.
         * @zh 获取顶点的类型化数组。
         * @returns 顶点的类型化数组。
         */
        getVertices(): Float32Array;
        /**
         * @en Get the uvs typed array.
         * @returns The uvs typed array.
         * @zh 获取uv的类型化数组。
         * @returns uv的类型化数组。
         */
        getUVs(): Float32Array;
        /**
         * @en Get the colors typed array.
         * @returns The colors typed array.
         * @zh 获取颜色的类型化数组。
         * @returns 颜色的类型化数组。
         */
        getColors(): Float32Array;
        /**
         * @en Get the indices typed array.
         * @returns The indices typed array.
         * @zh 获取索引的类型化数组。
         * @returns 索引的类型化数组。
         */
        getIndices(): Uint16Array;
        private checkVBuf;
        private checkIBuf;
        private resizeBuf;
    }
    /**
     * @ignore
     */
    class WasmAdapter {
        static instantiateWasm: (url: string, imports: any) => Promise<any>;
        static locateFile: (path: string, dir: string, webDir: string) => string;
        static Memory: {
            new (descriptor: WebAssembly.MemoryDescriptor): WebAssembly.Memory;
            prototype: WebAssembly.Memory;
        };
        static create(module: Function, wasmFile?: string): Function;
        static locateFileDefault(path: string, scriptDirectory?: string): string;
    }
    /**
     * @internal
     * 弱引用对象
     * 注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
     */
    class WeakObject {
        /**多少时间清理一次缓存，默认10分钟清理一次*/
        static delInterval: number;
        private static _maps;
        private static _i;
        /**
         * @en Global WeakObject singleton.
         * @zh 全局WeakObject单例
         */
        static get I(): WeakObject;
        /**
         * @en Clear cache and recycle memory.
         * @zh 清理缓存，回收内存
         */
        static clearCache(): void;
        private _obj;
        constructor();
        /**
         * 设置缓存
         * @param key kye对象，可被回收
         * @param value object对象，可被回收
         */
        set(key: any, value: any): void;
        /**
         * 获取缓存
         * @param key kye对象，可被回收
         */
        get(key: any): any;
        /**
         * 删除缓存
         */
        del(key: any): void;
        /**
         * 是否有缓存
         */
        has(key: any): boolean;
    }
    /**
     * @private
     * @en WordText class for managing text content and rendering.
     * @zh WordText 类，用于管理文本内容和渲染。
     */
    class WordText {
        /**
         * @en The text content.
         * @zh 文本内容。
         */
        text: string;
        /**
         * @en The width of the entire WordText. -1 indicates it hasn't been calculated yet.
         * @zh 整个 WordText 的宽度。-1 表示还没有计算。
         */
        width: number;
        /**
         * @en The text information saved by grouping the characters of this object into texture groups. Inside is another array. The specific meaning can be found in the place of use.
         * @zh 把本对象的字符按照texture分组保存的文字信息。里面又是一个数组。具体含义见使用的地方。
         */
        pageChars: any[];
        /**
         * @en The ctx used for caching above. When crossing ctx (such as drawToTexture), it needs to be cleaned up, (because the settings for different ctx are different?). Set to any to indicate no concern for specific types, only for comparison purposes
         * @zh 上面缓存的时候用的ctx。跨ctx的时候（例如drawToTexture）要清理，（因为不同的ctx的设置不同？）。设置为any表示不关心具体类型，只是用来比较的
         */
        pagecharsCtx: any;
        /**
         * @en Horizontal scale cached during rendering.
         * @zh 渲染时缓存的水平缩放。
         */
        scalex: number;
        /**
         * @en Vertical scale cached during rendering.
         * @zh 渲染时缓存的垂直缩放。
         */
        scaley: number;
        _nativeObj: any;
        _splitRender: boolean;
        constructor();
        /**
         * @en Set the text content.
         * @param txt The text to set.
         * @zh 设置文本内容。
         * @param txt 要设置的文本。
         */
        setText(txt: string): void;
        /**
         * @en Convert the WordText to a string.
         * @returns The text content.
         * @zh 将 WordText 转换为字符串。
         * @returns 文本内容。
         */
        toString(): string;
        /**
         * @en The length of the text.
         * @zh 文本的长度。
         */
        get length(): number;
        /**
         * @en Clean the cache. This method will delete associated textures.
         * It's okay not to do it, textrender will automatically clean up the unused ones
         * @zh 清理缓存。此方法会删除关联的贴图。
         * 不做也可以，textrender会自动清理不用的
         * TODO 重用
         */
        cleanCache(): void;
        /**
         * @en The split render status.
         * @zh 拆分渲染状态。
         */
        get splitRender(): boolean;
        set splitRender(value: boolean);
    }
    /**
     * @en BlendMode enumeration.
     * @zh 混合模式枚举。
     * @blueprintable
     */
    enum BlendMode {
        invalid = 0,
        normal = 1,
        add = 2,
        multiply = 3,
        screen = 4,
        overlay = 5,
        light = 6,
        lighter = 7,
        mask = 8,
        destinationOut = 9,
        addOld = 10,
        lighterOld = 11,
        sourceAlpha = 12
    }
    /**
     * @ignore
     */
    class BlendModeHandler {
        /**@internal */
        static _init_(): void;
        static setShaderData(blendType: BlendMode, shaderData: ShaderData, premultipliedAlpha?: boolean): void;
        static initBlendMode(shaderData: ShaderData): void;
    }
    /** @ignore */
    class DrawStyle {
        static readonly DEFAULT: Readonly<DrawStyle>;
        _color: ColorUtils;
        static create(value: ColorUtils | string | number): DrawStyle;
        constructor(value: string | number | ColorUtils);
        equal(value: string | ColorUtils): boolean;
    }
    /** @ignore */
    class Path {
        _lastOriX: number;
        _lastOriY: number;
        paths: RenderPath[];
        private _curPath;
        beginPath(convex: boolean): void;
        closePath(): void;
        newPath(): void;
        addPoint(pointX: number, pointY: number): void;
        push(points: number[], convex: boolean): void;
        reset(): void;
    }
    class RenderPath {
        path: any[];
        loop: boolean;
        convex: boolean;
    }
    interface ISaveData {
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
    }
    /** @ignore */
    class SaveBase implements ISaveData {
        static TYPE_ALPHA: number;
        static TYPE_STYLE: number;
        static TYPE_FONT: number;
        static TYPE_LINEWIDTH: number;
        static TYPE_MARK: number;
        static TYPE_TRANSFORM: number;
        static TYPE_TRANSLATE: number;
        static TYPE_ENABLEMERGE: number;
        static TYPE_TEXTBASELINE: number;
        static TYPE_TEXTALIGN: number;
        static TYPE_GLOBALCOMPOSITEOPERATION: number;
        static TYPE_CLIPRECT: number;
        static TYPE_CLIPRECT_STENCIL: number;
        static TYPE_IBVB: number;
        static TYPE_SHADER: number;
        static TYPE_FILTERS: number;
        static TYPE_FILTERS_TYPE: number;
        private static POOL;
        private static _namemap;
        private _valueName;
        private _value;
        private _dataObj;
        private _newSubmit;
        constructor();
        static _createArray(): any[];
        /**@internal */
        static _init(): any;
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static save(runner: GraphicsRunner, type: number, dataObj: any, newSubmit: boolean): void;
    }
    /** @ignore */
    class SaveClipRect implements ISaveData {
        static MAX: Rectangle;
        private static POOL;
        _globalClipMatrix: Matrix;
        _clipInfoID: number;
        _clipRect: Rectangle;
        _clip_x: number;
        _clip_y: number;
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static save(runner: GraphicsRunner): void;
    }
    /** @ignore */
    class SaveMark implements ISaveData {
        private static POOL;
        /**@internal */
        _saveuse: number;
        /**@internal */
        _preSaveMark: SaveMark;
        constructor();
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static Create(runner: GraphicsRunner): SaveMark;
    }
    /** @ignore */
    class SaveStyle implements ISaveData {
        private static POOL;
        private _fillStyle;
        private _other;
        private _key;
        constructor();
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static save(runner: GraphicsRunner, key: "fillStyle" | "strokeStyle"): void;
    }
    /** @ignore */
    class SaveTransform implements ISaveData {
        private static POOL;
        _savematrix: Matrix;
        _matrix: Matrix;
        constructor();
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static save(runner: GraphicsRunner): void;
    }
    /** @ignore */
    class SaveTranslate implements ISaveData {
        private static POOL;
        _mat: Matrix;
        isSaveMark(): boolean;
        restore(runner: GraphicsRunner): void;
        static save(runner: GraphicsRunner): void;
    }
    class Shader2D {
        /**@internal */
        static graphicsShader: Shader3D;
        /**@internal */
        /**@internal */
        static render2DNodeShader: Shader3D;
        /**
         * @internal
         */
        destroy(): void;
        /**
         * primitive Mesh Descript
         */
        /**
         * TextureSV Mesh Descript
         */
        static readonly graphicsAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        static readonly Render2DNodeAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * init 2D internal Shader
         */
        static __init__(): void;
    }
    class ShaderDefines2D {
        /**@internal */
        static FILLTEXTURE: ShaderDefine;
        /**@internal */
        static GAMMASPACE: ShaderDefine;
        /**@internal */
        static INVERTY: ShaderDefine;
        /**@internal */
        static GAMMATEXTURE: ShaderDefine;
        static VERTEX_SIZE: ShaderDefine;
        /**@internal */
        static TEXTURESHADER: ShaderDefine;
        /**@internal */
        static PRIMITIVESHADER: ShaderDefine;
        /** @internal */
        static RENDERTEXTURE: ShaderDefine;
        /**@internal */
        static MATERIALCLIP: ShaderDefine;
        /**@internal */
        static UNIFORM_CLIPMATDIR: number;
        static UNIFORM_CLIPMATPOS: number;
        static UNIFORM_MATERIAL_CLIPMATDIR: number;
        static UNIFORM_MATERIAL_CLIPMATPOS: number;
        static UNIFORM_SIZE: number;
        static UNIFORM_VERTALPHA: number;
        static UNIFORM_SPRITETEXTURE: number;
        static UNIFORM_VERTEX_SIZE: number;
        static UNIFORM_TEXRANGE: number;
        /**
         * 渲染矩阵第一个vector3属性ID
         */
        static UNIFORM_NMATRIX_0: number;
        /**
         * 渲染矩阵第二个vector3属性ID
         */
        static UNIFORM_NMATRIX_1: number;
        /** uniform vec3 u_InvertMat_0; // 反转矩阵的第一行 */
        static UNIFORM_INVERTMAT_0: number;
        /** uniform vec3 u_InvertMat_1; // 反转矩阵的第二行 */
        static UNIFORM_INVERTMAT_1: number;
        static __init__(): void;
        static initSprite2DCommandEncoder(): void;
    }
    class GraphicsShaderInfo {
        shaderData: ShaderData;
        constructor();
        toDefault(): void;
        private _textureHost;
        get textureHost(): Texture | BaseTexture;
        set textureHost(value: Texture | BaseTexture);
        set enableVertexSize(value: boolean);
        get enableVertexSize(): boolean;
        set vertexSize(value: Vector4);
        get vertexSize(): Vector4;
        set materialClip(value: boolean);
        get materialClip(): boolean;
        set clipMatDir(value: Vector4);
        get clipMatDir(): Vector4;
        set clipMatPos(value: Vector4);
        get clipMatPos(): Vector4;
        get u_TexRange(): Vector4;
        set u_TexRange(value: Vector4);
        set fillTexture(value: boolean);
        get fillTexture(): boolean;
        cloneTo(shaderData: ShaderData): void;
        clear(): void;
        destroy(): void;
    }
    class BasePoly {
        /**
         * 构造线的三角形数据。根据一个位置数组生成vb和ib
         * @param p
         * @param indices
         * @param lineWidth
         * @param indexBase				顶点开始的值，ib中的索引会加上这个
         * @param outVertex
         * @return
         */
        static createLine2(p: any[], indices: any[], lineWidth: number, indexBase: number, outVertex: any[], loop: boolean): any[];
        /**
          * 设置中间折角顶点的位置
          * @param x1,y1 第一个点的坐标
          * @param x2,y2 中间点的坐标
          * @param x3,y3 第三个点的坐标
          * @param w 线条宽度的一半
          * @param vertexs 顶点数组
          * @param out 用于存储法向量的临时向量
          * @param join 连接点样式
          */
        private static _setMiddleVertexs;
        /**
          * 计算三个点形成的夹角 (以第二个点为顶点)
          * @param x1 点1的x坐标
          * @param y1 点1的y坐标
          * @param x2 点2的x坐标 (顶点)
          * @param y2 点2的y坐标 (顶点)
          * @param x3 点3的x坐标
          * @param y3 点3的y坐标
          * @returns 夹角 (弧度制)
          */
        private static angleBetweenPoints;
        private static _createSimpleLineVertices;
        private static _setTurnPoint;
        private static checkCrossPoint;
        /**
          * 计算两条直线或线段的交点
          * @param p1x 第一个点的x坐标
          * @param p1y 第一个点的y坐标
          * @param p2x 第二个点的x坐标
          * @param p2y 第二个点的y坐标
          * @param p3x 第三个点的x坐标
          * @param p3y 第三个点的y坐标
          * @param p4x 第四个点的x坐标
          * @param p4y 第四个点的y坐标
          * @param isLineSegment 如果为true则判断两个线段的交点，如果为false则判断两条直线的交点
          * @returns 交点坐标，如果没有交点则返回null
          */
        private static getCrossPoint;
        private static getDistance;
        static getNormal(x1: number, y1: number, x2: number, y2: number, w: number, out?: Vector2): Vector2;
        /**
         * 相邻的两段线，边界会相交，这些交点可以作为三角形的顶点。有两种可选，一种是采用左左,右右交点，一种是采用 左右，左右交点。当两段线夹角很小的时候，如果采用
         * 左左，右右会产生很长很长的交点，这时候就要采用左右左右交点，相当于把尖角截断。
         * 当采用左左右右交点的时候，直接用切线的垂线。采用左右左右的时候，用切线
         * 切线直接采用两个方向的平均值。不能用3-1的方式，那样垂线和下一段可能都在同一方向（例如都在右方）
         * 注意把重合的点去掉
         * @param path
         * @param color
         * @param width
         * @param loop
         * @param outvb
         * @param vbstride  顶点占用几个float,(bytelength/4)
         * @param outib
         * test:
         * 横线
         * [100,100, 400,100]
         * 竖线
         * [100,100, 100,400]
         * 直角
         * [100,100, 400,100, 400,400]
         * 重合点
         * [100,100,100,100,400,100]
         * 同一直线上的点
         * [100,100,100,200,100,3000]
         * 像老式电视的左边不封闭的图形
         * [98,176,  163,178, 95,66, 175,177, 198,178, 252,56, 209,178,  248,175,  248,266,  209,266, 227,277, 203,280, 188,271,  150,271, 140,283, 122,283, 131,268, 99,268]
         *
         */
        static createLineTriangle(path: any[], color: number, width: number, loop: boolean, outvb: Float32Array, vbstride: number, outib: Uint16Array): void;
    }
    class Earcut {
        static earcut(data: any, holeIndices: any, dim: any): any;
        static linkedList(data: any, start: any, end: any, dim: any, clockwise: any): any;
        static filterPoints(start: any, end: any): any;
        static earcutLinked(ear: any, triangles: any, dim: any, minX: any, minY: any, invSize: any, pass?: any): any;
        static isEar(ear: any): any;
        static isEarHashed(ear: any, minX: any, minY: any, invSize: any): boolean;
        static cureLocalIntersections(start: any, triangles: any, dim: any): any;
        static splitEarcut(start: any, triangles: any, dim: any, minX: any, minY: any, invSize: any): void;
        static eliminateHoles(data: any, holeIndices: any, outerNode: any, dim: any): any;
        static compareX(a: any, b: any): any;
        static eliminateHole(hole: any, outerNode: any): void;
        static findHoleBridge(hole: any, outerNode: any): any;
        static indexCurve(start: any, minX: any, minY: any, invSize: any): void;
        static sortLinked(list: any): any;
        static zOrder(x: any, y: any, minX: any, minY: any, invSize: any): any;
        static getLeftmost(start: any): any;
        static pointInTriangle(ax: any, ay: any, bx: any, by: any, cx: any, cy: any, px: any, py: any): boolean;
        static isValidDiagonal(a: any, b: any): boolean;
        static area(p: any, q: any, r: any): any;
        static equals(p1: any, p2: any): boolean;
        static intersects(p1: any, q1: any, p2: any, q2: any): boolean;
        static intersectsPolygon(a: any, b: any): boolean;
        static locallyInside(a: any, b: any): boolean;
        static middleInside(a: any, b: any): boolean;
        static splitPolygon(a: any, b: any): any;
        static insertNode(i: any, x: any, y: any, last: any): any;
        static removeNode(p: any): void;
        static signedArea(data: any, start: any, end: any, dim: any): any;
    }
    class EarcutNode {
        i: any;
        x: any;
        y: any;
        prev: any;
        next: any;
        z: any;
        prevZ: any;
        nextZ: any;
        steiner: any;
        constructor(i: any, x: any, y: any);
    }
    class SubmitBase {
        static RENDERBASE: SubmitBase;
        static ID: number;
        clipInfoID: number;
        protected _id: number;
        /**@internal */
        _renderType: number;
        /**@internal */
        _key: SubmitKey;
        mesh: GraphicsMesh;
        material: Material;
        vertexs: IGraphics2DVertexBlock[];
        blockIndexs: number[];
        indexCount: number;
        indices: number[];
        indexView: I2DGraphicIndexDataView;
        /** @internal */
        _internalInfo: GraphicsShaderInfo;
        renderStateIsBySprite: boolean;
        constructor();
        clear(): void;
        destroy(): void;
        appendData(info: MeshBlockInfo): void;
        update(runner: GraphicsRunner, mesh: GraphicsMesh, material: Material): void;
        static create(runner: GraphicsRunner, mesh: GraphicsMesh, material: Material): SubmitBase;
    }
    /**
     * ...
     * @author xie
     */
    class SubmitKey {
        blendShader: BlendMode;
        other: number;
        constructor();
        clear(): void;
    }
    class AtlasGrid {
        atlasID: number;
        private _width;
        private _height;
        private _texCount;
        private _rowInfo;
        private _cells;
        _used: number;
        constructor(width?: number, height?: number, id?: number);
        addRect(type: number, width: number, height: number, pt: Point): boolean;
        private _release;
        private _init;
        private _get;
        private _fill;
        private _check;
        private _clear;
    }
    class CharRender_Canvas {
        fontsz: number;
        canvas: HTMLCanvasElement;
        private ctx;
        private lastScaleX;
        private lastScaleY;
        private maxTexW;
        private maxTexH;
        private lastFont;
        constructor(maxw: number, maxh: number);
        /**
         * @override
         */
        get canvasWidth(): number;
        /**
         * @override
         */
        set canvasWidth(w: number);
        /**
         *
         * @param font
         * @param str
         * @override
         */
        getWidth(font: string, str: string): number;
        /**
         *
         * @param sx
         * @param sy
         * @override
         */
        scale(sx: number, sy: number): void;
        /**
         *TODO stroke
         * @param char
         * @param font
         * @param cri  修改里面的width。
         * @return
         * @override
         */
        getCharBmp(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number, rect?: number[]): ImageData | null;
        getCharCanvas(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number): HTMLCanvasElement;
    }
    /**
     * TODO如果占用内存较大,这个结构有很多成员可以临时计算
     */
    class CharRenderInfo implements IAutoExpiringResource {
        isRandomTouch: boolean;
        char: string;
        texture: TextTexture;
        deleted: boolean;
        uv: number[];
        pos: number;
        width: number;
        height: number;
        bmpWidth: number;
        bmpHeight: number;
        orix: number;
        oriy: number;
        touchTick: number;
        referenceCount: number;
        isSpace: boolean;
        touch(): void;
    }
    class MeasureFont {
        private bmpData32;
        private charRender;
        constructor(charRender: CharRender_Canvas);
        getFontSizeInfo(font: string, size: number): number;
        /**
         * 检查当前线是否存在数据
         * @param data
         * @param l
         * @param sx
         * @param ex
         * @return
         */
        private checkBmpLine;
        /**
         * 根据bmp数据和当前的包围盒，更新包围盒
         * 由于选择的文字是连续的，所以可以用二分法
         * @param data
         * @param curbbx 	[l,t,r,b]
         * @param   onlyH 不检查左右
         */
        private updateBbx;
    }
    /**
     *  文字贴图的大图集。
     */
    class TextAtlas {
        texWidth: number;
        texHeight: number;
        private atlasgrid;
        texture: TextTexture | null;
        charMaps: {
            [key: string]: CharRenderInfo;
        };
        constructor();
        setProtecteDist(d: number): void;
        /**
         * 如果返回null，则表示无法加入了
         * 分配的时候优先选择最接近自己高度的节点
         * @param w
         * @param h
         * @return
         */
        getAEmpty(w: number, h: number, pt: Point): boolean;
        /**
         * 大图集格子单元的占用率，老的也算上了。只是表示这个大图集还能插入多少东西。
         */
        get usedRate(): number;
        updateTextureUsage(): void;
        destroy(): void;
        printDebugInfo(): void;
    }
    class TextDebug {
        static showTextAtlas(texttex: TextTexture, n: number, bgcolor: string, x: number, y: number, w: number, h: number): Sprite;
        static printRenderInfo(render: TextRender): void;
    }
    /** @ignore */
    class TextRender extends EventDispatcher {
        readonly charRender: CharRender_Canvas;
        readonly fontMeasure: MeasureFont;
        readonly mapFont: Record<string, number>;
        readonly textAtlases: TextAtlas[];
        readonly isoTextures: TextTexture[];
        /**
         * fontSizeInfo
         * 记录每种字体的像素的大小。标准是32px的字体。由4个byte组成，分别表示[xdist,ydist,w,h]。
         * xdist,ydist 是像素起点到排版原点的距离，都是正的，表示实际数据往左和上偏多少，如果实际往右和下偏，则算作0，毕竟这个只是一个大概
         * 例如 [Arial]=0x00002020, 表示宽高都是32
         */
        private fontSizeInfo;
        private fontID;
        private fontScaleX;
        private fontScaleY;
        private _curStrPos;
        private lastFont;
        private fontSizeW;
        private fontSizeH;
        private fontSizeOffX;
        private fontSizeOffY;
        private renderPerChar;
        private fontStr;
        constructor();
        getFontSizeInfo(font: string): number;
        /**
         * 设置当前字体，获得字体的大小信息。
         * @param font
         */
        setFont(font: FontInfo): void;
        /**
         * 从string中取出一个完整的char，例如emoji的话要多个
         * 会修改 _curStrPos
         * TODO 由于各种文字中的组合写法，这个需要能扩展，以便支持泰文等
         * @param str
         */
        getNextChar(str: string): string | null;
        filltext(runner: GraphicsRunner, data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string): void;
        _fast_filltext(runner: GraphicsRunner, data: string | WordText | null, x: number, y: number, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, textAlign: number): void;
        /**
         * 画出重新按照贴图顺序分组的文字。
         * @param samePagesData
         * @param  startx 保存的数据是相对位置，所以需要加上这个偏移。用相对位置更灵活一些。
         * @param y {int} 因为这个只能画在一行上所以没有必要保存y。所以这里再把y传进来
         */
        protected _drawResortedWords(runner: GraphicsRunner, startx: number, starty: number, samePagesData: {
            [key: number]: any;
        }): void;
        /**
         * 检查 txts数组中有没有被释放的资源
         * @param txts {{ri:CharRenderInfo,...}[][]}
         * @param startid
         * @return
         */
        hasFreedText(txts: any[]): boolean;
        getCharRenderInfo(str: string, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, isoTexture?: boolean): CharRenderInfo;
        findAtlas(w: number, h: number): TextAtlas;
        /**
         * 清理利用率低的大图集
         */
        GC(): void;
        /**
         * 尝试清理大图集
         */
        cleanAtlases(): void;
    }
    /**
     * @ignore
     */
    class TextRenderConfig {
        static maxCanvasWidth: number;
        static atlasWidth: number;
        static atlasGridW: number;
        static noAtlas: boolean;
        static forceSplitRender: boolean;
        static forceWholeRender: boolean;
        static scaleFontWithCtx: boolean;
        static maxFontScale: number;
        static fontScale: number;
        static standardFontSize: number;
        static destroyAtlasDt: number;
        static checkCleanTextureDt: number;
        static destroyUnusedTextureDt: number;
        static cleanMem: number;
        static showLog: boolean;
        static debugUV: boolean;
        static simClean: boolean;
        static debugCharCanvas: boolean;
        static useImageData: boolean;
    }
    /**
     * 保存文字的贴图
     * @blueprintIgnore
     */
    class TextTexture extends Texture2D {
        private static pool;
        private static poolLen;
        private static cleanTm;
        genID: number;
        curUsedCovRate: number;
        curUsedCovRateAtlas: number;
        lastTouchTm: number;
        ri: CharRenderInfo;
        private _discardTm;
        constructor(textureW: number, textureH: number);
        /**
         * 添加一个文字位图
         * @param data
         * @param x 拷贝位置。
         * @param y
         * @param  uv
         * @return uv数组  如果uv不为空就返回传入的uv，否则new一个数组
         */
        addChar(data: ImageData | HTMLCanvasElement, x: number, y: number, uv?: number[]): number[];
        /**
         * 填充白色。调试用。
         */
        fillWhite(): void;
        discard(): void;
        static getTextTexture(w: number, h: number): TextTexture;
        /**
         * 定期清理
         * 为了简单，只有发生 getAPage 或者 discardPage的时候才检测是否需要清理
         *
         * 暂时先不用这个了。
         */
        static clean(): void;
        /**
         * 这个贴图被当前帧使用了。
         * 这个是基于贴图的，更简单，效率更高
         */
        touchTexture(): void;
        touchRect(ri: CharRenderInfo): void;
    }
    /**
     * BufferState类用于实现渲染所需的Buffer状态集合。
     * @blueprintIgnore
     */
    class BufferState {
        private static vertexBufferArray;
        /**@private [只读]*/
        _deviceBufferState: IBufferState;
        /**@internal [只读]*/
        _bindedIndexBuffer: IndexBuffer3D;
        /**@internal */
        _vertexBuffers: VertexBuffer3D[];
        /**
         * 创建一个 <code>BufferState</code> 实例。
         */
        constructor();
        applyState(vertexBuffers: VertexBuffer3D[], indexBuffer: IndexBuffer3D | null): void;
        /**
         * @private
         */
        destroy(): void;
    }
    type MeshBlockInfo = {
        mesh: GraphicsMesh;
        positions?: number[];
        vertexViews?: I2DGraphicVertexDataView[];
        vertexBlocks?: number[];
    };
    /** @ignore */
    class GraphicsMesh {
        static stride: number;
        static vertexDeclarition: VertexDeclaration;
        static __init__(): void;
        /** @internal */
        _buffer: Graphic2DDynamicVIBuffer;
        get bufferState(): IBufferState;
        constructor();
        /**
         * @en Check vertex buffer
         * @param vertexCount vertex count
         * @returns vertex buffer info
         * @zh 检查顶点缓冲区
         * @param vertexCount 顶点数量
         * @returns 顶点缓冲区信息
         */
        checkVertex(vertexCount: number): MeshBlockInfo;
        /**
         * @en Check index buffer
         * @param indexCount index count
         * @returns index buffer info
         * @zh 检查索引缓冲区
         * @param indexCount 索引数量
         * @returns 索引缓冲区信息
         */
        checkIndex(indexCount: number): I2DGraphicIndexDataView;
        /**
         * @en Clear blocks
         * @param vertexBlocks vertex blocks
         * @zh 清除块
         * @param vertexBlocks 顶点块
         */
        clearBlocks(vertexBlocks: number[]): void;
        /**
         * @en Clear index view
         * @param indexView index view
         * @zh 清除索引视图
         * @param indexView 索引视图
         */
        clearIndexView(indexView: I2DGraphicIndexDataView): void;
        /**
         * @en Clear
         * @zh 清除
         */
        clear(): void;
        /**
         * @en Destroy
         * @zh 销毁
         */
        destroy(): void;
    }
    class IncludeFile {
        static splitToWords(str: string, block: ShaderNode): string[];
        script: string;
        codes: any;
        funs: any;
        curUseID: number;
        funnames: string;
        constructor(txt: string);
        getWith(name?: string | null): string;
        getFunsScript(funsdef: string): string;
    }
    class RenderState2D {
        static worldMatrix4: number[];
        static worldMatrix: Matrix;
        static matWVP: any;
        static worldAlpha: number;
        static worldScissorTest: boolean;
        static width: number;
        static height: number;
        static InvertY: boolean;
        static restoreTempArray(): void;
        static clear(): void;
    }
    interface IShaderCompiledObj {
        vsNode: ShaderNode;
        psNode: ShaderNode;
        includeNames: Set<string>;
        defs: Set<string>;
    }
    /**
     * @ignore
     * <code>ShaderCompile</code> 类用于实现Shader编译。
     */
    class ShaderCompile {
        static readonly IFDEF_NO: number;
        static readonly IFDEF_YES: number;
        static readonly IFDEF_ELSE: number;
        static readonly IFDEF_PARENT: number;
        static readonly includes: Record<string, IncludeFile>;
        static loadIncludeFileSync: (fileName: string) => void;
        static addInclude(fileName: string, txt: string, allowReplace?: boolean): IncludeFile;
        static compile(vs: string, ps: string, basePath?: string): IShaderCompiledObj;
        static compileAsync(vs: string, ps: string, basePath: string): Promise<IShaderCompiledObj>;
        private static _loadIncludesDeep;
        private static _compileToTree;
        static getRenderState(obj: Record<string, string | boolean | number | string[]>, renderState: RenderState): void;
    }
    interface ShaderProcessInfo {
        defineString: string[];
        vs: ShaderNode;
        ps: ShaderNode;
        attributeMap: Record<string, [
            number,
            ShaderDataType
        ]>;
        uniformMap: Map<number, UniformProperty>;
        is2D: boolean;
    }
    /**
     * @blueprintIgnore @blueprintIgnoreSubclasses
     */
    class ShaderCompileDefineBase {
        _VS: ShaderNode;
        _PS: ShaderNode;
        _defs: Set<string>;
        _validDefine: IDefineDatas;
        _owner: SubShader;
        name: string;
        constructor(owner: any, name: string, compiledObj: IShaderCompiledObj);
        withCompile(compileDefine: IDefineDatas): IShaderInstance;
    }
    class ShaderNode {
        private static __id;
        private static __noCompileEnable;
        childs: any[];
        text: string;
        parent: ShaderNode;
        name: string;
        noCompile: boolean;
        includefiles: any[];
        condition: any;
        conditionType: number;
        useFuns: string;
        z: number;
        src: string;
        constructor(includefiles: any[]);
        setParent(parent: ShaderNode): void;
        setCondition(condition: string, type: number): void;
        toscript(def: any, out: any[]): any[];
        private _toscript;
    }
    /**
     * @blueprintable
     */
    class LayaEnv {
        /**
         * @en The version of the engine.
         * @zh 引擎的版本。
         * @readonly
         */
        static version: string;
        /**
         * @en Whether the engine is running in the editor. If it is false, it indicates that the engine is running in the scene view of the IDE, otherwise it is true.
         * @zh 区分引擎是在编辑模式还是播放模式，在IDE的场景视图编辑时，此值为 false，否则为 true。
         * @readonly
         */
        static isPlaying: boolean;
        /**
         * @en Whether the engine is running in the preview mode or the product mode. If it is false, it indicates that the engine is running after the release, otherwise it is true.
         * @zh 区分引擎是在预览模式还是产品模式。如果发布后运行，此值为 false，否则为 true。
         * @readonly
         */
        static isPreview: boolean;
        /**
         * @en Whether the engine is running in the native platform.
         * @zh 引擎是否正在运行在原生平台。
         * @readonly
         */
        static isConch: boolean;
        /**
         * @en Whether the engine is running in the editor. The engine may have two states in the editor, one is running in the scene view of the editor, and the other is running in the game view of the editor. Please distinguish these two states through isPlaying.
         * @zh 引擎是否正在运行在编辑器下。引擎在编辑器下可能有两种状态，一种是运行在编辑器的场景视图，一种是运行在编辑器的游戏视图，请通过isPlaying区别这两种情况。
         * @readonly
         */
        static isEditor: boolean;
        /** @deprecated Uses Laya.addBeforeInitCallback */
        static beforeInit: (stageConfig: IStageConfig) => void;
        /** @deprecated Use Laya.addAfterInitCallback */
        static afterInit: () => void;
    }
    interface IStageConfig {
        designWidth?: number;
        designHeight?: number;
        scaleMode?: string;
        screenMode?: string;
        alignV?: string;
        alignH?: string;
        backgroundColor?: string;
    }
    class TtVideoTexture extends VideoTexture {
        readonly decoder: any;
        private _volume;
        private _muted;
        private _ended;
        constructor();
        get readyState(): number;
        get volume(): number;
        set volume(value: number);
        get muted(): boolean;
        set muted(value: boolean);
        get loop(): boolean;
        set loop(value: boolean);
        get ended(): boolean;
        get currentTime(): number;
        set currentTime(value: number);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onStop(): void;
        onRender(): boolean;
        protected onDestroy(): void;
    }
    class MgBrowserAdapter extends BrowserAdapter {
        static beforeInit: () => void;
        static afterInit: () => void;
        protected _visible: boolean;
        protected _orientation: OrientationType;
        protected _supportSetCursor: boolean;
        protected _supportCreateArrayBufferURL: boolean;
        protected init(): void;
        start(): Promise<void>;
        onInitRender(): void;
        protected setupWasmSupport(): void;
        getVisibility(): boolean;
        getScreenOrientation(): OrientationType;
        createMainCanvas(): HTMLCanvasElement;
        createElement<K extends keyof HTMLElementTagNameMap>(tagName: K): HTMLElementTagNameMap[K];
        setCursor(cursor: string): void;
        get supportArrayBufferURL(): boolean;
        createBufferURL(data: ArrayBuffer): string;
        revokeBufferURL(url: string): void;
        getOpenDataContextCanvas(): any;
        postMessageToOpenDataContext(msg: any): void;
        protected onCaptureGlobalError(enabled: boolean, func: (e: any) => void): void;
        alert(msg: string): void;
    }
    class MgCacheManager {
        /**
         * @en Minimum space to be cleared when the cache is full
         * @zh 缓存容量满时每次清理容量值
         */
        static minClearSpace: number;
        /**
         * @en Maximum capacity of cache directory
         * @zh 缓存目录的最大容量
         */
        static spaceLimit: number;
        /**
         * @en The interval time for processing cache requests, in milliseconds
         * @zh 处理缓存请求的间隔时间，单位是毫秒
         */
        static processInterval: number;
        /**
         * @en The interval time for saving file access time, in milliseconds. This time can be long, because it does not matter if the access time is not accurate.
         * @zh 保存文件访问时间的间隔时间，单位是毫秒。这个时间可以很长，因为访问时间就算不对问题也不大。
         */
        static saveAccessTimeInterval: number;
        private cacheRoot;
        private totalFileSize;
        private cacheGroups;
        private fileCache;
        private cacheRequest;
        private running;
        private toSaveManifestFlags;
        private toSaveManifestRequest;
        private lastGroup;
        private lastGroupUsed;
        private toClear;
        constructor(cacheRoot: string);
        /** @internal */
        start(): Promise<void>;
        /**
         * @en Get a file from the cache, if it is not in the cache, return null.
         * @param url The URL of the file to be retrieved.
         * @returns The path of the cached file, or null if it is not in the cache.
         * @zh 从缓存中获取文件，如果不在缓存中，则返回null。
         * @param url 要获取的文件的URL。
         * @returns 缓存文件的路径，如果不在缓存中，则返回null。
         */
        getFile(url: string): Promise<string | null>;
        /**
         * @en Add a file to the cache.
         * @param url The URL of the file to be cached.
         * @param tempFilePath The temporary file path of the file to be cached.
         * @zh 将文件添加到缓存中。
         * @param url 要缓存的文件的URL。
         * @param tempFilePath 要缓存的文件的临时文件路径。
         */
        addFile(url: string, tempFilePath: string): void;
        /**
         * @en Clear all cache files. This method will not be executed immediately, but will be executed in the subsequent processing cycle.
         * @zh 清除所有缓存文件。这个方法不会立即执行，而是在后续的处理周期中执行。
         */
        clearAllCache(): void;
        private process;
        private selectGroup;
        private addFilesToCache;
        private clearSpace;
        private doClearSpace;
        private doClearAllCache;
        private loadAllManifests;
        private loadManifest;
        private saveDirtyManifests;
        private saveManifest;
        private createCacheDirs;
        private checkAndDeleteOldCacheDir;
    }
    class MgDeviceAdapter extends DeviceAdapter {
        private _watchDic;
        private _watchId;
        private _watchOptions;
        private _accInfo;
        private _rotInfo;
        constructor();
        get supportedLocation(): boolean;
        getCurrentPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): void;
        watchPosition(successCallback: (info: GeolocationInfo) => void, errorCallback?: (err: {
            code: number;
            message: string;
        }) => void, options?: PositionOptions): number;
        clearWatchPosition(id: number): void;
        private onUpdate;
        protected startListeningDeviceMotion(): void;
        protected startListeningDeviceOrientation(): void;
    }
    class MgDownloader extends Downloader {
        /**
         * @en Cache manager
         * @zh 缓存管理器
         */
        cacheManager: MgCacheManager;
        /**
         * @en Whether to escape Chinese characters in URL
         * @zh 是否对URL中的中文字符进行转义
         */
        escapeZhCharsInURL: boolean;
        /**
         * @en Whether to support subpackage multi-level folder loading
         * @zh 是否支持分包多级文件夹加载
         */
        supportSubPackageMultiLevelFolders: boolean;
        private subPackages;
        constructor(enableCache?: boolean);
        common(owner: any, url: string, originalUrl: string, contentType: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        image(owner: any, url: string, originalUrl: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        package(path: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        protected downloadFile(url: string, onProgress: ProgressCallback, onComplete: DownloadCompleteCallback): void;
        protected readFile(url: string, contentType: string, onComplete: DownloadCompleteCallback): void;
        private urlToFilePath;
        protected checkSubpackagePrefix(url: string): string;
        escapeURL(url: string): string;
    }
    class MgFileSystemAdapter extends FileSystemAdapter {
        private fs;
        private hasAccess;
        constructor();
        readFile(path: string, encoding?: string): Promise<ArrayBuffer | string>;
        writeFile(path: string, data: ArrayBuffer | string, encoding?: string): Promise<void>;
        unlink(path: string): Promise<void>;
        copyFile(srcPath: string, destPath: string): Promise<void>;
        exists(path: string): Promise<boolean>;
        getFileSize(path: string): Promise<number>;
        mkdir(path: string, options?: {
            recursive?: boolean;
        }): Promise<void>;
        rmdir(path: string, options?: {
            recursive?: boolean;
        }): Promise<void>;
        readdir(path: string): Promise<string[]>;
        unzip(zipFilePath: string, targetPath: string): Promise<void>;
    }
    class MgFontAdapter extends FontAdapter {
        loadFont(task: ILoadTask): Promise<{
            family: string;
        } | null>;
    }
    class MgInnerAudioChannel extends SoundChannel {
        private _ctx;
        get position(): number;
        get duration(): number;
        protected onPlay(url: string): void;
        private onLoaded;
        protected onPlayAgain(): void;
        protected onStop(): void;
        protected onPause(): void;
        protected onResume(): void;
        protected onVolumeChanged(): void;
        protected onMuted(): void;
        protected createContext(): WechatMinigame.InnerAudioContext;
        protected releaseContext(): void;
    }
    class MgMediaAdapter extends MediaAdapter {
        protected init(): void;
    }
    class MgStorageAdapter extends StorageAdapter {
        protected checkSupport(): boolean;
    }
    class MgTextInputAdapter extends TextInputAdapter {
        static enabled: boolean;
        constructor();
        setText(value: string): void;
        protected onBegin(): Promise<void>;
        protected onCanShowKeyboard(): Promise<void>;
        protected onEnd(target: Input, complete: boolean, switching: boolean): Promise<void>;
        private onKeyboardInput;
        private onKeyboardConfirm;
        private onKeyboardComplete;
    }
    /**
     * @ignore
     */
    class MgVideoPlayer extends VideoPlayer {
        readonly video: WechatMinigame.Video;
        private _loop;
        private _currentTime;
        private _ended;
        private _muted;
        private _playbackRate;
        get loop(): boolean;
        set loop(value: boolean);
        get ended(): boolean;
        get currentTime(): number;
        set currentTime(value: number);
        get muted(): boolean;
        set muted(value: boolean);
        get playbackRate(): number;
        set playbackRate(value: number);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onTransformChanged(): void;
        protected onDestroy(): void;
    }
    class MgWebAudioChannel extends MgInnerAudioChannel {
        constructor(url: string);
        protected createContext(): WechatMinigame.InnerAudioContext;
    }
    class MgWebSocket implements IWebSocket {
        ws: WechatMinigame.SocketTask;
        onOpen: (result: any) => void;
        onClose: () => void;
        onError: (e: any) => void;
        onMessage: (data: string | ArrayBuffer) => void;
        open(url: string, options?: IWebSocketConnectOptions): void;
        close(): void;
        send(data: string | ArrayBuffer): Promise<void>;
    }
    class NativeBrowserAdapter extends BrowserAdapter {
        init(): void;
        createMainCanvas(): HTMLCanvasElement;
        get supportArrayBufferURL(): boolean;
        createBufferURL(data: ArrayBuffer): string;
        revokeBufferURL(url: string): void;
    }
    class NativeFontAdapter extends FontAdapter {
        loadFont(task: ILoadTask): Promise<{
            family: string;
        } | null>;
    }
    class NativeMediaAdapter extends MediaAdapter {
        protected init(): void;
    }
    class NativeTextInputAdapter extends TextInputAdapter {
        constructor();
        setText(value: string): void;
        protected onBegin(): Promise<void>;
        private _onResize;
        protected onCanShowKeyboard(): Promise<void>;
        protected onEnd(target: Input, complete: boolean, switching: boolean): Promise<void>;
        protected syncTransform(): void;
        protected hideInputElement(): void;
        private onKeyboardInput;
        private onKeyboardConfirm;
        private onKeyboardComplete;
    }
    /**
     * @ignore
     */
    class NativeVideoPlayer extends VideoPlayer {
        readonly video: any;
        private _loop;
        private _ended;
        private _muted;
        private _playbackRate;
        get loop(): boolean;
        set loop(value: boolean);
        get ended(): boolean;
        get currentTime(): number;
        set currentTime(value: number);
        get muted(): boolean;
        set muted(value: boolean);
        get playbackRate(): number;
        set playbackRate(value: number);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onTransformChanged(): void;
        protected onDestroy(): void;
    }
    class NativeVideoTexture extends VideoTexture {
        readonly decoder: any;
        private _currentTime;
        private _ended;
        private _waitFirstFrame;
        private _startOption;
        constructor();
        get readyState(): number;
        get ended(): boolean;
        get currentTime(): number;
        set currentTime(value: number);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onStop(): void;
        onRender(): boolean;
        protected onDestroy(): void;
    }
    class TbTextInputAdapter extends TextInputAdapter {
        constructor();
        setText(value: string): void;
        protected onBegin(): Promise<void>;
        protected onCanShowKeyboard(): Promise<void>;
        protected onEnd(): Promise<void>;
    }
    class WxVideoTexture extends VideoTexture {
        readonly decoder: WechatMinigame.VideoDecoder;
        private _currentTime;
        private _ended;
        private _waitFirstFrame;
        private _startOption;
        constructor();
        get readyState(): number;
        get ended(): boolean;
        get currentTime(): number;
        set currentTime(value: number);
        protected onLoad(url: string): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onStop(): void;
        onRender(): boolean;
        protected onDestroy(): void;
    }
    /**
     * @en Global UI configuration settings.
     * @zh 全局配置
     * @blueprintable
     */
    class UIConfig {
        /**
         * @en Enable touch scrolling (for scroll bars).
         * @zh 是否开启触摸滚动（针对滚动条）
         */
        static touchScrollEnable: boolean;
        /**
         * @en Enable mouse wheel scrolling (for scroll bars).
         * @zh 是否开启滑轮滚动（针对滚动条）
         */
        static mouseWheelEnable: boolean;
        /**
         * @en Show scroll bar buttons.
         * @zh 是否显示滚动条按钮
         */
        static showButtons: boolean;
        /**
         * @en Background color for pop-up dialogs.
         * @zh 弹出框背景颜色
         */
        static popupBgColor: string;
        /**
         * @en Background transparency for pop-up dialogs.
         * @zh 弹出框背景透明度
         */
        static popupBgAlpha: number;
        /**
         * @en Whether clicking on the edge of a modal window will close it. The default is to close the window.
         * @zh 模式窗口点击边缘，是否关闭窗口，默认是关闭的
         */
        static closeDialogOnSide: boolean;
    }
}
